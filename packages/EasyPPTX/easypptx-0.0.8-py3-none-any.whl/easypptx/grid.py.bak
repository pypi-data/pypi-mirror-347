"""Grid layout module for EasyPPTX."""

from collections.abc import Callable
from typing import Any, TypeVar, overload

from easypptx.slide import PositionType

# Create a forward declaration for the Grid class
T = TypeVar("T", bound="Grid")


class GridCell:
    """Class representing a cell in a grid.

    This class stores information about a cell's position and dimensions
    within a grid layout.

    Attributes:
        row: Row index
        col: Column index
        x: X position as percentage
        y: Y position as percentage
        width: Width as percentage
        height: Height as percentage
        content: The content placed in this cell (if any)
    """

    def __init__(self, row: int, col: int, x: str, y: str, width: str, height: str) -> None:
        """Initialize a GridCell.

        Args:
            row: Row index of the cell
            col: Column index of the cell
            x: X position as percentage
            y: Y position as percentage
            width: Width as percentage
            height: Height as percentage
        """
        self.row = row
        self.col = col
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.content: Any = None
        self.span_rows = 1
        self.span_cols = 1
        self.is_spanned = False  # Whether this cell is part of another cell's span

    def __repr__(self) -> str:
        """Return string representation of the cell."""
        return (
            f"GridCell(row={self.row}, col={self.col}, x={self.x}, "
            f"y={self.y}, width={self.width}, height={self.height})"
        )


class OutOfBoundsError(IndexError):
    """Exception raised when grid coordinates are out of bounds."""


class CellMergeError(ValueError):
    """Exception raised when there's an issue with cell merging."""


class GridCellProxy:
    """Proxy class for accessing grid cells with enhanced syntax.

    This class provides a more intuitive API for accessing grid cells and provides
    direct access to all the add_xxx methods that the Grid class supports.

    Attributes:
        grid: The parent Grid object
        row: The row index of this cell
        col: The column index of this cell
    """

    def __init__(self, grid: "Grid", row: int, col: int):
        """Initialize a GridCellProxy.

        Args:
            grid: The parent Grid object
            row: The row index of this cell
            col: The column index of this cell
        """
        self.grid = grid
        self.row = row
        self.col = col

    def add_text(self, text: str, **kwargs) -> Any:
        """Add text to this cell.

        Args:
            text: The text to add
            **kwargs: Additional keyword arguments for the text

        Returns:
            The created text object
        """
        return self.grid.add_textbox(self.row, self.col, text=text, **kwargs)

    def add_image(self, image_path: str, **kwargs) -> Any:
        """Add an image to this cell.

        Args:
            image_path: The path to the image
            **kwargs: Additional keyword arguments for the image

        Returns:
            The created image object
        """
        return self.grid.add_image(self.row, self.col, image_path=image_path, **kwargs)

    def add_pyplot(self, figure, **kwargs) -> Any:
        """Add a matplotlib figure to this cell.

        Args:
            figure: The matplotlib figure to add
            **kwargs: Additional keyword arguments for the figure

        Returns:
            The created pyplot object
        """
        return self.grid.add_pyplot(self.row, self.col, figure=figure, **kwargs)

    def add_table(self, data, **kwargs) -> Any:
        """Add a table to this cell.

        Args:
            data: The table data to add
            **kwargs: Additional keyword arguments for the table

        Returns:
            The created table object
        """
        return self.grid.add_table(self.row, self.col, data=data, **kwargs)

    def add_grid(self, rows: int = 1, cols: int = 1, padding: float = 5.0) -> T:
        """Add a nested grid to this cell.

        Args:
            rows: The number of rows in the nested grid
            cols: The number of columns in the nested grid
            padding: The padding for the nested grid

        Returns:
            The created grid object
        """
        return self.grid.add_grid_to_cell(self.row, self.col, rows=rows, cols=cols, padding=padding)


class GridRowProxy:
    """Proxy class for accessing grid rows with enhanced syntax.

    This class provides a more intuitive API for accessing grid rows and redirects
    add_xxx method calls to the next available cell in the row.

    Attributes:
        grid: The parent Grid object
        row: The row index
        current_col: The current column index for sequential operations
    """

    def __init__(self, grid: "Grid", row: int):
        """Initialize a GridRowProxy.

        Args:
            grid: The parent Grid object
            row: The row index
        """
        self.grid = grid
        self.row = row
        self.current_col = 0

    def __getitem__(self, col: int) -> GridCellProxy:
        """Get the cell at the specified column.

        Args:
            col: The column index

        Returns:
            A GridCellProxy for the specified cell
        """
        return GridCellProxy(self.grid, self.row, col)

    def _get_next_available_col(self) -> int:
        """Get the next available column in this row.

        Returns:
            The column index of the next available cell

        Raises:
            IndexError: If all cells in this row are filled
        """
        if self.current_col >= self.grid.cols:
            raise IndexError(f"All cells in row {self.row} are already filled")

        col = self.current_col
        self.current_col += 1
        return col

    def add_text(self, text: str, **kwargs) -> Any:
        """Add text to the next available cell in this row.

        Args:
            text: The text to add
            **kwargs: Additional keyword arguments for the text

        Returns:
            The created text object
        """
        next_col = self._get_next_available_col()
        return self.grid.add_textbox(self.row, next_col, text=text, **kwargs)

    def add_textbox(self, text: str, **kwargs) -> Any:
        """Alias for add_text to maintain consistency with Grid.add_textbox.

        Args:
            text: The text to add
            **kwargs: Additional keyword arguments for the text

        Returns:
            The created text object
        """
        return self.add_text(text=text, **kwargs)

    def add_image(self, image_path: str, **kwargs) -> Any:
        """Add an image to the next available cell in this row.

        Args:
            image_path: The path to the image
            **kwargs: Additional keyword arguments for the image

        Returns:
            The created image object
        """
        next_col = self._get_next_available_col()
        return self.grid.add_image(self.row, next_col, image_path=image_path, **kwargs)

    def add_pyplot(self, figure, **kwargs) -> Any:
        """Add a matplotlib figure to the next available cell in this row.

        Args:
            figure: The matplotlib figure to add
            **kwargs: Additional keyword arguments for the figure

        Returns:
            The created pyplot object
        """
        next_col = self._get_next_available_col()
        return self.grid.add_pyplot(self.row, next_col, figure=figure, **kwargs)

    def add_table(self, data, **kwargs) -> Any:
        """Add a table to the next available cell in this row.

        Args:
            data: The table data to add
            **kwargs: Additional keyword arguments for the table

        Returns:
            The created table object
        """
        next_col = self._get_next_available_col()
        return self.grid.add_table(self.row, next_col, data=data, **kwargs)

    def add_grid(self, rows: int = 1, cols: int = 1, padding: float = 5.0) -> T:
        """Add a nested grid to the next available cell in this row.

        Args:
            rows: The number of rows in the nested grid
            cols: The number of columns in the nested grid
            padding: The padding for the nested grid

        Returns:
            The created grid object
        """
        next_col = self._get_next_available_col()
        return self.grid.add_grid_to_cell(self.row, next_col, rows=rows, cols=cols, padding=padding)

    # Reset the current column to 0 to allow for multiple passes
    def reset(self) -> None:
        """Reset the current column index to 0.

        This allows for multiple passes through the row.

        Returns:
            None
        """
        self.current_col = 0


class Grid:
    """Class for creating grid layouts in PowerPoint slides.

    This class provides methods for creating grid layouts and adding content
    to specific cells within the grid. The Grid is iterable and indexable like
    a numpy ndarray or matplotlib subplot grid.

    Attributes:
        parent: The parent Slide or Grid object
        x: X position of the grid as percentage or absolute value
        y: Y position of the grid as percentage or absolute value
        width: Width of the grid as percentage or absolute value
        height: Height of the grid as percentage or absolute value
        rows: Number of rows in the grid
        cols: Number of columns in the grid
        padding: Padding between cells as percentage of cell size
        cells: 2D array of GridCell objects

    Examples:
        ```python
        # Access a cell with grid[row, col]
        cell = grid[0, 1]  # Get cell at row 0, column 1

        # Add content directly to a cell using proxy access
        grid[0, 1].add_text("Cell 0,1", font_size=24)
        grid[1, 0].add_image(image_path="image.png")

        # Add content to the next available cell in a row
        grid[0].add_text("First available cell in row 0")
        grid[0].add_text("Second available cell in row 0")

        # Loop through all cells
        for cell in grid:
            print(cell)

        # Loop through cells linearly (flattened)
        for cell in grid.flat:
            print(cell.row, cell.col)

        # Add content using traditional methods
        grid.add_textbox(0, 1, text="Cell 0,1", font_size=24)
        grid.add_image(1, 0, image_path="image.png")
        ```
    """

    def __init__(
        self,
        parent: Any,
        x: PositionType = "0%",
        y: PositionType = "0%",
        width: PositionType = "100%",
        height: PositionType = "100%",
        rows: int = 1,
        cols: int = 1,
        padding: float = 5.0,
    ) -> None:
        """Initialize a Grid layout.

        Args:
            parent: The parent Slide or Grid object
            x: X position of the grid (default: "0%")
            y: Y position of the grid (default: "0%")
            width: Width of the grid (default: "100%")
            height: Height of the grid (default: "100%")
            rows: Number of rows (default: 1)
            cols: Number of columns (default: 1)
            padding: Padding between cells as percentage of cell size (default: 5.0)
        """
        self.parent = parent
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.rows = rows
        self.cols = cols
        self.padding = padding

        # Store slide dimensions for percentage calculations
        self._slide_width = self._get_slide_width()
        self._slide_height = self._get_slide_height()

        # Calculate cell dimensions
        self.cells = self._create_cells()

    def _get_slide_width(self) -> int:
        """Get the slide width in EMUs from the parent.

        Returns:
            The slide width in English Metric Units (EMUs)
        """
        # If parent is a Slide object, use its slide width
        if hasattr(self.parent, "_slide_width"):
            return self.parent._slide_width
        # If parent is another Grid, use its slide width
        elif hasattr(self.parent, "_get_slide_width"):
            return self.parent._get_slide_width()
        # Default value if we can't get it (equivalent to 10 inches)
        return 9144000  # 10 inches in EMUs

    def _get_slide_height(self) -> int:
        """Get the slide height in EMUs from the parent.

        Returns:
            The slide height in English Metric Units (EMUs)
        """
        # If parent is a Slide object, use its slide height
        if hasattr(self.parent, "_slide_height"):
            return self.parent._slide_height
        # If parent is another Grid, use its slide height
        elif hasattr(self.parent, "_get_slide_height"):
            return self.parent._get_slide_height()
        # Default value if we can't get it (equivalent to 7.5 inches)
        return 6858000  # 7.5 inches in EMUs

    def _create_cells(self) -> list:
        """Create the grid cells based on the layout.

        Returns:
            2D array of GridCell objects
        """
        cells = []

        # Convert percentage values to floats for calculations
        padding_factor = self.padding / 100.0

        # Calculate the width and height of each cell including padding
        cell_width_percent = 100.0 / self.cols
        cell_height_percent = 100.0 / self.rows

        # Calculate the effective width and height of each cell (excluding padding)
        effective_cell_width = cell_width_percent * (1 - padding_factor)
        effective_cell_height = cell_height_percent * (1 - padding_factor)

        # Half of the padding (as percentage of total grid size)
        half_padding_width = (cell_width_percent * padding_factor) / 2
        half_padding_height = (cell_height_percent * padding_factor) / 2

        # Create cells
        for row in range(self.rows):
            cell_row = []
            for col in range(self.cols):
                # Calculate cell position
                x_percent = (col * cell_width_percent) + half_padding_width
                y_percent = (row * cell_height_percent) + half_padding_height

                # Convert to percentage strings
                x_str = f"{x_percent:.2f}%"
                y_str = f"{y_percent:.2f}%"
                width_str = f"{effective_cell_width:.2f}%"
                height_str = f"{effective_cell_height:.2f}%"

                # Create the cell
                cell = GridCell(row, col, x_str, y_str, width_str, height_str)
                cell_row.append(cell)

            cells.append(cell_row)

        return cells

    def get_cell(self, row: int, col: int) -> GridCell:
        """Get a cell at the specified row and column.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)

        Returns:
            The GridCell at the specified position

        Raises:
            OutOfBoundsError: If row or column is out of bounds
        """
        if row < 0 or row >= self.rows or col < 0 or col >= self.cols:
            raise OutOfBoundsError(f"Cell position ({row}, {col}) is out of bounds")

        return self.cells[row][col]

    def merge_cells(self, start_row: int, start_col: int, end_row: int, end_col: int) -> GridCell:
        """Merge cells in the specified range.

        Args:
            start_row: Starting row index (0-based)
            start_col: Starting column index (0-based)
            end_row: Ending row index (0-based, inclusive)
            end_col: Ending column index (0-based, inclusive)

        Returns:
            The merged cell

        Raises:
            OutOfBoundsError: If any row or column is out of bounds
            CellMergeError: If the merged area overlaps with an existing merged cell
        """
        # Validate bounds
        if (
            start_row < 0
            or start_row >= self.rows
            or start_col < 0
            or start_col >= self.cols
            or end_row < 0
            or end_row >= self.rows
            or end_col < 0
            or end_col >= self.cols
        ):
            raise OutOfBoundsError("Merge area is out of bounds")

        # Make sure start coordinates are less than or equal to end coordinates
        if start_row > end_row or start_col > end_col:
            raise CellMergeError("Start coordinates must be less than or equal to end coordinates")

        # Check if any of the cells in the range are already merged
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                cell = self.cells[row][col]
                if cell.is_spanned:
                    raise CellMergeError("Cell is already part of a merged cell")

        # Get the first cell (top-left)
        first_cell = self.cells[start_row][start_col]

        # Calculate the new width and height
        last_cell = self.cells[end_row][end_col]

        # Extract numeric values from percentage strings
        first_x = float(first_cell.x.strip("%"))
        first_y = float(first_cell.y.strip("%"))

        # Calculate the rightmost and bottommost positions
        last_x = float(last_cell.x.strip("%"))
        last_y = float(last_cell.y.strip("%"))
        last_width = float(last_cell.width.strip("%"))
        last_height = float(last_cell.height.strip("%"))

        # Calculate the new width and height
        new_width = (last_x + last_width) - first_x
        new_height = (last_y + last_height) - first_y

        # Update the first cell's dimensions
        first_cell.width = f"{new_width:.2f}%"
        first_cell.height = f"{new_height:.2f}%"
        first_cell.span_rows = end_row - start_row + 1
        first_cell.span_cols = end_col - start_col + 1

        # Mark other cells in the range as spanned
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if row != start_row or col != start_col:
                    self.cells[row][col].is_spanned = True

        return first_cell

    def add_to_cell(self, row: int, col: int, content_func: Callable, **kwargs) -> Any:
        """Add content to a specific cell in the grid.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            content_func: Function to call to add content (e.g., slide.add_text)
            **kwargs: Additional arguments to pass to the content function

        Returns:
            The object returned by the content function

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell
        """
        # Get the cell
        cell = self.get_cell(row, col)

        # Check if the cell is part of a merged cell
        if cell.is_spanned:
            raise CellMergeError("Cell is part of a merged cell")

        # Calculate the absolute position based on the grid's position
        # Convert grid position percentage to float
        if isinstance(self.x, str) and self.x.endswith("%"):
            grid_x_percent = float(self.x.strip("%"))
        else:
            # Convert inches to percentage based on actual slide width
            slide_width_inches = self._slide_width / 914400  # Convert EMUs to inches
            grid_x_percent = (float(self.x) / slide_width_inches) * 100

        if isinstance(self.y, str) and self.y.endswith("%"):
            grid_y_percent = float(self.y.strip("%"))
        else:
            # Convert inches to percentage based on actual slide height
            slide_height_inches = self._slide_height / 914400  # Convert EMUs to inches
            grid_y_percent = (float(self.y) / slide_height_inches) * 100

        # Calculate absolute position
        cell_x_percent = float(cell.x.strip("%"))
        cell_y_percent = float(cell.y.strip("%"))

        # Handle the width/height values to correctly handle both string and float types
        width_value = (
            float(self.width.strip("%")) if isinstance(self.width, str) and "%" in self.width else float(self.width)
        )
        height_value = (
            float(self.height.strip("%")) if isinstance(self.height, str) and "%" in self.height else float(self.height)
        )

        abs_x_percent = grid_x_percent + (cell_x_percent * width_value / 100)
        abs_y_percent = grid_y_percent + (cell_y_percent * height_value / 100)

        # Calculate absolute width and height
        cell_width_percent = float(cell.width.strip("%"))
        cell_height_percent = float(cell.height.strip("%"))

        abs_width_percent = cell_width_percent * width_value / 100
        abs_height_percent = cell_height_percent * height_value / 100

        # Format as percentage strings
        kwargs["x"] = f"{abs_x_percent:.2f}%"
        kwargs["y"] = f"{abs_y_percent:.2f}%"
        kwargs["width"] = f"{abs_width_percent:.2f}%"
        kwargs["height"] = f"{abs_height_percent:.2f}%"

        # We previously were going to set word_wrap, but slide.add_text doesn't accept this parameter
        # The word_wrap flag is now set internally in the add_text method

        # Call the content function with the calculated position
        content = content_func(**kwargs)

        # Store the content in the cell
        cell.content = content

        return content

    def add_grid_to_cell(
        self,
        row: int,
        col: int,
        rows: int = 1,
        cols: int = 1,
        padding: float = 5.0,
    ) -> "Grid":
        """Add a nested grid to a specific cell.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            rows: Number of rows in the nested grid (default: 1)
            cols: Number of columns in the nested grid (default: 1)
            padding: Padding between cells as percentage of cell size (default: 5.0)

        Returns:
            The nested Grid object

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell
        """
        # Get the cell
        cell = self.get_cell(row, col)

        # Check if the cell is part of a merged cell
        if cell.is_spanned:
            raise CellMergeError("Cell is part of a merged cell")

        # Calculate absolute position for the nested grid
        if isinstance(self.x, str) and self.x.endswith("%"):
            grid_x_percent = float(self.x.strip("%"))
        else:
            # Convert inches to percentage based on actual slide width
            slide_width_inches = self._slide_width / 914400  # Convert EMUs to inches
            grid_x_percent = (float(self.x) / slide_width_inches) * 100

        if isinstance(self.y, str) and self.y.endswith("%"):
            grid_y_percent = float(self.y.strip("%"))
        else:
            # Convert inches to percentage based on actual slide height
            slide_height_inches = self._slide_height / 914400  # Convert EMUs to inches
            grid_y_percent = (float(self.y) / slide_height_inches) * 100

        # Calculate absolute position
        cell_x_percent = float(cell.x.strip("%"))
        cell_y_percent = float(cell.y.strip("%"))

        # Handle the width/height values to correctly handle both string and float types
        width_value = (
            float(self.width.strip("%")) if isinstance(self.width, str) and "%" in self.width else float(self.width)
        )
        height_value = (
            float(self.height.strip("%")) if isinstance(self.height, str) and "%" in self.height else float(self.height)
        )

        abs_x_percent = grid_x_percent + (cell_x_percent * width_value / 100)
        abs_y_percent = grid_y_percent + (cell_y_percent * height_value / 100)

        # Calculate absolute width and height
        cell_width_percent = float(cell.width.strip("%"))
        cell_height_percent = float(cell.height.strip("%"))

        abs_width_percent = cell_width_percent * width_value / 100
        abs_height_percent = cell_height_percent * height_value / 100

        # Create the nested grid
        nested_grid = Grid(
            parent=self.parent,
            x=f"{abs_x_percent:.2f}%",
            y=f"{abs_y_percent:.2f}%",
            width=f"{abs_width_percent:.2f}%",
            height=f"{abs_height_percent:.2f}%",
            rows=rows,
            cols=cols,
            padding=padding,
        )

        # Store the nested grid in the cell
        # Store the nested grid in the cell's content
        if hasattr(cell, "content"):
            cell.content = nested_grid

        return nested_grid

    def __iter__(self):
        """Make Grid iterable to loop through all cells.

        Returns:
            Iterator over all grid cells
        """
        for row in range(self.rows):
            for col in range(self.cols):
                yield self.cells[row][col]

    @overload
    def __getitem__(self, key: int) -> GridRowProxy | GridCellProxy: ...

    @overload
    def __getitem__(self, key: tuple[int, int]) -> GridCellProxy: ...

    def __getitem__(self, key: int | tuple[int, int]) -> GridRowProxy | GridCellProxy:
        """Access a cell or range of cells using enhanced indexing with auto-expansion.

        This method supports three types of indexing:
        - grid[row] for row-based operations (returns GridRowProxy)
        - grid[idx] for flat access to cells by index (returns GridCellProxy)
        - grid[row, col] for cell-specific operations (returns GridCellProxy)

        For flat indexing, cells are ordered row-wise (0 is top-left, then across the row,
        then to the next row).

        If the requested cell is out of bounds, the grid will automatically expand
        to accommodate the request (unless the index is negative).

        Args:
            key: An int for row or flat access, or a tuple of (row, col) for cell access

        Returns:
            - GridRowProxy if key is a row index
            - GridCellProxy if key is a flat index or tuple of (row, col)

        Raises:
            OutOfBoundsError: If the requested cell or row is out of bounds with a negative index
            TypeError: If the key is not in the right format

        Examples:
            ```python
            # Access a specific cell by row, col
            grid[0, 1].add_text("Cell 0,1")

            # Access a row (adds content to the next available cell)
            grid[1].add_image("image.png")

            # Access a cell using flat indexing (0-based)
            grid[0].add_text("First cell (top-left)")
            grid[3].add_text("Fourth cell")

            # Auto-expansion - these will automatically expand the grid
            grid[5, 5].add_text("This expands the grid to include row 5, col 5")
            grid[20].add_text("This expands the grid to include at least 21 cells")
            ```
        """
        if isinstance(key, tuple) and len(key) == 2:
            # Access as grid[row, col] -> return a GridCellProxy
            row, col = key
            # Validate bounds
            if row < 0 or row >= self.rows or col < 0 or col >= self.cols:
                raise OutOfBoundsError(f"Cell position ({row}, {col}) is out of bounds")
            return GridCellProxy(self, row, col)
        elif isinstance(key, int):
            # Check if this is a flat index access or row access
            if 0 <= key < self.rows * self.cols:
                # This could be either a flat index or a row index
                # If key is a valid row index and the grid has multiple rows, interpret as row access
                if key < self.rows:
                    # This is both a valid row and a valid flat index
                    # We need to distinguish between the two

                    # Default to row access for backwards compatibility
                    # Return a GridRowProxy
                    return GridRowProxy(self, key)
                else:
                    # This is definitely a flat index (not a valid row)
                    row = key // self.cols
                    col = key % self.cols
                    return GridCellProxy(self, row, col)
            elif key < 0:
                # Negative index handling for flat access
                total_cells = self.rows * self.cols
                # Convert negative index to positive
                actual_idx = total_cells + key

                if actual_idx < 0:
                    # Still negative after conversion
                    raise OutOfBoundsError(f"Flat index {key} is out of bounds")

                row = actual_idx // self.cols
                col = actual_idx % self.cols
                return GridCellProxy(self, row, col)
            else:
                # This must be an out of bounds row index
                raise OutOfBoundsError(f"Row index {key} is out of bounds")
        else:
            raise TypeError("Grid indices must be integers (for rows or flat access) or tuples of the form (row, col) for cell access")

    @property
    def flat(self):
        """Flat iterator for this grid, similar to matplotlib's subplot.flat.

        Returns:
            A flat iterator over all cells in the grid
        """
        return GridFlatIterator(self)

    def add_textbox(self, row: int, col: int, text: str, **kwargs) -> Any:
        """Add a text box to a specific cell in the grid.

        This is a convenience method that calls add_to_cell with the parent's
        add_text method.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            text: The text content to add
            **kwargs: Additional arguments to pass to the parent's add_text method
                     (font_size, font_bold, align, etc.)

        Returns:
            The created text shape

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell

        Example:
            ```python
            # Add text to a specific cell
            grid.add_textbox(0, 1, "Hello World", font_size=24, align="center")
            ```
        """
        # Add the text parameter to kwargs
        kwargs["text"] = text

        # Call add_to_cell with the parent's add_text method
        return self.add_to_cell(row, col, self.parent.add_text, **kwargs)

    def add_image(self, row: int, col: int, image_path: str, **kwargs) -> Any:
        """Add an image to a specific cell in the grid.

        This is a convenience method that calls add_to_cell with the parent's
        add_image method.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            image_path: Path to the image file
            **kwargs: Additional arguments to pass to the parent's add_image method
                     (maintain_aspect_ratio, border, shadow, etc.)

        Returns:
            The created image shape

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell

        Example:
            ```python
            # Add image to a specific cell
            grid.add_image(1, 0, "path/to/image.jpg", maintain_aspect_ratio=True)
            ```
        """
        # Add the image_path parameter to kwargs
        kwargs["image_path"] = image_path

        # Call add_to_cell with the parent's add_image method
        return self.add_to_cell(row, col, self.parent.add_image, **kwargs)

    def add_pyplot(self, row: int, col: int, figure, **kwargs) -> Any:
        """Add a matplotlib figure to a specific cell in the grid.

        This is a convenience method that creates a temporary file for the figure
        and then adds it as an image to the cell.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            figure: Matplotlib figure object (plt.figure() or plt.gcf())
            **kwargs: Additional arguments for the figure
                     (dpi, file_format, etc.)

        Returns:
            The created image shape

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell

        Example:
            ```python
            import matplotlib.pyplot as plt

            # Create a matplotlib figure
            plt.figure()
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.title('Sample Plot')

            # Add plot to a specific cell
            grid.add_pyplot(0, 1, plt.gcf(), dpi=300)
            ```
        """
        import os
        import tempfile

        # Set default values
        dpi = kwargs.pop("dpi", 300)
        file_format = kwargs.pop("file_format", "png")

        # Create a temporary file for the figure
        with tempfile.NamedTemporaryFile(suffix=f".{file_format}", delete=False) as temp_file:
            temp_path = temp_file.name

        # Save the figure to the temporary file
        figure.savefig(temp_path, dpi=dpi, format=file_format, bbox_inches="tight")

        try:
            # Add the image to the cell
            image_shape = self.add_image(row, col, image_path=temp_path, **kwargs)
            return image_shape
        finally:
            # Clean up the temporary file
            try:
                if os.path.exists(temp_path):
                    os.unlink(temp_path)
            except OSError:
                pass

    def add_table(self, row: int, col: int, data, **kwargs) -> Any:
        """Add a table to a specific cell in the grid.

        This is a convenience method that creates a Table object and adds it to the cell.

        Args:
            row: Row index (0-based)
            col: Column index (0-based)
            data: Table data as a list of lists or pandas DataFrame
            **kwargs: Additional arguments for the table
                     (has_header, style, etc.)

        Returns:
            The created table shape

        Raises:
            OutOfBoundsError: If row or column is out of bounds
            CellMergeError: If the cell is part of a merged cell

        Example:
            ```python
            # Add table to a specific cell
            data = [["Name", "Value"], ["Item 1", 100], ["Item 2", 200]]
            grid.add_table(0, 0, data, has_header=True)

            # With pandas DataFrame
            import pandas as pd
            df = pd.DataFrame({"Name": ["Item 1", "Item 2"], "Value": [100, 200]})
            grid.add_table(1, 1, df)
            ```
        """
        import pandas as pd

        from easypptx.table import Table

        # Get the cell to determine the position and dimensions
        cell = self.get_cell(row, col)

        # Create a Table object
        table_obj = Table(self.parent)

        # Extract position from the cell
        kwargs["x"] = cell.x
        kwargs["y"] = cell.y
        kwargs["width"] = cell.width
        kwargs["height"] = cell.height

        # Remove data from kwargs to handle separately
        kwargs.pop("data", None)

        # Handle has_header parameter if provided
        if "has_header" in kwargs:
            kwargs["first_row_header"] = kwargs.pop("has_header")

        # Convert pandas DataFrame to list if needed
        if isinstance(data, pd.DataFrame):
            table_data = [list(data.columns)] + [list(row) for _, row in data.iterrows()]
        else:
            table_data = data

        # Create the table with the processed data
        table_shape = table_obj.add(data=table_data, **kwargs)

        # Store the table in the cell's content
        cell.content = table_shape

        return table_shape

    def append(self, content_func: Callable) -> None:
        """Append content to the grid and automatically update the layout.

        This method adds a new content function to the grid and automatically
        recalculates the grid layout to accommodate the new content. If needed,
        it will expand the grid by adding rows.

        Args:
            content_func: A function that adds content (like add_text, add_image, etc.)

        Returns:
            None

        Examples:
            ```python
            # Create a dynamic grid
            grid = Grid(slide, rows=2, cols=3)

            # Append content, grid will expand as needed
            grid.append(lambda **kwargs: slide.add_text("Item 1", **kwargs))
            grid.append(lambda **kwargs: slide.add_text("Item 2", **kwargs))
            grid.append(lambda **kwargs: slide.add_image("image.png", **kwargs))
            ```
        """
        # Calculate current grid capacity and total items
        capacity = self.rows * self.cols
        cells_used = 0

        # Count used cells
        for row in range(self.rows):
            for col in range(self.cols):
                if self.cells[row][col].content is not None:
                    cells_used += 1

        # If grid is full, add a new row
        if cells_used >= capacity:
            self._expand_grid(add_rows=1, add_cols=0)

        # Find the next available cell
        target_cell = None
        for row in range(self.rows):
            for col in range(self.cols):
                if self.cells[row][col].content is None:
                    target_cell = self.cells[row][col]
                    break
            if target_cell:
                break

        # Add content to the target cell
        if target_cell:
            row, col = target_cell.row, target_cell.col

            # Calculate position and dimensions for content
            x = target_cell.x
            y = target_cell.y
            width = target_cell.width
            height = target_cell.height

            # Call the content function with the cell's position and dimensions
            content = content_func(x=x, y=y, width=width, height=height)

            # Store the content in the cell
            target_cell.content = content

    def _expand_grid(self, add_rows: int = 0, add_cols: int = 0) -> None:
        """Expand the grid by adding rows and/or columns.

        This method increases the size of the grid by adding the specified number
        of rows and/or columns while maintaining the existing content.

        Args:
            add_rows: Number of rows to add (default: 0)
            add_cols: Number of columns to add (default: 0)

        Returns:
            None
        """
        if add_rows <= 0 and add_cols <= 0:
            return  # Nothing to do

        # Save original dimensions
        original_rows = self.rows
        original_cols = self.cols

        # Update dimensions
        self.rows += add_rows
        self.cols += add_cols

        # Recalculate cell dimensions
        new_cells = self._create_cells()

        # Copy content from old cells to new cells where applicable
        for row in range(original_rows):
            for col in range(original_cols):
                if row < self.rows and col < self.cols:
                    new_cells[row][col].content = self.cells[row][col].content

        # Update cells
        self.cells = new_cells

    @classmethod
    def autogrid(
        cls,
        parent: Any,
        content_funcs: list,
        rows: int | None = None,
        cols: int | None = None,
        x: PositionType = "5%",
        y: PositionType = "5%",
        width: PositionType = "90%",
        height: PositionType = "90%",
        padding: float = 5.0,
        title: str | None = None,
        title_height: PositionType = "10%",
    ) -> "Grid":
        """Create a grid and automatically place content into cells.

        This method automatically determines the appropriate grid dimensions
        and places the provided content functions into the grid cells.

        Args:
            parent: The parent Slide object
            content_funcs: List of content functions to place in grid cells
            rows: Number of rows (if None, calculated automatically)
            cols: Number of columns (if None, calculated automatically)
            x: X position of the grid (default: "5%")
            y: Y position of the grid (default: "5%")
            width: Width of the grid (default: "90%")
            height: Height of the grid (default: "90%")
            padding: Padding between cells (default: 5.0)
            title: Optional title for the grid (default: None)
            title_height: Height of the title area (default: "10%")

        Returns:
            The created Grid object
        """
        # Calculate grid dimensions if not specified
        num_items = len(content_funcs)
        if num_items == 0:
            return cls(parent, x=x, y=y, width=width, height=height)

        if rows is None and cols is None:
            # Determine optimal grid dimensions
            cols = max(1, int(num_items**0.5))
            rows = (num_items + cols - 1) // cols
        elif rows is None:
            rows = (num_items + cols - 1) // cols
        elif cols is None:
            cols = (num_items + rows - 1) // rows

        # Adjust grid position and dimensions if a title is provided
        adjusted_y = y
        adjusted_height = height

        if title and isinstance(y, str) and y.endswith("%"):
            y_percent = float(y.strip("%"))
            title_height_percent = float(str(title_height).strip("%"))
            # Adjust y position and height for the grid
            adjusted_y = f"{y_percent:.2f}%"
            title_y = adjusted_y
            adjusted_y = f"{(y_percent + title_height_percent):.2f}%"

            # Adjust height to account for title
            if isinstance(height, str) and height.endswith("%"):
                height_percent = float(height.strip("%"))
                adjusted_height = f"{(height_percent - title_height_percent):.2f}%"

        # Create the grid
        grid = cls(
            parent=parent,
            x=x,
            y=adjusted_y,
            width=width,
            height=adjusted_height,
            rows=rows,
            cols=cols,
            padding=padding,
        )

        # Add title if provided
        if title:
            parent.add_text(
                text=title,
                x=x,
                y=title_y,
                width=width,
                height=title_height,
                font_size=24,
                font_bold=True,
                align="center",
            )

        # Place content into grid cells
        row_idx = 0
        col_idx = 0

        for func in content_funcs:
            # Create a wrapper function factory to properly capture the current func
            def create_wrapper(content_func):
                def position_agnostic_wrapper(**kwargs):
                    return content_func()

                return position_agnostic_wrapper

            # Create a wrapper specifically for this function
            wrapper = create_wrapper(func)

            # Add content to the current cell using the wrapper
            grid.add_to_cell(
                row=row_idx,
                col=col_idx,
                content_func=wrapper,
            )

            # Move to next cell
            col_idx += 1
            if col_idx >= cols:
                col_idx = 0
                row_idx += 1

            # Stop if we've filled the grid
            if row_idx >= rows:
                break

        return grid

    @classmethod
    def autogrid_pyplot(
        cls,
        parent: Any,
        figures: list,
        rows: int | None = None,
        cols: int | None = None,
        x: PositionType = "5%",
        y: PositionType = "5%",
        width: PositionType = "90%",
        height: PositionType = "90%",
        padding: float = 5.0,
        title: str | None = None,
        title_height: PositionType = "10%",
        dpi: int = 300,
        file_format: str = "png",
    ) -> "Grid":
        """Create a grid and automatically place matplotlib figures into cells.

        This method automatically determines the appropriate grid dimensions
        and places the provided matplotlib figures into the grid cells.

        Args:
            parent: The parent Slide object
            figures: List of matplotlib figures to place in grid cells
            rows: Number of rows (if None, calculated automatically)
            cols: Number of columns (if None, calculated automatically)
            x: X position of the grid (default: "5%")
            y: Y position of the grid (default: "5%")
            width: Width of the grid (default: "90%")
            height: Height of the grid (default: "90%")
            padding: Padding between cells (default: 5.0)
            title: Optional title for the grid (default: None)
            title_height: Height of the title area (default: "10%")
            dpi: Resolution for saved figures (default: 300)
            file_format: Image format for saved figures (default: "png")

        Returns:
            The created Grid object
        """
        import os
        import tempfile

        # Create content functions from matplotlib figures
        content_funcs = []

        # Save each figure to a temporary file and create content functions
        temp_files = []
        for fig in figures:
            # Create a temporary file using context manager
            with tempfile.NamedTemporaryFile(suffix=f".{file_format}", delete=False) as temp_file:
                temp_path = temp_file.name
                temp_files.append(temp_path)

            # Save the figure to the temporary file
            fig.savefig(temp_path, dpi=dpi, format=file_format, bbox_inches="tight")

            # Create a closure with an explicit parameter to avoid loop variable capture issues
            def create_content_func(image_path):
                def add_image_func(**kwargs):
                    return parent.add_image(
                        image_path=image_path,
                        x=kwargs.get("x", "10%"),
                        y=kwargs.get("y", "10%"),
                        width=kwargs.get("width", "80%"),
                        height=kwargs.get("height", "80%"),
                    )

                return add_image_func

            # Add the content function to the list with temp_path bound to a parameter
            content_funcs.append(create_content_func(image_path=temp_path))

        # Create the grid
        try:
            grid = cls.autogrid(
                parent=parent,
                content_funcs=content_funcs,
                rows=rows,
                cols=cols,
                x=x,
                y=y,
                width=width,
                height=height,
                padding=padding,
                title=title,
                title_height=title_height,
            )
        finally:
            # Clean up temporary files
            for temp_file_path in temp_files:
                try:
                    if os.path.exists(temp_file_path):
                        os.unlink(temp_file_path)
                except OSError as e:
                    import logging

                    logging.warning(f"Failed to remove temporary file {temp_file_path}: {e}")

        return grid


class GridFlatIterator:
    """Flat iterator for a Grid, like matplotlib's subplot.flat.

    This iterator provides a way to loop through all cells in a grid in a flattened manner,
    regardless of their row and column positions.

    Attributes:
        grid: The Grid object to iterate over
        current_index: The current index in the flattened grid
        total_cells: The total number of cells in the grid
    """

    def __init__(self, grid: Grid):
        """Initialize a flat iterator for the grid.

        Args:
            grid: The Grid object to iterate over
        """
        self.grid = grid
        self.current_index = 0
        self.total_cells = grid.rows * grid.cols

    def __iter__(self):
        """Return the iterator itself."""
        return self

    def __next__(self):
        """Get the next cell in the flattened grid.

        Returns:
            The next GridCell object

        Raises:
            StopIteration: When all cells have been iterated through
        """
        if self.current_index >= self.total_cells:
            raise StopIteration

        row = self.current_index // self.grid.cols
        col = self.current_index % self.grid.cols
        self.current_index += 1

        return self.grid.cells[row][col]
