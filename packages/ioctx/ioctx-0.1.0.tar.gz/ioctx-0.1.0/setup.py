# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['ioctx']

package_data = \
{'': ['*']}

install_requires = \
['typing-extensions>=4.0.0']

extras_require = \
{'requests': ['requests>=2.25.0']}

setup_kwargs = {
    'name': 'ioctx',
    'version': '0.1.0',
    'description': 'A structured effects system for testable side effects in Python',
    'long_description': '# ioctx-py\n\n[![PyPI version](https://img.shields.io/pypi/v/ioctx.svg)](https://pypi.org/project/ioctx/)\n[![Python Versions](https://img.shields.io/pypi/pyversions/ioctx.svg)](https://pypi.org/project/ioctx/)\n[![License](https://img.shields.io/github/license/wizzardx/ioctx-py.svg)](https://github.com/wizzardx/ioctx-py/blob/main/LICENSE)\n[![Build Status](https://img.shields.io/github/workflow/status/wizzardx/ioctx-py/CI)](https://github.com/wizzardx/ioctx-py/actions)\n\nA structured effects system for testable side effects in Python.\n\n## What is ioctx?\n\nioctx provides a composable, reifiable approach to handling IO operations in Python. Rather than relying on ad-hoc mocking and monkeypatching, ioctx gives you a structured way to make side effects explicit, testable, and traceable.\n\n### The Problem\n\nTraditional approaches to testing IO in Python suffer from several limitations:\n\n- **Global state modification**: Monkeypatching changes global state, creating test isolation problems\n- **Opacity**: No structured record of which operations were intercepted or how they were handled\n- **Incompleteness**: Mocking individual functions is piecemeal and requires careful tracking\n- **Inflexible boundaries**: The boundary between "real" and "fake" operations is often all-or-nothing\n\n### The Solution\n\nioctx provides a unified approach through the `IOContext` protocol:\n\n- **Explicit**: IO operations are performed through a context object passed to functions\n- **Composable**: Different IO contexts can be layered and combined\n- **Reifiable**: All operations can be represented as data for inspection and analysis\n- **Flexible**: Switch between real and simulated IO without changing function logic\n\n## Installation\n\n```bash\npip install ioctx\n```\n\n## Basic Usage\n\n### Defining Functions with IO Context\n\n```python\nfrom ioctx import IOContext\n\ndef fetch_and_process(data_url: str, output_path: str, ctx: IOContext) -> Summary:\n    """Fetch data from URL, process it, and save results."""\n    # Fetch data\n    response = ctx.http_get(data_url)\n    if response.status_code != 200:\n        ctx.log("error", f"Failed to fetch data: {response.status_code}")\n        raise DataFetchError(f"HTTP error: {response.status_code}")\n\n    # Process data\n    data = parse_data(response.text)\n    results = analyze_data(data)\n\n    # Save results\n    ctx.write_file(output_path, results.to_json().encode(\'utf-8\'))\n    ctx.log("info", f"Wrote results to {output_path}")\n\n    return results.summary\n```\n\n### Using with Real IO\n\n```python\nfrom ioctx import RealIO\n\n# Use real IO operations\nreal_ctx = RealIO()\nsummary = fetch_and_process(\n    "https://data.example.com/dataset.json",\n    "/tmp/results.json",\n    real_ctx\n)\n```\n\n### Testing with Fake IO\n\n```python\nfrom ioctx import FakeIO, HttpResponse\n\n# Set up fake responses for testing\nfake_ctx = FakeIO(\n    file_contents={},\n    http_responses={\n        "https://data.example.com/dataset.json": HttpResponse(\n            200,\n            \'{"records": [{"id": 1, "value": 42}, {"id": 2, "value": 17}]}\'\n        )\n    }\n)\n\n# Test with fake IO\ntest_summary = fetch_and_process(\n    "https://data.example.com/dataset.json",\n    "/tmp/results.json",\n    fake_ctx\n)\n\nassert test_summary.record_count == 2\nassert test_summary.total_value == 59\n```\n\n### Logging and Tracing\n\n```python\nfrom ioctx import TracingIO, RealIO\n\n# Add tracing to real operations\ntracing_ctx = TracingIO(RealIO())\nfetch_and_process(\n    "https://data.example.com/dataset.json",\n    "/tmp/results.json",\n    tracing_ctx\n)\n\n# Examine trace\nfor operation, args, result in tracing_ctx.trace:\n    print(f"Operation: {operation}")\n    print(f"Arguments: {args}")\n    print("Result: ", result)\n    print("---")\n```\n\n## Advanced Features\n\n### Composing IO Contexts\n\n```python\n# Create a stack of IO contexts\nbase_ctx = RealIO()\nvalidated_ctx = ValidatingIO(\n    base_ctx,\n    allowed_domains=["api.example.com"],\n    allowed_paths=["/tmp/", "/var/data/"]\n)\ntraced_ctx = TracingIO(validated_ctx)\n\n# Use the composed stack\nresult = process_data("input.csv", traced_ctx)\n\n# Operations pass through each layer\n# 1. Tracing records the call\n# 2. Validation checks permissions\n# 3. RealIO performs the actual IO\n```\n\n### Recording and Replaying IO\n\n```python\n# Record a sequence of operations\nrecord_ctx = RecordingIO(RealIO())\nresults = complex_analysis("data/large_dataset.csv", record_ctx)\nrecording = record_ctx.get_recording()\n\n# Save for later\nimport pickle\nwith open("analysis_recording.pkl", "wb") as f:\n    pickle.dump(recording, f)\n\n# Later, replay the same operations\nwith open("analysis_recording.pkl", "rb") as f:\n    recording = pickle.load(f)\n\nreplay_ctx = ReplayIO(recording)\nresults2 = complex_analysis("data/large_dataset.csv", replay_ctx)\n# results and results2 will be identical\n```\n\n## Why Use ioctx?\n\n- **Testing**: Write deterministic tests for code with IO dependencies without complex mocking\n- **Reproducibility**: Capture and replay exact sequences of IO operations\n- **Tracing**: Record all IO for debugging, auditing, or performance analysis\n- **Validation**: Enforce constraints on what IO operations are allowed\n- **Simulation**: Create realistic test environments with controlled responses\n\n## How Does ioctx Compare?\n\n| Approach | Global State | Visibility | Composition | Reification |\n|----------|--------------|------------|-------------|-------------|\n| unittest.mock | Modifies | Limited | Difficult | None |\n| pytest-mock | Modifies | Limited | Difficult | None |\n| Manual dependency injection | Clean | Manual | Yes | Manual |\n| ioctx | Clean | Built-in | Built-in | Built-in |\n\n## Project Status\n\nioctx is in active development. Current roadmap:\n\n- **Q3 2025**: Initial PyPI release with core functionality\n- **Q4 2025**: Support for additional IO categories and ecosystem integration\n- **Q1 2026**: Advanced tooling for analysis and visualization of IO traces\n\n## Contributing\n\nContributions are welcome! The project is looking for help with:\n\n1. Core API refinement\n2. Backend implementations\n3. Integration bridges\n4. Documentation and examples\n5. Performance optimization\n\nCheck the [Contributing Guide](CONTRIBUTING.md) for more details.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n',
    'author': 'Your Name',
    'author_email': 'your.email@example.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/username/ioctx-py',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
