# -*- coding: utf-8 -*-

"""
gumletrestapis

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from gumletrestapis.api_helper import APIHelper
from gumletrestapis.models.additional_track import AdditionalTrack
from gumletrestapis.models.animated_gif import AnimatedGif
from gumletrestapis.models.call_to_action import CallToAction
from gumletrestapis.models.crop import Crop
from gumletrestapis.models.generate_subtitles import GenerateSubtitles
from gumletrestapis.models.image_overlay import ImageOverlay
from gumletrestapis.models.pad import Pad
from gumletrestapis.models.text_overlay import TextOverlay
from gumletrestapis.models.trim import Trim


class VideoAssetsRequest(object):

    """Implementation of the 'Video Assets Request' model.

    Attributes:
        input (str): URL or web address of a file that Gumlet should download
            to create a new asset.
        collection_id (str): Gumlet video collection id.
        profile_id (str): Provide `profile_id` of the previously created video
            profile. This parameter will override all the parameters (except
            `input` and `collection_id`) from the video profile.
        format (FormatEnum): Transcode and deliver the asset in the requested
            format. The options can be one of `ABR` (HLS + DASH) and`MP4`.
        tag (str): Specify a text string or identifier which can identify an
            asset or bunch of assets later.
        title (str): Specify a text string or identifier which can be used for
            filtering or searching the asset.
        description (str): Attach some textual data with the asset. This field
            is neither searchable nor filterable.
        metadata (str): Add your metadata you want to associate with this
            asset.<br/> Example: <br/> <code>  {  "internal_video_id" :
            "123Abc"  }  </code>
        width (str): Resize video with the given width. Can be an absolute
            value in pixels or a percentage value with the `%` suffix.
            Specified values greater than the original asset width will be
            ignored. Applicable only when specified format is `MP4`.
        height (str): Resize video with the given height. Can be an absolute
            value in pixels or a percentage value with the `%` suffix.
            Specified values greater than the original asset height will be
            ignored. Applicable only when specified format is `MP4`.
        resolution (str): Required resolutions of the transformed asset in
            case of HLS or MPEG-DASH delivery format. Can be a comma separated
            string out of the following values: `240p`, `360p`, `480p`,
            `540p`, `720p`, and `1080p`. Re-sized rendition will retain the
            input aspect ratio.
        crop (Crop): This transformation can be used to crop the video by
            defining a rectangular area within the dimensions of the output
            video.
        pad (Pad): This transformation can be used to add padding to the video.
        trim (Trim): Trim transformation can be used to trim videos based on
            time duration.
        image_overlay (ImageOverlay): Image overlay can be used to brand a
            video or add a visual label in the form of an image.
        text_overlay (TextOverlay): Text overlay can be used to brand a video
            or add a label in the form of text.
        animated_gif (AnimatedGif): Create an animated GIF from the video.
        additional_tracks (List[AdditionalTrack]): Add additional Audio /
            Subtitle tracks to Gumlet for transcoding and delivery along with
            video asset track.
        generate_subtitles (GenerateSubtitles): Gumlet allows to generate
            subtitles from the audio stream (use <a
            href='https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes'
            > ISO 639-1 </a> Language Codes)
        mp_4_access (bool): Creates `MP4` version for download purpose in case
            of `MPEG-DASH` or `HLS` delivery format. **Default: `false`**
        per_title_encoding (bool): Gumlet analyzes each input video on a wide
            range of visual aspects. Based on the analysis, it chooses a
            unique set of transcoding options for processing the video. This
            ensures that the output video is of optimal size and best quality.
            **Default: `true`**
        process_low_resolution_input (bool): Currently, the minimum supported
            frame size is `57600` (`240x240`) pixels for `HLS/DASH` and
            `21025` (`145x145`) pixels for `MP4` format. However, enabling
            this flag will allow Gumlet to simply put your video asset into
            the specified delivery format without transcoding and
            optimization. Enabling this flag will cause any kind of specified
            video transformation to be ignored if you input video asset frame
            size is lower than the minimum supported frame size for the
            specified format. **Default: `false`**
        audio_only (bool): This flag allows Gumlet to transcode and deliver
            audio-only in the specified format. In this case, video
            transformation and thumbnails/animated GIFs would not be created.
            **Default: `false`**
        enable_drm (bool): Enable DRM encryption for transcoded videos. Gumlet
            supports Widevine and Fairplay DRMs.
        call_to_actions (List[CallToAction]): CTA, is an explicit prompt
            within the video content encouraging viewers to take a particular
            action.
        playlist_id (str): Add this asset to a playlist.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "input": 'input',
        "collection_id": 'collection_id',
        "format": 'format',
        "profile_id": 'profile_id',
        "tag": 'tag',
        "title": 'title',
        "description": 'description',
        "metadata": 'metadata',
        "width": 'width',
        "height": 'height',
        "resolution": 'resolution',
        "crop": 'crop',
        "pad": 'pad',
        "trim": 'trim',
        "image_overlay": 'image_overlay',
        "text_overlay": 'text_overlay',
        "animated_gif": 'animated_gif',
        "additional_tracks": 'additional_tracks',
        "generate_subtitles": 'generate_subtitles',
        "mp_4_access": 'mp4_access',
        "per_title_encoding": 'per_title_encoding',
        "process_low_resolution_input": 'process_low_resolution_input',
        "audio_only": 'audio_only',
        "enable_drm": 'enable_drm',
        "call_to_actions": 'call_to_actions',
        "playlist_id": 'playlist_id'
    }

    _optionals = [
        'profile_id',
        'tag',
        'title',
        'description',
        'metadata',
        'width',
        'height',
        'resolution',
        'crop',
        'pad',
        'trim',
        'image_overlay',
        'text_overlay',
        'animated_gif',
        'additional_tracks',
        'generate_subtitles',
        'mp_4_access',
        'per_title_encoding',
        'process_low_resolution_input',
        'audio_only',
        'enable_drm',
        'call_to_actions',
        'playlist_id',
    ]

    def __init__(self,
                 input=None,
                 collection_id=None,
                 format=None,
                 profile_id=APIHelper.SKIP,
                 tag=APIHelper.SKIP,
                 title=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 metadata=APIHelper.SKIP,
                 width=APIHelper.SKIP,
                 height=APIHelper.SKIP,
                 resolution=APIHelper.SKIP,
                 crop=APIHelper.SKIP,
                 pad=APIHelper.SKIP,
                 trim=APIHelper.SKIP,
                 image_overlay=APIHelper.SKIP,
                 text_overlay=APIHelper.SKIP,
                 animated_gif=APIHelper.SKIP,
                 additional_tracks=APIHelper.SKIP,
                 generate_subtitles=APIHelper.SKIP,
                 mp_4_access=APIHelper.SKIP,
                 per_title_encoding=APIHelper.SKIP,
                 process_low_resolution_input=APIHelper.SKIP,
                 audio_only=APIHelper.SKIP,
                 enable_drm=APIHelper.SKIP,
                 call_to_actions=APIHelper.SKIP,
                 playlist_id=APIHelper.SKIP):
        """Constructor for the VideoAssetsRequest class"""

        # Initialize members of the class
        self.input = input 
        self.collection_id = collection_id 
        if profile_id is not APIHelper.SKIP:
            self.profile_id = profile_id 
        self.format = format 
        if tag is not APIHelper.SKIP:
            self.tag = tag 
        if title is not APIHelper.SKIP:
            self.title = title 
        if description is not APIHelper.SKIP:
            self.description = description 
        if metadata is not APIHelper.SKIP:
            self.metadata = metadata 
        if width is not APIHelper.SKIP:
            self.width = width 
        if height is not APIHelper.SKIP:
            self.height = height 
        if resolution is not APIHelper.SKIP:
            self.resolution = resolution 
        if crop is not APIHelper.SKIP:
            self.crop = crop 
        if pad is not APIHelper.SKIP:
            self.pad = pad 
        if trim is not APIHelper.SKIP:
            self.trim = trim 
        if image_overlay is not APIHelper.SKIP:
            self.image_overlay = image_overlay 
        if text_overlay is not APIHelper.SKIP:
            self.text_overlay = text_overlay 
        if animated_gif is not APIHelper.SKIP:
            self.animated_gif = animated_gif 
        if additional_tracks is not APIHelper.SKIP:
            self.additional_tracks = additional_tracks 
        if generate_subtitles is not APIHelper.SKIP:
            self.generate_subtitles = generate_subtitles 
        if mp_4_access is not APIHelper.SKIP:
            self.mp_4_access = mp_4_access 
        if per_title_encoding is not APIHelper.SKIP:
            self.per_title_encoding = per_title_encoding 
        if process_low_resolution_input is not APIHelper.SKIP:
            self.process_low_resolution_input = process_low_resolution_input 
        if audio_only is not APIHelper.SKIP:
            self.audio_only = audio_only 
        if enable_drm is not APIHelper.SKIP:
            self.enable_drm = enable_drm 
        if call_to_actions is not APIHelper.SKIP:
            self.call_to_actions = call_to_actions 
        if playlist_id is not APIHelper.SKIP:
            self.playlist_id = playlist_id 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        input = dictionary.get("input") if dictionary.get("input") else None
        collection_id = dictionary.get("collection_id") if dictionary.get("collection_id") else None
        format = dictionary.get("format") if dictionary.get("format") else None
        profile_id = dictionary.get("profile_id") if dictionary.get("profile_id") else APIHelper.SKIP
        tag = dictionary.get("tag") if dictionary.get("tag") else APIHelper.SKIP
        title = dictionary.get("title") if dictionary.get("title") else APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        metadata = dictionary.get("metadata") if dictionary.get("metadata") else APIHelper.SKIP
        width = dictionary.get("width") if dictionary.get("width") else APIHelper.SKIP
        height = dictionary.get("height") if dictionary.get("height") else APIHelper.SKIP
        resolution = dictionary.get("resolution") if dictionary.get("resolution") else APIHelper.SKIP
        crop = Crop.from_dictionary(dictionary.get('crop')) if 'crop' in dictionary.keys() else APIHelper.SKIP
        pad = Pad.from_dictionary(dictionary.get('pad')) if 'pad' in dictionary.keys() else APIHelper.SKIP
        trim = Trim.from_dictionary(dictionary.get('trim')) if 'trim' in dictionary.keys() else APIHelper.SKIP
        image_overlay = ImageOverlay.from_dictionary(dictionary.get('image_overlay')) if 'image_overlay' in dictionary.keys() else APIHelper.SKIP
        text_overlay = TextOverlay.from_dictionary(dictionary.get('text_overlay')) if 'text_overlay' in dictionary.keys() else APIHelper.SKIP
        animated_gif = AnimatedGif.from_dictionary(dictionary.get('animated_gif')) if 'animated_gif' in dictionary.keys() else APIHelper.SKIP
        additional_tracks = None
        if dictionary.get('additional_tracks') is not None:
            additional_tracks = [AdditionalTrack.from_dictionary(x) for x in dictionary.get('additional_tracks')]
        else:
            additional_tracks = APIHelper.SKIP
        generate_subtitles = GenerateSubtitles.from_dictionary(dictionary.get('generate_subtitles')) if 'generate_subtitles' in dictionary.keys() else APIHelper.SKIP
        mp_4_access = dictionary.get("mp4_access") if "mp4_access" in dictionary.keys() else APIHelper.SKIP
        per_title_encoding = dictionary.get("per_title_encoding") if "per_title_encoding" in dictionary.keys() else APIHelper.SKIP
        process_low_resolution_input = dictionary.get("process_low_resolution_input") if "process_low_resolution_input" in dictionary.keys() else APIHelper.SKIP
        audio_only = dictionary.get("audio_only") if "audio_only" in dictionary.keys() else APIHelper.SKIP
        enable_drm = dictionary.get("enable_drm") if "enable_drm" in dictionary.keys() else APIHelper.SKIP
        call_to_actions = None
        if dictionary.get('call_to_actions') is not None:
            call_to_actions = [CallToAction.from_dictionary(x) for x in dictionary.get('call_to_actions')]
        else:
            call_to_actions = APIHelper.SKIP
        playlist_id = dictionary.get("playlist_id") if dictionary.get("playlist_id") else APIHelper.SKIP
        # Return an object of this model
        return cls(input,
                   collection_id,
                   format,
                   profile_id,
                   tag,
                   title,
                   description,
                   metadata,
                   width,
                   height,
                   resolution,
                   crop,
                   pad,
                   trim,
                   image_overlay,
                   text_overlay,
                   animated_gif,
                   additional_tracks,
                   generate_subtitles,
                   mp_4_access,
                   per_title_encoding,
                   process_low_resolution_input,
                   audio_only,
                   enable_drm,
                   call_to_actions,
                   playlist_id)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'input={self.input!r}, '
                f'collection_id={self.collection_id!r}, '
                f'profile_id={(self.profile_id if hasattr(self, "profile_id") else None)!r}, '
                f'format={self.format!r}, '
                f'tag={(self.tag if hasattr(self, "tag") else None)!r}, '
                f'title={(self.title if hasattr(self, "title") else None)!r}, '
                f'description={(self.description if hasattr(self, "description") else None)!r}, '
                f'metadata={(self.metadata if hasattr(self, "metadata") else None)!r}, '
                f'width={(self.width if hasattr(self, "width") else None)!r}, '
                f'height={(self.height if hasattr(self, "height") else None)!r}, '
                f'resolution={(self.resolution if hasattr(self, "resolution") else None)!r}, '
                f'crop={(self.crop if hasattr(self, "crop") else None)!r}, '
                f'pad={(self.pad if hasattr(self, "pad") else None)!r}, '
                f'trim={(self.trim if hasattr(self, "trim") else None)!r}, '
                f'image_overlay={(self.image_overlay if hasattr(self, "image_overlay") else None)!r}, '
                f'text_overlay={(self.text_overlay if hasattr(self, "text_overlay") else None)!r}, '
                f'animated_gif={(self.animated_gif if hasattr(self, "animated_gif") else None)!r}, '
                f'additional_tracks={(self.additional_tracks if hasattr(self, "additional_tracks") else None)!r}, '
                f'generate_subtitles={(self.generate_subtitles if hasattr(self, "generate_subtitles") else None)!r}, '
                f'mp_4_access={(self.mp_4_access if hasattr(self, "mp_4_access") else None)!r}, '
                f'per_title_encoding={(self.per_title_encoding if hasattr(self, "per_title_encoding") else None)!r}, '
                f'process_low_resolution_input={(self.process_low_resolution_input if hasattr(self, "process_low_resolution_input") else None)!r}, '
                f'audio_only={(self.audio_only if hasattr(self, "audio_only") else None)!r}, '
                f'enable_drm={(self.enable_drm if hasattr(self, "enable_drm") else None)!r}, '
                f'call_to_actions={(self.call_to_actions if hasattr(self, "call_to_actions") else None)!r}, '
                f'playlist_id={(self.playlist_id if hasattr(self, "playlist_id") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'input={self.input!s}, '
                f'collection_id={self.collection_id!s}, '
                f'profile_id={(self.profile_id if hasattr(self, "profile_id") else None)!s}, '
                f'format={self.format!s}, '
                f'tag={(self.tag if hasattr(self, "tag") else None)!s}, '
                f'title={(self.title if hasattr(self, "title") else None)!s}, '
                f'description={(self.description if hasattr(self, "description") else None)!s}, '
                f'metadata={(self.metadata if hasattr(self, "metadata") else None)!s}, '
                f'width={(self.width if hasattr(self, "width") else None)!s}, '
                f'height={(self.height if hasattr(self, "height") else None)!s}, '
                f'resolution={(self.resolution if hasattr(self, "resolution") else None)!s}, '
                f'crop={(self.crop if hasattr(self, "crop") else None)!s}, '
                f'pad={(self.pad if hasattr(self, "pad") else None)!s}, '
                f'trim={(self.trim if hasattr(self, "trim") else None)!s}, '
                f'image_overlay={(self.image_overlay if hasattr(self, "image_overlay") else None)!s}, '
                f'text_overlay={(self.text_overlay if hasattr(self, "text_overlay") else None)!s}, '
                f'animated_gif={(self.animated_gif if hasattr(self, "animated_gif") else None)!s}, '
                f'additional_tracks={(self.additional_tracks if hasattr(self, "additional_tracks") else None)!s}, '
                f'generate_subtitles={(self.generate_subtitles if hasattr(self, "generate_subtitles") else None)!s}, '
                f'mp_4_access={(self.mp_4_access if hasattr(self, "mp_4_access") else None)!s}, '
                f'per_title_encoding={(self.per_title_encoding if hasattr(self, "per_title_encoding") else None)!s}, '
                f'process_low_resolution_input={(self.process_low_resolution_input if hasattr(self, "process_low_resolution_input") else None)!s}, '
                f'audio_only={(self.audio_only if hasattr(self, "audio_only") else None)!s}, '
                f'enable_drm={(self.enable_drm if hasattr(self, "enable_drm") else None)!s}, '
                f'call_to_actions={(self.call_to_actions if hasattr(self, "call_to_actions") else None)!s}, '
                f'playlist_id={(self.playlist_id if hasattr(self, "playlist_id") else None)!s})')
