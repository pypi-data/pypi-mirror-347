# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['dataclass_settings']

package_data = \
{'': ['*']}

install_requires = \
['typing-extensions>=4.7.1', 'typing-inspect']

setup_kwargs = {
    'name': 'dataclass-settings',
    'version': '0.5.1',
    'description': 'Declarative dataclass settings.',
    'long_description': '# dataclass-settings\n\n[![Actions Status](https://github.com/DanCardin/dataclass-settings/actions/workflows/test.yml/badge.svg)](https://github.com/dancardin/dataclass-settings/actions)\n[![Coverage Status](https://coveralls.io/repos/github/DanCardin/dataclass-settings/badge.svg?branch=main)](https://coveralls.io/github/DanCardin/dataclass-settings?branch=main)\n[![Documentation Status](https://readthedocs.org/projects/dataclass-settings/badge/?version=latest)](https://dataclass-settings.readthedocs.io/en/latest/?badge=latest)\n\n- [Full documentation here](https://dataclass-settings.readthedocs.io/en/latest/).\n- [Bundled Loaders](https://dataclass-settings.readthedocs.io/en/latest/loaders.html).\n\n`dataclass-settings` intends to work with any\n[PEP-681](https://peps.python.org/pep-0681/)-compliant dataclass-like object,\nincluding but not limited to:\n\n- [Pydantic models](https://pydantic-docs.helpmanual.io/) (v1/v2),\n- [dataclasses](https://docs.python.org/3/library/dataclasses.html)\n- [attrs classes](https://www.attrs.org/en/stable/).\n- [msgspec models](https://jcristharif.com/msgspec/).\n\n`dataclass-settings` owes its existence\n[pydantic-settings](https://github.com/pydantic/pydantic-settings), in that\npydantic-settings will be a benchmark for `dataclass-settings`\'s featureset.\nHowever it was bourne out of frustration with pydantic-setting\'s approach to\nimplementing that featureset.\n\n## Example\n\n```python\nfrom __future__ import annotations\nfrom dataclass_settings import load_settings, Env, Secret\nfrom pydantic import BaseModel\n\n\nclass Example(BaseModel):\n    env: Annotated[str, Env("ENVIRONMENT")] = "local"\n    dsn: Annotated[str, Env("DSN"), Secret(\'dsn\')] = "dsn://"\n\n    sub_config: SubConfig\n\n\nclass SubConfig(BaseModel):\n    nested: Annotated[int, Env("NESTED")] = "4"\n\n\nexample: Example = load_settings(Example)\n\n# or, if you want `nested` to be `SUB_CONFIG_NESTED`\nexample: Example = load_settings(Example, nested_delimiter=\'_\')\n```\n\n## vs Pydantic Settings\n\n### Simplicity\n\n- `pydantic-settings` alters how you go about defining your normal pydantic\n  models. You need to switch (some of the) base classes, you need to configure\n  the magical `model_config = SettingsConfigDict(...)` object, etc.\n\n  The model becomes inherently entangled with the settings-loading library.\n\n- `dataclass-settings` attaches targeted Annotations metadata to a vanilla\n  pydantic model. You can **choose** to not use `load_settings` (for example, in\n  tests), and construct the model instance however you\'d like.\n\n### Clarity\n\n- `pydantic-settings` makes it really, really difficult to intuit what the\n  concrete environment varibale that\'s going to be loaded for a given field is\n  **actually** going to be. Based on my own experience, and from perusing their\n  issue tracker, it seems like this is not an uncommon experience.\n\n  The combination of field name, `SettingsConfigDict` settings, casing,\n  `alias`/`validation_alias`/`serialization_alias`, and relative position of the\n  env var in the greater config all contribute to it being a **task** to deduce\n  which concrete name will be used when loading.\n\n- `dataclass-settings` by **default** requires an explicit, concrete name, which\n  maps directly to the value being loaded (`Env(\'FOO\')` loads `FOO`, for sure!)\n\n  If you want to opt into a less explcict, more inferred setup (like\n  pydantic-settings), you can do so by utilizing the `nested_delimiter=\'_\'` and\n  `infer_name=True` arguments.\n\n### Typing\n\n- `pydantic-settings` does not play **super** well with type checkers,\n  necessitating the use of a mypy plugin for it to not emit type errors into\n  user code.\n\n  The code recommended in their documentation for namespacing settings, looks\n  like:\n\n  ```python\n  class Settings(BaseSettings):\n      more_settings: SubModel = SubModel()\n  ```\n\n  This only type-checks with mypy (after using the plugin), but not\n  pyright/pylance. Additionally, this **actually** evaluates the `SubModel`\n  constructor during module parsing!\n\n  These issues seem(?) to be inherent to the strategy of subclassing\n  `BaseModel`, and building in its logic into the object construction process\n\n- `dataclass-settings` sidesteps this problem by decoupling the definition of\n  the settings from the loading of settings.\n\n  As such, you\'re more able to define the model, exactly as you would have with\n  vanilla pydantic:\n\n  ```python\n  class Settings(BaseModel):\n      more_settings: SubModel\n  ```\n\n  Internally, the `load_settings` function handles the work of constructing the\n  requisite input structure pydantic expects to construct the whole object tree.\n\n### Compatibility\n\n- `pydantic-settings`\'s `BaseSettings` inherits from pydantic\'s `BaseModel`. And\n  thus can only function against pydantic models, as the name would imply.\n\n- `dataclass-settings`\'s primary entrypoint is a function that accepts a\n  supportable type. As such, it can theoretically support any type that has a\n  well defined object structure, like all of `pydantic`, `dataclasses`, and\n  `attrs`.\n\n  Practically, `pydantic` has the most robust system for parsing/validating a\n  json-like structure into the models, so it\'s probably to be the most flexible\n  anyways. But for many simple cases, particuarly those without nesting, or that\n  only deal in simple types (like int, float, str, etc); then dataclasses/attrs\n  can certainly provide a similar experience.\n\n### Flexibility\n\n- At time of writing, `pydantic-settings`\'s strategy around "loaders", i.e.\n  supportable settings sources is relatively inflexible. Their issue tracker\n  contains a decent number of requests for a more flexible way of defining\n  settings priorities among different loaders, or even using different settings\n  from within a loader.\n\n  This, at least, doesn\'t seem to be an inherent issue to the library\n  necessarily. Just that at present, their API appears to try to reuse\n  pydantic\'s `Field` and `alias` mechanisms to infer the settings for all\n  loaders.\n\n- `dataclass-settings` instead annotates each field individually, with the\n  loaders that field should use. That means you can have different priorities\n  (or entirely different loaders!) per field.\n',
    'author': 'DanCardin',
    'author_email': 'ddcardin@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/dancardin/dataclass-settings',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4',
}


setup(**setup_kwargs)
