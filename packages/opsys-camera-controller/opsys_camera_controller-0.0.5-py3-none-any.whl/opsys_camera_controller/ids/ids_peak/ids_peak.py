# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
The IDS peak API is a library that unites GenTL and GenApi. In some places, it also introduces some extra functionality. 
The purpose of this extra functionality is to increase the usability and comfort of the standard GenAPI.
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ids_peak_python_interface
else:
    import _ids_peak_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _ids_peak_python_interface.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _ids_peak_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _ids_peak_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _ids_peak_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _ids_peak_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _ids_peak_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _ids_peak_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _ids_peak_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _ids_peak_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ids_peak_python_interface:
_ids_peak_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
class NodeChangedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NodeChangedCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::nodes::Node > const &") -> "void":
        return _ids_peak_python_interface.NodeChangedCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == NodeChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.NodeChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_NodeChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_NodeChangedCallbackBase(self)
        return weakref.proxy(self)

# Register NodeChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.NodeChangedCallbackBase_swigregister(NodeChangedCallbackBase)
class SystemInterfaceFoundCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SystemInterfaceFoundCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::InterfaceDescriptor > const &") -> "void":
        return _ids_peak_python_interface.SystemInterfaceFoundCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == SystemInterfaceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.SystemInterfaceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_SystemInterfaceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_SystemInterfaceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register SystemInterfaceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.SystemInterfaceFoundCallbackBase_swigregister(SystemInterfaceFoundCallbackBase)
class InterfaceDeviceFoundCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceFoundCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::DeviceDescriptor > const &") -> "void":
        return _ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == InterfaceDeviceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_swigregister(InterfaceDeviceFoundCallbackBase)
class DeviceDescriptorDeviceOpenedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceDescriptorDeviceOpenedCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::Device > const &") -> "void":
        return _ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceDescriptorDeviceOpenedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceDescriptorDeviceOpenedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceDescriptorDeviceOpenedCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceDescriptorDeviceOpenedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_swigregister(DeviceDescriptorDeviceOpenedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStartedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStartedCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::FirmwareUpdateInformation > const &", arg1: "uint32_t") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_call(self, arg0, arg1)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStartedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStartedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStartedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStartedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStartedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase

    def call(self, arg0: "peak::core::FirmwareUpdateStep", arg1: "uint32_t", arg2: "std::string const &") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_call(self, arg0, arg1, arg2)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase

    def call(self, arg0: "peak::core::FirmwareUpdateStep", arg1: "double") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_call(self, arg0, arg1)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase

    def call(self, arg0: "peak::core::FirmwareUpdateStep") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase)
class FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase

    def call(self) -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_call(self)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateFinishedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateFinishedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateFinishedCallbackBase)
class FirmwareUpdateProgressObserverUpdateFailedCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateFailedCallbackBase

    def call(self, arg0: "std::string const &") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateFailedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateFailedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateFailedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateFailedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateFailedCallbackBase)

def AcquisitionStartModeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.AcquisitionStartModeEnumEntryToString(entry)

def AcquisitionStopModeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.AcquisitionStopModeEnumEntryToString(entry)

def BufferPayloadTypeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.BufferPayloadTypeEnumEntryToString(entry)

def CharacterEncodingEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.CharacterEncodingEnumEntryToString(entry)

def DataStreamFlushModeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.DataStreamFlushModeEnumEntryToString(entry)

def DeviceAccessStatusEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.DeviceAccessStatusEnumEntryToString(entry)

def DeviceAccessTypeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.DeviceAccessTypeEnumEntryToString(entry)

def EventTypeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.EventTypeEnumEntryToString(entry)

def EndiannessEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.EndiannessEnumEntryToString(entry)

def FirmwareUpdatePersistenceEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.FirmwareUpdatePersistenceEnumEntryToString(entry)

def FirmwareUpdateStepEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.FirmwareUpdateStepEnumEntryToString(entry)

def FirmwareUpdateVersionStyleEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.FirmwareUpdateVersionStyleEnumEntryToString(entry)

def PixelFormatNamespaceEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.PixelFormatNamespaceEnumEntryToString(entry)

def PortURLSchemeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.PortURLSchemeEnumEntryToString(entry)

def NodeAccessStatusEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeAccessStatusEnumEntryToString(entry)

def NodeCachingModeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeCachingModeEnumEntryToString(entry)

def NodeDisplayNotationEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeDisplayNotationEnumEntryToString(entry)

def NodeIncrementTypeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeIncrementTypeEnumEntryToString(entry)

def NodeNamespaceEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeNamespaceEnumEntryToString(entry)

def NodeRepresentationEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeRepresentationEnumEntryToString(entry)

def NodeTypeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeTypeEnumEntryToString(entry)

def NodeVisibilityEnumEntryToString(entry: "int32_t") -> "std::string":
    return _ids_peak_python_interface.NodeVisibilityEnumEntryToString(entry)
class DeviceManagerSystemFoundCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerSystemFoundCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::System const > const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerSystemFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerSystemFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerSystemFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerSystemFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_swigregister(DeviceManagerSystemFoundCallbackBase)
class DeviceManagerInterfaceFoundCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerInterfaceFoundCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::Interface const > const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerInterfaceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerInterfaceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerInterfaceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerInterfaceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_swigregister(DeviceManagerInterfaceFoundCallbackBase)
class DeviceManagerInterfaceLostCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerInterfaceLostCallbackBase

    def call(self, arg0: "std::string const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerInterfaceLostCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerInterfaceLostCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerInterfaceLostCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerInterfaceLostCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_swigregister(DeviceManagerInterfaceLostCallbackBase)
class DeviceManagerDeviceFoundCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceFoundCallbackBase

    def call(self, arg0: "std::shared_ptr< peak::core::DeviceDescriptor > const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_swigregister(DeviceManagerDeviceFoundCallbackBase)
class DeviceManagerDeviceLostCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceLostCallbackBase

    def call(self, arg0: "std::string const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceLostCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceLostCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceLostCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceLostCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_swigregister(DeviceManagerDeviceLostCallbackBase)
class DeviceManagerUpdateErrorCallbackBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerUpdateErrorCallbackBase

    def call(self, arg0: "std::string const &") -> "void":
        return _ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_call(self, arg0)

    def __init__(self):
        if self.__class__ == DeviceManagerUpdateErrorCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerUpdateErrorCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerUpdateErrorCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerUpdateErrorCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_swigregister(DeviceManagerUpdateErrorCallbackBase)
class Exception(Exception):
    r"""The base class for all exceptions thrown by the library."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.Exception_swiginit(self, _ids_peak_python_interface.new_Exception(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_Exception

# Register Exception in _ids_peak_python_interface:
_ids_peak_python_interface.Exception_swigregister(Exception)
class AbortedException(Exception):
    r"""The exception thrown for signaling an aborted operation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.AbortedException_swiginit(self, _ids_peak_python_interface.new_AbortedException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_AbortedException

# Register AbortedException in _ids_peak_python_interface:
_ids_peak_python_interface.AbortedException_swigregister(AbortedException)
class BadAccessException(Exception):
    r"""The exception thrown for signaling an access error."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.BadAccessException_swiginit(self, _ids_peak_python_interface.new_BadAccessException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_BadAccessException

# Register BadAccessException in _ids_peak_python_interface:
_ids_peak_python_interface.BadAccessException_swigregister(BadAccessException)
class BadAllocException(Exception):
    r"""The exception thrown for signaling a failed memory allocation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.BadAllocException_swiginit(self, _ids_peak_python_interface.new_BadAllocException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_BadAllocException

# Register BadAllocException in _ids_peak_python_interface:
_ids_peak_python_interface.BadAllocException_swigregister(BadAllocException)
class InternalErrorException(Exception):
    r"""The exception thrown for internal errors."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.InternalErrorException_swiginit(self, _ids_peak_python_interface.new_InternalErrorException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_InternalErrorException

# Register InternalErrorException in _ids_peak_python_interface:
_ids_peak_python_interface.InternalErrorException_swigregister(InternalErrorException)
class InvalidAddressException(Exception):
    r"""The exception thrown for trying to work on an invalid address."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.InvalidAddressException_swiginit(self, _ids_peak_python_interface.new_InvalidAddressException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_InvalidAddressException

# Register InvalidAddressException in _ids_peak_python_interface:
_ids_peak_python_interface.InvalidAddressException_swigregister(InvalidAddressException)
class InvalidArgumentException(Exception):
    r"""The exception thrown for pass an invalid argument to a function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.InvalidArgumentException_swiginit(self, _ids_peak_python_interface.new_InvalidArgumentException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_InvalidArgumentException

# Register InvalidArgumentException in _ids_peak_python_interface:
_ids_peak_python_interface.InvalidArgumentException_swigregister(InvalidArgumentException)
class InvalidCastException(Exception):
    r"""The exception thrown for trying to apply an invalid cast."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.InvalidCastException_swiginit(self, _ids_peak_python_interface.new_InvalidCastException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_InvalidCastException

# Register InvalidCastException in _ids_peak_python_interface:
_ids_peak_python_interface.InvalidCastException_swigregister(InvalidCastException)
class InvalidInstanceException(Exception):
    r"""The exception thrown for trying to work on an invalid instance."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.InvalidInstanceException_swiginit(self, _ids_peak_python_interface.new_InvalidInstanceException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_InvalidInstanceException

# Register InvalidInstanceException in _ids_peak_python_interface:
_ids_peak_python_interface.InvalidInstanceException_swigregister(InvalidInstanceException)
class NotAvailableException(Exception):
    r"""The exception thrown for signaling a feature is not available in the device."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NotAvailableException

# Register NotAvailableException in _ids_peak_python_interface:
_ids_peak_python_interface.NotAvailableException_swigregister(NotAvailableException)
class NotFoundException(Exception):
    r"""The exception thrown for signaling a failed find operation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.NotFoundException_swiginit(self, _ids_peak_python_interface.new_NotFoundException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_NotFoundException

# Register NotFoundException in _ids_peak_python_interface:
_ids_peak_python_interface.NotFoundException_swigregister(NotFoundException)
class NotImplementedException(Exception):
    r"""The exception thrown for signaling a feature is not implemented."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NotImplementedException

# Register NotImplementedException in _ids_peak_python_interface:
_ids_peak_python_interface.NotImplementedException_swigregister(NotImplementedException)
class NotInitializedException(Exception):
    r"""
    The exception thrown for signaling that the library was not initialized.

    Notes: Remember to call InitializeLibrary() before anything else.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.NotInitializedException_swiginit(self, _ids_peak_python_interface.new_NotInitializedException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_NotInitializedException

# Register NotInitializedException in _ids_peak_python_interface:
_ids_peak_python_interface.NotInitializedException_swigregister(NotInitializedException)
class OutOfRangeException(Exception):
    r"""The exception thrown for trying to access a value being out of range."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.OutOfRangeException_swiginit(self, _ids_peak_python_interface.new_OutOfRangeException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_OutOfRangeException

# Register OutOfRangeException in _ids_peak_python_interface:
_ids_peak_python_interface.OutOfRangeException_swigregister(OutOfRangeException)
class TimeoutException(Exception):
    r"""The exception thrown for signaling an exceeded timeout during a function call."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _ids_peak_python_interface.TimeoutException_swiginit(self, _ids_peak_python_interface.new_TimeoutException(error_description))
    __swig_destroy__ = _ids_peak_python_interface.delete_TimeoutException

# Register TimeoutException in _ids_peak_python_interface:
_ids_peak_python_interface.TimeoutException_swigregister(TimeoutException)
class CTILoadingException(Exception):
    r"""The exception thrown for signaling an error on opening a cti."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_CTILoadingException

# Register CTILoadingException in _ids_peak_python_interface:
_ids_peak_python_interface.CTILoadingException_swigregister(CTILoadingException)
class Version(object):
    r"""
    Implements versioning functionality.

    This class allows to create and compare different versions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Version

    def __init__(self, *args):
        _ids_peak_python_interface.Version_swiginit(self, _ids_peak_python_interface.new_Version(*args))

    def ToString(self) -> "std::string":
        r"""
        Returns the version as string.

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_ToString(self)

    def Major(self) -> "uint32_t":
        r"""
        Returns the major part of the version which is the first part of the version scheme separated by dots.

        :rtype: int
        :return: **x**.y.z

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Major(self)

    def Minor(self) -> "uint32_t":
        r"""
        Returns the minor part of the version which is the second part of the version scheme separated by dots.

        :rtype: int
        :return: x.**y**.z

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Minor(self)

    def Subminor(self) -> "uint32_t":
        r"""
        Returns the subminor part of the version which is the third part of the version scheme separated by dots.

        :rtype: int
        :return: x.y.**z**

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Subminor(self)

# Register Version in _ids_peak_python_interface:
_ids_peak_python_interface.Version_swigregister(Version)

def __lt__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__lt__(lhs, rhs)

def __gt__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__gt__(lhs, rhs)

def __eq__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__eq__(lhs, rhs)

def __ne__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__ne__(lhs, rhs)
class Library(object):
    r"""
    A collection of global library functions.

    Currently, this includes Library::Initialize() / Library::Close(), which must be called before/after usage of the
    library, and Library::Version(), to retrieve version information about the the library.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Initialize() -> "void":
        r"""
        Initializes the IDS peak API library.

        This function **must** be called prior to any other function call to allow global initialization of library
        internals. This function is necessary since automated initialization functionality like within DllMain on MS
        Windows platforms is very limited.

        Calling this function multiple times is ok, but note that these calls are reference counted, so you have to call
        Close() as many times as Initialize().

        Since: 1.0
        2.0 Added reference counting

        Notes: Calling any other function before this will result in a core::NotInitializedException.

        :raises: std::runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Initialize()

    @staticmethod
    def Close() -> "void":
        r"""
        Closes the IDS peak API library and cleans up any resources that are still in use.

        This function should be called after no function of the library is needed anymore, before unloading the library.
        It cleans up any resources still in use. If an DeviceManager::Update is in progress, the update will finish
        before the library is closed.

        Notes: Calling any other function (except Initialize()) after this will result in a core::NotInitializedException.

        Calls to Initialize() and Close() are reference counted, so you have to call Close() as many times as you
              called Initialize().

        Warning: It is of particular importance on _MS Windows_ platforms, when using "Run-Time Dynamic Linking",
                 especially when unloading the DLL with FreeLibrary(). Otherwise it is very likely to run into the
                 "Loader-Lock Deadlock Problem" during DLL unloading.

        Since: 1.0
        2.0 Added reference counting

        :raises: std::runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Close()

    @staticmethod
    def Version() -> "peak::core::Version":
        r"""
        Returns the library version.

        :rtype: :py:class:`Version`
        :return: Library version

        Since: 1.0

        :raises: std::runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Version()

# Register Library in _ids_peak_python_interface:
_ids_peak_python_interface.Library_swigregister(Library)
Endianness_Unknown = _ids_peak_python_interface.Endianness_Unknown
r"""Endianness of the data is unknown to the GenTL Producer."""
Endianness_Little = _ids_peak_python_interface.Endianness_Little
r"""The data is stored in little endian format."""
Endianness_Big = _ids_peak_python_interface.Endianness_Big
r"""The data is stored in big endian format."""
class RawInformation(object):
    r""" The struct returned by all raw information functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DataType: "int32_t" = property(_ids_peak_python_interface.RawInformation_DataType_get, _ids_peak_python_interface.RawInformation_DataType_set)
    Data: "std::vector< uint8_t,std::allocator< uint8_t > >" = property(_ids_peak_python_interface.RawInformation_Data_get, _ids_peak_python_interface.RawInformation_Data_set)

    def __init__(self):
        _ids_peak_python_interface.RawInformation_swiginit(self, _ids_peak_python_interface.new_RawInformation())
    __swig_destroy__ = _ids_peak_python_interface.delete_RawInformation

# Register RawInformation in _ids_peak_python_interface:
_ids_peak_python_interface.RawInformation_swigregister(RawInformation)
class Timeout(object):
    r"""
    Represents a timeout value in milliseconds.

    Use INFINITE_TIMEOUT for an infinite timeout.

    Since: 1.1
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    INFINITE_TIMEOUT = _ids_peak_python_interface.Timeout_INFINITE_TIMEOUT
    r"""
    The constant defining an infinite timeout.

    The corresponding function will only return after the operation is completed.
    """

    def __init__(self, *args):
        _ids_peak_python_interface.Timeout_swiginit(self, _ids_peak_python_interface.new_Timeout(*args))
    __swig_destroy__ = _ids_peak_python_interface.delete_Timeout

# Register Timeout in _ids_peak_python_interface:
_ids_peak_python_interface.Timeout_swigregister(Timeout)
EventType_Error = _ids_peak_python_interface.EventType_Error
EventType_FeatureInvalidate = _ids_peak_python_interface.EventType_FeatureInvalidate
EventType_FeatureChange = _ids_peak_python_interface.EventType_FeatureChange
EventType_RemoteDevice = _ids_peak_python_interface.EventType_RemoteDevice
EventType_Module = _ids_peak_python_interface.EventType_Module
EventType_Custom = _ids_peak_python_interface.EventType_Custom
class Event(object):
    r"""Encapsulates the GenTL event data functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Event

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.Event_Info(self, infoCommand)

    def ID(self) -> "uint64_t":
        r"""
        Returns the ID.

        :rtype: int
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Event_ID(self)

    def Data(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Returns the event payload data.

        The delivered data depend on the event type.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: Payload data

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Event_Data(self)

    def Type(self) -> "peak::core::EventType":
        r"""
        Returns the type.

        :rtype: int
        :return: Type

        Since: 1.0
        """
        return _ids_peak_python_interface.Event_Type(self)

    def RawData(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Returns the event raw data.

        The delivered data depend on the underlying transport layer
        (GEV, USB3, ...) and the event type.
        (e.g. If the underlying CTI implements GEV and the event is a remote device event,
        the delivered data will be the event raw data of a GEV event)

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: Raw data

        Since: 1.2
        """
        return _ids_peak_python_interface.Event_RawData(self)

# Register Event in _ids_peak_python_interface:
_ids_peak_python_interface.Event_swigregister(Event)
class EventController(object):
    r"""
    Encapsulates the GenTL event functionality associated with one GenTL Event handle.

    This class is returned by EventSupportingModule::EnableEvents() and acts as a controller for events of the type given
    to EventSupportingModule::EnableEvents().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EventController

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.EventController_Info(self, infoCommand)

    def NumEventsInQueue(self) -> "size_t":
        r"""
        Returns the number of events in queue.

        :rtype: int
        :return: Number of events in queue

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_NumEventsInQueue(self)

    def NumEventsFired(self) -> "uint64_t":
        r"""
        Returns the number of fired events.

        :rtype: int
        :return: Number of fired events

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_NumEventsFired(self)

    def EventMaxSize(self) -> "size_t":
        r"""
        Returns the maximum size of an event in bytes.

        :rtype: int
        :return: Maximum size of an event in bytes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_EventMaxSize(self)

    def EventDataMaxSize(self) -> "size_t":
        r"""
        Returns the maximum size of the data of an event in bytes.

        :rtype: int
        :return: Maximum size of the data of an event in bytes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_EventDataMaxSize(self)

    def WaitForEvent(self, timeout_ms: "Timeout") -> "std::unique_ptr< peak::core::Event >":
        r"""
        Blocking wait for an event.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The maximum waiting time in milliseconds.
                                  When called with Timeout::INFINITE_TIMEOUT, the function will only return
                                  if the event is triggered or KillWait() is called.

        :rtype: std::unique_ptr< peak::core::Event >
        :return: Event

        Since: 1.0

        :raises: AbortedException The wait was aborted
        :raises: TimeoutException The function call timed out
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_WaitForEvent(self, timeout_ms)

    def KillWait(self) -> "void":
        r"""
        Terminates a wait for an event.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_KillWait(self)

    def FlushEvents(self) -> "void":
        r"""
        Discards all events in queue.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_FlushEvents(self)

    def ControlledEventType(self) -> "peak::core::EventType":
        r"""
        Returns the controlled event type.

        :rtype: int
        :return: Controlled event type

        Since: 1.0
        """
        return _ids_peak_python_interface.EventController_ControlledEventType(self)

# Register EventController in _ids_peak_python_interface:
_ids_peak_python_interface.EventController_swigregister(EventController)
NodeAccessStatus_NotImplemented = _ids_peak_python_interface.NodeAccessStatus_NotImplemented
NodeAccessStatus_NotAvailable = _ids_peak_python_interface.NodeAccessStatus_NotAvailable
NodeAccessStatus_WriteOnly = _ids_peak_python_interface.NodeAccessStatus_WriteOnly
NodeAccessStatus_ReadOnly = _ids_peak_python_interface.NodeAccessStatus_ReadOnly
NodeAccessStatus_ReadWrite = _ids_peak_python_interface.NodeAccessStatus_ReadWrite
NodeCachingMode_NoCache = _ids_peak_python_interface.NodeCachingMode_NoCache
r"""NoCache means all values are read directly from the device."""
NodeCachingMode_WriteThrough = _ids_peak_python_interface.NodeCachingMode_WriteThrough
r"""WriteThrough means that a value written to the camera is written to the cache as well."""
NodeCachingMode_WriteAround = _ids_peak_python_interface.NodeCachingMode_WriteAround
r"""WriteAround means that only read values are written to the cache."""
NodeNamespace_Custom = _ids_peak_python_interface.NodeNamespace_Custom
NodeNamespace_Standard = _ids_peak_python_interface.NodeNamespace_Standard
NodeType_Integer = _ids_peak_python_interface.NodeType_Integer
NodeType_Boolean = _ids_peak_python_interface.NodeType_Boolean
NodeType_Command = _ids_peak_python_interface.NodeType_Command
NodeType_Float = _ids_peak_python_interface.NodeType_Float
NodeType_String = _ids_peak_python_interface.NodeType_String
NodeType_Register = _ids_peak_python_interface.NodeType_Register
NodeType_Category = _ids_peak_python_interface.NodeType_Category
NodeType_Enumeration = _ids_peak_python_interface.NodeType_Enumeration
NodeType_EnumerationEntry = _ids_peak_python_interface.NodeType_EnumerationEntry
NodeVisibility_Beginner = _ids_peak_python_interface.NodeVisibility_Beginner
NodeVisibility_Expert = _ids_peak_python_interface.NodeVisibility_Expert
NodeVisibility_Guru = _ids_peak_python_interface.NodeVisibility_Guru
NodeVisibility_Invisible = _ids_peak_python_interface.NodeVisibility_Invisible
class Node(object):
    r"""
     End of conditional comment.
    Represents a GenAPI node.

    This class allows to interact with a single node of a module. It is the base class for all nodes a module can
    have.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Node

    def Name(self) -> "std::string":
        r"""
        Returns the name.

        :rtype: string
        :return: Name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Name(self)

    def DisplayName(self) -> "std::string":
        r"""
        Returns the display name.

        :rtype: string
        :return: Display name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_DisplayName(self)

    def Namespace(self) -> "peak::core::nodes::NodeNamespace":
        r"""
        Returns the namespace the node belongs to.

        :rtype: int
        :return: Namespace the node belongs to

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Namespace(self)

    def Visibility(self) -> "peak::core::nodes::NodeVisibility":
        r"""
        Returns the visibility.

        :rtype: int
        :return: Visibility

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Visibility(self)

    def AccessStatus(self) -> "peak::core::nodes::NodeAccessStatus":
        r"""
        Returns the access status.

        :rtype: int
        :return: Access status

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_AccessStatus(self)

    def IsCacheable(self) -> "bool":
        r"""
        Checks whether the node is cacheable.

        :rtype: boolean
        :return: True, if the node is cacheable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsCacheable(self)

    def IsAccessStatusCacheable(self) -> "bool":
        r"""
        Checks whether the node's access status is cacheable.

        :rtype: boolean
        :return: True, if the node's access status is cacheable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsAccessStatusCacheable(self)

    def IsStreamable(self) -> "bool":
        r"""
        Checks whether the node is streamable.

        :rtype: boolean
        :return: True, if the node is streamable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsStreamable(self)

    def IsDeprecated(self) -> "bool":
        r"""
        Checks whether the node is deprecated.

        :rtype: boolean
        :return: True, if the node is deprecated.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsDeprecated(self)

    def IsFeature(self) -> "bool":
        r"""
        Checks whether the node is a feature, i.e. it can be reached via
        category nodes from a category node named "Root".

        :rtype: boolean
        :return: True, if the node is a feature.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsFeature(self)

    def CachingMode(self) -> "peak::core::nodes::NodeCachingMode":
        r"""
        Returns the caching mode.

        :rtype: int
        :return: Caching mode

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_CachingMode(self)

    def PollingTime(self) -> "int64_t":
        r"""
        Returns the polling time.

        :rtype: int
        :return: Polling time in milliseconds

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_PollingTime(self)

    def ToolTip(self) -> "std::string":
        r"""
        Returns the tool tip.

        :rtype: string
        :return: Tool tip

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_ToolTip(self)

    def Description(self) -> "std::string":
        r"""
        Returns the description.

        :rtype: string
        :return: Description

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Description(self)

    def Type(self) -> "peak::core::nodes::NodeType":
        r"""
        Returns the type.

        The returned type is necessary to know the type the node has to be casted to if you want to access the full
        functionality of the node.

        :rtype: int
        :return: Type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Type(self)

    def ParentNodeMap(self) -> "std::shared_ptr< peak::core::NodeMap >":
        r"""
        Returns the parent node map.

        :rtype: :py:class:`NodeMap`
        :return: Parent node map

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_ParentNodeMap(self)

    def FindInvalidatedNode(self, name: "std::string const &") -> "std::shared_ptr< peak::core::nodes::Node >":
        r"""
        Tries to find an invalidated node with the given name.

        :type name: string, in
        :param name: The name of the invalidated node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no invalidated node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no invalidated node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindInvalidatedNode(self, name)

    def InvalidatedNodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the invalidated nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Invalidated nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_InvalidatedNodes(self)

    def FindInvalidatingNode(self, name: "std::string const &") -> "std::shared_ptr< peak::core::nodes::Node >":
        r"""
        Tries to find an invalidating node with the given name.

        :type name: string, in
        :param name: The name of the invalidating node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no invalidating node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no invalidating node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindInvalidatingNode(self, name)

    def InvalidatingNodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the invalidating nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Invalidating nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_InvalidatingNodes(self)

    def FindSelectedNode(self, name: "std::string const &") -> "std::shared_ptr< peak::core::nodes::Node >":
        r"""
        Tries to find a selected node with the given name.

        :type name: string, in
        :param name: The name of the selected node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no selected node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no selected node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindSelectedNode(self, name)

    def SelectedNodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the selected nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Selected nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_SelectedNodes(self)

    def FindSelectingNode(self, name: "std::string const &") -> "std::shared_ptr< peak::core::nodes::Node >":
        r"""
        Tries to find a selecting node with the given name.

        :type name: string, in
        :param name: The name of the selecting node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no selecting node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no selecting node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindSelectingNode(self, name)

    def SelectingNodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the selecting nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Selecting nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_SelectingNodes(self)

    def RegisterChangedCallback(self, callback: "NodeChangedCallbackBase") -> "peak::core::nodes::Node::ChangedCallbackHandle":
        return _ids_peak_python_interface.Node_RegisterChangedCallback(self, callback)

    def UnregisterChangedCallback(self, callbackHandle: "peak::core::nodes::Node::ChangedCallbackHandle") -> "void":
        return _ids_peak_python_interface.Node_UnregisterChangedCallback(self, callbackHandle)

    class ChangedCallback(NodeChangedCallbackBase):
        def __init__(self, callback):
            NodeChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::nodes::Node>&"):
            self._callback(arg0)
        _callback = None


# Register Node in _ids_peak_python_interface:
_ids_peak_python_interface.Node_swigregister(Node)
NodeCacheUsePolicy_UseCache = _ids_peak_python_interface.NodeCacheUsePolicy_UseCache
NodeCacheUsePolicy_IgnoreCache = _ids_peak_python_interface.NodeCacheUsePolicy_IgnoreCache
NodeIncrementType_NoIncrement = _ids_peak_python_interface.NodeIncrementType_NoIncrement
NodeIncrementType_FixedIncrement = _ids_peak_python_interface.NodeIncrementType_FixedIncrement
NodeIncrementType_ListIncrement = _ids_peak_python_interface.NodeIncrementType_ListIncrement
NodeRepresentation_Linear = _ids_peak_python_interface.NodeRepresentation_Linear
NodeRepresentation_Logarithmic = _ids_peak_python_interface.NodeRepresentation_Logarithmic
NodeRepresentation_Boolean = _ids_peak_python_interface.NodeRepresentation_Boolean
NodeRepresentation_PureNumber = _ids_peak_python_interface.NodeRepresentation_PureNumber
NodeRepresentation_HexNumber = _ids_peak_python_interface.NodeRepresentation_HexNumber
NodeRepresentation_IP4Address = _ids_peak_python_interface.NodeRepresentation_IP4Address
NodeRepresentation_MACAddress = _ids_peak_python_interface.NodeRepresentation_MACAddress
class BooleanNode(Node):
    r"""Represents a GenAPI boolean node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_BooleanNode

    def Value(self, *args) -> "bool":
        r"""
        Returns the value.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: boolean
        :return: Value

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BooleanNode_Value(self, *args)

    def SetValue(self, value: "bool") -> "void":
        r"""
        Sets the given value.

        :type value: boolean, in
        :param value: The value to be set.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BooleanNode_SetValue(self, value)

# Register BooleanNode in _ids_peak_python_interface:
_ids_peak_python_interface.BooleanNode_swigregister(BooleanNode)
class CategoryNode(Node):
    r"""Represents a GenAPI category node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_CategoryNode

    def SubNodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the sub nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Sub nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CategoryNode_SubNodes(self)

# Register CategoryNode in _ids_peak_python_interface:
_ids_peak_python_interface.CategoryNode_swigregister(CategoryNode)
class CommandNode(Node):
    r"""Represents a GenAPI command node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_CommandNode

    def IsDone(self) -> "bool":
        r"""
        Checks whether the command is done.

        :rtype: boolean
        :return: True, if the command is done
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CommandNode_IsDone(self)

    def Execute(self) -> "void":
        r"""
        Executes the command associated with this node

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CommandNode_Execute(self)

    def WaitUntilDone(self, waitTimeout_ms: "Timeout"=500) -> "void":
        r"""
        (Blocking) Wait for the executed command to be finished, i.e. until IsDone() is true.

        :type waitTimeout_ms: :py:class:`Timeout`, in, optional
        :param waitTimeout_ms: The maximum waiting time in milliseconds.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: TimeoutException       The specified timeout expired without the executed command being finished.
        """
        return _ids_peak_python_interface.CommandNode_WaitUntilDone(self, waitTimeout_ms)

# Register CommandNode in _ids_peak_python_interface:
_ids_peak_python_interface.CommandNode_swigregister(CommandNode)
class EnumerationEntryNode(Node):
    r"""Represents a GenAPI enumeration entry node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EnumerationEntryNode

    def IsSelfClearing(self) -> "bool":
        r"""
        Checks whether the node is self clearing.

        :rtype: boolean
        :return: True, if the node is self clearing.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_IsSelfClearing(self)

    def SymbolicValue(self) -> "std::string":
        r"""
        Returns the symbolic value (i.e. name/string value) of the enum entry.

        :rtype: string
        :return: Symbolic value.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_SymbolicValue(self)

    def StringValue(self) -> "std::string":
        
        return _ids_peak_python_interface.EnumerationEntryNode_StringValue(self)

    def Value(self) -> "int64_t":
        r"""
        Returns the numeric value of the enum entry.

        :rtype: int
        :return: Value.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_Value(self)

    def NumericValue(self) -> "int64_t":
        
        return _ids_peak_python_interface.EnumerationEntryNode_NumericValue(self)

# Register EnumerationEntryNode in _ids_peak_python_interface:
_ids_peak_python_interface.EnumerationEntryNode_swigregister(EnumerationEntryNode)
class EnumerationNode(Node):
    r"""Represents a GenAPI enumeration node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EnumerationNode

    def CurrentEntry(self, *args) -> "std::shared_ptr< peak::core::nodes::EnumerationEntryNode >":
        r"""
        Returns the current entry.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Current entry

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_CurrentEntry(self, *args)

    def SetCurrentEntry(self, *args) -> "void":
        r"""
        *Overload 1:*

        Sets the current entry.

        :type entry: :py:class:`EnumerationEntryNode`, in
        :param entry: The entry to set as current entry.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: InvalidArgumentException There is no matching entry in this enumeration node.

        |

        *Overload 2:*

        Sets the current entry to an entry with the given symbolic value.

        :type symbolicValue: string, in
        :param symbolicValue: The symbolic value of the entry to set.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: InvalidArgumentException There is no entry with this symbolicValue in this enumeration node.

        |

        *Overload 3:*

        Sets the current entry to an entry with the given value.

        :type value: int, in
        :param value: The value of the entry to set.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: InvalidArgumentException There is no entry with this value in this enumeration node.
        """
        return _ids_peak_python_interface.EnumerationNode_SetCurrentEntry(self, *args)

    def FindEntry(self, *args) -> "std::shared_ptr< peak::core::nodes::EnumerationEntryNode >":
        r"""
        *Overload 1:*

        Tries to find a entry with the given symbolic value.

        :type symbolicValue: string, in
        :param symbolicValue: The symbolic value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry.
        :rtype: :py:class:`EnumerationEntryNode`
        :return: If no entry with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no entry with the given name.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Tries to find a entry with the given numeric value.

        :type value: int, in
        :param value: The value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry.
        :rtype: :py:class:`EnumerationEntryNode`
        :return: If no entry with the given numeric value, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no entry with the given numeric value.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_FindEntry(self, *args)

    def Entries(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode >,std::allocator< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > > >":
        r"""
        Returns the entries.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode >,std::allocator< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > > >
        :return: Entries

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_Entries(self)

# Register EnumerationNode in _ids_peak_python_interface:
_ids_peak_python_interface.EnumerationNode_swigregister(EnumerationNode)
NodeDisplayNotation_Automatic = _ids_peak_python_interface.NodeDisplayNotation_Automatic
NodeDisplayNotation_Fixed = _ids_peak_python_interface.NodeDisplayNotation_Fixed
NodeDisplayNotation_Scientific = _ids_peak_python_interface.NodeDisplayNotation_Scientific
class FloatNode(Node):
    r"""Represents a GenAPI float node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FloatNode

    def Minimum(self) -> "double":
        r"""
        Returns the minimum.

        :rtype: float
        :return: Minimum

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Minimum(self)

    def Maximum(self) -> "double":
        r"""
        Returns the maximum.

        :rtype: float
        :return: Maximum

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Maximum(self)

    def Increment(self) -> "double":
        r"""
        Returns the increment.

        :rtype: float
        :return: Increment

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Increment(self)

    def IncrementType(self) -> "peak::core::nodes::NodeIncrementType":
        r"""
        Returns the increment type.

        :rtype: int
        :return: Increment type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_IncrementType(self)

    def ValidValues(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Returns the valid values.

        This function returns a list of valid values. A numeric node can have a list of valid values if it does not have
        a constant increment.

        :rtype: std::vector< double,std::allocator< double > >
        :return: Valid values

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_ValidValues(self)

    def Representation(self) -> "peak::core::nodes::NodeRepresentation":
        r"""
        Returns the representation.

        :rtype: int
        :return: Representation

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Representation(self)

    def Unit(self) -> "std::string":
        r"""
        Returns the unit.

        :rtype: string
        :return: Unit

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Unit(self)

    def DisplayNotation(self) -> "peak::core::nodes::NodeDisplayNotation":
        r"""
        Returns the display notation.

        :rtype: int
        :return: Display notation

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_DisplayNotation(self)

    def DisplayPrecision(self) -> "int64_t":
        r"""
        Returns the display precision.

        :rtype: int
        :return: Display precision

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_DisplayPrecision(self)

    def HasConstantIncrement(self) -> "bool":
        r"""
        Checks whether the node has a constant increment.

        :rtype: boolean
        :return: True, if the node has a constant increment.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_HasConstantIncrement(self)

    def Value(self, *args) -> "double":
        r"""
        Returns the value.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: float
        :return: Value

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Value(self, *args)

    def SetValue(self, value: "double") -> "void":
        r"""
        Sets the given value.

        :type value: float, in
        :param value: The value to set.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_SetValue(self, value)

# Register FloatNode in _ids_peak_python_interface:
_ids_peak_python_interface.FloatNode_swigregister(FloatNode)
class IntegerNode(Node):
    r"""Represents a GenAPI integer node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_IntegerNode

    def Minimum(self) -> "int64_t":
        
        return _ids_peak_python_interface.IntegerNode_Minimum(self)

    def Maximum(self) -> "int64_t":
        
        return _ids_peak_python_interface.IntegerNode_Maximum(self)

    def Increment(self) -> "int64_t":
        
        return _ids_peak_python_interface.IntegerNode_Increment(self)

    def IncrementType(self) -> "peak::core::nodes::NodeIncrementType":
        
        return _ids_peak_python_interface.IntegerNode_IncrementType(self)

    def ValidValues(self) -> "std::vector< int64_t,std::allocator< int64_t > >":
        
        return _ids_peak_python_interface.IntegerNode_ValidValues(self)

    def Representation(self) -> "peak::core::nodes::NodeRepresentation":
        
        return _ids_peak_python_interface.IntegerNode_Representation(self)

    def Unit(self) -> "std::string":
        
        return _ids_peak_python_interface.IntegerNode_Unit(self)

    def Value(self, *args) -> "int64_t":
        
        return _ids_peak_python_interface.IntegerNode_Value(self, *args)

    def SetValue(self, value: "int64_t") -> "void":
        
        return _ids_peak_python_interface.IntegerNode_SetValue(self, value)

# Register IntegerNode in _ids_peak_python_interface:
_ids_peak_python_interface.IntegerNode_swigregister(IntegerNode)
class RegisterNode(Node):
    r"""Represents a GenAPI register node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_RegisterNode

    def Address(self) -> "uint64_t":
        r"""
        Returns the address.

        :rtype: int
        :return: Address

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Address(self)

    def Length(self) -> "size_t":
        r"""
        Returns the length.

        :rtype: int
        :return: Length

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Length(self)

    def Read(self, *args) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Reads a given amount of bytes.

        :type numBytes: int, in
        :param numBytes: The amount of bytes to read.
        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: Read bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Read(self, *args)

    def Write(self, bytes: "VectorUInt8") -> "void":
        r"""
        Writes a given amount of bytes.

        :type bytes: std::vector< uint8_t,std::allocator< uint8_t > >, in
        :param bytes: The bytes to write.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Write(self, bytes)

# Register RegisterNode in _ids_peak_python_interface:
_ids_peak_python_interface.RegisterNode_swigregister(RegisterNode)
class StringNode(Node):
    r"""Represents a GenAPI string node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_StringNode

    def MaximumLength(self) -> "int64_t":
        r"""
        Returns the maximum length.

        :rtype: int
        :return: Maximum length

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.StringNode_MaximumLength(self)

    def Value(self, *args) -> "std::string":
        
        return _ids_peak_python_interface.StringNode_Value(self, *args)

    def SetValue(self, value: "std::string const &") -> "void":
        
        return _ids_peak_python_interface.StringNode_SetValue(self, value)

# Register StringNode in _ids_peak_python_interface:
_ids_peak_python_interface.StringNode_swigregister(StringNode)
class NodeMap(object):
    r"""
    Represents a GenAPI node map.

    This class allows to interact with the nodes of a module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NodeMap

    def HasNode(self, name: "std::string const &") -> "bool":
        r"""
        Checks whether the node map contains a node with the given name.

        :type name: string, in
        :param name: The name of the node to find.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasNode(self, name)

    def FindNode(self, name: "std::string const &") -> "std::shared_ptr< peak::core::nodes::Node >":
        r"""
        Tries to find a node with the given name.

        :type name: string, in
        :param name: The name of the node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_FindNode(self, name)

    def InvalidateNodes(self) -> "void":
        r"""
        Invalidates all nodes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_InvalidateNodes(self)

    def PollNodes(self, elapsedTime_ms: "int64_t") -> "void":
        r"""
        Polls all nodes having a polling time.

        :type elapsedTime_ms: int, in
        :param elapsedTime_ms: The elapsed time since the last poll in milliseconds.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_PollNodes(self, elapsedTime_ms)

    def Nodes(self) -> "std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >":
        r"""
        Returns the nodes.

        :rtype: std::vector< std::shared_ptr< peak::core::nodes::Node >,std::allocator< std::shared_ptr< peak::core::nodes::Node > > >
        :return: Nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_Nodes(self)

    def HasBufferSupportedChunks(self, buffer: "std::shared_ptr< peak::core::Buffer > const &") -> "bool":
        r"""
        Checks if the Buffer contains chunks corresponding to the NodeMap.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The Buffer to check.

        Since: 1.1

        :raises: InvalidArgumentException The given buffer is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasBufferSupportedChunks(self, buffer)

    def UpdateChunkNodes(self, buffer: "std::shared_ptr< peak::core::Buffer > const &") -> "void":
        r"""
        Updates chunk information in the NodeMap.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The Buffer to update from.

        When chunks are active, pass each new buffer to this method to parse the chunks and update the corresponding
        chunk nodes in the NodeMap.

        Since: 1.1

        :raises: InvalidArgumentException The given buffer is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_UpdateChunkNodes(self, buffer)

    def HasEventSupportedData(self, event: "std::unique_ptr< peak::core::Event > const &") -> "bool":
        r"""
        Checks if the Event contains data corresponding to the NodeMap.

        :type event: std::unique_ptr< peak::core::Event >, in
        :param event: The Event to check.

        Since: 1.2

        :raises: InvalidArgumentException The given event is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasEventSupportedData(self, event)

    def UpdateEventNodes(self, event: "std::unique_ptr< peak::core::Event > const &") -> "void":
        r"""
        Updates event information in the NodeMap.

        :type event: std::unique_ptr< peak::core::Event >, in
        :param event: The Event to update from.

        When events are active, pass each new event to this method to parse the event data and update the corresponding
        nodes in the NodeMap.

        Since: 1.2

        :raises: InvalidArgumentException The given Event does not have supported data
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_UpdateEventNodes(self, event)

    def StoreToFile(self, filePath: "std::string const &") -> "void":
        r"""
        Stores the values of streamable nodes to the file at the given file path.

        :type filePath: string, in
        :param filePath: The path of the file to store to.

        The stored file uses the GenApi persistence file format. It is not recommended to edit files using this format
        manually unless you are familiar with the GenApi persistence functionality.

        Since: 1.1

        :raises: InvalidArgumentException The given file path is invalid
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_StoreToFile(self, filePath)

    def LoadFromFile(self, filePath: "std::string const &") -> "void":
        r"""
        Loads the values of streamable nodes from the file at the given file path.

        :type filePath: string, in
        :param filePath: The path of the file to load from.

        The file to load has to use the GenApi persistence file format. It is not recommended to edit files using this
        format manually unless you are familiar with the GenApi persistence functionality.

        Since: 1.1

        :raises: InvalidArgumentException The given file path is invalid
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_LoadFromFile(self, filePath)

    def Lock(self) -> "std::unique_ptr< peak::core::NodeMap::ScopedNodeMapLock >":
        r"""
        Locks a recursive mutex on the NodeMap.

        Use this to synchronize NodeMap access from multiple threads.

        Notes: Each individual access is already protected by this mutex, so the nodemap doesn't need to
              be locked for those. But often, nodemap access consists of multiple calls, e.g.: First,
              (1.) change a selector value (e.g. set "GainSelector" node to "DigitalRed"), then (2.)
              access a selected node (e.g. set value in "Gain" node). If a different thread changes the
              selector value between (1.) and (2.), (2.) will access the wrong selected
              node. These kinds of calls should be protected by this lock.

        :rtype: std::unique_ptr< peak::core::NodeMap::ScopedNodeMapLock >
        :return: A ScopedNodeMapLock, which holds the lock and releases it on destruction.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_Lock(self)

    def Handle(self) -> "PEAK_NODE_MAP_HANDLE":
        r"""
        Get the backend handle

        Use this to use the c interface directly (not recommended)

        :rtype: PEAK_NODE_MAP_HANDLE
        :return: The PEAK_NODE_MAP_HANDLE

        Since: 1.5
        """
        return _ids_peak_python_interface.NodeMap_Handle(self)

# Register NodeMap in _ids_peak_python_interface:
_ids_peak_python_interface.NodeMap_swigregister(NodeMap)
PortURLScheme_Local = _ids_peak_python_interface.PortURLScheme_Local
PortURLScheme_HTTP = _ids_peak_python_interface.PortURLScheme_HTTP
PortURLScheme_File = _ids_peak_python_interface.PortURLScheme_File
PortURLScheme_Custom = _ids_peak_python_interface.PortURLScheme_Custom
class PortURL(object):
    r"""
    Represents a GenTL port URL.

    This class allows to query information about a GenTL port URL.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_PortURL

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.PortURL_Info(self, infoCommand)

    def URL(self) -> "std::string":
        r"""
        Returns the URL.

        :rtype: string
        :return: URL

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_URL(self)

    def Scheme(self) -> "peak::core::PortURLScheme":
        r"""
        Returns the scheme.

        :rtype: int
        :return: Scheme

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_Scheme(self)

    def FileName(self) -> "std::string":
        r"""
        Returns the file name.

        :rtype: string
        :return: File name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileName(self)

    def FileRegisterAddress(self) -> "uint64_t":
        r"""
        Returns the file register address.

        :rtype: int
        :return: File register address

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileRegisterAddress(self)

    def FileSize(self) -> "uint64_t":
        r"""
        Returns the file size.

        :rtype: int
        :return: File size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSize(self)

    def FileSHA1Hash(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Returns the file SHA1 hash.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: File SHA1 hash

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSHA1Hash(self)

    def FileVersionMajor(self) -> "int32_t":
        r"""
        Returns the file major version.

        :rtype: int
        :return: File major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionMajor(self)

    def FileVersionMinor(self) -> "int32_t":
        r"""
        Returns the file major version.

        :rtype: int
        :return: File major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionMinor(self)

    def FileVersionSubminor(self) -> "int32_t":
        r"""
        Returns the file subminor version.

        :rtype: int
        :return: File subminor version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionSubminor(self)

    def FileSchemaVersionMajor(self) -> "int32_t":
        r"""
        Returns the file schema major version.

        :rtype: int
        :return: File schema major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSchemaVersionMajor(self)

    def FileSchemaVersionMinor(self) -> "int32_t":
        r"""
        Returns the file schema minor version.

        :rtype: int
        :return: File schema minor version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSchemaVersionMinor(self)

    def ParentPort(self) -> "std::shared_ptr< peak::core::Port >":
        r"""
        Returns the parent port.

        :rtype: :py:class:`Port`
        :return: Parent port

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_ParentPort(self)

# Register PortURL in _ids_peak_python_interface:
_ids_peak_python_interface.PortURL_swigregister(PortURL)
class Port(object):
    r"""
    Represents a GenTL port.

    This class allows to query information about a GenTL port and to enumerate its URLs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Port

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.Port_Info(self, infoCommand)

    def ID(self) -> "std::string":
        r"""
        Returns the ID.

        :rtype: string
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ID(self)

    def Name(self) -> "std::string":
        r"""
        Returns the name.

        :rtype: string
        :return: Name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Name(self)

    def VendorName(self) -> "std::string":
        r"""
        Returns the vendor name.

        :rtype: string
        :return: Vendor name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_VendorName(self)

    def ModelName(self) -> "std::string":
        r"""
        Returns the model name.

        :rtype: string
        :return: Model name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ModelName(self)

    def Version(self) -> "std::string":
        r"""
        Returns the version.

        :rtype: string
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Version(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.Port_TLType(self)

    def ModuleName(self) -> "std::string":
        r"""
        Returns the module name.

        :rtype: string
        :return: Module name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ModuleName(self)

    def DataEndianness(self) -> "peak::core::Endianness":
        r"""
        Returns the data endianness.

        :rtype: int
        :return: Data endianness

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_DataEndianness(self)

    def IsReadable(self) -> "bool":
        r"""
        Checks whether the port is readable.

        :rtype: boolean
        :return: True, if the port is readable
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsReadable(self)

    def IsWritable(self) -> "bool":
        r"""
        Checks whether the port is writable.

        :rtype: boolean
        :return: True, if the port is writable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsWritable(self)

    def IsAvailable(self) -> "bool":
        r"""
        Checks whether the port is available.

        :rtype: boolean
        :return: True, if the port is available.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsAvailable(self)

    def IsImplemented(self) -> "bool":
        r"""
        Checks whether the port is implemented.

        :rtype: boolean
        :return: True, if the port is implemented.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsImplemented(self)

    def Read(self, address: "uint64_t", numBytes: "size_t") -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Reads a given amount of bytes at a given address.

        :type address: int, in
        :param address: The address to read at.
        :type numBytes: int, in
        :param numBytes: The amount of bytes to read.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: Read bytes

        Since: 1.0

        :raises: InvalidAddressException Address is invalid
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Read(self, address, numBytes)

    def Write(self, address: "uint64_t", bytes: "VectorUInt8") -> "void":
        r"""
        Writes a given amount of bytes at a given address.

        :type address: int, in
        :param address: The address to write at.
        :type bytes: std::vector< uint8_t,std::allocator< uint8_t > >, in
        :param bytes: The bytes to write.

        Since: 1.0

        :raises: InvalidAddressException Address is invalid
        :raises: OutOfRangeException The given value is out of range
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Write(self, address, bytes)

    def URLs(self) -> "std::vector< std::shared_ptr< peak::core::PortURL >,std::allocator< std::shared_ptr< peak::core::PortURL > > >":
        r"""
        Returns the URLs.

        :rtype: std::vector< std::shared_ptr< peak::core::PortURL >,std::allocator< std::shared_ptr< peak::core::PortURL > > >
        :return: URLs

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_URLs(self)

# Register Port in _ids_peak_python_interface:
_ids_peak_python_interface.Port_swigregister(Port)
class Module(object):
    r"""
    Represents an extended GenTL port.

    This class extends the functionality of a GenTL port with the functionality of the GenAPI. Instead of separating the
    node map from the port, this class brings them together making it much easier to get things done.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Module

    def NodeMaps(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap >,std::allocator< std::shared_ptr< peak::core::NodeMap > > >":
        r"""
        Returns the module's node maps.

        :rtype: std::vector< std::shared_ptr< peak::core::NodeMap >,std::allocator< std::shared_ptr< peak::core::NodeMap > > >
        :return: Node maps

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Module_NodeMaps(self)

    def Port(self) -> "std::shared_ptr< peak::core::Port >":
        r"""
        Returns the module's port.

        :rtype: :py:class:`Port`
        :return: Port

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Module_Port(self)

# Register Module in _ids_peak_python_interface:
_ids_peak_python_interface.Module_swigregister(Module)
class EventSupportingModule(Module):
    r"""
    The base class for all modules being able to raise events.

    This class generalizes all modules supporting events (System, Interface, Device, DataStream, Buffer).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EventSupportingModule

    def EnableEvents(self, type: "peak::core::EventType") -> "std::unique_ptr< peak::core::EventController >":
        r"""
        Enables events of the given event type.

        :type type: int, in
        :param type: The event type to enable.

        :rtype: std::unique_ptr< peak::core::EventController >
        :return: Event controller for the given event type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventSupportingModule_EnableEvents(self, type)

# Register EventSupportingModule in _ids_peak_python_interface:
_ids_peak_python_interface.EventSupportingModule_swigregister(EventSupportingModule)
class ModuleDescriptor(object):
    r"""The base class for all openable modules."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_ModuleDescriptor

    def ID(self) -> "std::string":
        r"""
        Returns the ID of the described module.

        :rtype: string
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ModuleDescriptor_ID(self)

# Register ModuleDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.ModuleDescriptor_swigregister(ModuleDescriptor)
class BufferChunk(object):
    r"""
    Represents a buffer chunk.

    This class allows to query information about a buffer chunk.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_BufferChunk

    def ID(self) -> "uint64_t":
        r"""
        Returns the ID.

        :rtype: int
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_ID(self)

    def BasePtr(self) -> "void *":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_BasePtr(self)

    def Size(self) -> "size_t":
        r"""
        Returns the size.

        :rtype: int
        :return: Size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_Size(self)

    def ParentBuffer(self) -> "std::shared_ptr< peak::core::Buffer >":
        r"""
        Returns the parent buffer.

        :rtype: :py:class:`Buffer`
        :return: Parent buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_ParentBuffer(self)

# Register BufferChunk in _ids_peak_python_interface:
_ids_peak_python_interface.BufferChunk_swigregister(BufferChunk)
BufferPartType_Unknown = _ids_peak_python_interface.BufferPartType_Unknown
BufferPartType_Image2D = _ids_peak_python_interface.BufferPartType_Image2D
BufferPartType_PlaneBiPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneBiPlanar2D
BufferPartType_PlaneTriPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneTriPlanar2D
BufferPartType_PlaneQuadPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneQuadPlanar2D
BufferPartType_Image3D = _ids_peak_python_interface.BufferPartType_Image3D
BufferPartType_PlaneBiPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneBiPlanar3D
BufferPartType_PlaneTriPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneTriPlanar3D
BufferPartType_PlaneQuadPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneQuadPlanar3D
BufferPartType_ConfidenceMap = _ids_peak_python_interface.BufferPartType_ConfidenceMap
BufferPartType_Custom = _ids_peak_python_interface.BufferPartType_Custom
class BufferPart(object):
    r"""
    Represents a buffer part.

    This class allows to query information about a buffer part.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_BufferPart

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.BufferPart_Info(self, infoCommand)

    def SourceID(self) -> "uint64_t":
        r"""
        Returns the source ID.

        :rtype: int
        :return: Source ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_SourceID(self)

    def BasePtr(self) -> "void *":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_BasePtr(self)

    def Size(self) -> "size_t":
        r"""
        Returns the size in bytes.

        :rtype: int
        :return: Size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Size(self)

    def Type(self) -> "peak::core::BufferPartType":
        r"""
        Returns the type.

        :rtype: int
        :return: Type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Type(self)

    def Format(self) -> "uint64_t":
        r"""
        Returns the format.

        :rtype: int
        :return: Format

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Format(self)

    def FormatNamespace(self) -> "uint64_t":
        r"""
        Returns the format namespace.

        :rtype: int
        :return: Format namespace

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_FormatNamespace(self)

    def Width(self) -> "size_t":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Width(self)

    def Height(self) -> "size_t":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Height(self)

    def XOffset(self) -> "size_t":
        r"""
        Returns the x offset.

        :rtype: int
        :return: X offset

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_XOffset(self)

    def YOffset(self) -> "size_t":
        r"""
        Returns the y offset.

        :rtype: int
        :return: Y offset

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_YOffset(self)

    def XPadding(self) -> "size_t":
        r"""
        Returns the x padding.

        :rtype: int
        :return: X padding

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_XPadding(self)

    def DeliveredImageHeight(self) -> "size_t":
        r"""
        Returns the delivered image height.

        :rtype: int
        :return: Delivered image height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_DeliveredImageHeight(self)

    def ParentBuffer(self) -> "std::shared_ptr< peak::core::Buffer >":
        r"""
        Returns the parent buffer.

        :rtype: :py:class:`Buffer`
        :return: Parent buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_ParentBuffer(self)

# Register BufferPart in _ids_peak_python_interface:
_ids_peak_python_interface.BufferPart_swigregister(BufferPart)
BufferPayloadType_Unknown = _ids_peak_python_interface.BufferPayloadType_Unknown
BufferPayloadType_Image = _ids_peak_python_interface.BufferPayloadType_Image
BufferPayloadType_RawData = _ids_peak_python_interface.BufferPayloadType_RawData
BufferPayloadType_File = _ids_peak_python_interface.BufferPayloadType_File
BufferPayloadType_Chunk = _ids_peak_python_interface.BufferPayloadType_Chunk
BufferPayloadType_JPEG = _ids_peak_python_interface.BufferPayloadType_JPEG
BufferPayloadType_JPEG2000 = _ids_peak_python_interface.BufferPayloadType_JPEG2000
BufferPayloadType_H264 = _ids_peak_python_interface.BufferPayloadType_H264
BufferPayloadType_ChunkOnly = _ids_peak_python_interface.BufferPayloadType_ChunkOnly
BufferPayloadType_DeviceSpecific = _ids_peak_python_interface.BufferPayloadType_DeviceSpecific
BufferPayloadType_MultiPart = _ids_peak_python_interface.BufferPayloadType_MultiPart
BufferPayloadType_Custom = _ids_peak_python_interface.BufferPayloadType_Custom
PixelFormatNamespace_GEV = _ids_peak_python_interface.PixelFormatNamespace_GEV
PixelFormatNamespace_IIDC = _ids_peak_python_interface.PixelFormatNamespace_IIDC
PixelFormatNamespace_PFNC16Bit = _ids_peak_python_interface.PixelFormatNamespace_PFNC16Bit
PixelFormatNamespace_PFNC32Bit = _ids_peak_python_interface.PixelFormatNamespace_PFNC32Bit
PixelFormatNamespace_Custom = _ids_peak_python_interface.PixelFormatNamespace_Custom
class Buffer(EventSupportingModule):
    r"""
    Represents a GenTL buffer module.

    This class allows to query information about a GenTL buffer module and to enumerate its chunks or parts.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Buffer

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        r"""Information based on GenTL BUFFER_INFO_CMD."""
        return _ids_peak_python_interface.Buffer_Info(self, infoCommand)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.Buffer_TLType(self)

    def BasePtr(self) -> "void *":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_BasePtr(self)

    def Size(self) -> "size_t":
        r"""
        Returns the size of the buffer in bytes.

        :rtype: int
        :return: Buffer size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Size(self)

    def PayloadType(self) -> "peak::core::BufferPayloadType":
        r"""
        Returns the payload type.

        :rtype: int
        :return: Payload type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PayloadType(self)

    def PixelFormat(self) -> "uint64_t":
        r"""
        Returns the pixel format of the data.

        The interpretation of the pixel format depends on the namespace the pixel format belongs to. This can be
        inquired using PixelFormatNamespace().

        :rtype: int
        :return: Pixel format

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelFormat(self)

    def PixelFormatNamespace(self) -> "peak::core::PixelFormatNamespace":
        r"""
        Returns the pixel format namespace, to allow interpretation of the PixelFormat().

        :rtype: int
        :return: Pixel format namespace

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelFormatNamespace(self)

    def PixelEndianness(self) -> "peak::core::Endianness":
        r"""
        Returns the pixel endianness.

        :rtype: int
        :return: Pixel endianness

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelEndianness(self)

    def ExpectedDataSize(self) -> "size_t":
        r"""
        Returns the expected data size.

        :rtype: int
        :return: Expected data size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ExpectedDataSize(self)

    def DeliveredDataSize(self) -> "size_t":
        r"""
        Returns the delivered data size.

        :rtype: int
        :return: Delivered data size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredDataSize(self)

    def FrameID(self) -> "uint64_t":
        r"""
        Returns the frame ID.

        :rtype: int
        :return: Frame ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_FrameID(self)

    def ImageOffset(self) -> "size_t":
        r"""
        Returns the offset of the image data from the beginning of the delivered buffer in bytes.

        :rtype: int
        :return: Image offset in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ImageOffset(self)

    def DeliveredImageHeight(self) -> "size_t":
        r"""
        Returns the delivered image height.

        :rtype: int
        :return: Delivered image height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredImageHeight(self)

    def DeliveredChunkPayloadSize(self) -> "size_t":
        r"""
        Returns the delivered chunk payload size.

        :rtype: int
        :return: Delivered chunk payload size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredChunkPayloadSize(self)

    def ChunkLayoutID(self) -> "uint64_t":
        r"""
        Returns the chunk layout ID.

        :rtype: int
        :return: Chunk layout ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ChunkLayoutID(self)

    def FileName(self) -> "std::string":
        r"""
        Returns the file name.

        :rtype: string
        :return: File name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_FileName(self)

    def Width(self) -> "size_t":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Width(self)

    def Height(self) -> "size_t":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Height(self)

    def XOffset(self) -> "size_t":
        r"""
        Returns the x offset of the data in the buffer in number of pixels from the image origin to handle
        areas of interest.

        :rtype: int
        :return: X offset in number of pixels

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_XOffset(self)

    def YOffset(self) -> "size_t":
        r"""
        Returns the y offset of the data in the buffer in number of lines from the image origin to handle
        areas of interest.

        :rtype: int
        :return: Y offset in number of lines

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_YOffset(self)

    def XPadding(self) -> "size_t":
        r"""
        Returns the x padding of the data in the buffer in number of bytes.

        :rtype: int
        :return: X padding in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_XPadding(self)

    def YPadding(self) -> "size_t":
        r"""
        Returns the y padding of the data in the buffer in number of bytes.

        :rtype: int
        :return: Y padding in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_YPadding(self)

    def Timestamp_ticks(self) -> "uint64_t":
        r"""
        Returns the timestamp.

        :rtype: int
        :return: Timestamp in ticks

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Timestamp_ticks(self)

    def Timestamp_ns(self) -> "uint64_t":
        r"""
        Returns the timestamp.

        :rtype: int
        :return: Timestamp in nanoseconds

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Timestamp_ns(self)

    def IsQueued(self) -> "bool":
        r"""
        Checks whether the buffer is queued  or not.

        :rtype: boolean
        :return: True, while the buffer is in the input pool, is currently being filled or is in the output buffer queue.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsQueued(self)

    def IsAcquiring(self) -> "bool":
        r"""
        Checks whether the buffer is currently being filled.

        :rtype: boolean
        :return: True, while the buffer is being filled.
        :rtype: boolean
        :return: False otherwise.


        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsAcquiring(self)

    def IsIncomplete(self) -> "bool":
        r"""
        Checks whether the buffer is incomplete or not.

        Incomplete buffers can happen when an error occurred while the buffer was being filled.

        :rtype: boolean
        :return: True if the buffer couldn't be filled completely.
        :rtype: boolean
        :return: False if the buffer is complete.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsIncomplete(self)

    def HasNewData(self) -> "bool":
        r"""
        Checks whether the buffer has new data since the last delivery.

        :rtype: boolean
        :return: True when the buffer has new data since the last delivery.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasNewData(self)

    def HasImage(self) -> "bool":
        r"""
        Checks whether the buffer contains image data.

        :rtype: boolean
        :return: True, if the buffer contains an image.
        :rtype: boolean
        :return: False otherwise.

        See GenTL BUFFER_INFO_IMAGEPRESENT.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasImage(self)

    def HasChunks(self) -> "bool":
        r"""
        Checks whether the buffer contains chunks.

        If HasChunks() is true, check the BufferChunks using Chunks().

        :rtype: boolean
        :return: True, if the buffer has chunks.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasChunks(self)

    def Chunks(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk >,std::allocator< std::shared_ptr< peak::core::BufferChunk > > >":
        r"""
        Returns the buffer's chunks if it contains chunks.

        Check if the buffer has chunks with HasChunks().

        :rtype: std::vector< std::shared_ptr< peak::core::BufferChunk >,std::allocator< std::shared_ptr< peak::core::BufferChunk > > >
        :return: Buffer chunks

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Chunks(self)

    def Parts(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart >,std::allocator< std::shared_ptr< peak::core::BufferPart > > >":
        r"""
        Returns all buffer parts for multipart buffers.

        :rtype: std::vector< std::shared_ptr< peak::core::BufferPart >,std::allocator< std::shared_ptr< peak::core::BufferPart > > >
        :return: Buffer parts

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Parts(self)

    def ParentDataStream(self) -> "std::shared_ptr< peak::core::DataStream >":
        r"""
        Returns the parent data stream.

        :rtype: :py:class:`DataStream`
        :return: Parent data stream

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ParentDataStream(self)

# Register Buffer in _ids_peak_python_interface:
_ids_peak_python_interface.Buffer_swigregister(Buffer)
DataStreamFlushMode_InputPoolToOutputQueue = _ids_peak_python_interface.DataStreamFlushMode_InputPoolToOutputQueue
r"""
    Flushes the buffers from the input pool to the
    output buffer queue and if necessary adds
    entries in the "New Buffer" event data queue.
    The buffers currently being filled are not
    affected by this operation.
    """
DataStreamFlushMode_DiscardOutputQueue = _ids_peak_python_interface.DataStreamFlushMode_DiscardOutputQueue
r"""
    Discards all buffers in the output buffer queue
    and if necessary remove the entries from the
    event data queue.
    """
DataStreamFlushMode_AllToInputPool = _ids_peak_python_interface.DataStreamFlushMode_AllToInputPool
r"""
    Puts all buffers in the input pool. This is
    including those in the output buffer queue and
    the ones which are currently being filled and
    discard entries in the event data queue.
    """
DataStreamFlushMode_UnqueuedToInputPool = _ids_peak_python_interface.DataStreamFlushMode_UnqueuedToInputPool
r"""
    Puts all buffers that are neither in the input pool
    nor being currently filled nor in the output
    buffer queue in the input pool.
    """
DataStreamFlushMode_DiscardAll = _ids_peak_python_interface.DataStreamFlushMode_DiscardAll
r"""
    Discards all buffers in the input pool and the
    buffers in the output queue including buffers
    currently being filled so that no buffer is bound
    to any internal mechanism and all buffers may
    be revoked or requeued.
    """
DataStreamFlushMode_Custom = _ids_peak_python_interface.DataStreamFlushMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
AcquisitionStartMode_Default = _ids_peak_python_interface.AcquisitionStartMode_Default
r"""Default behavior."""
AcquisitionStartMode_Custom = _ids_peak_python_interface.AcquisitionStartMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
AcquisitionStopMode_Default = _ids_peak_python_interface.AcquisitionStopMode_Default
r"""
    Stops the acquisition engine when the currently
    running tasks like filling a buffer are completed
    (default behavior).
    """
AcquisitionStopMode_Kill = _ids_peak_python_interface.AcquisitionStopMode_Kill
r"""
    Stop the acquisition engine immediately. In
    case this results in a partially filled buffer the
    Producer will return the buffer through the
    regular mechanism to the user, indicating
    through the info function of that buffer that this
    buffer is not complete.
    """
AcquisitionStopMode_Custom = _ids_peak_python_interface.AcquisitionStopMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
class DataStream(EventSupportingModule):
    r"""
    Represents a GenTL DataStream module.

    This class allows to query information about a GenTL DataStream module and to manage and receive
    Buffer Buffers from the physical device.

    The workflow for the buffers follows the GenTL model: First, memory needs to be allocated and announced to
    the API, so they are in the GenTL "Announced Buffer Pool". Then, the buffers are queued, so they are available in
    the GenTL "Input Buffer Pool". From this pool, buffers are chosen and filled by the device. Once a buffer is filled,
    i.e. a new frame is available, it is added to the GenTL "Output Buffer Queue" and a "NewBufferEvent" is sent. At
    this point, the newly filled buffer is available to the API.

    ### Buffer management

    There are two options for managing memory for the buffers:
    * Allocate the memory for the buffer yourself and announce it to the API yourself, using AnnounceBuffer().
      Then you'll also need to free the memory for the buffer yourself, once you are done. To help with that,
      AnnounceBuffer() allows to add a callback, which is called when the buffer is revoked. At that point the memory
      won't be used anymore, and therefore can be deleted. If you don't add this callback, you'll have to manage the
      time of deletion yourself.
    * Let the API allocate and free the memory for the buffer, using AllocAndAnnounceBuffer(). Then, the memory
      will be freed automatically when the buffer is revoked.

    After announcing the buffer, use QueueBuffer() to move it to the "Input Buffer Pool".

    Once a Buffer is not needed anymore, revoke it using RevokeBuffer().

    Use Flush() to move buffers between the Input Buffer Pool, the Output Buffer Queue and the Announced Buffer Pool.

    ### Receiving new buffers

    Once enough buffers are announced and queued, use StartAcquisition() to start generating new frames.

    Notes: Typically, the RemoteDevice also needs to be started using its NodeMap, e.g.:

    .. code-block:: c++

        stream->StartAcquisition(peak::core::AcquisitionStartMode::Default);
        remoteDevice->NodeMaps()[0]->FindNode<peak::core::nodes::CommandNode>("AcquisitionStart")->Execute();
        remoteDevice->NodeMaps()[0]->FindNode<peak::core::nodes::CommandNode>("AcquisitionStart")->WaitUntilDone();

    Once the acquisition is started, wait for the NewBufferEvent using WaitForFinishedBuffer(), which blocks until a
    newly filled buffer is available.

    See GenTL Data Stream Module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    INFINITE_NUMBER = _ids_peak_python_interface.DataStream_INFINITE_NUMBER
    r""" The constant defining an infinite number, used in StartAcquisition()."""
    __swig_destroy__ = _ids_peak_python_interface.delete_DataStream

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.DataStream_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.DataStream_Info(self, infoCommand)

    def ID(self) -> "std::string":
        
        return _ids_peak_python_interface.DataStream_ID(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.DataStream_TLType(self)

    def NumBuffersAnnouncedMinRequired(self) -> "size_t":
        r"""
        Returns the minimum number of announced buffers required to start the acquisition.

        :rtype: int
        :return: Minimum number of announced buffers required

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAnnouncedMinRequired(self)

    def NumBuffersAnnounced(self) -> "size_t":
        r"""
        Returns the number of announced buffers.

        :rtype: int
        :return: Number of announced buffers

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAnnounced(self)

    def NumBuffersQueued(self) -> "size_t":
        r"""
        Returns the number of queued buffers.

        :rtype: int
        :return: Number of queued buffers

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersQueued(self)

    def NumBuffersAwaitDelivery(self) -> "size_t":
        r"""
        Returns the number of buffers awaiting delivery.

        :rtype: int
        :return: Number of buffers awaiting delivery

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAwaitDelivery(self)

    def NumBuffersDelivered(self) -> "uint64_t":
        r"""
        Returns the number of delivered buffers.

        :rtype: int
        :return: Number of delivered buffers

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersDelivered(self)

    def NumBuffersStarted(self) -> "uint64_t":
        r"""
        Returns the number of started buffers.

        :rtype: int
        :return: Number of started buffers

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersStarted(self)

    def NumUnderruns(self) -> "uint64_t":
        r"""
        Returns the number of underruns.

        :rtype: int
        :return: Number of underruns

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumUnderruns(self)

    def NumChunksPerBufferMax(self) -> "size_t":
        r"""
        Returns the maximum number of chunks per buffer.

        :rtype: int
        :return: Maximum number of chunks per buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumChunksPerBufferMax(self)

    def BufferAlignment(self) -> "size_t":
        r"""
        Returns the buffer alignment.

        :rtype: int
        :return: Buffer alignment in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_BufferAlignment(self)

    def PayloadSize(self) -> "size_t":
        r"""
        Returns the payload size in bytes, i.e. the size of the buffers.

        :rtype: int
        :return: Payload size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_PayloadSize(self)

    def DefinesPayloadSize(self) -> "bool":
        r"""
        Checks whether the data stream defines the payload size.

        :rtype: boolean
        :return: True, if the DataStream defines the payload size.
        :rtype: boolean
        :return: False otherwise. In this case, ask the RemoteDevice for the payload size instead of the DataStream, e.g.:

                    .. code-block:: c++

                    payload_size =
            device->RemoteDevice()->NodeMaps()[0]->FindNode<peak::core::nodes::IntegerNode>("PayloadSize")->Value();

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_DefinesPayloadSize(self)

    def IsGrabbing(self) -> "bool":
        r"""
        Checks whether the data stream is grabbing.

        :rtype: boolean
        :return: True, while the acquisition is running.
        :rtype: boolean
        :return: False, if the acquisition isn't started yet or was stopped.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_IsGrabbing(self)

    def QueueBuffer(self, buffer: "std::shared_ptr< peak::core::Buffer > const &") -> "void":
        r"""
        Queues a given buffer.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The buffer to queue.

        Since: 1.0

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_QueueBuffer(self, buffer)

    def RevokeBuffer(self, buffer: "std::shared_ptr< peak::core::Buffer > const &") -> "void":
        r"""
        Revokes a given buffer.

        This function revokes a given buffer. If the given buffer was allocated by the client side, the callback given
        during buffer announcement (AnnounceBuffer()) gets triggered.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The buffer to revoke.

        Since: 1.0

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_RevokeBuffer(self, buffer)

    def Flush(self, mode: "peak::core::DataStreamFlushMode") -> "void":
        r"""
        Move buffers between the Input %Buffer Pool, the Output %Buffer Queue and the Announced %Buffer Pool,
        depending on the mode parameter.

        :type mode: int, in
        :param mode: Operation modes being used to flush the buffers of the data stream.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_Flush(self, mode)

    def AnnouncedBuffers(self) -> "std::vector< std::shared_ptr< peak::core::Buffer >,std::allocator< std::shared_ptr< peak::core::Buffer > > >":
        r"""
        Returns the currently announced buffers.

        :rtype: std::vector< std::shared_ptr< peak::core::Buffer >,std::allocator< std::shared_ptr< peak::core::Buffer > > >
        :return: List of currently announced buffers

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_AnnouncedBuffers(self)

    def StartAcquisition(self, *args) -> "void":
        r"""
        Starts the acquisition.

        :type mode: int, in, optional
        :param mode: The mode being used to start the acquisition.
        :type numToAcquire: int, in, optional
        :param numToAcquire: The number of buffers to acquire.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_StartAcquisition(self, *args)

    def StopAcquisition(self, *args) -> "void":
        r"""
        Stops the acquisition.

        :type mode: int, in, optional
        :param mode: The mode being used to stop the acquisition.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_StopAcquisition(self, *args)

    def WaitForFinishedBuffer(self, timeout_ms: "Timeout") -> "std::shared_ptr< peak::core::Buffer >":
        r"""
        Blocking wait for a finished Buffer.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for a finished buffer in milliseconds.

        :rtype: :py:class:`Buffer`
        :return: Newly filled Buffer.

        Since: 1.0

        :raises: AbortedException The wait was aborted
        :raises: TimeoutException The function call timed out
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_WaitForFinishedBuffer(self, timeout_ms)

    def KillWait(self) -> "void":
        r"""
        Kills one wait for a finished buffer or stores the kill request if there is no waiting thread.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_KillWait(self)

    def ParentDevice(self) -> "std::shared_ptr< peak::core::Device >":
        
        return _ids_peak_python_interface.DataStream_ParentDevice(self)

    def AllocAndAnnounceBuffer(self, size: "size_t") -> "std::shared_ptr< peak::core::Buffer >":
        return _ids_peak_python_interface.DataStream_AllocAndAnnounceBuffer(self, size)

# Register DataStream in _ids_peak_python_interface:
_ids_peak_python_interface.DataStream_swigregister(DataStream)
class DataStreamDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL DataStream module's ID.

    This class allows to query information about a GenTL DataStream module without opening it.
    Furthermore, it allows to open this GenTL DataStream module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DataStreamDescriptor

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.DataStreamDescriptor_Key(self)

    def ParentDevice(self) -> "std::shared_ptr< peak::core::Device >":
        r"""
        Returns the parent device.

        :rtype: :py:class:`Device`
        :return: Parent device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStreamDescriptor_ParentDevice(self)

    def OpenDataStream(self) -> "std::shared_ptr< peak::core::DataStream >":
        r"""
        Opens the data stream.

        :rtype: :py:class:`DataStream`
        :return: Opened data stream

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStreamDescriptor_OpenDataStream(self)

    def OpenedDataStream(self) -> "std::shared_ptr< peak::core::DataStream >":
        r"""
        Returns the DataStream that was opened with this DataStreamDescriptor.

        :rtype: :py:class:`DataStream`
        :return: Opened DataStream

        Since: 1.0

        :raises: BadAccessException DataStream is not open
        """
        return _ids_peak_python_interface.DataStreamDescriptor_OpenedDataStream(self)

# Register DataStreamDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.DataStreamDescriptor_swigregister(DataStreamDescriptor)
DeviceAccessStatus_ReadWrite = _ids_peak_python_interface.DeviceAccessStatus_ReadWrite
DeviceAccessStatus_ReadOnly = _ids_peak_python_interface.DeviceAccessStatus_ReadOnly
DeviceAccessStatus_NoAccess = _ids_peak_python_interface.DeviceAccessStatus_NoAccess
DeviceAccessStatus_Busy = _ids_peak_python_interface.DeviceAccessStatus_Busy
DeviceAccessStatus_OpenReadWrite = _ids_peak_python_interface.DeviceAccessStatus_OpenReadWrite
DeviceAccessStatus_OpenReadOnly = _ids_peak_python_interface.DeviceAccessStatus_OpenReadOnly
DeviceAccessStatus_Custom = _ids_peak_python_interface.DeviceAccessStatus_Custom
class RemoteDevice(Module):
    r"""
    Allows to access the physical Device.

    Access the NodeMap and Port of the physical device. This class doesn't have any additional functionality,
    but helps separate the local virtual device proxy from that actual physical hardware device. I.e. the NodeMap of
    this RemoteDevice is created from the XML file retrieved from the physical device, while the NodeMap of the proxy
    Device is created by the ProducerLibrary (CTI).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_RemoteDevice

    def LocalDevice(self) -> "std::shared_ptr< peak::core::Device >":
        r"""
        Returns the local device (device proxy) of the remote device.

        :rtype: :py:class:`Device`
        :return: Local device of the remote device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RemoteDevice_LocalDevice(self)

# Register RemoteDevice in _ids_peak_python_interface:
_ids_peak_python_interface.RemoteDevice_swigregister(RemoteDevice)
class Device(EventSupportingModule):
    r"""
    Represents a GenTL Device module, i.e. a local virtual Device proxy for the actual hardware RemoteDevice.

    This class allows to query information about a GenTL Device module and to enumerate its
    DataStreamDescriptor DataStreamDescriptors, which allows to open the corresponding DataStream.

    Additionally, it allows access to its RemoteDevice, i.e. the actual hardware device. To change hardware settings,
    you typically need to work with the NodeMap of the RemoteDevice. E.g. to change the exposure time:

    .. code-block:: c++

        // get the (first) node map of the remote device
        auto remoteNodeMap = device->RemoteDevice()->NodeMaps().at(0);
        // change exposure time
        remoteNodeMap->FindNode<peak::core::nodes::FloatNode>("ExposureTime")->SetValue(1.5);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Device

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.Device_Info(self, infoCommand)

    def ID(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_ID(self)

    def DisplayName(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_DisplayName(self)

    def VendorName(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_VendorName(self)

    def ModelName(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_ModelName(self)

    def Version(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_Version(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_TLType(self)

    def UserDefinedName(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_UserDefinedName(self)

    def SerialNumber(self) -> "std::string":
        
        return _ids_peak_python_interface.Device_SerialNumber(self)

    def AccessStatus(self) -> "peak::core::DeviceAccessStatus":
        
        return _ids_peak_python_interface.Device_AccessStatus(self)

    def TimestampTickFrequency(self) -> "uint64_t":
        
        return _ids_peak_python_interface.Device_TimestampTickFrequency(self)

    def RemoteDevice(self) -> "std::shared_ptr< peak::core::RemoteDevice >":
        r"""
        Returns the remote device of the device.

        This function returns the remote device which provides the access to the physical device. In contrast, this class
        acts only as a proxy for the physical device.

        :rtype: :py:class:`RemoteDevice`
        :return: Remote device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Device_RemoteDevice(self)

    def DataStreams(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor >,std::allocator< std::shared_ptr< peak::core::DataStreamDescriptor > > >":
        r"""
        Returns the data stream list of the device.

        :rtype: std::vector< std::shared_ptr< peak::core::DataStreamDescriptor >,std::allocator< std::shared_ptr< peak::core::DataStreamDescriptor > > >
        :return: Data stream list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Device_DataStreams(self)

    def ParentInterface(self) -> "std::shared_ptr< peak::core::Interface >":
        
        return _ids_peak_python_interface.Device_ParentInterface(self)

    def Handle(self) -> "PEAK_DEVICE_HANDLE":
        r"""
        Get the backend handle

        Use this to use the c interface directly (not recommended)

        :rtype: PEAK_DEVICE_HANDLE
        :return: The PEAK_DEVICE_HANDLE

        Since: 1.5
        """
        return _ids_peak_python_interface.Device_Handle(self)

# Register Device in _ids_peak_python_interface:
_ids_peak_python_interface.Device_swigregister(Device)
DeviceAccessType_ReadOnly = _ids_peak_python_interface.DeviceAccessType_ReadOnly
DeviceAccessType_Control = _ids_peak_python_interface.DeviceAccessType_Control
DeviceAccessType_Exclusive = _ids_peak_python_interface.DeviceAccessType_Exclusive
DeviceAccessType_Custom = _ids_peak_python_interface.DeviceAccessType_Custom
class DeviceDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL Device module's ID.

    This class allows to query information about a GenTL Device module without opening it. Furthermore, it enables
    you to open this GenTL Device module.

    ### Opening a Device

    When you try to open a device with an access mode that is not allowed, a BadAccessException is thrown. To avoid
    that, ask the device if the desired access mode is available with IsOpenable(). By default, IsOpenable
    asks for the highest access mode, DeviceAccessType::Exclusive:

    .. code-block:: c++

        if (deviceDescriptor->IsOpenable())
        {
            device = deviceDescriptor->OpenDevice(DeviceAccessType::Control);
        }

    ### %Device Information Monitoring

    With [this group of methods]('DeviceInformationMonitoring)', you can conveniently monitor for changes of
    information about the device.

    Register a callback using RegisterInformationChangedCallback() and configure which information you want to
    monitor with AddInformationRoleToMonitoring() and RemoveInformationRoleFromMonitoring().

    By default, the following DeviceInformationRoles are monitored:
    * AccessStatus
    * UserDefinedName
    * TimestampTickFrequency
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceDescriptor

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.DeviceDescriptor_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.DeviceDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "std::string":
        r"""
        Returns the display name.

        :rtype: string
        :return: Display name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_DisplayName(self)

    def VendorName(self) -> "std::string":
        r"""
        Returns the vendor name.

        :rtype: string
        :return: Vendor name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_VendorName(self)

    def ModelName(self) -> "std::string":
        r"""
        Returns the model name.

        :rtype: string
        :return: Model name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_ModelName(self)

    def Version(self) -> "std::string":
        r"""
        Returns the version.

        :rtype: string
        :return: Version

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_Version(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.DeviceDescriptor_TLType(self)

    def UserDefinedName(self) -> "std::string":
        r"""
        Returns the user defined name.

        :rtype: string
        :return: User defined name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_UserDefinedName(self)

    def SerialNumber(self) -> "std::string":
        r"""
        Returns the serial number.

        :rtype: string
        :return: Serial number

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_SerialNumber(self)

    def AccessStatus(self) -> "peak::core::DeviceAccessStatus":
        r"""
        Returns the access status.

        :rtype: int
        :return: Access status

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_AccessStatus(self)

    def TimestampTickFrequency(self) -> "uint64_t":
        r"""
        Returns the timestamp tick frequency.

        :rtype: int
        :return: Timestamp tick frequency in Hz

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_TimestampTickFrequency(self)

    def ParentInterface(self) -> "std::shared_ptr< peak::core::Interface >":
        r"""
        Returns the parent interface.

        :rtype: :py:class:`Interface`
        :return: Parent interface

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_ParentInterface(self)

    def IsOpenable(self, *args) -> "bool":
        r"""
        Checks whether the device can be opened with a specific access type.

        If the device can be opened with a higher access type, it can also be opened with a lower access type.

        .. code-block:: c++

            if (deviceDescriptor->IsOpenable())
            {
                device = deviceDescriptor->OpenDevice(DeviceAccessType::Control);
            }

        :type accessType: int, in, optional
        :param accessType: The access type to check.

        :rtype: boolean
        :return: True, if the device can be opened with the given access type.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_IsOpenable(self, *args)

    def OpenDevice(self, accessType: "peak::core::DeviceAccessType") -> "std::shared_ptr< peak::core::Device >":
        r"""
        Opens the Device.

        :type accessType: int, in
        :param accessType: The access type the device should be opened for.

        :rtype: :py:class:`Device`
        :return: Opened Device

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_OpenDevice(self, accessType)

    def OpenedDevice(self) -> "std::shared_ptr< peak::core::Device >":
        r"""
        Returns the Device that was opened with this DeviceDescriptor.

        :rtype: :py:class:`Device`
        :return: Opened Device

        Since: 1.0

        :raises: BadAccessException Device is not open
        """
        return _ids_peak_python_interface.DeviceDescriptor_OpenedDevice(self)

    def RegisterDeviceOpenedCallback(self, callback: "DeviceDescriptorDeviceOpenedCallbackBase") -> "peak::core::DeviceDescriptor::DeviceOpenedCallbackHandle":
        return _ids_peak_python_interface.DeviceDescriptor_RegisterDeviceOpenedCallback(self, callback)

    def UnregisterDeviceOpenedCallback(self, callbackHandle: "peak::core::DeviceDescriptor::DeviceOpenedCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceDescriptor_UnregisterDeviceOpenedCallback(self, callbackHandle)

    class DeviceOpenedCallback(DeviceDescriptorDeviceOpenedCallbackBase):
        def __init__(self, callback):
            DeviceDescriptorDeviceOpenedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::Device>&"):
            self._callback(arg0)
        _callback = None


# Register DeviceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceDescriptor_swigregister(DeviceDescriptor)
FirmwareUpdatePersistence_NoPersistence = _ids_peak_python_interface.FirmwareUpdatePersistence_NoPersistence
r""" All sets are reset to default values during the update."""
FirmwareUpdatePersistence_FullPersistence = _ids_peak_python_interface.FirmwareUpdatePersistence_FullPersistence
r""" The device guarantees, that all sets are persisted during the update."""
FirmwareUpdateVersionStyle_Dotted = _ids_peak_python_interface.FirmwareUpdateVersionStyle_Dotted
r"""
    The version consists of any number of parts separated by dots. If a part consists of decimal characters only,
    it is compared numerically, otherwise it is compared using strcmp(). This leads to the following ordering:
    1.1.a < 1.10.a < 1.10.b <1.10.b.a
    """
FirmwareUpdateVersionStyle_Semantic = _ids_peak_python_interface.FirmwareUpdateVersionStyle_Semantic
r"""The style as specified in 'Semantic Versioning 2.0.0' ( http://semver.org/ )."""
class FirmwareUpdateInformation(object):
    r"""
    Represents a single firmware update information.

    This class allows to query information from the *.guf file about a single firmware update information.

    See GenICam FWUpdate Standard.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateInformation

    def IsValid(self) -> "bool":
        r"""
        Checks whether the information held are valid.

        :rtype: boolean
        :return: True, if the information held are valid.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_IsValid(self)

    def FileName(self) -> "std::string":
        r"""
        Returns the file name of the package this firmware update information belongs to.

        :rtype: string
        :return: File name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_FileName(self)

    def Description(self) -> "std::string":
        r"""
        Returns the description of the firmware update.

        :rtype: string
        :return: Description

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_Description(self)

    def Version(self) -> "std::string":
        r"""
        Returns the version of the firmware update.

        :rtype: string
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_Version(self)

    def VersionExtractionPattern(self) -> "std::string":
        r"""
        Regular expression to extract the device version from the DeviceFirmwareVersion node.

        The first matched group is used as result. This is needed for devices which encode more information than just
        the firmware version inside the DeviceFirmwareVersion node. The default value is: ^(.*)$

        :rtype: string
        :return: Version extraction pattern

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_VersionExtractionPattern(self)

    def VersionStyle(self) -> "peak::core::FirmwareUpdateVersionStyle":
        r"""
        The style of the Version() value.

        This is needed to actually interpret and sort the versions. Using this information an update software is
        able to inform the user if an update would actually be a downgrade or if it was already applied to the device.

        :rtype: int
        :return: Version style

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_VersionStyle(self)

    def ReleaseNotes(self) -> "std::string":
        r"""
        Release notes of the firmware update.

        :rtype: string
        :return: Release notes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_ReleaseNotes(self)

    def ReleaseNotesURL(self) -> "std::string":
        r"""
        A link to a webpage with more release notes.

        This webpage can contain addition details not contained in ReleaseNotes().

        :rtype: string
        :return: URL where the release notes of the firmware update can be found

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_ReleaseNotesURL(self)

    def UserSetPersistence(self) -> "peak::core::FirmwareUpdatePersistence":
        r"""
        Specifies if the device persists user sets during the update.

        :rtype: int
        :return: User set persistence

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_UserSetPersistence(self)

    def SequencerSetPersistence(self) -> "peak::core::FirmwareUpdatePersistence":
        r"""
        Specifies if the device persists sequencer sets during the update.

        :rtype: int
        :return: Sequencer set persistence

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_SequencerSetPersistence(self)

# Register FirmwareUpdateInformation in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateInformation_swigregister(FirmwareUpdateInformation)
FirmwareUpdateStep_CheckPreconditions = _ids_peak_python_interface.FirmwareUpdateStep_CheckPreconditions
FirmwareUpdateStep_AcquireUpdateData = _ids_peak_python_interface.FirmwareUpdateStep_AcquireUpdateData
FirmwareUpdateStep_WriteFeature = _ids_peak_python_interface.FirmwareUpdateStep_WriteFeature
FirmwareUpdateStep_ExecuteFeature = _ids_peak_python_interface.FirmwareUpdateStep_ExecuteFeature
FirmwareUpdateStep_AssertFeature = _ids_peak_python_interface.FirmwareUpdateStep_AssertFeature
FirmwareUpdateStep_UploadFile = _ids_peak_python_interface.FirmwareUpdateStep_UploadFile
FirmwareUpdateStep_ResetDevice = _ids_peak_python_interface.FirmwareUpdateStep_ResetDevice
class FirmwareUpdateProgressObserver(object):
    r"""
    Allows to observe a firmware update process.

    Observe a firmware update process by registering several callbacks.
    These callbacks get called when the observer is passed to the FirmwareUpdater::UpdateDevice() function. The
    callbacks inform about changes of the status of the firmware update process.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ids_peak_python_interface.FirmwareUpdateProgressObserver_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserver())
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserver

    def RegisterUpdateStartedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateStartedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateStartedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStartedCallback(self, callback)

    def UnregisterUpdateStartedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateStartedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStartedCallback(self, callbackHandle)

    class UpdateStartedCallback(FirmwareUpdateProgressObserverUpdateStartedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStartedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::FirmwareUpdateInformation>&", arg1 : "uint32_t"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterUpdateStepStartedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateStepStartedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepStartedCallback(self, callback)

    def UnregisterUpdateStepStartedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateStepStartedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepStartedCallback(self, callbackHandle)

    class UpdateStepStartedCallback(FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "peak::core::FirmwareUpdateStep", arg1 : "uint32_t", arg2 : "const std::string&"):
            self._callback(arg0, arg1, arg2)
        _callback = None


    def RegisterUpdateStepProgressChangedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateStepProgressChangedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepProgressChangedCallback(self, callback)

    def UnregisterUpdateStepProgressChangedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateStepProgressChangedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepProgressChangedCallback(self, callbackHandle)

    class UpdateStepProgressChangedCallback(FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "peak::core::FirmwareUpdateStep", arg1 : "double"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterUpdateStepFinishedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateStepFinishedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepFinishedCallback(self, callback)

    def UnregisterUpdateStepFinishedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateStepFinishedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepFinishedCallback(self, callbackHandle)

    class UpdateStepFinishedCallback(FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "peak::core::FirmwareUpdateStep"):
            self._callback(arg0)
        _callback = None


    def RegisterUpdateFinishedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateFinishedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateFinishedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateFinishedCallback(self, callback)

    def UnregisterUpdateFinishedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateFinishedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateFinishedCallback(self, callbackHandle)

    class UpdateFinishedCallback(FirmwareUpdateProgressObserverUpdateFinishedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateFinishedCallbackBase.__init__(self)
            self._callback = callback
        def call(self):
            self._callback()
        _callback = None


    def RegisterUpdateFailedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateFailedCallbackBase") -> "peak::core::FirmwareUpdateProgressObserver::UpdateFailedCallbackHandle":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateFailedCallback(self, callback)

    def UnregisterUpdateFailedCallback(self, callbackHandle: "peak::core::FirmwareUpdateProgressObserver::UpdateFailedCallbackHandle") -> "void":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateFailedCallback(self, callbackHandle)

    class UpdateFailedCallback(FirmwareUpdateProgressObserverUpdateFailedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateFailedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::string&"):
            self._callback(arg0)
        _callback = None


# Register FirmwareUpdateProgressObserver in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserver_swigregister(FirmwareUpdateProgressObserver)
class FirmwareUpdater(object):
    r"""
    Allows to update the firmware of a device.

    To update the device firmware, call CollectFirmwareUpdateInformation() with a *.guf file and the device to update,
    select one of the firmware updates in the list, then pass it to UpdateDevice() to exectue the update.

    To observe the update progress, pass a FirmwareUpdateProgressObserver to the UpdateDevice(). This is optional, but
    very helpful, since firmware updates can take several minutes.

    Notes: The DeviceDescriptor passed to CollectFirmwareUpdateInformation() and UpdateDevice() will be opened in
          Exclusive mode. Therefore, if the Device is opened in any other application, both methods will fail with an
          InternalErrorException.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ids_peak_python_interface.FirmwareUpdater_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdater())
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdater

    def CollectFirmwareUpdateInformation(self, *args) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation >,std::allocator< std::shared_ptr< peak::core::FirmwareUpdateInformation > > >":
        r"""
        *Overload 1:*

        Collects all firmware update information of a given *.guf file.

        :type gufPath: string, in
        :param gufPath: The path of the *.guf file containing the firmware update.

        :rtype: std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation >,std::allocator< std::shared_ptr< peak::core::FirmwareUpdateInformation > > >
        :return: A list of firmware update information.

        Since: 1.2

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Collects the firmware update information of a given *.guf file fitting to a given device.

        :type gufPath: string, in
        :param gufPath: The path of the *.guf file containing the firmware update.
        :type device: :py:class:`DeviceDescriptor`, in
        :param device: The device to update.

        :rtype: std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation >,std::allocator< std::shared_ptr< peak::core::FirmwareUpdateInformation > > >
        :return: A list of firmware update information fitting to the given device

        Since: 1.0

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdater_CollectFirmwareUpdateInformation(self, *args)

    def UpdateDevice(self, *args) -> "void":
        r"""
        Updates a given device by using a given firmware update information.

        This is a blocking call, i.e. it only returns once the update is done. Depending on the device, the update may
        take several minutes. To watch the progress during the update, pass a FirmwareUpdateProgressObserver.

        :type device: :py:class:`DeviceDescriptor`, in
        :param device: The device to update.
        :type updateInformation: :py:class:`FirmwareUpdateInformation`, in
        :param updateInformation: The firmware update information to update the device.
        :type progressObserver: :py:class:`FirmwareUpdateProgressObserver`, in, optional
        :param progressObserver: The progress observer to observe the update process. It is optional.
        :type deviceResetDiscoveryTimeout: :py:class:`Timeout`, in, optional
        :param deviceResetDiscoveryTimeout: Time to wait for a device to reboot during the update.

        Notes: The DeviceDescriptor passed to this function will be invalid after the update. Update the
              DeviceManager/Interface and retrieve a new DeviceDescriptor.

        Since: 1.0
        1.2 Added deviceResetDiscoveryTimeout parameter.

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.
        :raises: TimeoutException The deviceResetDiscoveryTimeout was exceeded.
        """
        return _ids_peak_python_interface.FirmwareUpdater_UpdateDevice(self, *args)

# Register FirmwareUpdater in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdater_swigregister(FirmwareUpdater)
class Interface(EventSupportingModule):
    r"""
    Represents a GenTL Interface module.

    This class allows to query information about a GenTL Interface module and to enumerate its
    DeviceDescriptor DeviceDescriptors, which allow you to open the corresponding Device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Interface

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.Interface_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.Interface_Info(self, infoCommand)

    def ID(self) -> "std::string":
        
        return _ids_peak_python_interface.Interface_ID(self)

    def DisplayName(self) -> "std::string":
        
        return _ids_peak_python_interface.Interface_DisplayName(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.Interface_TLType(self)

    def UpdateDevices(self, timeout_ms: "Timeout") -> "void":
        r"""
        Searches for devices.

        This function triggers an update of the internal device list. The callbacks registered on the interface
        will be triggered if an device is found or lost.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new devices in milliseconds. In any case the
                                  GenTL Producer must make sure that this operation is completed in a
                                  reasonable amount of time depending on the underlying technology.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_UpdateDevices(self, timeout_ms)

    def Devices(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor >,std::allocator< std::shared_ptr< peak::core::DeviceDescriptor > > >":
        r"""
        Returns the device list.

        :rtype: std::vector< std::shared_ptr< peak::core::DeviceDescriptor >,std::allocator< std::shared_ptr< peak::core::DeviceDescriptor > > >
        :return: Device list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_Devices(self)

    def ParentSystem(self) -> "std::shared_ptr< peak::core::System >":
        
        return _ids_peak_python_interface.Interface_ParentSystem(self)

    def RegisterDeviceLostCallback(self, callback: "peak::core::Interface::DeviceLostCallback const &") -> "peak::core::Interface::DeviceLostCallbackHandle":
        r"""
        Registers a callback for signaling a lost device.

        This function registers a callback which gets called every time a device is lost. Pass the callback
        handle returned by this function to UnregisterDeviceLostCallback() to unregister the callback.

        :type callback: peak::core::Interface::DeviceLostCallback, in
        :param callback: The callback to call if a device is lost.

        :rtype: std::function< void (std::string const &) >
        :return: Callback handle

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_RegisterDeviceLostCallback(self, callback)

    def UnregisterDeviceLostCallback(self, callbackHandle: "peak::core::Interface::DeviceLostCallbackHandle") -> "void":
        r"""
        Unregisters a device lost callback.

        This function unregisters a device lost callback by taking its handle.

        :type callbackHandle: std::function< void (std::string const &) >, in
        :param callbackHandle: The handle of the callback to unregister.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_UnregisterDeviceLostCallback(self, callbackHandle)

    def RegisterDeviceFoundCallback(self, callback: "InterfaceDeviceFoundCallbackBase") -> "peak::core::Interface::DeviceFoundCallbackHandle":
        return _ids_peak_python_interface.Interface_RegisterDeviceFoundCallback(self, callback)

    def UnregisterDeviceFoundCallback(self, callbackHandle: "peak::core::Interface::DeviceFoundCallbackHandle") -> "void":
        return _ids_peak_python_interface.Interface_UnregisterDeviceFoundCallback(self, callbackHandle)

    class DeviceFoundCallback(InterfaceDeviceFoundCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::DeviceDescriptor>&"):
            self._callback(arg0)
        _callback = None


# Register Interface in _ids_peak_python_interface:
_ids_peak_python_interface.Interface_swigregister(Interface)
class InterfaceDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL Interface module's ID.

    This class allows to query information about a GenTL Interface module without opening it. Furthermore, it allows
    to open the corresponding Interface module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDescriptor

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.InterfaceDescriptor_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.InterfaceDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "std::string":
        r"""
        Returns the display name.

        :rtype: string
        :return: Display name

        Since: 1.0

        :raises: NotFoundException Interface could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_DisplayName(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.InterfaceDescriptor_TLType(self)

    def ParentSystem(self) -> "std::shared_ptr< peak::core::System >":
        r"""
        Returns the parent system.

        :rtype: :py:class:`System`
        :return: Parent system

        Since: 1.0

        :raises: NotFoundException Interface could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_ParentSystem(self)

    def OpenInterface(self) -> "std::shared_ptr< peak::core::Interface >":
        r"""
        Opens the interface.

        :rtype: :py:class:`Interface`
        :return: Opened interface

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_OpenInterface(self)

    def OpenedInterface(self) -> "std::shared_ptr< peak::core::Interface >":
        r"""
        Returns the Interface that was opened with this InterfaceDescriptor.

        :rtype: :py:class:`Interface`
        :return: Opened Interface

        Since: 1.0

        :raises: BadAccessException Interface is not open
        """
        return _ids_peak_python_interface.InterfaceDescriptor_OpenedInterface(self)

# Register InterfaceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDescriptor_swigregister(InterfaceDescriptor)
CharacterEncoding_ASCII = _ids_peak_python_interface.CharacterEncoding_ASCII
CharacterEncoding_UTF8 = _ids_peak_python_interface.CharacterEncoding_UTF8
class System(EventSupportingModule):
    r"""
    Represents a GenTL System module.

    This class allows to query information about the GenTL System module and to enumerate its
    InterfaceDescriptor InterfaceDescriptors, which allow to open the corresponding Interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_System

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.System_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        
        return _ids_peak_python_interface.System_Info(self, infoCommand)

    def ID(self) -> "std::string":
        r"""
        Returns the ID.

        :rtype: string
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_ID(self)

    def DisplayName(self) -> "std::string":
        
        return _ids_peak_python_interface.System_DisplayName(self)

    def VendorName(self) -> "std::string":
        
        return _ids_peak_python_interface.System_VendorName(self)

    def ModelName(self) -> "std::string":
        
        return _ids_peak_python_interface.System_ModelName(self)

    def Version(self) -> "std::string":
        
        return _ids_peak_python_interface.System_Version(self)

    def TLType(self) -> "std::string":
        
        return _ids_peak_python_interface.System_TLType(self)

    def CTIFileName(self) -> "std::string":
        
        return _ids_peak_python_interface.System_CTIFileName(self)

    def CTIFullPath(self) -> "std::string":
        
        return _ids_peak_python_interface.System_CTIFullPath(self)

    def GenTLVersionMajor(self) -> "uint32_t":
        
        return _ids_peak_python_interface.System_GenTLVersionMajor(self)

    def GenTLVersionMinor(self) -> "uint32_t":
        
        return _ids_peak_python_interface.System_GenTLVersionMinor(self)

    def CharacterEncoding(self) -> "peak::core::CharacterEncoding":
        
        return _ids_peak_python_interface.System_CharacterEncoding(self)

    def UpdateInterfaces(self, timeout_ms: "Timeout") -> "void":
        r"""
        Searches for interfaces.

        This function triggers an update of the internal interface list. The callbacks registered on the system
        will be triggered if an interface is found or lost.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new interfaces in milliseconds. In any case the
                                  GenTL Producer must make sure that this operation is completed in a
                                  reasonable amount of time depending on the underlying technology.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_UpdateInterfaces(self, timeout_ms)

    def Interfaces(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor >,std::allocator< std::shared_ptr< peak::core::InterfaceDescriptor > > >":
        r"""
        Returns the interface list.

        :rtype: std::vector< std::shared_ptr< peak::core::InterfaceDescriptor >,std::allocator< std::shared_ptr< peak::core::InterfaceDescriptor > > >
        :return: Interface list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_Interfaces(self)

    def ParentLibrary(self) -> "std::shared_ptr< peak::core::ProducerLibrary >":
        
        return _ids_peak_python_interface.System_ParentLibrary(self)

    def RegisterInterfaceLostCallback(self, callback: "peak::core::System::InterfaceLostCallback const &") -> "peak::core::System::InterfaceLostCallbackHandle":
        r"""
        Registers a callback for signaling a lost interface.

        This function registers a callback which gets called every time a interface is lost. Pass the callback
        handle returned by this function to UnregisterInterfaceLostCallback() to unregister the callback.

        :type callback: peak::core::System::InterfaceLostCallback, in
        :param callback: The callback to call if a interface is lost.

        :rtype: std::function< void (std::string const &) >
        :return: Callback handle

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_RegisterInterfaceLostCallback(self, callback)

    def UnregisterInterfaceLostCallback(self, callbackHandle: "peak::core::System::InterfaceLostCallbackHandle") -> "void":
        r"""
        Unregisters a interface lost callback.

        This function unregisters a interface lost callback by taking its handle.

        :type callbackHandle: std::function< void (std::string const &) >, in
        :param callbackHandle: The handle of the callback to unregister.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_UnregisterInterfaceLostCallback(self, callbackHandle)

    def RegisterInterfaceFoundCallback(self, callback: "SystemInterfaceFoundCallbackBase") -> "peak::core::System::InterfaceFoundCallbackHandle":
        return _ids_peak_python_interface.System_RegisterInterfaceFoundCallback(self, callback)

    def UnregisterInterfaceFoundCallback(self, callbackHandle: "peak::core::System::InterfaceFoundCallbackHandle") -> "void":
        return _ids_peak_python_interface.System_UnregisterInterfaceFoundCallback(self, callbackHandle)

    class InterfaceFoundCallback(SystemInterfaceFoundCallbackBase):
        def __init__(self, callback):
            SystemInterfaceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::InterfaceDescriptor>&"):
            self._callback(arg0)
        _callback = None


# Register System in _ids_peak_python_interface:
_ids_peak_python_interface.System_swigregister(System)
class SystemDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with the GenTL System module's ID.

    This class allows to query information about the GenTL System module without opening it. Furthermore, it enables
    you to open the GenTL System module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SystemDescriptor

    def Key(self) -> "std::string":
        
        return _ids_peak_python_interface.SystemDescriptor_Key(self)

    def Info(self, infoCommand: "int32_t") -> "peak::core::RawInformation":
        r"""
        Delivers information based on the given GenTL info command.

        :type infoCommand: int, in
        :param infoCommand: The GenTL info command.

        This function can be used to query information going beyond the predefined info functions, based on the GenTL
        info commands of the corresponding module.

        Example (error handling is omitted):

        .. code-block:: c++

            #include <peak/thirdparty/GenTL.h>
            auto info = object->Info(GenTL::XX_INFO_XX);

            // Cast depending on the delivered data type
            if (info.dataType == GenTL::INFO_DATATYPE_UINT64)
            {
                uint64_t uint64Var = *reinterpret_cast<const uint64_t*>(info.data.data());
                // Do something with the information
            }
            else if (infoDataTypeVar == GenTL::INFO_DATATYPE_INT64)
            {
                ...
            }
            ...

        :rtype: :py:class:`RawInformation`
        :return: Raw information according to the passed info command

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "std::string":
        r"""
        Returns the display name.

        :rtype: string
        :return: Display name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_DisplayName(self)

    def VendorName(self) -> "std::string":
        r"""
        Returns the vendor name.

        :rtype: string
        :return: Vendor name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_VendorName(self)

    def ModelName(self) -> "std::string":
        r"""
        Returns the model name.

        :rtype: string
        :return: Model name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_ModelName(self)

    def Version(self) -> "std::string":
        r"""
        Returns the version.

        :rtype: string
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_Version(self)

    def TLType(self) -> "std::string":
        r"""
        Returns the TL (transport layer) type.

        :rtype: string
        :return: TL type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_TLType(self)

    def CTIFileName(self) -> "std::string":
        r"""
        Returns the file name of the GenTL producer library this system belongs to.

        :rtype: string
        :return: File name of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CTIFileName(self)

    def CTIFullPath(self) -> "std::string":
        r"""
        Returns the full path of the GenTL producer library this system belongs to.

        :rtype: string
        :return: Full path of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CTIFullPath(self)

    def GenTLVersionMajor(self) -> "uint32_t":
        r"""
        Returns the GenTL major version of the GenTL producer library this system belongs to.

        :rtype: int
        :return: GenTL major version of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_GenTLVersionMajor(self)

    def GenTLVersionMinor(self) -> "uint32_t":
        r"""
        Returns the GenTL minor version of the GenTL producer library this system belongs to.

        :rtype: int
        :return: GenTL minor version of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_GenTLVersionMinor(self)

    def CharacterEncoding(self) -> "peak::core::CharacterEncoding":
        r"""
        Returns the character encoding of the GenTL producer library this system belongs to.

        :rtype: int
        :return: Character encoding of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CharacterEncoding(self)

    def ParentLibrary(self) -> "std::shared_ptr< peak::core::ProducerLibrary >":
        r"""
        Returns the parent library.

        :rtype: :py:class:`ProducerLibrary`
        :return: Parent library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_ParentLibrary(self)

    def OpenSystem(self) -> "std::shared_ptr< peak::core::System >":
        r"""
        Opens the system.

        :rtype: :py:class:`System`
        :return: Opened system

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_OpenSystem(self)

    def OpenedSystem(self) -> "std::shared_ptr< peak::core::System >":
        r"""
        Returns the System that was opened with this SystemDescriptor.

        :rtype: :py:class:`System`
        :return: Opened System

        Since: 1.0

        :raises: BadAccessException System is not open
        """
        return _ids_peak_python_interface.SystemDescriptor_OpenedSystem(self)

# Register SystemDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.SystemDescriptor_swigregister(SystemDescriptor)
class ProducerLibrary(object):
    r"""
    Represents a GenTL producer library (CTI).

    This class allows to load and initialize a GenTL producer library (CTI) and access its functionality. Each
    ProducerLibrary contains exactly one SystemDescriptor, which allows you to open the corresponding System.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_ProducerLibrary

    @staticmethod
    def Open(ctiPath: "std::string const &") -> "std::shared_ptr< peak::core::ProducerLibrary >":
        r"""
        Opens the given producer library (CTI).

        :type ctiPath: string, in
        :param ctiPath: The path of the producer library (CTI) to open.

        :rtype: :py:class:`ProducerLibrary`
        :return: Producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: CTILoadingException Loading the cti failed.
        """
        return _ids_peak_python_interface.ProducerLibrary_Open(ctiPath)

    def Key(self) -> "std::string":
        r"""
        Returns the unique key.

        The returned key is unique even across different producer libraries.

        :rtype: string
        :return: Unique key

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ProducerLibrary_Key(self)

    def System(self) -> "std::shared_ptr< peak::core::SystemDescriptor >":
        r"""
        Returns the system descriptor.

        The returned system descriptor can be used to query information about the GenTL system module
        without opening it and to open the GenTL system module.

        :rtype: :py:class:`SystemDescriptor`
        :return: System descriptor

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ProducerLibrary_System(self)

# Register ProducerLibrary in _ids_peak_python_interface:
_ids_peak_python_interface.ProducerLibrary_swigregister(ProducerLibrary)
class EnvironmentInspector(object):
    r"""Allows to inspect the environment the application is running in."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def CollectCTIPaths() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Collects producer library paths found in the current environment.

        Select a *.cti file from this list of paths and use it with ProducerLibrary::Open().

        Notes: This function depends on the architecture your application is compiled for. This means you are getting
              the paths for the 32-bit producer libraries if your application is compiled for a 32-bit system and the
              paths for the 64-bit producer libraries if your application is compiled for a 64-bit system.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: Producer library paths found in the current environment

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: NotFoundException The environment variable GENICAM_GENTL32_PATH / GENICAM_GENTL64_PATH was not
                                      found or was empty when scanning for environment ProducerLibraries.
        """
        return _ids_peak_python_interface.EnvironmentInspector_CollectCTIPaths()

# Register EnvironmentInspector in _ids_peak_python_interface:
_ids_peak_python_interface.EnvironmentInspector_swigregister(EnvironmentInspector)
class DeviceManager(object):
    r"""
    The global DeviceManager (singleton) searches all installed producer libraries (*.cti) and enumerates the
    modules contained in them.

    Retrieve the global DeviceManager with DeviceManager::Instance().

    When Update() is called, it searches for all producer libraries contained in the directories found in the official
    GenICam GenTL environment variable GENICAM_GENTL{32/64}_PATH. It then openes all found
    core::ProducerLibrary ProducerLibraries, their core::System Systems, their
    core::Interface Interfaces, and lists all available core::DeviceDescriptor DeviceDescriptors.

    .. code-block:: c++

        auto& deviceManager = peak::DeviceManager::Instance();
        deviceManager.Update();
        deviceDescriptors = deviceManager.Devices();

    Notes: The found producer libraries depend on the architecture your application is compiled for. This means you are
          getting 32-bit producer libraries if your application is compiled for a 32-bit system and 64-bit producer
          libraries if your application is compiled for a 64-bit system.

    The DeviceManager is a singleton. Therefore, after it was used, it stays active until program termination. That
    means the opened core::ProducerLibrary ProducerLibraries, core::System Systems, and
    core::Interface Interfaces  stay open. To close them before and start from scratch during runtime, call
    Reset().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    UpdatePolicy_ScanEnvironmentForProducerLibraries = _ids_peak_python_interface.DeviceManager_UpdatePolicy_ScanEnvironmentForProducerLibraries
    UpdatePolicy_DontScanEnvironmentForProducerLibraries = _ids_peak_python_interface.DeviceManager_UpdatePolicy_DontScanEnvironmentForProducerLibraries
    ResetPolicy_ErrorOnOpenDevices = _ids_peak_python_interface.DeviceManager_ResetPolicy_ErrorOnOpenDevices
    ResetPolicy_IgnoreOpenDevices = _ids_peak_python_interface.DeviceManager_ResetPolicy_IgnoreOpenDevices

    @staticmethod
    def Instance() -> "peak::DeviceManager &":
        r"""
        Returns the global DeviceManager.

        Since: 1.0
        """
        return _ids_peak_python_interface.DeviceManager_Instance()

    def AddProducerLibrary(self, ctiPath: "std::string const &") -> "void":
        r"""
        Adds the given producer library (CTI).

        This function can be used to add producer libraries manually. This is useful when the desired producer
        library is not registered at the GenTL environment variable.

        :type ctiPath: string, in
        :param ctiPath: The path to the producer library (CTI) to add

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are
              applied before calling Update(). Changes applied during a running update only take effect with the next
              call to Update().
        """
        return _ids_peak_python_interface.DeviceManager_AddProducerLibrary(self, ctiPath)

    def Reset(self, *args) -> "void":
        r"""
        Resets the DeviceManager.

        All core::Interface Interfaces  and core::System Systems  are closed, additional
        ProducerLibraries (added via AddProducerLibrary()) are cleared. Any registered callbacks stay active and the
        DeviceLostCallback and InterfaceLostCallback are called for all devices / interfaces.

        Notes: Can't reset the DeviceManager while there are open core::Device Devices. Close all devices before
              calling this method. Otherwise, a core::InternalErrorException is thrown.

        :type resetPolicy: int, in, optional
        :param resetPolicy: With the default ResetPolicy::ErrorOnOpenDevices, an exception is thrown if there are
                       any open devices managed by the DeviceManager. With ResetPolicy::IgnoreOpenDevices, no such exception
                       is thrown.

        Since: 1.0

        :raises: core::InternalErrorException If there are open devices (with ResetPolicy::ErrorOnOpenDevices).
        """
        return _ids_peak_python_interface.DeviceManager_Reset(self, *args)

    def InterfaceUpdateTimeout(self) -> "peak::core::Timeout":
        r"""
        Returns the interface update timeout.

        :rtype: :py:class:`Timeout`
        :return: Interface update timeout in milliseconds

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_InterfaceUpdateTimeout(self)

    def SetInterfaceUpdateTimeout(self, timeout_ms: "Timeout") -> "void":
        r"""
        Sets the interface update timeout.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new interfaces in milliseconds.

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are
              applied before calling Update(). Changes applied during a running update only take effect with the next
              call to Update().
        """
        return _ids_peak_python_interface.DeviceManager_SetInterfaceUpdateTimeout(self, timeout_ms)

    def DeviceUpdateTimeout(self) -> "peak::core::Timeout":
        r"""
        Returns the device update timeout.

        :rtype: :py:class:`Timeout`
        :return: Device update timeout in milliseconds

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_DeviceUpdateTimeout(self)

    def SetDeviceUpdateTimeout(self, timeout_ms: "Timeout") -> "void":
        r"""
        Sets the device update timeout.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new devices in milliseconds.

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are
              applied before calling Update(). Changes applied during a running update only take effect with the next
              call to Update().
        """
        return _ids_peak_python_interface.DeviceManager_SetDeviceUpdateTimeout(self, timeout_ms)

    def Devices(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor >,std::allocator< std::shared_ptr< peak::core::DeviceDescriptor > > >":
        r"""
        Returns the found devices.

        :rtype: std::vector< std::shared_ptr< peak::core::DeviceDescriptor >,std::allocator< std::shared_ptr< peak::core::DeviceDescriptor > > >
        :return: Found devices

        Since: 1.0

        :raises: core::InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_Devices(self)

    def RegisterSystemFoundCallback(self, callback: "DeviceManagerSystemFoundCallbackBase") -> "peak::DeviceManager::SystemFoundCallbackHandle":
        return _ids_peak_python_interface.DeviceManager_RegisterSystemFoundCallback(self, callback)

    def UnregisterSystemFoundCallback(self, callbackHandle: "peak::DeviceManager::SystemFoundCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceManager_UnregisterSystemFoundCallback(self, callbackHandle)

    class SystemFoundCallback(DeviceManagerSystemFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerSystemFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<const peak::core::System>&"):
            self._callback(arg0)
        _callback = None


    def RegisterInterfaceFoundCallback(self, callback: "DeviceManagerInterfaceFoundCallbackBase") -> "peak::DeviceManager::InterfaceFoundCallbackHandle":
        return _ids_peak_python_interface.DeviceManager_RegisterInterfaceFoundCallback(self, callback)

    def UnregisterInterfaceFoundCallback(self, callbackHandle: "peak::DeviceManager::InterfaceFoundCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceManager_UnregisterInterfaceFoundCallback(self, callbackHandle)

    class InterfaceFoundCallback(DeviceManagerInterfaceFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerInterfaceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<const peak::core::Interface>&"):
            self._callback(arg0)
        _callback = None


    def RegisterInterfaceLostCallback(self, callback: "DeviceManagerInterfaceLostCallbackBase") -> "peak::DeviceManager::InterfaceLostCallbackHandle":
        return _ids_peak_python_interface.DeviceManager_RegisterInterfaceLostCallback(self, callback)

    def UnregisterInterfaceLostCallback(self, callbackHandle: "peak::DeviceManager::InterfaceLostCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceManager_UnregisterInterfaceLostCallback(self, callbackHandle)

    class InterfaceLostCallback(DeviceManagerInterfaceLostCallbackBase):
        def __init__(self, callback):
            DeviceManagerInterfaceLostCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::string&"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceFoundCallback(self, callback: "DeviceManagerDeviceFoundCallbackBase") -> "peak::DeviceManager::DeviceFoundCallbackHandle":
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceFoundCallback(self, callback)

    def UnregisterDeviceFoundCallback(self, callbackHandle: "peak::DeviceManager::DeviceFoundCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceFoundCallback(self, callbackHandle)

    class DeviceFoundCallback(DeviceManagerDeviceFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::shared_ptr<peak::core::DeviceDescriptor>&"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceLostCallback(self, callback: "DeviceManagerDeviceLostCallbackBase") -> "peak::DeviceManager::DeviceLostCallbackHandle":
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceLostCallback(self, callback)

    def UnregisterDeviceLostCallback(self, callbackHandle: "peak::DeviceManager::DeviceLostCallbackHandle") -> "void":
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceLostCallback(self, callbackHandle)

    class DeviceLostCallback(DeviceManagerDeviceLostCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceLostCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::string&"):
            self._callback(arg0)
        _callback = None


    class UpdateErrorCallback(DeviceManagerUpdateErrorCallbackBase):
        def __init__(self, callback):
            DeviceManagerUpdateErrorCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "const std::string&"):
            self._callback(arg0)
        _callback = None


    def Update(self, *args) -> "void":
        return _ids_peak_python_interface.DeviceManager_Update(self, *args)

# Register DeviceManager in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManager_swigregister(DeviceManager)
class VectorString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorString___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _ids_peak_python_interface.VectorString___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _ids_peak_python_interface.VectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _ids_peak_python_interface.VectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _ids_peak_python_interface.VectorString_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorString_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorString_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _ids_peak_python_interface.VectorString_size(self)

    def swap(self, v: "VectorString") -> "void":
        return _ids_peak_python_interface.VectorString_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _ids_peak_python_interface.VectorString_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _ids_peak_python_interface.VectorString_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _ids_peak_python_interface.VectorString_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _ids_peak_python_interface.VectorString_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorString_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _ids_peak_python_interface.VectorString_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _ids_peak_python_interface.VectorString_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorString_swiginit(self, _ids_peak_python_interface.new_VectorString(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorString_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _ids_peak_python_interface.VectorString_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _ids_peak_python_interface.VectorString_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorString_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _ids_peak_python_interface.VectorString_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _ids_peak_python_interface.VectorString_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorString

# Register VectorString in _ids_peak_python_interface:
_ids_peak_python_interface.VectorString_swigregister(VectorString)
class VectorDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _ids_peak_python_interface.VectorDouble___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _ids_peak_python_interface.VectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _ids_peak_python_interface.VectorDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDouble___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _ids_peak_python_interface.VectorDouble_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDouble_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _ids_peak_python_interface.VectorDouble_size(self)

    def swap(self, v: "VectorDouble") -> "void":
        return _ids_peak_python_interface.VectorDouble_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _ids_peak_python_interface.VectorDouble_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _ids_peak_python_interface.VectorDouble_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _ids_peak_python_interface.VectorDouble_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _ids_peak_python_interface.VectorDouble_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorDouble_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _ids_peak_python_interface.VectorDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorDouble_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _ids_peak_python_interface.VectorDouble_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDouble_swiginit(self, _ids_peak_python_interface.new_VectorDouble(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDouble_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _ids_peak_python_interface.VectorDouble_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _ids_peak_python_interface.VectorDouble_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDouble_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _ids_peak_python_interface.VectorDouble_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _ids_peak_python_interface.VectorDouble_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDouble

# Register VectorDouble in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDouble_swigregister(VectorDouble)
class VectorInt64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorInt64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        return _ids_peak_python_interface.VectorInt64___len__(self)

    def __getslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "std::vector< long long,std::allocator< long long > > *":
        return _ids_peak_python_interface.VectorInt64___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInt64___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorInt64___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInt64___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        return _ids_peak_python_interface.VectorInt64___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInt64___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        return _ids_peak_python_interface.VectorInt64_pop(self)

    def append(self, x: "std::vector< long long >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInt64_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        return _ids_peak_python_interface.VectorInt64_size(self)

    def swap(self, v: "VectorInt64") -> "void":
        return _ids_peak_python_interface.VectorInt64_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        return _ids_peak_python_interface.VectorInt64_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        return _ids_peak_python_interface.VectorInt64_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        return _ids_peak_python_interface.VectorInt64_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        return _ids_peak_python_interface.VectorInt64_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorInt64_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        return _ids_peak_python_interface.VectorInt64_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorInt64_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        return _ids_peak_python_interface.VectorInt64_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorInt64_swiginit(self, _ids_peak_python_interface.new_VectorInt64(*args))

    def push_back(self, x: "std::vector< long long >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInt64_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        return _ids_peak_python_interface.VectorInt64_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        return _ids_peak_python_interface.VectorInt64_back(self)

    def assign(self, n: "std::vector< long long >::size_type", x: "std::vector< long long >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInt64_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInt64_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInt64_insert(self, *args)

    def reserve(self, n: "std::vector< long long >::size_type") -> "void":
        return _ids_peak_python_interface.VectorInt64_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        return _ids_peak_python_interface.VectorInt64_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorInt64

# Register VectorInt64 in _ids_peak_python_interface:
_ids_peak_python_interface.VectorInt64_swigregister(VectorInt64)
class VectorUInt8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorUInt8_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        return _ids_peak_python_interface.VectorUInt8___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        return _ids_peak_python_interface.VectorUInt8___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorUInt8___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorUInt8___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorUInt8___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        return _ids_peak_python_interface.VectorUInt8___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorUInt8___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        return _ids_peak_python_interface.VectorUInt8_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorUInt8_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        return _ids_peak_python_interface.VectorUInt8_size(self)

    def swap(self, v: "VectorUInt8") -> "void":
        return _ids_peak_python_interface.VectorUInt8_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        return _ids_peak_python_interface.VectorUInt8_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        return _ids_peak_python_interface.VectorUInt8_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _ids_peak_python_interface.VectorUInt8_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _ids_peak_python_interface.VectorUInt8_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorUInt8_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        return _ids_peak_python_interface.VectorUInt8_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorUInt8_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        return _ids_peak_python_interface.VectorUInt8_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorUInt8_swiginit(self, _ids_peak_python_interface.new_VectorUInt8(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorUInt8_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        return _ids_peak_python_interface.VectorUInt8_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        return _ids_peak_python_interface.VectorUInt8_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorUInt8_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorUInt8_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorUInt8_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        return _ids_peak_python_interface.VectorUInt8_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        return _ids_peak_python_interface.VectorUInt8_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorUInt8

# Register VectorUInt8 in _ids_peak_python_interface:
_ids_peak_python_interface.VectorUInt8_swigregister(VectorUInt8)
class VectorNodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorNodeMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::size_type":
        return _ids_peak_python_interface.VectorNodeMap___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::NodeMap > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::NodeMap > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::NodeMap >,std::allocator< std::shared_ptr< peak::core::NodeMap > > > *":
        return _ids_peak_python_interface.VectorNodeMap___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorNodeMap___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::NodeMap > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::NodeMap > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorNodeMap___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorNodeMap___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &":
        return _ids_peak_python_interface.VectorNodeMap___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorNodeMap___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type":
        return _ids_peak_python_interface.VectorNodeMap_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorNodeMap_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::size_type":
        return _ids_peak_python_interface.VectorNodeMap_size(self)

    def swap(self, v: "VectorNodeMap") -> "void":
        return _ids_peak_python_interface.VectorNodeMap_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::iterator":
        return _ids_peak_python_interface.VectorNodeMap_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::iterator":
        return _ids_peak_python_interface.VectorNodeMap_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::reverse_iterator":
        return _ids_peak_python_interface.VectorNodeMap_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::reverse_iterator":
        return _ids_peak_python_interface.VectorNodeMap_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorNodeMap_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::allocator_type":
        return _ids_peak_python_interface.VectorNodeMap_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorNodeMap_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::iterator":
        return _ids_peak_python_interface.VectorNodeMap_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorNodeMap_swiginit(self, _ids_peak_python_interface.new_VectorNodeMap(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorNodeMap_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &":
        return _ids_peak_python_interface.VectorNodeMap_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &":
        return _ids_peak_python_interface.VectorNodeMap_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::NodeMap > >::size_type", x: "std::vector< std::shared_ptr< peak::core::NodeMap > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorNodeMap_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorNodeMap_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorNodeMap_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::NodeMap > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorNodeMap_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::NodeMap > >::size_type":
        return _ids_peak_python_interface.VectorNodeMap_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorNodeMap

# Register VectorNodeMap in _ids_peak_python_interface:
_ids_peak_python_interface.VectorNodeMap_swigregister(VectorNodeMap)
class VectorEnumerationEntryNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::size_type":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode >,std::allocator< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > > > *":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::size_type":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_size(self)

    def swap(self, v: "VectorEnumerationEntryNode") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::iterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::iterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::reverse_iterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::reverse_iterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::allocator_type":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::iterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorEnumerationEntryNode_swiginit(self, _ids_peak_python_interface.new_VectorEnumerationEntryNode(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::size_type", x: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::nodes::EnumerationEntryNode > >::size_type":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorEnumerationEntryNode

# Register VectorEnumerationEntryNode in _ids_peak_python_interface:
_ids_peak_python_interface.VectorEnumerationEntryNode_swigregister(VectorEnumerationEntryNode)
class VectorPortURL(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorPortURL_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::size_type":
        return _ids_peak_python_interface.VectorPortURL___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::PortURL > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::PortURL > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::PortURL >,std::allocator< std::shared_ptr< peak::core::PortURL > > > *":
        return _ids_peak_python_interface.VectorPortURL___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorPortURL___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::PortURL > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::PortURL > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorPortURL___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorPortURL___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &":
        return _ids_peak_python_interface.VectorPortURL___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorPortURL___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type":
        return _ids_peak_python_interface.VectorPortURL_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorPortURL_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::size_type":
        return _ids_peak_python_interface.VectorPortURL_size(self)

    def swap(self, v: "VectorPortURL") -> "void":
        return _ids_peak_python_interface.VectorPortURL_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::iterator":
        return _ids_peak_python_interface.VectorPortURL_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::iterator":
        return _ids_peak_python_interface.VectorPortURL_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::reverse_iterator":
        return _ids_peak_python_interface.VectorPortURL_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::reverse_iterator":
        return _ids_peak_python_interface.VectorPortURL_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorPortURL_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::allocator_type":
        return _ids_peak_python_interface.VectorPortURL_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorPortURL_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::iterator":
        return _ids_peak_python_interface.VectorPortURL_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorPortURL_swiginit(self, _ids_peak_python_interface.new_VectorPortURL(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorPortURL_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &":
        return _ids_peak_python_interface.VectorPortURL_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &":
        return _ids_peak_python_interface.VectorPortURL_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::PortURL > >::size_type", x: "std::vector< std::shared_ptr< peak::core::PortURL > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorPortURL_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorPortURL_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorPortURL_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::PortURL > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorPortURL_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::PortURL > >::size_type":
        return _ids_peak_python_interface.VectorPortURL_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorPortURL

# Register VectorPortURL in _ids_peak_python_interface:
_ids_peak_python_interface.VectorPortURL_swigregister(VectorPortURL)
class VectorInterfaceDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor >,std::allocator< std::shared_ptr< peak::core::InterfaceDescriptor > > > *":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_size(self)

    def swap(self, v: "VectorInterfaceDescriptor") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::allocator_type":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorInterfaceDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorInterfaceDescriptor(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::size_type", x: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::InterfaceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorInterfaceDescriptor

# Register VectorInterfaceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorInterfaceDescriptor_swigregister(VectorInterfaceDescriptor)
class VectorDeviceDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorDeviceDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDeviceDescriptor___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor >,std::allocator< std::shared_ptr< peak::core::DeviceDescriptor > > > *":
        return _ids_peak_python_interface.VectorDeviceDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDeviceDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type":
        return _ids_peak_python_interface.VectorDeviceDescriptor_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDeviceDescriptor_size(self)

    def swap(self, v: "VectorDeviceDescriptor") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::allocator_type":
        return _ids_peak_python_interface.VectorDeviceDescriptor_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDeviceDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorDeviceDescriptor(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDeviceDescriptor_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDeviceDescriptor_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::size_type", x: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorDeviceDescriptor_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::DeviceDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDeviceDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDeviceDescriptor

# Register VectorDeviceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDeviceDescriptor_swigregister(VectorDeviceDescriptor)
class VectorFirmwareUpdateInformation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::size_type":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation >,std::allocator< std::shared_ptr< peak::core::FirmwareUpdateInformation > > > *":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::size_type":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_size(self)

    def swap(self, v: "VectorFirmwareUpdateInformation") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::iterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::iterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::reverse_iterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::reverse_iterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::allocator_type":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::iterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorFirmwareUpdateInformation_swiginit(self, _ids_peak_python_interface.new_VectorFirmwareUpdateInformation(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::size_type", x: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::FirmwareUpdateInformation > >::size_type":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorFirmwareUpdateInformation

# Register VectorFirmwareUpdateInformation in _ids_peak_python_interface:
_ids_peak_python_interface.VectorFirmwareUpdateInformation_swigregister(VectorFirmwareUpdateInformation)
class VectorDataStreamDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor >,std::allocator< std::shared_ptr< peak::core::DataStreamDescriptor > > > *":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_size(self)

    def swap(self, v: "VectorDataStreamDescriptor") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::reverse_iterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::allocator_type":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::iterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDataStreamDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorDataStreamDescriptor(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::size_type", x: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::DataStreamDescriptor > >::size_type":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDataStreamDescriptor

# Register VectorDataStreamDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDataStreamDescriptor_swigregister(VectorDataStreamDescriptor)
class VectorBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorBuffer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::size_type":
        return _ids_peak_python_interface.VectorBuffer___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::Buffer > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::Buffer > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::Buffer >,std::allocator< std::shared_ptr< peak::core::Buffer > > > *":
        return _ids_peak_python_interface.VectorBuffer___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBuffer___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::Buffer > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::Buffer > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorBuffer___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBuffer___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &":
        return _ids_peak_python_interface.VectorBuffer___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBuffer___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type":
        return _ids_peak_python_interface.VectorBuffer_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBuffer_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::size_type":
        return _ids_peak_python_interface.VectorBuffer_size(self)

    def swap(self, v: "VectorBuffer") -> "void":
        return _ids_peak_python_interface.VectorBuffer_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::iterator":
        return _ids_peak_python_interface.VectorBuffer_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::iterator":
        return _ids_peak_python_interface.VectorBuffer_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBuffer_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBuffer_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorBuffer_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::allocator_type":
        return _ids_peak_python_interface.VectorBuffer_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorBuffer_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::iterator":
        return _ids_peak_python_interface.VectorBuffer_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBuffer_swiginit(self, _ids_peak_python_interface.new_VectorBuffer(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBuffer_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &":
        return _ids_peak_python_interface.VectorBuffer_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &":
        return _ids_peak_python_interface.VectorBuffer_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::Buffer > >::size_type", x: "std::vector< std::shared_ptr< peak::core::Buffer > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBuffer_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBuffer_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBuffer_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::Buffer > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorBuffer_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::Buffer > >::size_type":
        return _ids_peak_python_interface.VectorBuffer_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBuffer

# Register VectorBuffer in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBuffer_swigregister(VectorBuffer)
class VectorBufferChunk(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorBufferChunk_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::size_type":
        return _ids_peak_python_interface.VectorBufferChunk___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::BufferChunk >,std::allocator< std::shared_ptr< peak::core::BufferChunk > > > *":
        return _ids_peak_python_interface.VectorBufferChunk___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferChunk___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type":
        return _ids_peak_python_interface.VectorBufferChunk_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::size_type":
        return _ids_peak_python_interface.VectorBufferChunk_size(self)

    def swap(self, v: "VectorBufferChunk") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::iterator":
        return _ids_peak_python_interface.VectorBufferChunk_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::iterator":
        return _ids_peak_python_interface.VectorBufferChunk_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBufferChunk_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBufferChunk_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::allocator_type":
        return _ids_peak_python_interface.VectorBufferChunk_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::iterator":
        return _ids_peak_python_interface.VectorBufferChunk_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBufferChunk_swiginit(self, _ids_peak_python_interface.new_VectorBufferChunk(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferChunk_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferChunk_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::size_type", x: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::BufferChunk > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorBufferChunk_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::BufferChunk > >::size_type":
        return _ids_peak_python_interface.VectorBufferChunk_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBufferChunk

# Register VectorBufferChunk in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBufferChunk_swigregister(VectorBufferChunk)
class VectorBufferPart(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _ids_peak_python_interface.VectorBufferPart_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::size_type":
        return _ids_peak_python_interface.VectorBufferPart___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< peak::core::BufferPart > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::BufferPart > >::difference_type") -> "std::vector< std::shared_ptr< peak::core::BufferPart >,std::allocator< std::shared_ptr< peak::core::BufferPart > > > *":
        return _ids_peak_python_interface.VectorBufferPart___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferPart___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< peak::core::BufferPart > >::difference_type", j: "std::vector< std::shared_ptr< peak::core::BufferPart > >::difference_type") -> "void":
        return _ids_peak_python_interface.VectorBufferPart___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferPart___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferPart___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferPart___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type":
        return _ids_peak_python_interface.VectorBufferPart_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferPart_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::size_type":
        return _ids_peak_python_interface.VectorBufferPart_size(self)

    def swap(self, v: "VectorBufferPart") -> "void":
        return _ids_peak_python_interface.VectorBufferPart_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::iterator":
        return _ids_peak_python_interface.VectorBufferPart_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::iterator":
        return _ids_peak_python_interface.VectorBufferPart_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBufferPart_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::reverse_iterator":
        return _ids_peak_python_interface.VectorBufferPart_rend(self)

    def clear(self) -> "void":
        return _ids_peak_python_interface.VectorBufferPart_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::allocator_type":
        return _ids_peak_python_interface.VectorBufferPart_get_allocator(self)

    def pop_back(self) -> "void":
        return _ids_peak_python_interface.VectorBufferPart_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::iterator":
        return _ids_peak_python_interface.VectorBufferPart_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBufferPart_swiginit(self, _ids_peak_python_interface.new_VectorBufferPart(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferPart_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferPart_front(self)

    def back(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &":
        return _ids_peak_python_interface.VectorBufferPart_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< peak::core::BufferPart > >::size_type", x: "std::vector< std::shared_ptr< peak::core::BufferPart > >::value_type const &") -> "void":
        return _ids_peak_python_interface.VectorBufferPart_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferPart_resize(self, *args)

    def insert(self, *args) -> "void":
        return _ids_peak_python_interface.VectorBufferPart_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< peak::core::BufferPart > >::size_type") -> "void":
        return _ids_peak_python_interface.VectorBufferPart_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< peak::core::BufferPart > >::size_type":
        return _ids_peak_python_interface.VectorBufferPart_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBufferPart

# Register VectorBufferPart in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBufferPart_swigregister(VectorBufferPart)

