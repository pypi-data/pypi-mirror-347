# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
IDS peak IPL (Image Processing Library) is an object-oriented library that provides special functionality for processing image data.
The IDS peak IPL can be used, for example, to convert raw bayer images from the camera that were captured via the IDS peak API into color (debayering).
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _peak_ipl_python_interface
else:
    import _peak_ipl_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _peak_ipl_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _peak_ipl_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _peak_ipl_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _peak_ipl_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _peak_ipl_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _peak_ipl_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _peak_ipl_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _peak_ipl_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _peak_ipl_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _peak_ipl_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _peak_ipl_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _peak_ipl_python_interface:
_peak_ipl_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _peak_ipl_python_interface.SHARED_PTR_DISOWN
class HistogramChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PixelSum: "uint64_t" = property(_peak_ipl_python_interface.HistogramChannel_PixelSum_get, _peak_ipl_python_interface.HistogramChannel_PixelSum_set)
    PixelCount: "uint64_t" = property(_peak_ipl_python_interface.HistogramChannel_PixelCount_get, _peak_ipl_python_interface.HistogramChannel_PixelCount_set)
    Bins: "std::vector< uint64_t,std::allocator< uint64_t > >" = property(_peak_ipl_python_interface.HistogramChannel_Bins_get, _peak_ipl_python_interface.HistogramChannel_Bins_set)

    def __init__(self):
        _peak_ipl_python_interface.HistogramChannel_swiginit(self, _peak_ipl_python_interface.new_HistogramChannel())
    __swig_destroy__ = _peak_ipl_python_interface.delete_HistogramChannel

# Register HistogramChannel in _peak_ipl_python_interface:
_peak_ipl_python_interface.HistogramChannel_swigregister(HistogramChannel)
class ImageWriterPNGParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Quality: "uint32_t" = property(_peak_ipl_python_interface.ImageWriterPNGParameter_Quality_get, _peak_ipl_python_interface.ImageWriterPNGParameter_Quality_set)

    def __init__(self):
        _peak_ipl_python_interface.ImageWriterPNGParameter_swiginit(self, _peak_ipl_python_interface.new_ImageWriterPNGParameter())
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageWriterPNGParameter

# Register ImageWriterPNGParameter in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageWriterPNGParameter_swigregister(ImageWriterPNGParameter)
class ImageWriterJPEGParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Quality: "uint32_t" = property(_peak_ipl_python_interface.ImageWriterJPEGParameter_Quality_get, _peak_ipl_python_interface.ImageWriterJPEGParameter_Quality_set)

    def __init__(self):
        _peak_ipl_python_interface.ImageWriterJPEGParameter_swiginit(self, _peak_ipl_python_interface.new_ImageWriterJPEGParameter())
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageWriterJPEGParameter

# Register ImageWriterJPEGParameter in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageWriterJPEGParameter_swigregister(ImageWriterJPEGParameter)
PEAK_IPL_VIDEO_CONTAINER_AVI = _peak_ipl_python_interface.PEAK_IPL_VIDEO_CONTAINER_AVI
PEAK_IPL_VIDEO_ENCODER_RAW = _peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_RAW
PEAK_IPL_VIDEO_ENCODER_MJPEG = _peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_MJPEG
PEAK_IPL_VIDEO_ENCODER_OPTION_QUALITY = _peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_OPTION_QUALITY
PEAK_IPL_VIDEO_CONTAINER_OPTION_FRAMERATE = _peak_ipl_python_interface.PEAK_IPL_VIDEO_CONTAINER_OPTION_FRAMERATE

def CreateEncoder(encoder: "PEAK_IPL_VIDEO_ENCODER") -> "std::shared_ptr< peak::ipl::encoder::IEncoder >":
    return _peak_ipl_python_interface.CreateEncoder(encoder)

def CreateContainer(container: "PEAK_IPL_VIDEO_CONTAINER") -> "std::shared_ptr< peak::ipl::container::IContainer >":
    return _peak_ipl_python_interface.CreateContainer(container)
class PixelLineChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Values: "std::vector< uint32_t,std::allocator< uint32_t > >" = property(_peak_ipl_python_interface.PixelLineChannel_Values_get, _peak_ipl_python_interface.PixelLineChannel_Values_set)

    def __init__(self):
        _peak_ipl_python_interface.PixelLineChannel_swiginit(self, _peak_ipl_python_interface.new_PixelLineChannel())
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelLineChannel

# Register PixelLineChannel in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelLineChannel_swigregister(PixelLineChannel)

def ConversionModeEnumEntryToString(entry: "int32_t") -> "std::string":
    return _peak_ipl_python_interface.ConversionModeEnumEntryToString(entry)

def EndiannessEnumEntryToString(entry: "int32_t") -> "std::string":
    return _peak_ipl_python_interface.EndiannessEnumEntryToString(entry)

def OrientationEnumEntryToString(entry: "int32_t") -> "std::string":
    return _peak_ipl_python_interface.OrientationEnumEntryToString(entry)

def PixelFormatNameEnumEntryToString(entry: "int32_t") -> "std::string":
    return _peak_ipl_python_interface.PixelFormatNameEnumEntryToString(entry)
class SharpnessROI(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _peak_ipl_python_interface.SharpnessROI_swiginit(self, _peak_ipl_python_interface.new_SharpnessROI(*args))
    rect: "peak::ipl::Rect2D" = property(_peak_ipl_python_interface.SharpnessROI_rect_get, _peak_ipl_python_interface.SharpnessROI_rect_set)
    xSamplingInterval: "uint8_t" = property(_peak_ipl_python_interface.SharpnessROI_xSamplingInterval_get, _peak_ipl_python_interface.SharpnessROI_xSamplingInterval_set)
    ySamplingInterval: "uint8_t" = property(_peak_ipl_python_interface.SharpnessROI_ySamplingInterval_get, _peak_ipl_python_interface.SharpnessROI_ySamplingInterval_set)
    weight: "peak::ipl::Sharpness::SharpnessROIWeight" = property(_peak_ipl_python_interface.SharpnessROI_weight_get, _peak_ipl_python_interface.SharpnessROI_weight_set)
    __swig_destroy__ = _peak_ipl_python_interface.delete_SharpnessROI

# Register SharpnessROI in _peak_ipl_python_interface:
_peak_ipl_python_interface.SharpnessROI_swigregister(SharpnessROI)
class Exception(Exception):
    r"""The base class for all exceptions thrown by the library."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.Exception_swiginit(self, _peak_ipl_python_interface.new_Exception(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_Exception

# Register Exception in _peak_ipl_python_interface:
_peak_ipl_python_interface.Exception_swigregister(Exception)
class OutOfRangeException(Exception):
    r"""The exception thrown for trying to access a value being out of range."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.OutOfRangeException_swiginit(self, _peak_ipl_python_interface.new_OutOfRangeException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_OutOfRangeException

# Register OutOfRangeException in _peak_ipl_python_interface:
_peak_ipl_python_interface.OutOfRangeException_swigregister(OutOfRangeException)
class BufferTooSmallException(Exception):
    r"""The exception thrown when a given buffer is too small for the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_BufferTooSmallException

# Register BufferTooSmallException in _peak_ipl_python_interface:
_peak_ipl_python_interface.BufferTooSmallException_swigregister(BufferTooSmallException)
class InvalidArgumentException(Exception):
    r"""The exception thrown when passing an invalid parameter to a function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.InvalidArgumentException_swiginit(self, _peak_ipl_python_interface.new_InvalidArgumentException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_InvalidArgumentException

# Register InvalidArgumentException in _peak_ipl_python_interface:
_peak_ipl_python_interface.InvalidArgumentException_swigregister(InvalidArgumentException)
class ImageFormatNotSupportedException(Exception):
    r"""The exception thrown when an image format isn't supported by a function"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.ImageFormatNotSupportedException_swiginit(self, _peak_ipl_python_interface.new_ImageFormatNotSupportedException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageFormatNotSupportedException

# Register ImageFormatNotSupportedException in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageFormatNotSupportedException_swigregister(ImageFormatNotSupportedException)
class ImageFormatInterpretationException(Exception):
    r"""The exception thrown when a given image format can't be used on this data, e.g. during reading from file"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.ImageFormatInterpretationException_swiginit(self, _peak_ipl_python_interface.new_ImageFormatInterpretationException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageFormatInterpretationException

# Register ImageFormatInterpretationException in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageFormatInterpretationException_swigregister(ImageFormatInterpretationException)
class IOException(Exception):
    r"""The exception thrown when a given image format can't be used on this data, e.g. during reading from file"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.IOException_swiginit(self, _peak_ipl_python_interface.new_IOException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_IOException

# Register IOException in _peak_ipl_python_interface:
_peak_ipl_python_interface.IOException_swigregister(IOException)
class BusyException(Exception):
    r"""The exception thrown when the resource busy"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.BusyException_swiginit(self, _peak_ipl_python_interface.new_BusyException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_BusyException

# Register BusyException in _peak_ipl_python_interface:
_peak_ipl_python_interface.BusyException_swigregister(BusyException)
class NotPermittedException(Exception):
    r"""The exception thrown when the operation not permitted."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.NotPermittedException_swiginit(self, _peak_ipl_python_interface.new_NotPermittedException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_NotPermittedException

# Register NotPermittedException in _peak_ipl_python_interface:
_peak_ipl_python_interface.NotPermittedException_swigregister(NotPermittedException)
class TimeoutException(Exception):
    r"""The exception thrown when the operation times out."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, error_description: "std::string const &"):
        _peak_ipl_python_interface.TimeoutException_swiginit(self, _peak_ipl_python_interface.new_TimeoutException(error_description))
    __swig_destroy__ = _peak_ipl_python_interface.delete_TimeoutException

# Register TimeoutException in _peak_ipl_python_interface:
_peak_ipl_python_interface.TimeoutException_swigregister(TimeoutException)
class InvalidHandleException(Exception):
    r"""The exception thrown when passing an invalid handle to a function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_InvalidHandleException

# Register InvalidHandleException in _peak_ipl_python_interface:
_peak_ipl_python_interface.InvalidHandleException_swigregister(InvalidHandleException)
ConversionMode_Fast = _peak_ipl_python_interface.ConversionMode_Fast
r""" Fast conversion mode"""
ConversionMode_HighQuality = _peak_ipl_python_interface.ConversionMode_HighQuality
r""" High-Quality conversion mode"""
ConversionMode_Classic = _peak_ipl_python_interface.ConversionMode_Classic
r""" Classic conversion mode"""
PixelFormatName_Invalid = _peak_ipl_python_interface.PixelFormatName_Invalid
r""" Invalid Pixel Format"""
PixelFormatName_BayerGR8 = _peak_ipl_python_interface.PixelFormatName_BayerGR8
r""" BayerGR 8-Bit pixel format"""
PixelFormatName_BayerGR10 = _peak_ipl_python_interface.PixelFormatName_BayerGR10
r""" BayerGR 10-Bit pixel format"""
PixelFormatName_BayerGR12 = _peak_ipl_python_interface.PixelFormatName_BayerGR12
r""" BayerGR 12-Bit pixel format"""
PixelFormatName_BayerRG8 = _peak_ipl_python_interface.PixelFormatName_BayerRG8
r""" BayerRG 8-Bit pixel format"""
PixelFormatName_BayerRG10 = _peak_ipl_python_interface.PixelFormatName_BayerRG10
r""" BayerRG 10-Bit pixel format"""
PixelFormatName_BayerRG12 = _peak_ipl_python_interface.PixelFormatName_BayerRG12
r""" BayerRG 12-Bit pixel format"""
PixelFormatName_BayerGB8 = _peak_ipl_python_interface.PixelFormatName_BayerGB8
r""" BayerGB 8-Bit pixel format"""
PixelFormatName_BayerGB10 = _peak_ipl_python_interface.PixelFormatName_BayerGB10
r""" BayerGB 10-Bit pixel format"""
PixelFormatName_BayerGB12 = _peak_ipl_python_interface.PixelFormatName_BayerGB12
r""" BayerGB 12-Bit pixel format"""
PixelFormatName_BayerBG8 = _peak_ipl_python_interface.PixelFormatName_BayerBG8
r""" BayerBG 8-Bit pixel format"""
PixelFormatName_BayerBG10 = _peak_ipl_python_interface.PixelFormatName_BayerBG10
r""" BayerBG 10-Bit pixel format"""
PixelFormatName_BayerBG12 = _peak_ipl_python_interface.PixelFormatName_BayerBG12
r""" BayerBG 12-Bit pixel format"""
PixelFormatName_Mono8 = _peak_ipl_python_interface.PixelFormatName_Mono8
r""" Mono 8-Bit pixel format"""
PixelFormatName_Mono10 = _peak_ipl_python_interface.PixelFormatName_Mono10
r""" Mono 10-Bit pixel format"""
PixelFormatName_Mono12 = _peak_ipl_python_interface.PixelFormatName_Mono12
r""" Mono 12-Bit pixel format"""
PixelFormatName_YUV420_8_YY_UV_SemiplanarIDS = _peak_ipl_python_interface.PixelFormatName_YUV420_8_YY_UV_SemiplanarIDS
r""" YUV 4:2:0 8-bit YY/UV Semiplanar"""
PixelFormatName_YUV420_8_YY_VU_SemiplanarIDS = _peak_ipl_python_interface.PixelFormatName_YUV420_8_YY_VU_SemiplanarIDS
r""" YUV 4:2:0 8-bit YY/VU Semiplanar"""
PixelFormatName_RGB8 = _peak_ipl_python_interface.PixelFormatName_RGB8
r""" RGB 8-Bit pixel format"""
PixelFormatName_RGB10 = _peak_ipl_python_interface.PixelFormatName_RGB10
r""" RGB 10-Bit pixel format"""
PixelFormatName_RGB12 = _peak_ipl_python_interface.PixelFormatName_RGB12
r""" RGB 12-Bit pixel format"""
PixelFormatName_BGR8 = _peak_ipl_python_interface.PixelFormatName_BGR8
r""" BGR 8-Bit pixel format"""
PixelFormatName_BGR10 = _peak_ipl_python_interface.PixelFormatName_BGR10
r""" BGR 10-Bit pixel format"""
PixelFormatName_BGR12 = _peak_ipl_python_interface.PixelFormatName_BGR12
r""" BGR 12-Bit pixel format"""
PixelFormatName_RGBa8 = _peak_ipl_python_interface.PixelFormatName_RGBa8
r""" RGBa 8-Bit pixel format"""
PixelFormatName_RGBa10 = _peak_ipl_python_interface.PixelFormatName_RGBa10
r""" RGBa 10-Bit pixel format"""
PixelFormatName_RGBa12 = _peak_ipl_python_interface.PixelFormatName_RGBa12
r""" RGBa 12-Bit pixel format"""
PixelFormatName_BGRa8 = _peak_ipl_python_interface.PixelFormatName_BGRa8
r""" BGRa 8-Bit pixel format"""
PixelFormatName_BGRa10 = _peak_ipl_python_interface.PixelFormatName_BGRa10
r""" BGRa 10-Bit pixel format"""
PixelFormatName_BGRa12 = _peak_ipl_python_interface.PixelFormatName_BGRa12
r""" BGRa 12-Bit pixel format"""
PixelFormatName_BayerBG10p = _peak_ipl_python_interface.PixelFormatName_BayerBG10p
r""" BayerBG 10-Bit packed pixel format"""
PixelFormatName_BayerBG12p = _peak_ipl_python_interface.PixelFormatName_BayerBG12p
r""" BayerBG 12-Bit packed pixel format"""
PixelFormatName_BayerGB10p = _peak_ipl_python_interface.PixelFormatName_BayerGB10p
r""" BayerGB 10-Bit packed pixel format"""
PixelFormatName_BayerGB12p = _peak_ipl_python_interface.PixelFormatName_BayerGB12p
r""" BayerGB 12-Bit packed pixel format"""
PixelFormatName_BayerGR10p = _peak_ipl_python_interface.PixelFormatName_BayerGR10p
r""" BayerGR 10-Bit packed pixel format"""
PixelFormatName_BayerGR12p = _peak_ipl_python_interface.PixelFormatName_BayerGR12p
r""" BayerGR 12-Bit packed pixel format"""
PixelFormatName_BayerRG10p = _peak_ipl_python_interface.PixelFormatName_BayerRG10p
r""" BayerRG 10-Bit packed pixel format"""
PixelFormatName_BayerRG12p = _peak_ipl_python_interface.PixelFormatName_BayerRG12p
r""" BayerRG 12-Bit packed pixel format"""
PixelFormatName_Mono10p = _peak_ipl_python_interface.PixelFormatName_Mono10p
r""" Mono 10-Bit packed pixel format"""
PixelFormatName_Mono12p = _peak_ipl_python_interface.PixelFormatName_Mono12p
r""" Mono 10-Bit packed pixel format"""
PixelFormatName_RGB10p32 = _peak_ipl_python_interface.PixelFormatName_RGB10p32
r""" BayerBG 10-Bit packed pixel format"""
PixelFormatName_BGR10p32 = _peak_ipl_python_interface.PixelFormatName_BGR10p32
r""" BayerBG 10-Bit packed pixel format"""
PixelFormatName_BayerRG10g40IDS = _peak_ipl_python_interface.PixelFormatName_BayerRG10g40IDS
r"""
    BayerRG 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGB10g40IDS = _peak_ipl_python_interface.PixelFormatName_BayerGB10g40IDS
r"""
    BayerGB 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGR10g40IDS = _peak_ipl_python_interface.PixelFormatName_BayerGR10g40IDS
r"""
    BayerGR 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerBG10g40IDS = _peak_ipl_python_interface.PixelFormatName_BayerBG10g40IDS
r"""
    BayerBG 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerRG12g24IDS = _peak_ipl_python_interface.PixelFormatName_BayerRG12g24IDS
r"""
    BayerRG 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGB12g24IDS = _peak_ipl_python_interface.PixelFormatName_BayerGB12g24IDS
r"""
    BayerGB 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGR12g24IDS = _peak_ipl_python_interface.PixelFormatName_BayerGR12g24IDS
r"""
    BayerGR 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerBG12g24IDS = _peak_ipl_python_interface.PixelFormatName_BayerBG12g24IDS
r"""
    BayerBG 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_Mono10g40IDS = _peak_ipl_python_interface.PixelFormatName_Mono10g40IDS
r"""
    Mono 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_Mono12g24IDS = _peak_ipl_python_interface.PixelFormatName_Mono12g24IDS
r"""
    Mono 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
BayerPattern_Unknown = _peak_ipl_python_interface.BayerPattern_Unknown
r""" Unknown pattern"""
BayerPattern__None = _peak_ipl_python_interface.BayerPattern__None
r""" No pattern"""
BayerPattern_Bayer_GR = _peak_ipl_python_interface.BayerPattern_Bayer_GR
r""" BayerGR pattern"""
BayerPattern_Bayer_RG = _peak_ipl_python_interface.BayerPattern_Bayer_RG
r""" BayerRG pattern"""
BayerPattern_Bayer_GB = _peak_ipl_python_interface.BayerPattern_Bayer_GB
r""" BayerGB pattern"""
BayerPattern_Bayer_BG = _peak_ipl_python_interface.BayerPattern_Bayer_BG
r""" BayerBG pattern"""
Endianness_Unknown = _peak_ipl_python_interface.Endianness_Unknown
r""" Unknown endianness"""
Endianness_LittleEndian = _peak_ipl_python_interface.Endianness_LittleEndian
r""" Little endian (lower bytes first)"""
Endianness_BigEndian = _peak_ipl_python_interface.Endianness_BigEndian
r""" Big endian (higher bytes first)"""
Orientation_Horizontal = _peak_ipl_python_interface.Orientation_Horizontal
r""" Horizontal orientation"""
Orientation_Vertical = _peak_ipl_python_interface.Orientation_Vertical
r""" Vertical orientation"""
InterpolationAlgorithm_nearest = _peak_ipl_python_interface.InterpolationAlgorithm_nearest
r""" nearest neighbor interpolation"""
InterpolationAlgorithm_linear = _peak_ipl_python_interface.InterpolationAlgorithm_linear
r""" bilinear interpolation"""
InterpolationAlgorithm_cubic = _peak_ipl_python_interface.InterpolationAlgorithm_cubic
r""" bicubic interpolation"""
InterpolationAlgorithm_area = _peak_ipl_python_interface.InterpolationAlgorithm_area
r""" resampling using pixel area relation"""
InterpolationAlgorithm_lanczos4 = _peak_ipl_python_interface.InterpolationAlgorithm_lanczos4
r""" Lanczos interpolation over 8x8 neighborhood"""
InterpolationAlgorithm_linear_exact = _peak_ipl_python_interface.InterpolationAlgorithm_linear_exact
r""" Bit-exact bilinear interpolation"""
InterpolationAlgorithm_nearest_exact = _peak_ipl_python_interface.InterpolationAlgorithm_nearest_exact
r""" Bit-exact bicubic interpolation"""
class Size2D(object):
    r"""2D size of an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width: "size_t" = property(_peak_ipl_python_interface.Size2D_width_get, _peak_ipl_python_interface.Size2D_width_set, doc=r""" Width of size""")
    height: "size_t" = property(_peak_ipl_python_interface.Size2D_height_get, _peak_ipl_python_interface.Size2D_height_set, doc=r""" Height of size""")

    @staticmethod
    def New(width: "size_t", height: "size_t") -> "peak::ipl::Size2D":
        return _peak_ipl_python_interface.Size2D_New(width, height)

    def __init__(self):
        _peak_ipl_python_interface.Size2D_swiginit(self, _peak_ipl_python_interface.new_Size2D())
    __swig_destroy__ = _peak_ipl_python_interface.delete_Size2D

# Register Size2D in _peak_ipl_python_interface:
_peak_ipl_python_interface.Size2D_swigregister(Size2D)
class Point2D(object):
    r"""2D position in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "size_t" = property(_peak_ipl_python_interface.Point2D_x_get, _peak_ipl_python_interface.Point2D_x_set, doc=r""" X position""")
    y: "size_t" = property(_peak_ipl_python_interface.Point2D_y_get, _peak_ipl_python_interface.Point2D_y_set, doc=r""" Y position""")

    @staticmethod
    def New(x: "size_t", y: "size_t") -> "peak::ipl::Point2D":
        return _peak_ipl_python_interface.Point2D_New(x, y)

    def __init__(self):
        _peak_ipl_python_interface.Point2D_swiginit(self, _peak_ipl_python_interface.new_Point2D())
    __swig_destroy__ = _peak_ipl_python_interface.delete_Point2D

# Register Point2D in _peak_ipl_python_interface:
_peak_ipl_python_interface.Point2D_swigregister(Point2D)
class ScaleFactor(object):
    r"""Scale Factors of an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "double" = property(_peak_ipl_python_interface.ScaleFactor_x_get, _peak_ipl_python_interface.ScaleFactor_x_set, doc=r""" X factor""")
    y: "double" = property(_peak_ipl_python_interface.ScaleFactor_y_get, _peak_ipl_python_interface.ScaleFactor_y_set, doc=r""" Y factor""")

    @staticmethod
    def New(x: "double", y: "double") -> "peak::ipl::ScaleFactor":
        return _peak_ipl_python_interface.ScaleFactor_New(x, y)

    def __init__(self):
        _peak_ipl_python_interface.ScaleFactor_swiginit(self, _peak_ipl_python_interface.new_ScaleFactor())
    __swig_destroy__ = _peak_ipl_python_interface.delete_ScaleFactor

# Register ScaleFactor in _peak_ipl_python_interface:
_peak_ipl_python_interface.ScaleFactor_swigregister(ScaleFactor)
class Image(object):
    r"""Stores the pixel format, width and height of an image and the pointer to the image buffer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_Image

    def Width(self) -> "size_t":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_Width(self)

    def Height(self) -> "size_t":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_Height(self)

    def Size(self) -> "peak::ipl::Size2D":
        r"""
        Returns the Size.

        :rtype: :py:class:`Size2D`
        :return: Size

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.Image_Size(self)

    def ByteCount(self) -> "size_t":
        r"""
        Returns the size of the given image in number of bytes.

        :rtype: int
        :return: ByteCount

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_ByteCount(self)

    def PixelFormat(self) -> "peak::ipl::PixelFormat":
        r"""
        Returns the pixel format.

        :rtype: :py:class:`PixelFormat`
        :return: Pixel format

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_PixelFormat(self)

    def ConvertTo(self, *args) -> "peak::ipl::Image":
        r"""
        *Overload 1:*

        Returns a new created image containing the data of the current image converted to the given pixel format.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The output pixel format.
        :type conversionMode: int, in, optional
        :param conversionMode:    The conversion mode.

        :rtype: :py:class:`Image`
        :return: Converted image

        Notes: This function allocates memory on every use. For faster processing, consider using ImageConverter::Convert instead.

        :raises: Exception An internal error has occurred.

        Since: 1.0

        |

        *Overload 2:*

        Saves the data of the current image converted to the given pixel format into a destination buffer
               and creates an image from that buffer.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The output pixel format.
        :type outputImageBuffer: uint8_t, out
        :param outputImageBuffer:     Pointer to destination buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of destination buffer.
        :type conversionMode: int, in, optional
        :param conversionMode:        The conversion mode.

        :rtype: :py:class:`Image`
        :return: Converted image

        Notes: This function allocates memory on every use. For faster processing, consider using ImageConverter::Convert instead.

        :raises: BufferTooSmallException  The provided buffer is too small for the output image.
        :raises: Exception                An internal error has occurred.

        Since: 1.1

        |

        *Overload 3:*

        Saves the data of the current image converted to the given pixel format into a destination buffer
               and creates an image from that buffer.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The output pixel format.
        :type outputImageBuffer: uint8_t, out
        :param outputImageBuffer:     Pointer to destination buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of destination buffer.
        :param conversionMode:        The conversion mode.

        :rtype: :py:class:`Image`
        :return: Converted image

        Notes: This function allocates memory on every use. For faster processing, consider using ImageConverter::Convert instead.

        :raises: BufferTooSmallException  The provided buffer is too small for the output image.
        :raises: Exception                An internal error has occurred.

        Since: 1.1
        """
        return _peak_ipl_python_interface.Image_ConvertTo(self, *args)

    def Scale(self, *args) -> "peak::ipl::Image":
        r"""
        *Overload 1:*

        Scale the image to the supplied width and height using the supplied ``algorithm``

        :type size: :py:class:`Size2D`, in
        :param size:          output size of the image
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 2:*

        Scale the image to the supplied scale factors ``factor`` using the supplied ``algorithm``

        :type factor: :py:class:`ScaleFactor`, in
        :param factor:        output image scale factors
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        Notes: the image size is { input_image.width * factor.X, input_image.height * factor.Y }

        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 3:*

        Scale the image to the supplied scale factors ``factor`` using the supplied ``algorithm``

        :type factor: :py:class:`ScaleFactor`, in
        :param factor:        output image scale factors
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        Notes: the image size is { input_image.width * factor.X, input_image.height * factor.Y }

        :raises: Exception        An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.Image_Scale(self, *args)

    def ScaleInto(self, *args) -> "void":
        r"""
        Scale the image to the supplied width and height using the supplied ``algorithm`` and save it into the supplied buffer

        :type size: :py:class:`Size2D`, in
        :param size:          output size of the image
        :type buffer: uint8_t, in
        :param buffer:        the used interpolation algorithm
        :type bufferSize: std::size_t, in
        :param bufferSize:    the used interpolation algorithm
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :raises: Exception        An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.Image_ScaleInto(self, *args)

    def Crop(self, *args) -> "peak::ipl::Image":
        r"""
        *Overload 1:*

        Crop the image to the ``size`` starting at ``pos``.

        :type pos: :py:class:`Point2D`, in
        :param pos:        the startting position
        :type size: :py:class:`Size2D`, in
        :param size:       the used size

        :rtype: :py:class:`Image`
        :return: The cropped image
                *
        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 2:*

        Crop the image to the supplied size. Position is set to (0, 0)

        :type size: :py:class:`Size2D`, in
        :param size:     The output size.

        :rtype: :py:class:`Image`
        :return: The cropped image
                *
        :raises: Exception    An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.Image_Crop(self, *args)

    def Clone(self) -> "peak::ipl::Image":
        r"""
        Returns a new created image containing the data of the current image as `deep copy`.

        :rtype: :py:class:`Image`
        :return: The copied image

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_Clone(self)

    def Empty(self) -> "bool":
        r"""
        Checks whether the image is empty.

        An image can be empty if its data have been moved.

        :rtype: boolean
        :return: True if the image is empty

        Since: 1.0
        """
        return _peak_ipl_python_interface.Image_Empty(self)

    def Timestamp(self) -> "uint64_t":
        r"""
         The timestamp in nanoseconds

        The point in camera time at which the image was exposed.

        :rtype: int
        :return: Timestamp in nanoseconds

        Since: 1.6
        """
        return _peak_ipl_python_interface.Image_Timestamp(self)

    def __eq__(self, img: "Image") -> "bool":
        r"""
        Checks whether the image is data-wise the same.
        :rtype: boolean
        :return: True if image is data-wise the same, false if not.
        """
        return _peak_ipl_python_interface.Image___eq__(self, img)

    def __ne__(self, img: "Image") -> "bool":
        r"""
        Checks whether the image is data-wise different.
        :rtype: boolean
        :return: True if image is data-wise different, false if not.
        """
        return _peak_ipl_python_interface.Image___ne__(self, img)

    def __deepcopy__(self, memo):
        return self.Clone()

    def get_numpy(self):
        info = self.PixelFormat()
        pixel_size = info.CalculateStorageSizeOfPixels(1)
        channel_count = info.NumChannels()
        channel_size = pixel_size / channel_count

        if info.IsPacked():
            return self.get_numpy_1D()
        else:
            if channel_count == 1:
                if channel_size == 1:
                    return self.get_numpy_2D()
                elif channel_size == 2:
                    return self.get_numpy_2D_16()
                else:
                    return self.get_numpy_1D()
            else:
                if channel_size == 1:
                    return self.get_numpy_3D()
                elif channel_size == 2:
                    return self.get_numpy_3D_16()
                else:
                    return self.get_numpy_1D()



    @staticmethod
    def CreateFromSize(pixelFormatName: "peak::ipl::PixelFormatName", width: "size_t", height: "size_t") -> "peak::ipl::Image":
        return _peak_ipl_python_interface.Image_CreateFromSize(pixelFormatName, width, height)

    @staticmethod
    def CreateFromSizeAndBuffer(pixelFormatName: "peak::ipl::PixelFormatName", buffer: "void *", bufferSize_bytes: "size_t", width: "size_t", height: "size_t") -> "peak::ipl::Image":
        return _peak_ipl_python_interface.Image_CreateFromSizeAndBuffer(pixelFormatName, buffer, bufferSize_bytes, width, height)

    @staticmethod
    def CreateFromSizeAndPythonBuffer(pixelFormatName: "peak::ipl::PixelFormatName", buffer: "uint8_t *", width: "size_t", height: "size_t") -> "peak::ipl::Image":
        return _peak_ipl_python_interface.Image_CreateFromSizeAndPythonBuffer(pixelFormatName, buffer, width, height)

    def get_numpy_1D(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_1D(self)

    def get_numpy_2D(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_2D(self)

    def get_numpy_3D(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_3D(self)

    def get_numpy_1D_16(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_1D_16(self)

    def get_numpy_2D_16(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_2D_16(self)

    def get_numpy_3D_16(self) -> "void":
        return _peak_ipl_python_interface.Image_get_numpy_3D_16(self)

    def DataView(self) -> "std::pair< std::uint8_t *,std::size_t >":
        return _peak_ipl_python_interface.Image_DataView(self)

# Register Image in _peak_ipl_python_interface:
_peak_ipl_python_interface.Image_swigregister(Image)
class Rect2D(object):
    r"""Rectangle type"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _peak_ipl_python_interface.Rect2D_swiginit(self, _peak_ipl_python_interface.new_Rect2D(*args))

    def topLeft(self) -> "peak::ipl::Point2D":
        r""" Returns the position of the top-left corner of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_topLeft(self)

    def size(self) -> "peak::ipl::Size2D":
        r""" Returns the size of the rectancle"""
        return _peak_ipl_python_interface.Rect2D_size(self)

    def left(self) -> "size_t":
        r""" Returns the left position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_left(self)

    def right(self) -> "size_t":
        r""" Returns the right position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_right(self)

    def top(self) -> "size_t":
        r""" Returns the top position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_top(self)

    def bottom(self) -> "size_t":
        r""" Returns the bottom position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_bottom(self)

    def setSize(self, size: "Size2D") -> "void":
        r""" Sets a new size for the rectangle"""
        return _peak_ipl_python_interface.Rect2D_setSize(self, size)

    def setWidth(self, width: "size_t") -> "void":
        r""" Sets the rectangle width"""
        return _peak_ipl_python_interface.Rect2D_setWidth(self, width)

    def setHeight(self, height: "size_t") -> "void":
        r""" Sets the rectangle height"""
        return _peak_ipl_python_interface.Rect2D_setHeight(self, height)

    def setX(self, x: "size_t") -> "void":
        r""" Sets the left position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_setX(self, x)

    def setY(self, y: "size_t") -> "void":
        r""" Sets the top position of the rectangle"""
        return _peak_ipl_python_interface.Rect2D_setY(self, y)
    __swig_destroy__ = _peak_ipl_python_interface.delete_Rect2D

# Register Rect2D in _peak_ipl_python_interface:
_peak_ipl_python_interface.Rect2D_swigregister(Rect2D)
class ColorCorrectionFactors(object):
    r"""The Factors of the Color Correction Matrix."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_ColorCorrectionFactors

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ColorCorrectionFactors instance

        Creates a new ColorCorrectionFactors instance.

        The matrix is row-wise sorted:

        |    |    |    |
        | -- | -- | -- |
        | RR | GR | BR |
        | RG | GG | BG |
        | RB | GB | BB |

        :type facRR: float, in
        :param facRR: Red-Red Factor.
        :type facGR: float, in
        :param facGR: Green-Red Factor.
        :type facBR: float, in
        :param facBR: Blue-Red Factor.
        :type facRG: float, in
        :param facRG: Red-Green Factor.
        :type facGG: float, in
        :param facGG: Green-Green Factor.
        :type facBG: float, in
        :param facBG: Blue-Green Factor.
        :type facRB: float, in
        :param facRB: Red-Blue Factor.
        :type facGB: float, in
        :param facGB: Green-Blue Factor.
        :type facBB: float, in
        :param facBB: Blue-Blue Factor.

        Since: 1.0

        |

        *Overload 2:*
         Constructor for a new ColorCorrectionFactors instance

        Creates a new ColorCorrectionFactors instance. The Factors are initialized to zero.

        Since: 1.0

        |

        *Overload 3:*
         Move constructor for ColorCorrectionFactors instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type o: :py:class:`ColorCorrectionFactors`, in
        :param o: The other instance to move the factors from.

        Since: 1.0
        """
        _peak_ipl_python_interface.ColorCorrectionFactors_swiginit(self, _peak_ipl_python_interface.new_ColorCorrectionFactors(*args))

    def __eq__(self, other: "ColorCorrectionFactors") -> "bool":
        r"""
         Compare ColorCorrectionFactors

        Compares the factors from ``other`` to this instance

        :type other: :py:class:`ColorCorrectionFactors`, in
        :param other: The other instance to compare.

        :rtype: boolean
        :return: True if equal, false otherwise.

        Since: 1.0
        """
        return _peak_ipl_python_interface.ColorCorrectionFactors___eq__(self, other)
    factorRR: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorRR_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorRR_set)
    factorGR: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorGR_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorGR_set)
    factorBR: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorBR_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorBR_set)
    factorRG: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorRG_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorRG_set)
    factorGG: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorGG_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorGG_set)
    factorBG: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorBG_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorBG_set)
    factorRB: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorRB_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorRB_set)
    factorGB: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorGB_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorGB_set)
    factorBB: "float" = property(_peak_ipl_python_interface.ColorCorrectionFactors_factorBB_get, _peak_ipl_python_interface.ColorCorrectionFactors_factorBB_set)

# Register ColorCorrectionFactors in _peak_ipl_python_interface:
_peak_ipl_python_interface.ColorCorrectionFactors_swigregister(ColorCorrectionFactors)
class ColorCorrector(object):
    r"""Applies a 3x3 color correction matrix to the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_ColorCorrector

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ColorCorrector instance

        Creates a new ColorCorrector instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ColorCorrector instance

        Creates a new ColorCorrector instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ColorCorrector`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted.
        1.8 Implemented as shallow copy.

        |

        *Overload 3:*
         Move constructor for ColorCorrector instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`ColorCorrector`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _peak_ipl_python_interface.ColorCorrector_swiginit(self, _peak_ipl_python_interface.new_ColorCorrector(*args))

    def SetColorCorrectionFactors(self, colorCorrectorFactors: "ColorCorrectionFactors") -> "void":
        r"""
        Sets the values of the color correction matrix.

        The matrix is row-wise sorted:
        |    |    |    |
        | -- | -- | -- |
        | RR | GR | BR |
        | RG | GG | BG |
        | RB | GB | BB |

        :type colorCorrectorFactors: :py:class:`ColorCorrectionFactors`, in
        :param colorCorrectorFactors: The factors of the color correction matrix.

        Since: 1.0
        """
        return _peak_ipl_python_interface.ColorCorrector_SetColorCorrectionFactors(self, colorCorrectorFactors)

    def ColorCorrectionFactors(self, *args) -> "peak::ipl::ColorCorrectionFactors":
        r"""
        *Overload 1:*

        Returns the factors of the color correction matrix.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: colorCorrectorFactors The factors of the color correction matrix

        Since: 1.0

        |

        *Overload 2:*

        Returns the factors of the color correction matrix.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: colorCorrectorFactors The factors of the color correction matrix

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.ColorCorrector_ColorCorrectionFactors(self, *args)

    def Saturation(self) -> "float":
        r"""
        Returns the color saturation value.

        :rtype: float
        :return: The color saturation value

        Since: 1.6
        """
        return _peak_ipl_python_interface.ColorCorrector_Saturation(self)

    def SaturationMin(self) -> "float":
        r"""
        Returns the minimum color saturation value.

        :rtype: float
        :return: The minimum color saturation value

        Since: 1.6
        """
        return _peak_ipl_python_interface.ColorCorrector_SaturationMin(self)

    def SaturationMax(self) -> "float":
        r"""
        Returns the maximum color saturation value.

        :rtype: float
        :return: The maximum color saturation value

        Since: 1.6
        """
        return _peak_ipl_python_interface.ColorCorrector_SaturationMax(self)

    def SetSaturation(self, saturation: "float") -> "void":
        r"""
        Sets the color saturation value.

        :type saturation: float, in
        :param saturation: The color saturation value.

        Since: 1.6
        """
        return _peak_ipl_python_interface.ColorCorrector_SetSaturation(self, saturation)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Returns whether the color corrector supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.0
        """
        return _peak_ipl_python_interface.ColorCorrector_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "void":
        r"""
        Corrects the colors of the given image by applying a 3x3 color correction matrix to the data
               in place that is it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format (for example packed pixel format)

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _peak_ipl_python_interface.ColorCorrector_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
         Corrects the colors of the given image by applying a 3x3 color correction matrix to the data.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the color corrected pixels

        :raises: ImageFormatNotSupportedException image has unsupported pixel format (for example packed pixel format)

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _peak_ipl_python_interface.ColorCorrector_Process(self, inputImage)

# Register ColorCorrector in _peak_ipl_python_interface:
_peak_ipl_python_interface.ColorCorrector_swigregister(ColorCorrector)
class GammaCorrector(object):
    r"""Applies gamma correction to the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_GammaCorrector

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new GammaCorrector instance

        Creates a new GammaCorrector instance.

        Since: 1.2.2

        |

        *Overload 2:*
         Copy Constructor for a new GammaCorrector instance

        Creates a new GammaCorrector instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`GammaCorrector`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.2.2 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for GammaCorrector instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`GammaCorrector`, in
        :param other: The other instance to move.

        Since: 1.2.2
        """
        _peak_ipl_python_interface.GammaCorrector_swiginit(self, _peak_ipl_python_interface.new_GammaCorrector(*args))

    def SetGammaCorrectionValue(self, gammaValue: "float") -> "void":
        r"""
        Sets the values of the gamma correction.

        :type gammaValue: float, in
        :param gammaValue: The value of the gamma correction.

        :raises: InvalidArgument gammaValue isn't supported.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_SetGammaCorrectionValue(self, gammaValue)

    def GammaCorrectionValue(self) -> "float":
        r"""
        Returns the value of the gamma correction.

        :rtype: float
        :return: gammaValue The value of the gamma correction.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_GammaCorrectionValue(self)

    def GammaCorrectionMin(self) -> "float":
        r"""
        Returns the minimum value of the gamma correction.

        :rtype: float
        :return: gammaMin The minimum value of the gamma correction.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_GammaCorrectionMin(self)

    def GammaCorrectionMax(self) -> "float":
        r"""
        Returns the maximum value of the gamma correction.

        :rtype: float
        :return: gammaMax The maximum value of the gamma correction.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_GammaCorrectionMax(self)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Returns whether the gamma corrector supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "void":
        r"""
        Corrects the gammas of the given image in place that is, it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
         Corrects the gammas of the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.2.2
        """
        return _peak_ipl_python_interface.GammaCorrector_Process(self, inputImage)

# Register GammaCorrector in _peak_ipl_python_interface:
_peak_ipl_python_interface.GammaCorrector_swigregister(GammaCorrector)
class Histogram(object):
    r"""Stores the histogram values."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_Histogram

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: ImageFormatNotSupportedException image has a packed pixel format

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format

        |

        *Overload 2:*
         Copy Constructor for a new Histogram instance

        Creates a new Histogram instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Histogram`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Histogram instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Histogram`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _peak_ipl_python_interface.Histogram_swiginit(self, _peak_ipl_python_interface.new_Histogram(*args))

    def PixelFormat(self) -> "peak::ipl::PixelFormat":
        r"""
        Returns the pixel format of the histogram.

        :rtype: :py:class:`PixelFormat`
        :return: PixelFormat

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.Histogram_PixelFormat(self)

    def Channels(self) -> "std::vector< peak::ipl::HistogramChannel,std::allocator< peak::ipl::HistogramChannel > >":
        return _peak_ipl_python_interface.Histogram_Channels(self)

# Register Histogram in _peak_ipl_python_interface:
_peak_ipl_python_interface.Histogram_swigregister(Histogram)
class HotpixelCorrection(object):
    r"""
    Algorithm for (adaptive) hotpixel detection and correction.

    This algorithm corrects hotpixels either manually by correcting a predefined list of pixels or adaptively by
    automatically updating the list of pixels to correct. In manual mode, pass a list of hotpixels to Correct(). The
    hotpixels can be obtained using Detect(), or from a different source, e.g. retrieved directly from the camera from an
    initial hotpixel calibration. In adaptive mode, just keep passing new images to CorrectAdaptive(). Hotpixels are then
    detected and corrected automatically.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SensitivityLevel_Invalid = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_Invalid
    SensitivityLevel_SensitivityLevel1 = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel1
    SensitivityLevel_SensitivityLevel2 = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel2
    SensitivityLevel_SensitivityLevel3 = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel3
    r""" default"""
    SensitivityLevel_SensitivityLevel4 = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel4
    SensitivityLevel_SensitivityLevel5 = _peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel5
    __swig_destroy__ = _peak_ipl_python_interface.delete_HotpixelCorrection

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new HotpixelCorrection instance

        Creates a new HotpixelCorrection instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new HotpixelCorrection instance

        Creates a new HotpixelCorrection instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`HotpixelCorrection`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for HotpixelCorrection instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`HotpixelCorrection`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _peak_ipl_python_interface.HotpixelCorrection_swiginit(self, _peak_ipl_python_interface.new_HotpixelCorrection(*args))

    def SetSensitivity(self, *args) -> "void":
        r"""
        Sets the sensitivity of the hotpixel detection.

        :type sensitivityLevel: int, in, optional
        :param sensitivityLevel: The sensitivity level to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.HotpixelCorrection_SetSensitivity(self, *args)

    def Sensitivity(self) -> "peak::ipl::HotpixelCorrection::SensitivityLevel":
        r"""
        Returns the current sensitivity.

        :rtype: int
        :return: SensitivityLevel

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.HotpixelCorrection_Sensitivity(self)

    def SetGainFactorPercent(self, gainFactorPercent: "uint32_t"=100) -> "void":
        r"""
        Sets the gain factor in percent.

        :type gainFactorPercent: int, in, optional
        :param gainFactorPercent: The gain factor in percent to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.HotpixelCorrection_SetGainFactorPercent(self, gainFactorPercent)

    def GainFactorPercent(self) -> "uint32_t":
        r"""
        Returns the current gain factor in percent.

        :rtype: int
        :return: the Gain factor in percent

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.HotpixelCorrection_GainFactorPercent(self)

    def Detect(self, inputImage: "Image") -> "std::vector< peak::ipl::Point2D,std::allocator< peak::ipl::Point2D > >":
        r"""
        Detects hotpixels in the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        :rtype: std::vector< peak::ipl::Point2D,std::allocator< peak::ipl::Point2D > >
        :return: List of detected hotpixels

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _peak_ipl_python_interface.HotpixelCorrection_Detect(self, inputImage)

    def Correct(self, inputImage: "Image", hotpixels: "VectorPoint2D") -> "peak::ipl::Image":
        r"""
        Corrects the given hotpixels in the given image.

        Pass a list of hotpixels, either returned by Detect(), or from a different source (e.g. retrieved directly from
        the camera from an initial hotpixel calibration).

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.
        :type hotpixels: std::vector< peak::ipl::Point2D,std::allocator< peak::ipl::Point2D > >, in
        :param hotpixels:  The list of hotpixels to be corrected.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _peak_ipl_python_interface.HotpixelCorrection_Correct(self, inputImage, hotpixels)

    def CorrectInPlace(self, inputImage: "Image", hotpixels: "VectorPoint2D") -> "peak::ipl::Image &":
        r"""
        Corrects the given hotpixels inplace in the given image.

        Pass a list of hotpixels, either returned by Detect(), or from a different source (e.g. retrieved directly from
        the camera from an initial hotpixel calibration). The image won't be copied and the hotpixel will be
        corrected within the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.
        :type hotpixels: std::vector< peak::ipl::Point2D,std::allocator< peak::ipl::Point2D > >, in
        :param hotpixels:  The list of hotpixels to be corrected.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.HotpixelCorrection_CorrectInPlace(self, inputImage, hotpixels)

    def CorrectAdaptive(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
        Corrects the given image adaptively.

        For each new passed to this method, first the list of hotpixels is adapted, then all pixels in the adapted
        hotpixel list are corrected.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _peak_ipl_python_interface.HotpixelCorrection_CorrectAdaptive(self, inputImage)

    def CorrectAdaptiveInPlace(self, inputImage: "Image") -> "peak::ipl::Image &":
        r"""
        Corrects the given image inplace adaptively.

        For each new passed to this method, first the list of hotpixels is adapted, then all pixels in the adapted
        hotpixel list are corrected. The image won't be copied.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.HotpixelCorrection_CorrectAdaptiveInPlace(self, inputImage)

# Register HotpixelCorrection in _peak_ipl_python_interface:
_peak_ipl_python_interface.HotpixelCorrection_swigregister(HotpixelCorrection)
class ImageConverter(object):
    r"""
    Converts images from one PixelFormat to another.

    Notes: In order to speed up processing, instances of this class maintain internal memory pools,
    which allows reuse of memory instead of allocating new memory on each conversion.

    The memory is freed when the instance is destroyed. There is one pool for every needed byte count, therefore, a new
    pool will be allocated if an image with a new size or format needs to be processed.

    One may select to create a new instance of this class when changing image settings in order to free old pools.
    If a new pool or buffer is needed, they will get allocated automatically during the conversion, which
    results in the first conversion taking more time.

    This can be prevented by using the function #ImageConverter::PreAllocateConversion before the conversion.
    Buffers can be reused once a converted image gets freed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageConverter

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ImageConverter instance

        Creates a new ImageConverter instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ImageConverter instance

        Creates a new ImageConverter instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ImageConverter`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for ImageConverter instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`ImageConverter`, in
        :param other: The other instance to move.

        Since: 1.0

        |

        *Overload 4:*

        Convenience constructor to directly pre-allocate an internal buffer pool.
        This calls [PreAllocateConversion]('ImageConverter::PreAllocateConversion)' internally.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :type imageCount: int, in, optional
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4

        |

        *Overload 5:*

        Convenience constructor to directly pre-allocate an internal buffer pool.
        This calls [PreAllocateConversion]('ImageConverter::PreAllocateConversion)' internally.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4
        """
        _peak_ipl_python_interface.ImageConverter_swiginit(self, _peak_ipl_python_interface.new_ImageConverter(*args))

    def PreAllocateConversion(self, inputPixelFormat: "PixelFormat", outputPixelFormat: "PixelFormat", width: "size_t", height: "size_t", imageCount: "size_t"=5) -> "void":
        r"""
        Pre-allocate buffer pools needed for the specified conversion.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :type imageCount: int, in, optional
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4
        """
        return _peak_ipl_python_interface.ImageConverter_PreAllocateConversion(self, inputPixelFormat, outputPixelFormat, width, height, imageCount)

    def ConversionMode(self) -> "peak::ipl::ConversionMode":
        r"""
        Returns the current conversion mode.

        :rtype: int
        :return: The current conversion mode

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.ImageConverter_ConversionMode(self)

    def SetConversionMode(self, conversionMode: "peak::ipl::ConversionMode") -> "void":
        r"""
        Set conversion mode.

        :type conversionMode: int, in
        :param conversionMode: The conversion mode to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _peak_ipl_python_interface.ImageConverter_SetConversionMode(self, conversionMode)

    def Convert(self, *args) -> "peak::ipl::Image":
        r"""
        *Overload 1:*

        Converts the input image converted to the given pixel format.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:        The input image.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The output pixel format.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image converted to the given pixel format

        :raises: Exception An internal error has occurred.

        Since: 1.0

        |

        *Overload 2:*
         Saves the data of the current image converted to the given pixel format into a destination buffer
                and creates an image from that buffer.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:            The input image.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The output pixel format.
        :type outputImageBuffer: uint8_t, out
        :param outputImageBuffer:     Pointer to destination buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of destination buffer.

        :rtype: :py:class:`Image`
        :return: Converted image

        :raises: BufferTooSmallException  The provided buffer is too small for the output image.
        :raises: Exception                An internal error has occurred.

        Since: 1.1
        """
        return _peak_ipl_python_interface.ImageConverter_Convert(self, *args)

    def SupportedOutputPixelFormatNames(self, inputPixelFormat: "PixelFormat") -> "std::vector< int32_t,std::allocator< int32_t > >":
        return _peak_ipl_python_interface.ImageConverter_SupportedOutputPixelFormatNames(self, inputPixelFormat)

# Register ImageConverter in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageConverter_swigregister(ImageConverter)
class ImageTransformer(object):
    r"""
    Performs transformations like mirror and rotate on images.

    Notes: To speed up processing instances of this class, maintain internal memory pools to reuse
    memory instead of allocating new memory for each transformation. The memory is freed when the
    instance is destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RotationAngle_Degree90Counterclockwise = _peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree90Counterclockwise
    RotationAngle_Degree90Clockwise = _peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree90Clockwise
    RotationAngle_Degree180 = _peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree180
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageTransformer

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ImageTransformer instance

        Creates a new ImageTransformer instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ImageTransformer instance

        Creates a new ImageTransformer instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ImageTransformer`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for ImageTransformer instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`ImageTransformer`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _peak_ipl_python_interface.ImageTransformer_swiginit(self, _peak_ipl_python_interface.new_ImageTransformer(*args))

    def MirrorUpDown(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
        Mirrors the input image in up-down direction.

        If the transformed image is a bayer-format image and the number of rows is even,
        the format will change. (e.g. BayerBG8 -> BayerGR8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in up-down direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorUpDown(self, inputImage)

    def MirrorLeftRight(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
        Mirrors the input image in the left-right direction.

        If the transformed image is a bayer-format image and the number of columns is even,
        the format will change. (e.g. BayerBG8 -> BayerGB8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in the left-right direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorLeftRight(self, inputImage)

    def MirrorUpDownLeftRight(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
        Mirrors the input image in up-down and left-right direction.

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in up-down and left-right direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorUpDownLeftRight(self, inputImage)

    def MirrorUpDownInPlace(self, image: "Image") -> "void":
        r"""
        Mirrors the given image in up-down direction in place i.e. it will change the input image itself.

        If the transformed image is a bayer-format image and the number of rows is even,
        the format will change. (e.g. BayerBG8 -> BayerGR8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorUpDownInPlace(self, image)

    def MirrorLeftRightInPlace(self, image: "Image") -> "void":
        r"""
        Mirrors the given image in the left-right direction in place i.e. it will change the input image itself.

        If the transformed image is a bayer-format image and the number of columns is even,
        the format will change. (e.g. BayerBG8 -> BayerGB8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorLeftRightInPlace(self, image)

    def MirrorUpDownLeftRightInPlace(self, image: "Image") -> "void":
        r"""
        Mirrors the given image in up-down and left-right direction in place i.e. it will change the input
                image itself.

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format
        """
        return _peak_ipl_python_interface.ImageTransformer_MirrorUpDownLeftRightInPlace(self, image)

    def Rotate(self, inputImage: "Image", rotationAngle: "peak::ipl::ImageTransformer::RotationAngle") -> "peak::ipl::Image":
        r"""
        Rotate the input image with the given rotationAngle

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :type rotationAngle: int, in
        :param rotationAngle:        The rotation angle.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image rotated with the given rotationAngle

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.2
        """
        return _peak_ipl_python_interface.ImageTransformer_Rotate(self, inputImage, rotationAngle)

    def RotateInPlace(self, image: "Image", rotationAngle: "peak::ipl::ImageTransformer::RotationAngle") -> "void":
        r"""
        Rotate the input image with the given rotationAngle

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the created image.

        :type rotationAngle: int, in
        :param rotationAngle:        The rotation angle.

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.2
        """
        return _peak_ipl_python_interface.ImageTransformer_RotateInPlace(self, image, rotationAngle)

# Register ImageTransformer in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageTransformer_swigregister(ImageTransformer)
class ImageReader(object):
    r"""
    Reads an image from a file.

    Supported Formats are currently:
    JPEG, PNG and BMP
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Read(*args) -> "peak::ipl::Image":
        r"""
        *Overload 1:*

        Returns a new created image which is read from the file with the given file path.

        The format is specified by the file ending.

        :type filePath: string, in
        :param filePath: The path to the file to read as an UTF-8 encoded string.

        :raises: ImageFormatNotSupportedException An image format of this file isn't supported
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8

        |

        *Overload 2:*

        Returns a new created image which is read from the file with the given file path.

        The Pixel format to use is specified manually here. The function tries to interpret the file with the given
        format. If this isn't possible, an exception is thrown. Explicit conversion of image formats must be done
        manually.

        :type filePath: string, in
        :param filePath:    The path to the file to read as an UTF-8 encoded string.
        :type pixelFormat: :py:class:`PixelFormat`, in
        :param pixelFormat: The Pixel format the retrieved image should have afterwards.

        :raises: ImageFormatInterpretationException Can't interpret this file with the given pixel format
        :raises: ImageFormatNotSupportedException   An image format of this file isn't supported
        :raises: IOException                        Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException           Arguments passed are invalid
        :raises: Exception                          An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if pixelFormat is a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _peak_ipl_python_interface.ImageReader_Read(*args)
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageReader

# Register ImageReader in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageReader_swigregister(ImageReader)
class ImageWriter(object):
    r"""
    Writes an image to a file.

    Supported Formats are currently:
    JPEG, PNG and BMP and a simple RAW format
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def WriteAsBMP(filePath: "std::string const &", imageToSave: "Image") -> "void":
        r"""
        Writes the specified image to the filesystem as BMP image.

        Not all image formats can be written to a BMP file.
        Currently supported for:
        Mono8, Mono10, Mono12, RGB8, BGR8, RGBa8, BGRa8
        Written as Mono:
        BayerGR8, BayerRG8, BayerGB8, BayerBG8, BayerGR10, BayerRG10, BayerGB10, BayerBG10, BayerGR12, BayerRG12,
        BayerGB12, BayerBG12
        For all other formats an exception is thrown.

        :type filePath: string, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded string.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if imageToSave has a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _peak_ipl_python_interface.ImageWriter_WriteAsBMP(filePath, imageToSave)

    @staticmethod
    def WriteAsRAW(filePath: "std::string const &", imageToSave: "Image") -> "void":
        r"""
        Writes the specified image to the filesystem as a raw binary image.

        This is supported for all non-packed pixel formats.

        :type filePath: string, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded string.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if imageToSave has a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _peak_ipl_python_interface.ImageWriter_WriteAsRAW(filePath, imageToSave)

    @staticmethod
    def Write(filePath: "std::string const &", imageToSave: "Image") -> "void":
        r"""
         Writes the specified image to the filesystem. The type is specified by the given file ending in file
                name.

        :type filePath: string, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded string.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type is not supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8
        """
        return _peak_ipl_python_interface.ImageWriter_Write(filePath, imageToSave)

    @staticmethod
    def WriteAsPNG(*args) -> "void":
        return _peak_ipl_python_interface.ImageWriter_WriteAsPNG(*args)

    @staticmethod
    def WriteAsJPG(*args) -> "void":
        return _peak_ipl_python_interface.ImageWriter_WriteAsJPG(*args)
    __swig_destroy__ = _peak_ipl_python_interface.delete_ImageWriter

# Register ImageWriter in _peak_ipl_python_interface:
_peak_ipl_python_interface.ImageWriter_swigregister(ImageWriter)
class IEncoder(object):
    r"""Encoder Interface Class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_IEncoder

    def Id(self) -> "PEAK_IPL_VIDEO_ENCODER":
        return _peak_ipl_python_interface.IEncoder_Id(self)

    def SetOption(self, option: "PEAK_IPL_VIDEO_ENCODER_OPTION", value: "void const *", count: "size_t") -> "void":
        r"""
        Sets an option on the encoder.
        :type option: int, in
        :param option: The encoder option to set.
        :type value: void, in
        :param value:  The value for the encoder option.
        :type count: int, in
        :param count:  The size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IEncoder_SetOption(self, option, value, count)

    def GetOption(self, option: "PEAK_IPL_VIDEO_ENCODER_OPTION", value: "void *", count: "size_t", outCount: "size_t *") -> "void":
        r"""
        Gets an option of the encoder.
        :type option: int, in
        :param option:   The encoder option to get.
        :type value: void, out
        :param value:    The value for the encoder option.
        :type count: int, in
        :param count:    The size of the value.
        :type outCount: int, out
        :param outCount: The resulting size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IEncoder_GetOption(self, option, value, count, outCount)

    def OptionRange(self, option: "PEAK_IPL_VIDEO_ENCODER_OPTION", min: "void *", max: "void *", inc: "void *") -> "void":
        r"""
        Receive the range for an option of the encoder.
        :type option: int, in
        :param option: The encoder option to receive the range from.
        :type min: void, out
        :param min:    The minimum value for the encoder option.
        :type max: void, out
        :param max:    The maximum value for the encoder option.
        :type inc: void, out
        :param inc:    The increment value for the encoder option.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IEncoder_OptionRange(self, option, min, max, inc)

# Register IEncoder in _peak_ipl_python_interface:
_peak_ipl_python_interface.IEncoder_swigregister(IEncoder)
class MJPEGEncoder(IEncoder):
    r"""
    JPEG encoder specialization of 'IEncoder'.
    Create the encoder with the according Create function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "MJPEGEncoder"):
        _peak_ipl_python_interface.MJPEGEncoder_swiginit(self, _peak_ipl_python_interface.new_MJPEGEncoder(arg2))

    def Id(self) -> "PEAK_IPL_VIDEO_ENCODER":
        r"""
        Get the current type of the encoder.
        :rtype: int
        :return: Encoder type
        """
        return _peak_ipl_python_interface.MJPEGEncoder_Id(self)

    def SetQuality(self, quality: "uint32_t") -> "void":
        r"""
        Sets the quality for the jpeg encoder.
        :type quality: int, in
        :param quality: Quality to set.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.MJPEGEncoder_SetQuality(self, quality)

    def GetQuality(self) -> "uint32_t":
        r"""
        Gets the quality for the jpeg encoder.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.MJPEGEncoder_GetQuality(self)

    def QualityRange(self) -> "peak::ipl::Range< double >":
        r"""
        Gets the quality range for the jpeg encoder.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.MJPEGEncoder_QualityRange(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_MJPEGEncoder

# Register MJPEGEncoder in _peak_ipl_python_interface:
_peak_ipl_python_interface.MJPEGEncoder_swigregister(MJPEGEncoder)

def GetSupportedEncodersForAContainer(container: "PEAK_IPL_VIDEO_CONTAINER") -> "std::vector< PEAK_IPL_VIDEO_ENCODER,std::allocator< PEAK_IPL_VIDEO_ENCODER > >":
    r"""
    Get the supported encoders
    :rtype: std::vector< PEAK_IPL_VIDEO_ENCODER,std::allocator< PEAK_IPL_VIDEO_ENCODER > >
    :return: List of supported encoders

    :raises: Exception                        An internal error has occurred

    Since: 1.5
    """
    return _peak_ipl_python_interface.GetSupportedEncodersForAContainer(container)

def GetSupportedPixelFormats(encoder: "PEAK_IPL_VIDEO_ENCODER") -> "std::vector< peak::ipl::PixelFormatName,std::allocator< peak::ipl::PixelFormatName > >":
    r"""
    Get the supported pixel formats for an encoder.
    :rtype: std::vector< peak::ipl::PixelFormatName,std::allocator< peak::ipl::PixelFormatName > >
    :return: List of supported pixel formats

    :raises: Exception                        An internal error has occurred

    Since: 1.5
    """
    return _peak_ipl_python_interface.GetSupportedPixelFormats(encoder)
class IContainer(object):
    r"""Container Interface Class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_IContainer

    def Id(self) -> "PEAK_IPL_VIDEO_CONTAINER":
        return _peak_ipl_python_interface.IContainer_Id(self)

    def SetOption(self, option: "PEAK_IPL_VIDEO_CONTAINER_OPTION", value: "void const *", count: "size_t") -> "void":
        r"""
        Sets an option on the container.
        :type option: int, in
        :param option: The container option to set.
        :type value: void, in
        :param value:  The value for the container option.
        :type count: int, in
        :param count:  The size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IContainer_SetOption(self, option, value, count)

    def GetOption(self, option: "PEAK_IPL_VIDEO_CONTAINER_OPTION", value: "void *", count: "size_t", outCount: "size_t *") -> "void":
        r"""
        Gets an option of the container.
        :type option: int, in
        :param option:   The container option to get.
        :type value: void, out
        :param value:    The value for the container option.
        :type count: int, in
        :param count:    The size of the value.
        :type outCount: int, out
        :param outCount: The resulting size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IContainer_GetOption(self, option, value, count, outCount)

    def OptionRange(self, option: "PEAK_IPL_VIDEO_CONTAINER_OPTION", min: "void *", max: "void *", inc: "void *") -> "void":
        r"""
        Receive the range for an option of the container.
        :type option: int, in
        :param option: The container option to receive the range from.
        :type min: void, out
        :param min:    The minimum value for the container option.
        :type max: void, out
        :param max:    The maximum value for the container option.
        :type inc: void, out
        :param inc:    The increment value for the container option.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.IContainer_OptionRange(self, option, min, max, inc)

# Register IContainer in _peak_ipl_python_interface:
_peak_ipl_python_interface.IContainer_swigregister(IContainer)
class AVIContainer(IContainer):
    r"""
    AVI container specialization of 'IContainer'.
    Create the container with the according Create function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "AVIContainer"):
        _peak_ipl_python_interface.AVIContainer_swiginit(self, _peak_ipl_python_interface.new_AVIContainer(arg2))

    def Id(self) -> "PEAK_IPL_VIDEO_CONTAINER":
        r"""
        Get the current type of the container.
        :rtype: int
        :return: Container type
        """
        return _peak_ipl_python_interface.AVIContainer_Id(self)

    def SetFramerate(self, fps: "double") -> "void":
        r"""
        Set the frame rate for the opened video.
        :type fps: float, in
        :param fps: The frame rate to set.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.AVIContainer_SetFramerate(self, fps)

    def GetFramerate(self) -> "double":
        r"""
        Get the frame rate for the opened video.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.AVIContainer_GetFramerate(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_AVIContainer

# Register AVIContainer in _peak_ipl_python_interface:
_peak_ipl_python_interface.AVIContainer_swigregister(AVIContainer)

def GetSupportedContainersForAnEncoder(encoder: "PEAK_IPL_VIDEO_ENCODER") -> "std::vector< PEAK_IPL_VIDEO_CONTAINER,std::allocator< PEAK_IPL_VIDEO_CONTAINER > >":
    r"""
    Get the supported containers.
    :rtype: std::vector< PEAK_IPL_VIDEO_CONTAINER,std::allocator< PEAK_IPL_VIDEO_CONTAINER > >
    :return: List of the supported containers.
    """
    return _peak_ipl_python_interface.GetSupportedContainersForAnEncoder(encoder)
class VideoWriter(object):
    r"""Writes images to a file in the form of a video."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_VideoWriter

    def __init__(self, *args):
        _peak_ipl_python_interface.VideoWriter_swiginit(self, _peak_ipl_python_interface.new_VideoWriter(*args))

    def Open(self, *args) -> "void":
        r"""
        *Overload 1:*

        Open the VideoWriter and sets up a container and an encoder. The file is created upon receiving the first
        image with 'Append'.

        :type fileName: string, in
        :param fileName: The filename of the video as an utf-8 encoded string (u8string)
        :type container: :py:class:`IContainer`, in
        :param container: The container of the video.
        :type encoder: :py:class:`IEncoder`, in
        :param encoder: The encoder of the video.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5

        |

        *Overload 2:*

        Open the VideoWriter with AVI container and mjpeg encoder.
        The file is created upon receiving the first image with 'Append'.
        :type fileName: string, in
        :param fileName: The filename of the video as an utf-8 encoded string (u8string)

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.VideoWriter_Open(self, *args)

    def IsOpen(self) -> "bool":
        r"""
        Check if the VideoWriter is already open.
        :rtype: boolean
        :return: Boolean if the VideoWriter is already open.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.VideoWriter_IsOpen(self)

    def Close(self) -> "void":
        r"""
        Close the opened VideoWriter.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.VideoWriter_Close(self)

    def Append(self, image: "Image") -> "void":
        r"""
        Append an image to the opened video.
        Remarks: Note that the image dimensions must be divisible by 8 (May be lifted by a later version)
        :type image: :py:class:`Image`, in
        :param image: The image to append.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: BusyException                    The internal queue is full. The image won't be added to the video
                                                     stream.
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _peak_ipl_python_interface.VideoWriter_Append(self, image)

    def __lshift__(self, image: "Image") -> "peak::ipl::VideoWriter &":
        
        return _peak_ipl_python_interface.VideoWriter___lshift__(self, image)

    def Encoder(self) -> "std::shared_ptr< peak::ipl::encoder::IEncoder >":
        r"""
        Get the used encoder.
        :rtype: :py:class:`IEncoder`
        :return: Instance of the encoder.
        """
        return _peak_ipl_python_interface.VideoWriter_Encoder(self)

    def Container(self) -> "std::shared_ptr< peak::ipl::container::IContainer >":
        r"""
        Get the used container.
        :rtype: :py:class:`IContainer`
        :return: Instance of the container.
        """
        return _peak_ipl_python_interface.VideoWriter_Container(self)

    def NumFramesEncoded(self) -> "uint64_t":
        r"""
        Get the encoded frames in the video stream.
        :rtype: int
        :return: Number of encoded frames in the video stream.
        """
        return _peak_ipl_python_interface.VideoWriter_NumFramesEncoded(self)

    def NumFramesDropped(self) -> "uint64_t":
        r"""
        Get the dropped frames in the video stream.
        :rtype: int
        :return: Number of dropped frames in the video stream.
        """
        return _peak_ipl_python_interface.VideoWriter_NumFramesDropped(self)

    def FileSize(self) -> "uint64_t":
        r"""
        Get the file size of the video in bytes.
        :rtype: int
        :return: File size of the video.
        """
        return _peak_ipl_python_interface.VideoWriter_FileSize(self)

    def ResetFrameCounters(self) -> "void":
        r"""Reset compressed and dropped frame counters."""
        return _peak_ipl_python_interface.VideoWriter_ResetFrameCounters(self)

    def SetQueueSize(self, queueSize: "int32_t") -> "void":
        r"""
        Set the internal queue size of the video writer
        :type queueSize: int
        :param queueSize: internal queue size to set. See 'QueueSizeRange()' for a range of valid values
        """
        return _peak_ipl_python_interface.VideoWriter_SetQueueSize(self, queueSize)

    def QueueSize(self) -> "int32_t":
        r"""
        Get the internal queue size of the video writer
        :rtype: int
        :return: the internal queue size
        """
        return _peak_ipl_python_interface.VideoWriter_QueueSize(self)

    def QueueSizeRange(self) -> "peak::ipl::Range< int32_t >":
        r"""
        Get the range of the queue size
        :rtype: peak::ipl::Range< int32_t >
        :return: Range<int32_t> with valid values
        """
        return _peak_ipl_python_interface.VideoWriter_QueueSizeRange(self)

    def NumBuffersQueued(self) -> "int32_t":
        r"""
        Get the count of the currently queued buffers, which are waiting to be processed
        :rtype: int
        :return: the count of the queued buffers
        """
        return _peak_ipl_python_interface.VideoWriter_NumBuffersQueued(self)

    def WaitUntilFrameDone(self, timeout_ms: "int32_t") -> "void":
        r"""
        Wait until frame processing is done.
        :type timeout_ms: int
        :param timeout_ms: The timeout in milliseconds.
        """
        return _peak_ipl_python_interface.VideoWriter_WaitUntilFrameDone(self, timeout_ms)

    def WaitUntilQueueEmpty(self, timeout_ms: "int32_t") -> "void":
        r"""
        Wait until the queue is empty.
        :type timeout_ms: int
        :param timeout_ms: The timeout in milliseconds.
        """
        return _peak_ipl_python_interface.VideoWriter_WaitUntilQueueEmpty(self, timeout_ms)

# Register VideoWriter in _peak_ipl_python_interface:
_peak_ipl_python_interface.VideoWriter_swigregister(VideoWriter)
class PixelFormat(object):
    r"""Represents a pixel format and its specific properties."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelFormat

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new PixelFormat instance

        Creates a new PixelFormat instance. The PixelFormatName is initialized to #PixelFormatName::Invalid.

        Since: 1.0

        |

        *Overload 2:*
         Constructor for a new PixelFormat instance

        Creates a new PixelFormat instance. The PixelFormatName is initialized to ``name``.

        :type name: int, in
        :param name: Used Pixel Format Name.

        Since: 1.0

        |

        *Overload 3:*
         Move constructor for PixelFormat instance

        Moves the PixelFormatName from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`PixelFormat`, in
        :param other: The other instance to move the PixelFormatName from.

        Since: 1.0
        """
        _peak_ipl_python_interface.PixelFormat_swiginit(self, _peak_ipl_python_interface.new_PixelFormat(*args))

    def Name(self) -> "std::string":
        r"""
        Returns the name of the pixel format as String.

        :rtype: string
        :return: Name

        Since: 1.0
        """
        return _peak_ipl_python_interface.PixelFormat_Name(self)

    def PixelFormatName(self) -> "peak::ipl::PixelFormatName":
        r"""
        Returns the name of the pixel format as enum value.

        :rtype: int
        :return: PixelFormatName

        Since: 1.0
        """
        return _peak_ipl_python_interface.PixelFormat_PixelFormatName(self)

    def __eq__(self, other: "PixelFormat") -> "bool":
        r"""
         Compare PixelFormat

        Compares the PixelFormatName from ``other`` to this instance

        :type other: :py:class:`PixelFormat`, in
        :param other: The other instance to compare.

        :rtype: boolean
        :return: True if equal, false otherwise.

        Since: 1.0
        """
        return _peak_ipl_python_interface.PixelFormat___eq__(self, other)

    def NumSignificantBitsPerChannel(self) -> "size_t":
        r"""
         Returns the number of significant bits per pixel per channel of the given pixel format.

        :rtype: int
        :return: Number of significant bits per pixel per channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_NumSignificantBitsPerChannel(self)

    def NumStorageBitsPerChannel(self) -> "size_t":
        r"""
         Returns the number of storage bits per pixel per channel of the given pixel format.

        :rtype: int
        :return: Number of storage bits per pixel per channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_NumStorageBitsPerChannel(self)

    def NumChannels(self) -> "size_t":
        r"""
         Returns the number of channels the given pixel format has.

        :rtype: int
        :return: Number of channels for pixel format.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_NumChannels(self)

    def MaximumValuePerChannel(self) -> "uint32_t":
        r"""
        Returns the maximum value of one pixel channel the given pixel format has.

        :rtype: int
        :return: Maximum value of one pixel channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_MaximumValuePerChannel(self)

    def NumSignificantBitsPerPixel(self) -> "size_t":
        r"""
        Returns the number of significant bits per pixel the given pixel format has.

        :rtype: int
        :return: Number of significant bits used.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_NumSignificantBitsPerPixel(self)

    def NumStorageBitsPerPixel(self) -> "size_t":
        r"""
        Returns the number of storage bits per pixel the given pixel format has.

        For unpacked formats, this is normally a multiple of 8.
        For packed formats, this is normally the same as #NumSignificantBitsPerPixel.

        :rtype: int
        :return: Number of storage bits used.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_NumStorageBitsPerPixel(self)

    def Endianness(self) -> "peak::ipl::Endianness":
        r"""
         Returns the endianness of the given pixel format.

        :rtype: int
        :return: The endianness of the pixel format.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_Endianness(self)

    def CalculateStorageSizeOfPixels(self, numPixels: "uint64_t") -> "uint64_t":
        r"""
         Returns the storage size the given number pixels of the given pixel format in bytes.

        For example, the calculation of the required buffer size, supply width multiplied by height here.

        :type numPixels: int, in
        :param numPixels:   The number of pixels.

        :rtype: int
        :return: The calculated storage size for the number of pixels.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_CalculateStorageSizeOfPixels(self, numPixels)

    def IsPacked(self) -> "bool":
        r"""
         Returns whether the pixel format is packed.

        :rtype: boolean
        :return: Whether the pixel format is packed. True for packed, false for unpacked.

        Since: 1.7

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_IsPacked(self)

    def IsBayered(self) -> "bool":
        r"""
         Returns whether the pixel format is a bayer format.

        :rtype: boolean
        :return: Whether the pixel format is a bayer format. True for Bayer, false for all else.

        Since: 1.7

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_IsBayered(self)

    def IsYUV(self) -> "bool":
        r"""
         Returns whether the pixel format is a yuv format.

        :rtype: boolean
        :return: Whether the pixel format is a yuv format. True for yuv, false for all else.

        Since: 1.9

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_IsYUV(self)

    def BayerPattern(self) -> "peak::ipl::BayerPattern":
        r"""
         Queries the bayer pattern of the given pixel format.

        :rtype: int
        :return: The bayer pattern if the format is a bayer format. Or #BayerPattern::None if the format has no Bayer pattern.

        Since: 1.8

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelFormat_BayerPattern(self)

# Register PixelFormat in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelFormat_swigregister(PixelFormat)
class PixelLine(object):
    r"""Represents the values of a horizontal or vertical line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelLine

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor.

        :type image: :py:class:`Image`, in
        :param image: The image to process.
        :type orientation: int, in
        :param orientation: The orientation of the pixel line.
        :type offset: int, in
        :param offset: Y offset if orientation = peak::ipl::Orientation::Horizontal; X offset if orientation = peak::ipl::Orientation::Vertical

        :raises: ImageFormatNotSupportedException image has a packed pixel format

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format

        |

        *Overload 2:*
         Copy Constructor for a new PixelLine instance

        Creates a new PixelLine instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`PixelLine`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for PixelLine instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`PixelLine`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _peak_ipl_python_interface.PixelLine_swiginit(self, _peak_ipl_python_interface.new_PixelLine(*args))

    def PixelFormatName(self) -> "peak::ipl::PixelFormatName":
        r"""
         Returns the pixel format of the given pixel line.

        :rtype: int
        :return: PixelFormatName

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelLine_PixelFormatName(self)

    def Orientation(self) -> "peak::ipl::Orientation":
        r"""
         Returns the orientation of the given pixel line.

        :rtype: int
        :return: Orientation

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelLine_Orientation(self)

    def Offset(self) -> "size_t":
        r"""
         Returns the offset of the given pixel line.
        (Vertical: Left - Horizontal: Top).

        :rtype: int
        :return: Offset

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _peak_ipl_python_interface.PixelLine_Offset(self)

    def Channels(self) -> "std::vector< peak::ipl::PixelLineChannel,std::allocator< peak::ipl::PixelLineChannel > >":
        return _peak_ipl_python_interface.PixelLine_Channels(self)

# Register PixelLine in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelLine_swigregister(PixelLine)
class PixelRow(PixelLine):
    r"""Represents the values for a horizontal line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelRow

    def __init__(self, *args):
        _peak_ipl_python_interface.PixelRow_swiginit(self, _peak_ipl_python_interface.new_PixelRow(*args))

# Register PixelRow in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelRow_swigregister(PixelRow)
class PixelColumn(PixelLine):
    r"""Represents the values for a vertical line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelColumn

    def __init__(self, *args):
        _peak_ipl_python_interface.PixelColumn_swiginit(self, _peak_ipl_python_interface.new_PixelColumn(*args))

# Register PixelColumn in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelColumn_swigregister(PixelColumn)
class Sharpness(object):
    r"""
    Configure and measure the sharpness of a given image.

    The class allows the measurement of the sharpness in a defined ROI of the given image. To get a sharpness value, the
    edges in the image are evaluated. The sharpness can only be indicated as a relative value, as it depends on the edges
    in the current image. An image with fewer edges won't reach the sharpness value of an image with a lot of edges.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_Sharpness

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Sharpness instance

        Creates a new Sharpness instance.

        Since: 1.6

        |

        *Overload 2:*
         Copy Constructor for a new Sharpness instance

        Creates a new Sharpness instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Sharpness`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.6 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Sharpness instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Sharpness`, in
        :param other: The other instance to move.

        Since: 1.6
        """
        _peak_ipl_python_interface.Sharpness_swiginit(self, _peak_ipl_python_interface.new_Sharpness(*args))
    SharpnessAlgorithm_Tenengrad = _peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_Tenengrad
    r""" contrast-based sharpness algorithm (convolution)"""
    SharpnessAlgorithm_MeanScore = _peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_MeanScore
    r""" contrast-based sharpness algorithm (mean value)"""
    SharpnessAlgorithm_HistogramVariance = _peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_HistogramVariance
    r""" statistics-based sharpness algorithm"""
    SharpnessAlgorithm_Sobel = _peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_Sobel
    r""" contrast-based sharpness algorithm (convolution)"""
    SharpnessROIWeight_Weak = _peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Weak
    r""" Weak use of roi for the measurement"""
    SharpnessROIWeight_Medium = _peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Medium
    r""" Normal use of roi for the measurement"""
    SharpnessROIWeight_Strong = _peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Strong
    r""" Strong use of roi for the measurement"""

    def Measure(self, image: "Image") -> "double":
        r"""
        Measures the sharpness of the given image. The higher the value, the better the sharpness.

        :type image: :py:class:`Image`, in
        :param image: The image to measure the relative sharpness.

        :rtype: float
        :return: Relative sharpness value

        :raises: InvalidPixelFormat pixel format isn't supported.

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_Measure(self, image)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Checks if the given pixel format can be used for sharpness measurement.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixelFormat of the input image.

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_IsPixelFormatSupported(self, pixelFormatName)

    def SupportedPixelFormats(self) -> "std::vector< peak::ipl::PixelFormatName,std::allocator< peak::ipl::PixelFormatName > >":
        r"""
        Returns a list of supported pixel formats which can be used for sharpness measurement.
        :rtype: std::vector< peak::ipl::PixelFormatName,std::allocator< peak::ipl::PixelFormatName > >
        :return: List of supported pixel formats.

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_SupportedPixelFormats(self)

    def SetAlgorithm(self, algorithm: "peak::ipl::Sharpness::SharpnessAlgorithm") -> "void":
        r"""
        Sets the algorithm used for measurement calculation.

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_SetAlgorithm(self, algorithm)

    def Algorithm(self) -> "peak::ipl::Sharpness::SharpnessAlgorithm":
        r"""
        Returns the used algorithm for the sharpness measurement.
        :rtype: int
        :return: Current algorithm

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_Algorithm(self)

    def ROIMinSize(self) -> "peak::ipl::Size2D":
        r"""
        Gets the minimum size of a ROI, in which the sharpness is measured.
        :rtype: :py:class:`Size2D`
        :return: Required minimum size of a roi

        Since: 1.6
        """
        return _peak_ipl_python_interface.Sharpness_ROIMinSize(self)

    def SetROI(self, *args) -> "void":
        return _peak_ipl_python_interface.Sharpness_SetROI(self, *args)

    def SetROIs(self, srois: "SharpnessROIList") -> "void":
        return _peak_ipl_python_interface.Sharpness_SetROIs(self, srois)

    def GetROIs(self) -> "std::vector< peak::ipl::SharpnessROI,std::allocator< peak::ipl::SharpnessROI > >":
        return _peak_ipl_python_interface.Sharpness_GetROIs(self)

# Register Sharpness in _peak_ipl_python_interface:
_peak_ipl_python_interface.Sharpness_swigregister(Sharpness)

def __eq__(*args) -> "bool":
    return _peak_ipl_python_interface.__eq__(*args)

def __ne__(*args) -> "bool":
    return _peak_ipl_python_interface.__ne__(*args)
class Gain(object):
    r"""Applies gain to the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_Gain

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Gain instance

        Creates a new Gain instance.

        Since: 1.2.2

        |

        *Overload 2:*
         Copy Constructor for a new Gain instance

        Creates a new Gain instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Gain`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.2.2 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Gain instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Gain`, in
        :param other: The other instance to move.

        Since: 1.2.2
        """
        _peak_ipl_python_interface.Gain_swiginit(self, _peak_ipl_python_interface.new_Gain(*args))

    def SetMasterGainValue(self, masterGainValue: "float") -> "void":
        r"""
        Sets the values of the master Gain.

        :type masterGainValue: float, in
        :param masterGainValue: The value of the master gain.

        :raises: InvalidArgument masterGainValue isn't supported.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_SetMasterGainValue(self, masterGainValue)

    def MasterGainValue(self) -> "float":
        r"""
        Returns the value of the master gain.

        :rtype: float
        :return: masterGainValue The value of the master gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_MasterGainValue(self)

    def MasterGainMin(self) -> "float":
        r"""
        Returns the minimum value of the master gain.

        :rtype: float
        :return: masterGainMin The minimum value of the master gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_MasterGainMin(self)

    def MasterGainMax(self) -> "float":
        r"""
        Returns the maximum value of the master gain.

        :rtype: float
        :return: masterGainMax The maximum value of the master gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_MasterGainMax(self)

    def SetRedGainValue(self, redGainValue: "float") -> "void":
        r"""
        Sets the values of the red Gain.

        :type redGainValue: float, in
        :param redGainValue: The value of the red gain.

        :raises: InvalidArgument redGainValue isn't supported.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_SetRedGainValue(self, redGainValue)

    def RedGainValue(self) -> "float":
        r"""
        Returns the value of the red gain.

        :rtype: float
        :return: redGainValue The value of the red gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_RedGainValue(self)

    def RedGainMin(self) -> "float":
        r"""
        Returns the minimum value of the red gain.

        :rtype: float
        :return: redGainMin The minimum value of the red gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_RedGainMin(self)

    def RedGainMax(self) -> "float":
        r"""
        Returns the maximum value of the red gain.

        :rtype: float
        :return: redGainMax The maximum value of the red gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_RedGainMax(self)

    def SetGreenGainValue(self, greenGainValue: "float") -> "void":
        r"""
        Sets the values of the green Gain.

        :type greenGainValue: float, in
        :param greenGainValue: The value of the green gain.

        :raises: InvalidArgument greenGainValue isn't supported.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_SetGreenGainValue(self, greenGainValue)

    def GreenGainValue(self) -> "float":
        r"""
        Returns the value of the green gain.

        :rtype: float
        :return: greenGainValue The value of the green gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_GreenGainValue(self)

    def GreenGainMin(self) -> "float":
        r"""
        Returns the minimum value of the green gain.

        :rtype: float
        :return: greenGainMin The minimum value of the green gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_GreenGainMin(self)

    def GreenGainMax(self) -> "float":
        r"""
        Returns the maximum value of the green gain.

        :rtype: float
        :return: greenGainMax The maximum value of the green gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_GreenGainMax(self)

    def SetBlueGainValue(self, blueGainValue: "float") -> "void":
        r"""
        Sets the values of the blue Gain.

        :type blueGainValue: float, in
        :param blueGainValue: The value of the blue gain.

        :raises: InvalidArgument blueGainValue isn't supported.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_SetBlueGainValue(self, blueGainValue)

    def BlueGainValue(self) -> "float":
        r"""
        Returns the value of the blue gain.

        :rtype: float
        :return: blueGainValue The value of the blue gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_BlueGainValue(self)

    def BlueGainMin(self) -> "float":
        r"""
        Returns the minimum value of the blue gain.

        :rtype: float
        :return: blueGainMin The minimum value of the blue gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_BlueGainMin(self)

    def BlueGainMax(self) -> "float":
        r"""
        Returns the maximum value of the blue gain.

        :rtype: float
        :return: blueGainMax The maximum value of the blue gain.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_BlueGainMax(self)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Returns whether the gain supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "void":
        r"""
        Applies the gain on the given image in place that is, it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
         Applies the gain on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.3.2
        """
        return _peak_ipl_python_interface.Gain_Process(self, inputImage)

# Register Gain in _peak_ipl_python_interface:
_peak_ipl_python_interface.Gain_swigregister(Gain)
class Binning(object):
    r"""The "peak::ipl" namespace contains the whole image processing library."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BinningMode_Average = _peak_ipl_python_interface.Binning_BinningMode_Average
    r""" Average (mean) of pixels"""
    BinningMode_Sum = _peak_ipl_python_interface.Binning_BinningMode_Sum
    r""" Sum of pixels"""
    __swig_destroy__ = _peak_ipl_python_interface.delete_Binning

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Binning instance

        Creates a new Binning instance.

        Since: 1.3.3

        |

        *Overload 2:*
         Copy Constructor for a new Binning instance

        Creates a new Binning instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Binning`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.3.3 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Binning instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Binning`, in
        :param other: The other instance to move.

        Since: 1.3.3
        """
        _peak_ipl_python_interface.Binning_swiginit(self, _peak_ipl_python_interface.new_Binning(*args))

    def SetBinningX(self, value: "uint8_t") -> "void":
        r"""
        Sets the values of the binning in horizontal direction.

        :type value: uint8_t, in
        :param value: The value of the binning in horizontal direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_SetBinningX(self, value)

    def BinningX(self) -> "uint8_t":
        r"""
        Returns the value of the binning in horizontal direction.

        :rtype: uint8_t
        :return: The value of the binning in horizontal direction.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_BinningX(self)

    def SetBinningY(self, value: "uint8_t") -> "void":
        r"""
        Sets the values of the binning in vertical direction.

        :type value: uint8_t, in
        :param value: The value of the binning in vertical direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_SetBinningY(self, value)

    def BinningY(self) -> "uint8_t":
        r"""
        Returns the value of the binning in vertical direction.

        :rtype: uint8_t
        :return: The value of the binning in vertical direction.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_BinningY(self)

    def BinningMin(self) -> "uint8_t":
        r"""
        Returns the minimum value for the binning.

        :rtype: uint8_t
        :return: The minimum value for the binning.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_BinningMin(self)

    def BinningMax(self) -> "uint8_t":
        r"""
        Returns the maximum value for the binning.

        :rtype: uint8_t
        :return: The maximum value for the binning.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_BinningMax(self)

    def ExpectedOutputSize(self, inputSize: "Size2D", pixelFormat: "peak::ipl::PixelFormatName") -> "peak::ipl::Size2D":
        r"""
        Returns the size of a binned image given the input size and pixelformat.

        :type inputSize: :py:class:`Size2D`, in
        :param inputSize:                         The size of the input image.
        :type pixelFormat: int, in
        :param pixelFormat:                       The pixelFormat of the input image.

        :rtype: :py:class:`Size2D`
        :return: The size of a binned image

        :raises: InvalidArgument pixelFormat isn't supported.

        Since: 1.3.4
        """
        return _peak_ipl_python_interface.Binning_ExpectedOutputSize(self, inputSize, pixelFormat)

    def SetMode(self, mode: "peak::ipl::Binning::BinningMode") -> "void":
        r"""
        Sets the values of the binning mode.

        :type mode: int, in
        :param mode: The value of the binning mode.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_SetMode(self, mode)

    def Mode(self) -> "peak::ipl::Binning::BinningMode":
        r"""
        Returns the value of the binning mode.

        :rtype: int
        :return: The value of the binning mode.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_Mode(self)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Returns whether the binning supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_IsPixelFormatSupported(self, pixelFormatName)

    def Process(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
         Applies the binning on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: InvalidArgument the image is too small.

        Since: 1.3.3
        """
        return _peak_ipl_python_interface.Binning_Process(self, inputImage)

# Register Binning in _peak_ipl_python_interface:
_peak_ipl_python_interface.Binning_swigregister(Binning)
class Decimation(object):
    r"""The "peak::ipl" namespace contains the whole image processing library."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_Decimation

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Decimation instance

        Creates a new Decimation instance.

        Since: 1.6.0

        |

        *Overload 2:*
         Copy Constructor for a new Decimation instance

        Creates a new Decimation instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Decimation`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.6.0 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Decimation instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Decimation`, in
        :param other: The other instance to move.

        Since: 1.6.0
        """
        _peak_ipl_python_interface.Decimation_swiginit(self, _peak_ipl_python_interface.new_Decimation(*args))

    def SetDecimationX(self, value: "uint8_t") -> "void":
        r"""
        Sets the values of the decimation in horizontal direction.

        :type value: uint8_t, in
        :param value: The value of the decimation in horizontal direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_SetDecimationX(self, value)

    def DecimationX(self) -> "uint8_t":
        r"""
        Returns the value of the decimation in horizontal direction.

        :rtype: uint8_t
        :return: The value of the decimation in horizontal direction.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_DecimationX(self)

    def SetDecimationY(self, value: "uint8_t") -> "void":
        r"""
        Sets the values of the decimation in vertical direction.

        :type value: uint8_t, in
        :param value: The value of the decimation in vertical direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_SetDecimationY(self, value)

    def DecimationY(self) -> "uint8_t":
        r"""
        Returns the value of the decimation in vertical direction.

        :rtype: uint8_t
        :return: The value of the decimation in vertical direction.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_DecimationY(self)

    def DecimationMin(self) -> "uint8_t":
        r"""
        Returns the minimum value for the decimation.

        :rtype: uint8_t
        :return: The minimum value for the decimation.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_DecimationMin(self)

    def DecimationMax(self) -> "uint8_t":
        r"""
        Returns the maximum value for the decimation.

        :rtype: uint8_t
        :return: The maximum value for the decimation.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_DecimationMax(self)

    def ExpectedOutputSize(self, inputSize: "Size2D", pixelFormat: "peak::ipl::PixelFormatName") -> "peak::ipl::Size2D":
        r"""
        Returns the size of a decimated image given the input size and pixelformat.

        :type inputSize: :py:class:`Size2D`, in
        :param inputSize:                         The size of the input image.
        :type pixelFormat: int, in
        :param pixelFormat:                       The pixelFormat of the input image.

        :rtype: :py:class:`Size2D`
        :return: The size of a decimated image

        :raises: InvalidArgument pixelFormat isn't supported.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_ExpectedOutputSize(self, inputSize, pixelFormat)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Returns whether the decimation supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_IsPixelFormatSupported(self, pixelFormatName)

    def Process(self, inputImage: "Image") -> "peak::ipl::Image":
        r"""
         Applies the decimation on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the decimated pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: InvalidArgument the image is too small.

        Since: 1.6.0
        """
        return _peak_ipl_python_interface.Decimation_Process(self, inputImage)

# Register Decimation in _peak_ipl_python_interface:
_peak_ipl_python_interface.Decimation_swigregister(Decimation)
class EdgeEnhancement(object):
    r"""
    Edge Enhancement for a given image.

    This class uses a software filter that emphasizes the edges in the image. The enhancement factor is configurable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _peak_ipl_python_interface.delete_EdgeEnhancement

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new EdgeEnhancement instance

        Creates a new EdgeEnhancement instance.

        Since: 1.7

        |

        *Overload 2:*
         Copy Constructor for a new EdgeEnhancement instance

        Creates a new EdgeEnhancement instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`EdgeEnhancement`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.7 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for EdgeEnhancement instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`EdgeEnhancement`, in
        :param other: The other instance to move.

        Since: 1.7
        """
        _peak_ipl_python_interface.EdgeEnhancement_swiginit(self, _peak_ipl_python_interface.new_EdgeEnhancement(*args))

    def ProcessInPlace(self, image: "Image") -> "void":
        r"""
        Process an image

        To check if it is supported, call #EdgeEnhancement::IsPixelFormatSupported first
        This function causes a higher CPU load.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: InvalidPixelFormat pixel format isn't supported.
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_ProcessInPlace(self, image)

    def Process(self, image: "Image") -> "peak::ipl::Image":
        r"""
        Process an image

        To check if it is supported, call #EdgeEnhancement::IsPixelFormatSupported first
        This function causes a higher CPU load.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :rtype: :py:class:`Image`
        :return: the sharpened image

        :raises: InvalidPixelFormat pixel format isn't supported.
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_Process(self, image)

    def IsPixelFormatSupported(self, pixelFormatName: "peak::ipl::PixelFormatName") -> "bool":
        r"""
        Check if the pixel format is supported

        Notes: Is currently only implemented for not packed and not raw pixel formats

        :type pixelFormatName: int, in
        :param pixelFormatName: The PixelFormatName to check support for.

        :rtype: boolean
        :return: true if pixelformat is supported, else false

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_IsPixelFormatSupported(self, pixelFormatName)

    def SetFactor(self, factor: "std::uint32_t") -> "void":
        r"""
        Set the edge enhancement factor

        :type factor: int, in
        :param factor: The factor to set.

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_SetFactor(self, factor)

    def Factor(self) -> "std::uint32_t":
        r"""
        Get the edge enhancement factor

        :rtype: int
        :return: the current edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_Factor(self)

    def DefaultFactor(self) -> "std::uint32_t":
        r"""
        Get the default edge enhancement factor

        :rtype: int
        :return: the default edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_DefaultFactor(self)

    def Range(self) -> "peak::ipl::Range< std::uint32_t >":
        r"""
        Get the range for the edge enhancement factor

        :rtype: peak::ipl::Range< std::uint32_t >
        :return: the range for the edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _peak_ipl_python_interface.EdgeEnhancement_Range(self)

# Register EdgeEnhancement in _peak_ipl_python_interface:
_peak_ipl_python_interface.EdgeEnhancement_swigregister(EdgeEnhancement)
class VectorInt32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorInt32___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorInt32___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _peak_ipl_python_interface.VectorInt32___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _peak_ipl_python_interface.VectorInt32___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorInt32___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorInt32___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorInt32___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _peak_ipl_python_interface.VectorInt32___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorInt32___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _peak_ipl_python_interface.VectorInt32_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorInt32_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorInt32_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _peak_ipl_python_interface.VectorInt32_size(self)

    def swap(self, v: "VectorInt32") -> "void":
        return _peak_ipl_python_interface.VectorInt32_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _peak_ipl_python_interface.VectorInt32_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _peak_ipl_python_interface.VectorInt32_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _peak_ipl_python_interface.VectorInt32_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _peak_ipl_python_interface.VectorInt32_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorInt32_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _peak_ipl_python_interface.VectorInt32_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorInt32_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _peak_ipl_python_interface.VectorInt32_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorInt32_swiginit(self, _peak_ipl_python_interface.new_VectorInt32(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorInt32_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _peak_ipl_python_interface.VectorInt32_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _peak_ipl_python_interface.VectorInt32_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorInt32_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorInt32_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorInt32_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorInt32_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _peak_ipl_python_interface.VectorInt32_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorInt32

# Register VectorInt32 in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorInt32_swigregister(VectorInt32)
class VectorUInt32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorUInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt32___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt32___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _peak_ipl_python_interface.VectorUInt32___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _peak_ipl_python_interface.VectorUInt32___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt32___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorUInt32___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt32___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt32___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt32___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _peak_ipl_python_interface.VectorUInt32_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt32_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt32_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _peak_ipl_python_interface.VectorUInt32_size(self)

    def swap(self, v: "VectorUInt32") -> "void":
        return _peak_ipl_python_interface.VectorUInt32_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _peak_ipl_python_interface.VectorUInt32_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _peak_ipl_python_interface.VectorUInt32_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _peak_ipl_python_interface.VectorUInt32_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _peak_ipl_python_interface.VectorUInt32_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorUInt32_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _peak_ipl_python_interface.VectorUInt32_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorUInt32_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _peak_ipl_python_interface.VectorUInt32_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorUInt32_swiginit(self, _peak_ipl_python_interface.new_VectorUInt32(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt32_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt32_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt32_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt32_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt32_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt32_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorUInt32_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _peak_ipl_python_interface.VectorUInt32_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorUInt32

# Register VectorUInt32 in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorUInt32_swigregister(VectorUInt32)
class VectorUInt64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorUInt64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt64___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt64___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _peak_ipl_python_interface.VectorUInt64___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _peak_ipl_python_interface.VectorUInt64___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt64___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorUInt64___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt64___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt64___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt64___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _peak_ipl_python_interface.VectorUInt64_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt64_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorUInt64_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _peak_ipl_python_interface.VectorUInt64_size(self)

    def swap(self, v: "VectorUInt64") -> "void":
        return _peak_ipl_python_interface.VectorUInt64_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _peak_ipl_python_interface.VectorUInt64_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _peak_ipl_python_interface.VectorUInt64_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _peak_ipl_python_interface.VectorUInt64_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _peak_ipl_python_interface.VectorUInt64_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorUInt64_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _peak_ipl_python_interface.VectorUInt64_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorUInt64_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _peak_ipl_python_interface.VectorUInt64_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorUInt64_swiginit(self, _peak_ipl_python_interface.new_VectorUInt64(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt64_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt64_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _peak_ipl_python_interface.VectorUInt64_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorUInt64_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt64_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorUInt64_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorUInt64_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _peak_ipl_python_interface.VectorUInt64_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorUInt64

# Register VectorUInt64 in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorUInt64_swigregister(VectorUInt64)
class VectorPixelLineChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorPixelLineChannel_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorPixelLineChannel___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorPixelLineChannel___bool__(self)

    def __len__(self) -> "std::vector< peak::ipl::PixelLineChannel >::size_type":
        return _peak_ipl_python_interface.VectorPixelLineChannel___len__(self)

    def __getslice__(self, i: "std::vector< peak::ipl::PixelLineChannel >::difference_type", j: "std::vector< peak::ipl::PixelLineChannel >::difference_type") -> "std::vector< peak::ipl::PixelLineChannel,std::allocator< peak::ipl::PixelLineChannel > > *":
        return _peak_ipl_python_interface.VectorPixelLineChannel___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< peak::ipl::PixelLineChannel >::difference_type", j: "std::vector< peak::ipl::PixelLineChannel >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< peak::ipl::PixelLineChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorPixelLineChannel___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel___setitem__(self, *args)

    def pop(self) -> "std::vector< peak::ipl::PixelLineChannel >::value_type":
        return _peak_ipl_python_interface.VectorPixelLineChannel_pop(self)

    def append(self, x: "PixelLineChannel") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorPixelLineChannel_empty(self)

    def size(self) -> "std::vector< peak::ipl::PixelLineChannel >::size_type":
        return _peak_ipl_python_interface.VectorPixelLineChannel_size(self)

    def swap(self, v: "VectorPixelLineChannel") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_swap(self, v)

    def begin(self) -> "std::vector< peak::ipl::PixelLineChannel >::iterator":
        return _peak_ipl_python_interface.VectorPixelLineChannel_begin(self)

    def end(self) -> "std::vector< peak::ipl::PixelLineChannel >::iterator":
        return _peak_ipl_python_interface.VectorPixelLineChannel_end(self)

    def rbegin(self) -> "std::vector< peak::ipl::PixelLineChannel >::reverse_iterator":
        return _peak_ipl_python_interface.VectorPixelLineChannel_rbegin(self)

    def rend(self) -> "std::vector< peak::ipl::PixelLineChannel >::reverse_iterator":
        return _peak_ipl_python_interface.VectorPixelLineChannel_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_clear(self)

    def get_allocator(self) -> "std::vector< peak::ipl::PixelLineChannel >::allocator_type":
        return _peak_ipl_python_interface.VectorPixelLineChannel_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_pop_back(self)

    def erase(self, *args) -> "std::vector< peak::ipl::PixelLineChannel >::iterator":
        return _peak_ipl_python_interface.VectorPixelLineChannel_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorPixelLineChannel_swiginit(self, _peak_ipl_python_interface.new_VectorPixelLineChannel(*args))

    def push_back(self, x: "PixelLineChannel") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_push_back(self, x)

    def front(self) -> "std::vector< peak::ipl::PixelLineChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorPixelLineChannel_front(self)

    def back(self) -> "std::vector< peak::ipl::PixelLineChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorPixelLineChannel_back(self)

    def assign(self, n: "std::vector< peak::ipl::PixelLineChannel >::size_type", x: "PixelLineChannel") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_insert(self, *args)

    def reserve(self, n: "std::vector< peak::ipl::PixelLineChannel >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorPixelLineChannel_reserve(self, n)

    def capacity(self) -> "std::vector< peak::ipl::PixelLineChannel >::size_type":
        return _peak_ipl_python_interface.VectorPixelLineChannel_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorPixelLineChannel

# Register VectorPixelLineChannel in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorPixelLineChannel_swigregister(VectorPixelLineChannel)
class VectorHistogramChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorHistogramChannel_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorHistogramChannel___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorHistogramChannel___bool__(self)

    def __len__(self) -> "std::vector< peak::ipl::HistogramChannel >::size_type":
        return _peak_ipl_python_interface.VectorHistogramChannel___len__(self)

    def __getslice__(self, i: "std::vector< peak::ipl::HistogramChannel >::difference_type", j: "std::vector< peak::ipl::HistogramChannel >::difference_type") -> "std::vector< peak::ipl::HistogramChannel,std::allocator< peak::ipl::HistogramChannel > > *":
        return _peak_ipl_python_interface.VectorHistogramChannel___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< peak::ipl::HistogramChannel >::difference_type", j: "std::vector< peak::ipl::HistogramChannel >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< peak::ipl::HistogramChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorHistogramChannel___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel___setitem__(self, *args)

    def pop(self) -> "std::vector< peak::ipl::HistogramChannel >::value_type":
        return _peak_ipl_python_interface.VectorHistogramChannel_pop(self)

    def append(self, x: "HistogramChannel") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorHistogramChannel_empty(self)

    def size(self) -> "std::vector< peak::ipl::HistogramChannel >::size_type":
        return _peak_ipl_python_interface.VectorHistogramChannel_size(self)

    def swap(self, v: "VectorHistogramChannel") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_swap(self, v)

    def begin(self) -> "std::vector< peak::ipl::HistogramChannel >::iterator":
        return _peak_ipl_python_interface.VectorHistogramChannel_begin(self)

    def end(self) -> "std::vector< peak::ipl::HistogramChannel >::iterator":
        return _peak_ipl_python_interface.VectorHistogramChannel_end(self)

    def rbegin(self) -> "std::vector< peak::ipl::HistogramChannel >::reverse_iterator":
        return _peak_ipl_python_interface.VectorHistogramChannel_rbegin(self)

    def rend(self) -> "std::vector< peak::ipl::HistogramChannel >::reverse_iterator":
        return _peak_ipl_python_interface.VectorHistogramChannel_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_clear(self)

    def get_allocator(self) -> "std::vector< peak::ipl::HistogramChannel >::allocator_type":
        return _peak_ipl_python_interface.VectorHistogramChannel_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_pop_back(self)

    def erase(self, *args) -> "std::vector< peak::ipl::HistogramChannel >::iterator":
        return _peak_ipl_python_interface.VectorHistogramChannel_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorHistogramChannel_swiginit(self, _peak_ipl_python_interface.new_VectorHistogramChannel(*args))

    def push_back(self, x: "HistogramChannel") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_push_back(self, x)

    def front(self) -> "std::vector< peak::ipl::HistogramChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorHistogramChannel_front(self)

    def back(self) -> "std::vector< peak::ipl::HistogramChannel >::value_type const &":
        return _peak_ipl_python_interface.VectorHistogramChannel_back(self)

    def assign(self, n: "std::vector< peak::ipl::HistogramChannel >::size_type", x: "HistogramChannel") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_insert(self, *args)

    def reserve(self, n: "std::vector< peak::ipl::HistogramChannel >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorHistogramChannel_reserve(self, n)

    def capacity(self) -> "std::vector< peak::ipl::HistogramChannel >::size_type":
        return _peak_ipl_python_interface.VectorHistogramChannel_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorHistogramChannel

# Register VectorHistogramChannel in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorHistogramChannel_swigregister(VectorHistogramChannel)
class VectorPoint2D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorPoint2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorPoint2D___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorPoint2D___bool__(self)

    def __len__(self) -> "std::vector< peak::ipl::Point2D >::size_type":
        return _peak_ipl_python_interface.VectorPoint2D___len__(self)

    def __getslice__(self, i: "std::vector< peak::ipl::Point2D >::difference_type", j: "std::vector< peak::ipl::Point2D >::difference_type") -> "std::vector< peak::ipl::Point2D,std::allocator< peak::ipl::Point2D > > *":
        return _peak_ipl_python_interface.VectorPoint2D___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< peak::ipl::Point2D >::difference_type", j: "std::vector< peak::ipl::Point2D >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< peak::ipl::Point2D >::value_type const &":
        return _peak_ipl_python_interface.VectorPoint2D___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D___setitem__(self, *args)

    def pop(self) -> "std::vector< peak::ipl::Point2D >::value_type":
        return _peak_ipl_python_interface.VectorPoint2D_pop(self)

    def append(self, x: "Point2D") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorPoint2D_empty(self)

    def size(self) -> "std::vector< peak::ipl::Point2D >::size_type":
        return _peak_ipl_python_interface.VectorPoint2D_size(self)

    def swap(self, v: "VectorPoint2D") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_swap(self, v)

    def begin(self) -> "std::vector< peak::ipl::Point2D >::iterator":
        return _peak_ipl_python_interface.VectorPoint2D_begin(self)

    def end(self) -> "std::vector< peak::ipl::Point2D >::iterator":
        return _peak_ipl_python_interface.VectorPoint2D_end(self)

    def rbegin(self) -> "std::vector< peak::ipl::Point2D >::reverse_iterator":
        return _peak_ipl_python_interface.VectorPoint2D_rbegin(self)

    def rend(self) -> "std::vector< peak::ipl::Point2D >::reverse_iterator":
        return _peak_ipl_python_interface.VectorPoint2D_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_clear(self)

    def get_allocator(self) -> "std::vector< peak::ipl::Point2D >::allocator_type":
        return _peak_ipl_python_interface.VectorPoint2D_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_pop_back(self)

    def erase(self, *args) -> "std::vector< peak::ipl::Point2D >::iterator":
        return _peak_ipl_python_interface.VectorPoint2D_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorPoint2D_swiginit(self, _peak_ipl_python_interface.new_VectorPoint2D(*args))

    def push_back(self, x: "Point2D") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_push_back(self, x)

    def front(self) -> "std::vector< peak::ipl::Point2D >::value_type const &":
        return _peak_ipl_python_interface.VectorPoint2D_front(self)

    def back(self) -> "std::vector< peak::ipl::Point2D >::value_type const &":
        return _peak_ipl_python_interface.VectorPoint2D_back(self)

    def assign(self, n: "std::vector< peak::ipl::Point2D >::size_type", x: "Point2D") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_insert(self, *args)

    def reserve(self, n: "std::vector< peak::ipl::Point2D >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorPoint2D_reserve(self, n)

    def capacity(self) -> "std::vector< peak::ipl::Point2D >::size_type":
        return _peak_ipl_python_interface.VectorPoint2D_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorPoint2D

# Register VectorPoint2D in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorPoint2D_swigregister(VectorPoint2D)
class SharpnessROIList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.SharpnessROIList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.SharpnessROIList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.SharpnessROIList___bool__(self)

    def __len__(self) -> "std::vector< peak::ipl::SharpnessROI >::size_type":
        return _peak_ipl_python_interface.SharpnessROIList___len__(self)

    def __getslice__(self, i: "std::vector< peak::ipl::SharpnessROI >::difference_type", j: "std::vector< peak::ipl::SharpnessROI >::difference_type") -> "std::vector< peak::ipl::SharpnessROI,std::allocator< peak::ipl::SharpnessROI > > *":
        return _peak_ipl_python_interface.SharpnessROIList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< peak::ipl::SharpnessROI >::difference_type", j: "std::vector< peak::ipl::SharpnessROI >::difference_type") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< peak::ipl::SharpnessROI >::value_type const &":
        return _peak_ipl_python_interface.SharpnessROIList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList___setitem__(self, *args)

    def pop(self) -> "std::vector< peak::ipl::SharpnessROI >::value_type":
        return _peak_ipl_python_interface.SharpnessROIList_pop(self)

    def append(self, x: "SharpnessROI") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.SharpnessROIList_empty(self)

    def size(self) -> "std::vector< peak::ipl::SharpnessROI >::size_type":
        return _peak_ipl_python_interface.SharpnessROIList_size(self)

    def swap(self, v: "SharpnessROIList") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_swap(self, v)

    def begin(self) -> "std::vector< peak::ipl::SharpnessROI >::iterator":
        return _peak_ipl_python_interface.SharpnessROIList_begin(self)

    def end(self) -> "std::vector< peak::ipl::SharpnessROI >::iterator":
        return _peak_ipl_python_interface.SharpnessROIList_end(self)

    def rbegin(self) -> "std::vector< peak::ipl::SharpnessROI >::reverse_iterator":
        return _peak_ipl_python_interface.SharpnessROIList_rbegin(self)

    def rend(self) -> "std::vector< peak::ipl::SharpnessROI >::reverse_iterator":
        return _peak_ipl_python_interface.SharpnessROIList_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_clear(self)

    def get_allocator(self) -> "std::vector< peak::ipl::SharpnessROI >::allocator_type":
        return _peak_ipl_python_interface.SharpnessROIList_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_pop_back(self)

    def erase(self, *args) -> "std::vector< peak::ipl::SharpnessROI >::iterator":
        return _peak_ipl_python_interface.SharpnessROIList_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.SharpnessROIList_swiginit(self, _peak_ipl_python_interface.new_SharpnessROIList(*args))

    def push_back(self, x: "SharpnessROI") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_push_back(self, x)

    def front(self) -> "std::vector< peak::ipl::SharpnessROI >::value_type const &":
        return _peak_ipl_python_interface.SharpnessROIList_front(self)

    def back(self) -> "std::vector< peak::ipl::SharpnessROI >::value_type const &":
        return _peak_ipl_python_interface.SharpnessROIList_back(self)

    def assign(self, n: "std::vector< peak::ipl::SharpnessROI >::size_type", x: "SharpnessROI") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_insert(self, *args)

    def reserve(self, n: "std::vector< peak::ipl::SharpnessROI >::size_type") -> "void":
        return _peak_ipl_python_interface.SharpnessROIList_reserve(self, n)

    def capacity(self) -> "std::vector< peak::ipl::SharpnessROI >::size_type":
        return _peak_ipl_python_interface.SharpnessROIList_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_SharpnessROIList

# Register SharpnessROIList in _peak_ipl_python_interface:
_peak_ipl_python_interface.SharpnessROIList_swigregister(SharpnessROIList)
class VectorVideo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.VectorVideo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.VectorVideo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.VectorVideo___bool__(self)

    def __len__(self) -> "std::vector< unsigned short >::size_type":
        return _peak_ipl_python_interface.VectorVideo___len__(self)

    def __getslice__(self, i: "std::vector< unsigned short >::difference_type", j: "std::vector< unsigned short >::difference_type") -> "std::vector< unsigned short,std::allocator< unsigned short > > *":
        return _peak_ipl_python_interface.VectorVideo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorVideo___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned short >::difference_type", j: "std::vector< unsigned short >::difference_type") -> "void":
        return _peak_ipl_python_interface.VectorVideo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorVideo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned short >::value_type const &":
        return _peak_ipl_python_interface.VectorVideo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorVideo___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned short >::value_type":
        return _peak_ipl_python_interface.VectorVideo_pop(self)

    def append(self, x: "std::vector< unsigned short >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorVideo_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.VectorVideo_empty(self)

    def size(self) -> "std::vector< unsigned short >::size_type":
        return _peak_ipl_python_interface.VectorVideo_size(self)

    def swap(self, v: "VectorVideo") -> "void":
        return _peak_ipl_python_interface.VectorVideo_swap(self, v)

    def begin(self) -> "std::vector< unsigned short >::iterator":
        return _peak_ipl_python_interface.VectorVideo_begin(self)

    def end(self) -> "std::vector< unsigned short >::iterator":
        return _peak_ipl_python_interface.VectorVideo_end(self)

    def rbegin(self) -> "std::vector< unsigned short >::reverse_iterator":
        return _peak_ipl_python_interface.VectorVideo_rbegin(self)

    def rend(self) -> "std::vector< unsigned short >::reverse_iterator":
        return _peak_ipl_python_interface.VectorVideo_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.VectorVideo_clear(self)

    def get_allocator(self) -> "std::vector< unsigned short >::allocator_type":
        return _peak_ipl_python_interface.VectorVideo_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.VectorVideo_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned short >::iterator":
        return _peak_ipl_python_interface.VectorVideo_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.VectorVideo_swiginit(self, _peak_ipl_python_interface.new_VectorVideo(*args))

    def push_back(self, x: "std::vector< unsigned short >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorVideo_push_back(self, x)

    def front(self) -> "std::vector< unsigned short >::value_type const &":
        return _peak_ipl_python_interface.VectorVideo_front(self)

    def back(self) -> "std::vector< unsigned short >::value_type const &":
        return _peak_ipl_python_interface.VectorVideo_back(self)

    def assign(self, n: "std::vector< unsigned short >::size_type", x: "std::vector< unsigned short >::value_type const &") -> "void":
        return _peak_ipl_python_interface.VectorVideo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorVideo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.VectorVideo_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned short >::size_type") -> "void":
        return _peak_ipl_python_interface.VectorVideo_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned short >::size_type":
        return _peak_ipl_python_interface.VectorVideo_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_VectorVideo

# Register VectorVideo in _peak_ipl_python_interface:
_peak_ipl_python_interface.VectorVideo_swigregister(VectorVideo)
class RangeDouble(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "double", max: "double", inc: "double"):
        r"""
        Constructor for the Range

        :type min: float
        :param min:  The minimum value for the range.
        :type max: float
        :param max:  The minimum value for the range.
        :type inc: float
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException
        """
        _peak_ipl_python_interface.RangeDouble_swiginit(self, _peak_ipl_python_interface.new_RangeDouble(min, max, inc))

    def Minimum(self) -> "double":
        r"""
        Get the minimum value for the range

        :rtype: float
        :return: the minimum value.
        """
        return _peak_ipl_python_interface.RangeDouble_Minimum(self)

    def Maximum(self) -> "double":
        r"""
        Get the maximum value for the range

        :rtype: float
        :return: the maximum value.
        """
        return _peak_ipl_python_interface.RangeDouble_Maximum(self)

    def Increment(self) -> "double":
        r"""
        Get the increment value for the range

        :rtype: float
        :return: the increment value.
        """
        return _peak_ipl_python_interface.RangeDouble_Increment(self)

    def InRange(self, value: "double") -> "bool":
        r"""
        Check if the value is in range

        :type value: float
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _peak_ipl_python_interface.RangeDouble_InRange(self, value)
    __swig_destroy__ = _peak_ipl_python_interface.delete_RangeDouble

# Register RangeDouble in _peak_ipl_python_interface:
_peak_ipl_python_interface.RangeDouble_swigregister(RangeDouble)
class RangeUint32(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "unsigned int", max: "unsigned int", inc: "unsigned int"):
        r"""
        Constructor for the Range

        :type min: int
        :param min:  The minimum value for the range.
        :type max: int
        :param max:  The minimum value for the range.
        :type inc: int
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException
        """
        _peak_ipl_python_interface.RangeUint32_swiginit(self, _peak_ipl_python_interface.new_RangeUint32(min, max, inc))

    def Minimum(self) -> "unsigned int":
        r"""
        Get the minimum value for the range

        :rtype: int
        :return: the minimum value.
        """
        return _peak_ipl_python_interface.RangeUint32_Minimum(self)

    def Maximum(self) -> "unsigned int":
        r"""
        Get the maximum value for the range

        :rtype: int
        :return: the maximum value.
        """
        return _peak_ipl_python_interface.RangeUint32_Maximum(self)

    def Increment(self) -> "unsigned int":
        r"""
        Get the increment value for the range

        :rtype: int
        :return: the increment value.
        """
        return _peak_ipl_python_interface.RangeUint32_Increment(self)

    def InRange(self, value: "unsigned int") -> "bool":
        r"""
        Check if the value is in range

        :type value: int
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _peak_ipl_python_interface.RangeUint32_InRange(self, value)
    __swig_destroy__ = _peak_ipl_python_interface.delete_RangeUint32

# Register RangeUint32 in _peak_ipl_python_interface:
_peak_ipl_python_interface.RangeUint32_swigregister(RangeUint32)
class RangeInt32(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "int", max: "int", inc: "int"):
        r"""
        Constructor for the Range

        :type min: int
        :param min:  The minimum value for the range.
        :type max: int
        :param max:  The minimum value for the range.
        :type inc: int
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException
        """
        _peak_ipl_python_interface.RangeInt32_swiginit(self, _peak_ipl_python_interface.new_RangeInt32(min, max, inc))

    def Minimum(self) -> "int":
        r"""
        Get the minimum value for the range

        :rtype: int
        :return: the minimum value.
        """
        return _peak_ipl_python_interface.RangeInt32_Minimum(self)

    def Maximum(self) -> "int":
        r"""
        Get the maximum value for the range

        :rtype: int
        :return: the maximum value.
        """
        return _peak_ipl_python_interface.RangeInt32_Maximum(self)

    def Increment(self) -> "int":
        r"""
        Get the increment value for the range

        :rtype: int
        :return: the increment value.
        """
        return _peak_ipl_python_interface.RangeInt32_Increment(self)

    def InRange(self, value: "int") -> "bool":
        r"""
        Check if the value is in range

        :type value: int
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _peak_ipl_python_interface.RangeInt32_InRange(self, value)
    __swig_destroy__ = _peak_ipl_python_interface.delete_RangeInt32

# Register RangeInt32 in _peak_ipl_python_interface:
_peak_ipl_python_interface.RangeInt32_swigregister(RangeInt32)
class RangeUInt8(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "unsigned char", max: "unsigned char", inc: "unsigned char"):
        r"""
        Constructor for the Range

        :type min: unsigned char
        :param min:  The minimum value for the range.
        :type max: unsigned char
        :param max:  The minimum value for the range.
        :type inc: unsigned char
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException
        """
        _peak_ipl_python_interface.RangeUInt8_swiginit(self, _peak_ipl_python_interface.new_RangeUInt8(min, max, inc))

    def Minimum(self) -> "unsigned char":
        r"""
        Get the minimum value for the range

        :rtype: unsigned char
        :return: the minimum value.
        """
        return _peak_ipl_python_interface.RangeUInt8_Minimum(self)

    def Maximum(self) -> "unsigned char":
        r"""
        Get the maximum value for the range

        :rtype: unsigned char
        :return: the maximum value.
        """
        return _peak_ipl_python_interface.RangeUInt8_Maximum(self)

    def Increment(self) -> "unsigned char":
        r"""
        Get the increment value for the range

        :rtype: unsigned char
        :return: the increment value.
        """
        return _peak_ipl_python_interface.RangeUInt8_Increment(self)

    def InRange(self, value: "unsigned char") -> "bool":
        r"""
        Check if the value is in range

        :type value: unsigned char
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _peak_ipl_python_interface.RangeUInt8_InRange(self, value)
    __swig_destroy__ = _peak_ipl_python_interface.delete_RangeUInt8

# Register RangeUInt8 in _peak_ipl_python_interface:
_peak_ipl_python_interface.RangeUInt8_swigregister(RangeUInt8)
class PixelFormatList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _peak_ipl_python_interface.PixelFormatList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _peak_ipl_python_interface.PixelFormatList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _peak_ipl_python_interface.PixelFormatList___bool__(self)

    def __len__(self) -> "std::vector< enum peak::ipl::PixelFormatName >::size_type":
        return _peak_ipl_python_interface.PixelFormatList___len__(self)

    def __getslice__(self, i: "std::vector< enum peak::ipl::PixelFormatName >::difference_type", j: "std::vector< enum peak::ipl::PixelFormatName >::difference_type") -> "std::vector< peak::ipl::PixelFormatName,std::allocator< peak::ipl::PixelFormatName > > *":
        return _peak_ipl_python_interface.PixelFormatList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _peak_ipl_python_interface.PixelFormatList___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< enum peak::ipl::PixelFormatName >::difference_type", j: "std::vector< enum peak::ipl::PixelFormatName >::difference_type") -> "void":
        return _peak_ipl_python_interface.PixelFormatList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.PixelFormatList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< enum peak::ipl::PixelFormatName >::value_type const &":
        return _peak_ipl_python_interface.PixelFormatList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _peak_ipl_python_interface.PixelFormatList___setitem__(self, *args)

    def pop(self) -> "std::vector< enum peak::ipl::PixelFormatName >::value_type":
        return _peak_ipl_python_interface.PixelFormatList_pop(self)

    def append(self, x: "std::vector< enum peak::ipl::PixelFormatName >::value_type const &") -> "void":
        return _peak_ipl_python_interface.PixelFormatList_append(self, x)

    def empty(self) -> "bool":
        return _peak_ipl_python_interface.PixelFormatList_empty(self)

    def size(self) -> "std::vector< enum peak::ipl::PixelFormatName >::size_type":
        return _peak_ipl_python_interface.PixelFormatList_size(self)

    def swap(self, v: "PixelFormatList") -> "void":
        return _peak_ipl_python_interface.PixelFormatList_swap(self, v)

    def begin(self) -> "std::vector< enum peak::ipl::PixelFormatName >::iterator":
        return _peak_ipl_python_interface.PixelFormatList_begin(self)

    def end(self) -> "std::vector< enum peak::ipl::PixelFormatName >::iterator":
        return _peak_ipl_python_interface.PixelFormatList_end(self)

    def rbegin(self) -> "std::vector< enum peak::ipl::PixelFormatName >::reverse_iterator":
        return _peak_ipl_python_interface.PixelFormatList_rbegin(self)

    def rend(self) -> "std::vector< enum peak::ipl::PixelFormatName >::reverse_iterator":
        return _peak_ipl_python_interface.PixelFormatList_rend(self)

    def clear(self) -> "void":
        return _peak_ipl_python_interface.PixelFormatList_clear(self)

    def get_allocator(self) -> "std::vector< enum peak::ipl::PixelFormatName >::allocator_type":
        return _peak_ipl_python_interface.PixelFormatList_get_allocator(self)

    def pop_back(self) -> "void":
        return _peak_ipl_python_interface.PixelFormatList_pop_back(self)

    def erase(self, *args) -> "std::vector< enum peak::ipl::PixelFormatName >::iterator":
        return _peak_ipl_python_interface.PixelFormatList_erase(self, *args)

    def __init__(self, *args):
        _peak_ipl_python_interface.PixelFormatList_swiginit(self, _peak_ipl_python_interface.new_PixelFormatList(*args))

    def push_back(self, x: "std::vector< enum peak::ipl::PixelFormatName >::value_type const &") -> "void":
        return _peak_ipl_python_interface.PixelFormatList_push_back(self, x)

    def front(self) -> "std::vector< enum peak::ipl::PixelFormatName >::value_type const &":
        return _peak_ipl_python_interface.PixelFormatList_front(self)

    def back(self) -> "std::vector< enum peak::ipl::PixelFormatName >::value_type const &":
        return _peak_ipl_python_interface.PixelFormatList_back(self)

    def assign(self, n: "std::vector< enum peak::ipl::PixelFormatName >::size_type", x: "std::vector< enum peak::ipl::PixelFormatName >::value_type const &") -> "void":
        return _peak_ipl_python_interface.PixelFormatList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _peak_ipl_python_interface.PixelFormatList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _peak_ipl_python_interface.PixelFormatList_insert(self, *args)

    def reserve(self, n: "std::vector< enum peak::ipl::PixelFormatName >::size_type") -> "void":
        return _peak_ipl_python_interface.PixelFormatList_reserve(self, n)

    def capacity(self) -> "std::vector< enum peak::ipl::PixelFormatName >::size_type":
        return _peak_ipl_python_interface.PixelFormatList_capacity(self)
    __swig_destroy__ = _peak_ipl_python_interface.delete_PixelFormatList

# Register PixelFormatList in _peak_ipl_python_interface:
_peak_ipl_python_interface.PixelFormatList_swigregister(PixelFormatList)

