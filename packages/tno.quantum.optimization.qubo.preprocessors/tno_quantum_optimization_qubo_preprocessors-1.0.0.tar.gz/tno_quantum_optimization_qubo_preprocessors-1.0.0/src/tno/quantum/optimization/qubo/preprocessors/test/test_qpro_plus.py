"""This module contains tests for the ``reduce_qpro_plus`` function."""

from __future__ import annotations

import itertools
from math import floor

import numpy as np
import pytest

from tno.quantum.optimization.qubo.components import QUBO
from tno.quantum.optimization.qubo.preprocessors._qpro_plus import reduce_qpro_plus
from tno.quantum.utils import BitVector


@pytest.fixture
def max_iter() -> int:
    return 100


@pytest.fixture
def rng() -> np.random.Generator:
    return np.random.default_rng(42)


@pytest.fixture
def qubo() -> QUBO:
    return QUBO(
        [
            [6, 0, 0, 0, 0],
            [0, 5, -3, -4, 0],
            [0, -3, 3, -3, 0],
            [0, -4, -3, 2, 0],
            [0, 0, 0, 0, -5],
        ]
    )


@pytest.fixture
def expected_bitvector() -> BitVector:
    return BitVector("01111")


def test_reduce_qpro_plus(qubo: QUBO, max_iter: int) -> None:
    """Test QUBO reduction using QPro+ algorithm, expect solution "01111"."""
    partial_solution, qubo_reduced = reduce_qpro_plus(
        qubo, max_iter=max_iter, verbose=True
    )

    # Verify solution
    assert len(partial_solution.free_variables()) == 0
    solution = partial_solution.expand([])
    assert partial_solution.expand([]) == BitVector("01111")
    # Verify QUBO is completely reduced
    assert qubo_reduced.size == 0
    # Verify evaluations
    assert qubo.evaluate(solution) == qubo_reduced.evaluate([])


@pytest.mark.parametrize("qubo_size", list(range(1, 8)))
def test_qubo_simplification(
    qubo_size: int, max_iter: int, rng: np.random.Generator
) -> None:
    """Brute force compare outcomes of reduced qubo with its original qubo.
    The qubo is generated by sampling a normal distribution with mean=0, var=10
    For each qubo size in QUBO_SIZES there are NUM_ITT number of repetitions
    """
    for _ in range(max_iter):
        qubo_matrix = rng.normal(0, 10, (qubo_size, qubo_size))
        qubo_original = QUBO(qubo_matrix)
        partial_solution, qubo_reduced = reduce_qpro_plus(qubo_original)
        for guess, outcome in brute_force(qubo_reduced).items():
            original_guess = partial_solution.expand(guess)
            original_qubo_outcome = qubo_original.evaluate(original_guess)
            assert outcome == pytest.approx(original_qubo_outcome, 10**-6)


@pytest.mark.parametrize("qubo_size", list(range(1, 8)))
def test_qubo_optimal_solution(
    qubo_size: int, max_iter: int, rng: np.random.Generator
) -> None:
    """Brute force compare optimal solution of reduced qubo with its original qubo.
    The qubo is generated by sampling a normal distribution with mean=0, var=10
    For each qubo size in QUBO_SIZES there are NUM_ITT number of repetitions
    """
    for _ in range(max_iter):
        qubo_matrix = rng.normal(0, 10, (qubo_size, qubo_size))
        qubo_original = QUBO(qubo_matrix)
        partial_solution, qubo_reduced = reduce_qpro_plus(qubo_original)
        solution = brute_force_solution(qubo_original)
        solution_reduced = brute_force_solution(qubo_reduced)
        assert partial_solution.expand(solution_reduced) == BitVector(solution)


@pytest.mark.parametrize("qubo_size", list(range(1, 8)))
@pytest.mark.parametrize("sparsity", list(np.linspace(0, 1, 21)))
def test_brute_force_sparse_qubo(
    qubo_size: int, sparsity: float, max_iter: int, rng: np.random.Generator
) -> None:
    """Brute force compare outcomes of reduced qubo with its original qubo.
    The qubo is generated by sampling a sparse qubo with SPARSITY% non zeros
    For each qubo size in QUBO_SIZES there are NUM_ITT number of repetitions
    """
    num_non_zeros = floor(sparsity * qubo_size * qubo_size)
    num_zeros = qubo_size * qubo_size - num_non_zeros

    rng = np.random.default_rng(1337)

    for _ in range(max_iter):
        # Create sparse qubo
        non_zeros = rng.normal(0, 10, num_non_zeros)
        zeros = np.zeros(num_zeros)
        qubo_matrix = np.concatenate((non_zeros, zeros), axis=0).reshape(
            (qubo_size, qubo_size)
        )
        rng.shuffle(qubo_matrix)

        original_qubo = QUBO(qubo_matrix)
        partial_solution, reduced_qubo = reduce_qpro_plus(original_qubo, max_iter=10)

        for guess, outcome in brute_force(reduced_qubo).items():
            original_guess = partial_solution.expand(guess)
            original_qubo_outcome = original_qubo.evaluate(original_guess)
            assert outcome == pytest.approx(original_qubo_outcome, 10**-6)


def brute_force(qubo: QUBO) -> dict[str, float]:
    """Naive brute force of qubo results."""
    if qubo.size == 0:
        return {"": qubo.offset}

    guess_iterable = map("".join, itertools.product("01", repeat=qubo.size))
    return {guess: qubo.evaluate(guess) for guess in guess_iterable}


def brute_force_solution(qubo: QUBO) -> str:
    solution = ""
    min_outcome = None
    for guess, outcome in brute_force(qubo).items():
        if min_outcome is None or outcome < min_outcome:
            solution = guess
            min_outcome = outcome
    return solution
