<html data-bs-theme="dark">

<head>
    <title>"placeholder_dashboard_title"</title>
    <!-- ChartJs import -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

    <!-- ChartJs Datalabel plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- ChartJs timeline plugin (helps create time axis) -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- ChartJs boxplot plugin (for time deviation graph) -->
    <script type="text/javascript"
        src="https://unpkg.com/@sgratzl/chartjs-chart-boxplot@3.6.0/build/index.umd.min.js"></script>

    <!-- DataTables and Bootstrap imports -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet" />
    <link href="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon"
        href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA==" />

    <style>
        :root {
            font-family: Helvetica, sans-serif;
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #eee;
            }

            .fullscreen,
            .sticky-top {
                background: #eee;
            }
        }

        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
            }

            .fullscreen,
            .sticky-top {
                background: #212529;
            }
        }

        .canvas {
            width: 800px;
            height: 540px;
            text-align: center;
        }

        .canvas-vertical {
            overflow-y: auto;
        }

        .card {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .sticky-top {
            padding-top: 6px;
        }

        .dt-container {
            margin-top: 20px;
        }

        .stats {
            float: right;
            text-align: right;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .fullscreen {
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            z-index: 10;
            padding: 11px 20px 70px 20px;
        }

        .selectBox {
            position: relative;
        }

        .selectBox select {
            width: 100%;
        }

        .overSelect {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        #checkboxes {
            display: none;
            position: absolute;
            z-index: 2;
        }

        #checkboxes label {
            display: block;
        }

        .border,
        .controls {
            min-height: 165px;
        }

        .hideItemText {
            margin-right: auto;
        }

        .moveUp {
            margin: 5px 2px 0px 2px;
            padding: 2px 1px 2px 1px;
            height: 16px !important;
        }

        .moveDown {
            margin: 5px 2px 0px 2px;
            padding: 3px 1px 2px 1px;
            height: 16px !important;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="sticky-top" id="filterSection">
            <div class="card-body">
                <div class="row border-bottom pb-1">
                    <div class="col-10">
                        <div class="row">
                            <div class="col-auto">
                                <h1>"placeholder_dashboard_title"</h1>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="runs">Runs</label>
                                <select class="form-select form-select-sm" id="runs"></select>
                            </div>
                            <div class="col-auto">
                                <div class="selectBox" id="selectRunTags">
                                    <label class="form-label form-label-sm" for="runTag">Run Tags</label>
                                    <select class="form-select form-select-sm">
                                        <option>Select Tags</option>
                                    </select>
                                    <div class="overSelect"></div>
                                </div>
                                <div id="checkboxes">
                                    <ul class="list-group" id="runTag"></ul>
                                </div>
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="fromDate">From Date</label>
                                <input class="form-control form-control-sm" id="fromDate" type="date" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="fromTime">From Time</label>
                                <input class="form-control form-control-sm" id="fromTime" type="time" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="toDate">To Date</label>
                                <input class="form-control form-control-sm" id="toDate" type="date" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="toTime">To Time</label>
                                <input class="form-control form-control-sm" id="toTime" type="time" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="amount"
                                    title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters.">Run
                                    Amount</label>
                                <input class="form-control form-control-sm" type="number" min=0 id="amount"
                                    title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters."
                                    value="10">
                            </div>
                            <div class="col-auto d-flex">
                                <button class="btn btn-outline-primary btn-sm mt-auto" id="resetFilters">Reset
                                    Filters</button>
                            </div>
                            <div class="col-auto d-flex">
                                <button type="button" class="btn btn-outline-primary btn-sm mt-auto"
                                    data-bs-toggle="modal" data-bs-target="#hideModal" id="customizeView">
                                    Customize View
                                </button>
                            </div>
                            <div class="col-auto mt-auto">
                                <a href="/">
                                    <button class="btn btn-outline-primary btn-sm" id="openDashboard" hidden>Open Admin
                                        Page</button>
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="col-2 stats">
                        <span id="stats"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="text-center mt-5" id="loading" style="display: none;">
            <div class="spinner-border" style="width: 5rem; height: 5rem;" role="status">
                <span class="sr-only"></span>
            </div>
        </div>

        <div class="card" id="runStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary collapse-icon" id="runDetailsButton"
                            data-bs-toggle="collapse" data-bs-target="#runData" aria-expanded="true"
                            aria-controls="runData"></div>
                    </div>
                    <div class="col">
                        <h3 id="runTitle">Statistics</h3>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card runData -->
            <div id="runDataHiddenTemp" hidden></div>
            <div id="runDataHidden" hidden>
                <!-- Run Statistics -->
                <div class="col canvas mb-5" id="runStatisticsCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled"
                        id="runStatisticsGraphPercentages">Percentages</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="runStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="runStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="runStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runStatisticsClose"
                        hidden>Close</button>
                    <canvas id="runStatisticsGraph"></canvas>
                </div>
                <!-- Run Duration -->
                <div class="col canvas mb-5" id="runDurationCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="runDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="runDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runDurationClose" hidden>Close</button>
                    <canvas id="runDurationGraph"></canvas>
                </div>
                <!-- Run Table -->
                <div class="col" id="runTableCanvas">
                    <table class="table table-striped" id="runTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="runData"></div>
        </div>

        <div class="card" id="suiteStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary collapse-icon" id="suiteDetailsButton"
                            data-bs-toggle="collapse" data-bs-target="#suiteData" aria-expanded="true"
                            aria-controls="suiteData"></div>
                    </div>
                    <div class="col-4">
                        <h3 id="suiteTitle">Suite Statistics</h3>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectSuites">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectSuites"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card suiteData -->
            <div id="suiteDataHiddenTemp" hidden></div>
            <div id="suiteDataHidden" hidden>
                <!-- Suite Statistics -->
                <div class="col canvas mb-5" id="suiteStatisticsCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled"
                        id="suiteStatisticsGraphPercentages">Percentages</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="suiteStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteStatisticsClose"
                        hidden>Close</button>
                    <canvas id="suiteStatisticsGraph"></canvas>
                </div>
                <!-- Suite Duration -->
                <div class="col canvas mb-5" id="suiteDurationCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="suiteDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="suiteDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteDurationClose"
                        hidden>Close</button>
                    <canvas id="suiteDurationGraph"></canvas>
                </div>
                <!-- Suite Most Failed -->
                <div class="col canvas mb-5" id="suiteMostFailedCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="suiteMostFailedGraphBar">Bar
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteMostFailedGraphTimeline">Timeline
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="suiteMostFailedFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteMostFailedClose"
                        hidden>Close</button>
                    <canvas id="suiteMostFailedGraph"></canvas>
                </div>
                <!-- Suite Table -->
                <div class="col" id="suiteTableCanvas">
                    <table class="table table-striped" id="suiteTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="suiteData"></div>
        </div>

        <div class="card" id="testStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary collapse-icon" id="testDetailsButton"
                            data-bs-toggle="collapse" data-bs-target="#testData" aria-expanded="true"
                            aria-controls="testData"></div>
                    </div>
                    <div class="col-4">
                        <h3 id="testTitle">Test Statistics</h3>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectTests">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectTests"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testTagsSelect">Test Tags</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testTagsSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testSelect">Test</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="showOnlySelectedtestStatistics">Show Only
                                Test</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="showOnlySelectedtestStatistics" />
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="testDataHiddenTemp" hidden></div>
            <div id="testDataHidden" hidden>
                <!-- Test Statistics -->
                <div class="col canvas canvas-vertical" id="testStatisticsCanvas">
                    <div id="testStatisticsVertical">
                        <button class="btn btn-primary btn-sm mb-3 mt-1 disabled"
                            id="testStatisticsGraphTimeline">Timeline
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="testStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testStatisticsClose"
                            hidden>Close</button>
                        <canvas id="testStatisticsGraph"></canvas>
                    </div>
                </div>
                <!-- Test Duration -->
                <div class="col canvas mb-5" id="testDurationCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="testDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="testDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationClose"
                        hidden>Close</button>
                    <canvas id="testDurationGraph"></canvas>
                </div>
                <!-- Test Duration Deviation -->
                <div class="col canvas mb-5" id="testDurationDeviationCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="testDurationDeviationGraphBar">Boxplot
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="testDurationDeviationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationDeviationClose"
                        hidden>Close</button>
                    <canvas id="testDurationDeviationGraph"></canvas>
                </div>
                <!-- Test Most Flaky -->
                <div class="col canvas mb-5" id="testMostFlakyCanvas">
                    <div class="btn-group me-1">
                        <label class="form-check-label mb-2" for="ignoreSkips">Ignore Skips</label>
                    </div>
                    <div class="btn-group form-switch me-1">
                        <input class="form-check-input mb-2" type="checkbox" role="switch" id="ignoreSkips">
                    </div>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="testMostFlakyGraphTimeline">Timeline
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyFullscreen"
                        style="margin-right:56px;">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyClose" hidden
                        style="margin-right:56px;">Close</button>
                    <canvas id="testMostFlakyGraph"></canvas>
                </div>
                <!-- Test Recent Most Flaky -->
                <div class="col canvas mb-5" id="testRecentMostFlakyCanvas">
                    <div class="btn-group me-1">
                        <label class="form-check-label mb-2" for="ignoreSkipsRecent">Ignore Skips</label>
                    </div>
                    <div class="btn-group form-switch me-1">
                        <input class="form-check-input mb-2" type="checkbox" role="switch" id="ignoreSkipsRecent">
                    </div>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testRecentMostFlakyGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled"
                        id="testRecentMostFlakyGraphTimeline">Timeline View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testRecentMostFlakyFullscreen"
                        style="margin-right:56px;">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testRecentMostFlakyClose" hidden
                        style="margin-right:56px;">Close</button>
                    <canvas id="testRecentMostFlakyGraph"></canvas>
                </div>
                <!-- Test Most Failed -->
                <div class="col canvas mb-5" id="testMostFailedCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFailedGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="testMostFailedGraphTimeline">Timeline
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="testMostFailedFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFailedClose"
                        hidden>Close</button>
                    <canvas id="testMostFailedGraph"></canvas>
                </div>
                <!-- Test Messages -->
                <div class="col canvas mb-5" id="testMessagesCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMessagesGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="testMessagesGraphTimeline">Timeline
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="testMessagesFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMessagesClose"
                        hidden>Close</button>
                    <canvas id="testMessagesGraph"></canvas>
                </div>
                <!-- Test Table -->
                <div class="col" id="testTableCanvas">
                    <table class="table table-striped" id="testTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="testData"></div>
        </div>

        <div class="card" id="keywordStatisticsSection" style="display: none;">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary collapse-icon" id="keywordDetailsButton"
                            data-bs-toggle="collapse" data-bs-target="#keywordData" aria-expanded="true"
                            aria-controls="keywordData"></div>
                    </div>
                    <div class="col-4">
                        <h3 id="keywordTitle">Keyword Statistics</h3>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="keywordSelect">Keyword</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="keywordSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="keywordDataHiddenTemp" hidden></div>
            <div id="keywordDataHidden" hidden>
                <!-- Keyword Statistics -->
                <div class="col canvas mb-5" id="keywordStatisticsCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled"
                        id="keywordStatisticsGraphPercentages">Percentages</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordStatisticsClose"
                        hidden>Close</button>
                    <canvas id="keywordStatisticsGraph"></canvas>
                </div>
                <!-- Keyword Times Run -->
                <div class="col canvas mb-5" id="keywordTimesRunCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="keywordTimesRunGraphBar">Bar
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTimesRunGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordTimesRunFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTimesRunClose"
                        hidden>Close</button>
                    <canvas id="keywordTimesRunGraph"></canvas>
                </div>
                <!-- Keyword Total Duration -->
                <div class="col canvas mb-5" id="keywordTotalDurationCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTotalDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="keywordTotalDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordTotalDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTotalDurationClose"
                        hidden>Close</button>
                    <canvas id="keywordTotalDurationGraph"></canvas>
                </div>
                <!-- Keyword Average Duration -->
                <div class="col canvas mb-5" id="keywordAverageDurationCanvas">
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordAverageDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="keywordAverageDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordAverageDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordAverageDurationClose"
                        hidden>Close</button>
                    <canvas id="keywordAverageDurationGraph"></canvas>
                </div>
                <!-- Keyword Min Duration -->
                <div class="col canvas mb-5" id="keywordMinDurationCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="keywordMinDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMinDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordMinDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMinDurationClose"
                        hidden>Close</button>
                    <canvas id="keywordMinDurationGraph"></canvas>
                </div>
                <!-- Keyword Max Duration -->
                <div class="col canvas mb-5" id="keywordMaxDurationCanvas">
                    <button class="btn btn-primary btn-sm mb-3 mt-1 disabled" id="keywordMaxDurationGraphBar">Bar
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMaxDurationGraphLine">Line
                        View</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                        id="keywordMaxDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMaxDurationClose"
                        hidden>Close</button>
                    <canvas id="keywordMaxDurationGraph"></canvas>
                </div>
                <!-- Keyword Table -->
                <div class="col" id="keywordTableCanvas">
                    <table class="table table-striped" id="keywordTable"></table>
                </div>
            </div>
            <div class="card-body collapse show" id="keywordData"></div>
        </div>

        <!-- Modal for hiding graphs/sections -->
        <div class="modal fade" id="hideModal" tabindex="-1" aria-labelledby="hideModalLabel" data-bs-backdrop="static">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="hideModalLabel">Customize View</h1>
                        <div>
                            <button type="button" class="btn btn-outline-primary btn-sm mt-auto" data-bs-dismiss="modal"
                                id="resetHide">Reset View</button>
                            <button type="button" class="btn btn-outline-primary btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal" id="saveHide">Save</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="row justify-content-evenly">
                            <div class="col">
                                <h2>Sections</h2>
                            </div>
                            <div class="col">
                                <h2>Graphs</h2>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col">
                                <h4>Show</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm btn-secondary" id="sectionRight"></button>
                                    <button class="btn btn-sm btn-secondary" id="sectionLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Hide</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionHide" class="list-group"></ol>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Show</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm btn-secondary" id="graphRight"></button>
                                    <button class="btn btn-sm btn-secondary" id="graphLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Hide</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphHide" class="list-group"></ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /////////////////////////////
        // GLOBAL VARIABLE SECTION //
        /////////////////////////////

        // collapse/expand buttons icons/svgs
        const arrowRight =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowRightSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><g><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowDown =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowDownSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowLeft =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g transform="scale(-1,1) translate(-52,0)"><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"/></g></svg>';
        const arrowDownVerySmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowUpVerySmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,0,0)"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"></path></svg>';

        // colors
        const passedBackgroundBorderColor = "#97bd61";
        const passedBackgroundColor = "rgba(151, 189, 97, 0.7)";
        const skippedBackgroundBorderColor = "#fed84f";
        const skippedBackgroundColor = "rgba(254, 216, 79, 0.7)";
        const failedBackgroundBorderColor = "#ce3e01";
        const failedBackgroundColor = "rgba(206, 62, 1, 0.7)";
        const greyBackgroundBorderColor = "#212529";
        const greyBackgroundColor = "rgba(33, 37, 41, 0.7)";

        // prepare input data
        var runs = "placeholder_runs".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var suites = "placeholder_suites".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var tests = "placeholder_tests".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var keywords = "placeholder_keywords".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var message_config = '"placeholder_message_config"'
        const use_logs = "placeholder_use_logs"
        const use_run_aliases = "placeholder_use_run_aliases"
        const server = "placeholder_server"
        if (!message_config.includes('placeholder_message_config')) { message_config = JSON.parse(message_config) }

        // create graphs
        var runStatisticsGraph;
        var runDurationGraph;
        var runTable;
        var suiteStatisticsGraph;
        var suiteDurationGraph;
        var suiteMostFailedGraph;
        var suiteTable;
        var testStatisticsGraph;
        var testDurationGraph;
        var testMostFlakyGraph;
        var testRecentMostFlakyGraph;
        var testDurationDeviationGraph;
        var testMostFailedGraph;
        var testMessagesGraph
        var testTable;
        var keywordStatisticsGraph;
        var keywordTimesRunGraph;
        var keywordTotalDurationGraph;
        var keywordAverageDurationGraph;
        var keywordMinDurationGraph;
        var keywordMaxDurationGraph;
        var keywordTable;

        // filtered data vars
        var filteredRuns;
        var filteredSuites;
        var filteredTests;
        var filteredKeywords;

        // var to keep track of the checkbox statuses
        var showOnlySelectedtestStatistics = false;
        var ignoreSkips = false; // test most flaky graph
        var ignoreSkipsRecent = false; // test recent most flaky graph
        let showingRunTags = false; // used to keep track if the runtags popup is showing and determine if it should be closed when clicked outside
        var filteredAmount = "placeholder_amount"

        // add items in hide modal
        const hideSections = [
            "Run Statistics",
            "Suite Statistics",
            "Test Statistics",
            "Keyword Statistics",
        ]
        const hideGraphs = [
            "Run Statistics",
            "Run Duration",
            "Run Table",
            "Suite Statistics",
            "Suite Duration",
            "Suite Most Failed",
            "Suite Table",
            "Test Statistics",
            "Test Duration",
            "Test Duration Deviation",
            "Test Most Flaky",
            "Test Recent Most Flaky",
            "Test Most Failed",
            "Test Messages",
            "Test Table",
            "Keyword Statistics",
            "Keyword Times Run",
            "Keyword Total Duration",
            "Keyword Average Duration",
            "Keyword Min Duration",
            "Keyword Max Duration",
            "Keyword Table"
        ]
        var hideItem = `<li class="hideItem list-group-item list-group-item-action d-flex {type}">
            <div class="hideItemText">{value}</div>
            <button class="btn btn-sm btn-secondary moveDown"></button>
            <button class="btn btn-sm btn-secondary moveUp"></button>
            </li>`

        /////////////////////////////
        // GENERIC SETUP FUNCTIONS //
        /////////////////////////////

        // theme function based on browser/machine color scheme
        function setup_theme() {
            if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                Chart.defaults.color = "#e2e1d7";
                Chart.defaults.borderColor = "rgba(255,255,255,0.1)";
                Chart.defaults.backgroundColor = "rgba(255,255,0,0.1)";
                Chart.defaults.elements.line.borderColor = "rgba(255,255,0,0.4)";
            } else {
                document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "light");
            }
        }

        // set default values
        function setup_stats() {
            document.getElementById("stats").innerHTML = `<i><a href="https://github.com/timdegroot1996/robotframework-dashboard" target="_blank">"placeholder_version"</a></i><br>
            <b>Database Summary</b><br>
            Runs: ${runs.length}<br>
            Suites: ${suites.length}<br>
            Tests: ${tests.length}<br>
            Keywords: ${keywords.length}`;

            document.getElementById('amount').value = filteredAmount
            if (server) {
                document.getElementById('openDashboard').hidden = false
            }
        }

        // function to setup all collapse buttons and icons
        function setup_collapsables() {
            // initialize all collapsables by adding the eventlisteners to the buttons
            const collapsables = document.querySelectorAll('.collapse-icon')
            for (let collapsable of collapsables) {
                update_collapse_button(collapsable);
                collapsable.addEventListener("click", (e) => {
                    update_collapse_button(collapsable);
                });
            }
            // function that handles the setting of the correct icon when expanding/collapsing sections
            function update_collapse_button(element) {
                if (element.className.includes("collapsed")) {
                    if (element.id.includes('Details')) {
                        element.innerHTML = arrowRight;
                    } else {
                        element.innerHTML = arrowRightSmall;
                    }
                } else {
                    if (element.id.includes('Details')) {
                        element.innerHTML = arrowDown;
                    } else {
                        element.innerHTML = arrowDownSmall;
                    }
                }
            }
        }

        // function to add a spinner for slow loads
        function setup_spinner(hide) {
            if (hide) {
                $('#loading').fadeOut(100)
                $('#runStatisticsSection').fadeIn()
                $('#suiteStatisticsSection').fadeIn()
                $('#testStatisticsSection').fadeIn()
                $('#keywordStatisticsSection').fadeIn()
            } else {
                $('#runStatisticsSection').hide()
                $('#suiteStatisticsSection').hide()
                $('#testStatisticsSection').hide()
                $('#keywordStatisticsSection').hide()
                $('#loading').show();
            }
        }

        // function to convert to camelcase
        function space_to_camelcase(string) {
            return string.replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
                return index === 0 ? word.toLowerCase() : word.toUpperCase();
            }).replace(/\s+/g, '');
        }

        // function to convert to camelcase from underscores
        function underscore_to_camelcase(str) {
            return str.replace(/_(.)/g, (match, group) => group.toUpperCase());
        }

        // function to convert a date object to the desired string format
        function format_date_to_string(date) {
            const pad = (n) => n.toString().padStart(2, '0');

            const year = date.getFullYear();
            const month = pad(date.getMonth() + 1); // Months are 0-indexed
            const day = pad(date.getDate());
            const hours = pad(date.getHours());
            const minutes = pad(date.getMinutes());
            const seconds = pad(date.getSeconds());

            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        function transform_file_path(filePath) {
            // Normalize path separators to handle both '\\' and '/'
            const normalizedPath = filePath.replace(/\\/g, '/');
            // Split the path into segments
            const pathSegments = normalizedPath.split('/');
            // Extract the filename
            const filename = pathSegments.pop();
            // Replace 'output' with 'log' in the filename
            const updatedFilename = filename.replace(/output/g, 'log').replace(/\.xml$/i, '.html');
            // Reconstruct the path with the updated filename
            const updatedPath = [...pathSegments, updatedFilename].join('/');
            // Restore original path separators if the original path used backslashes
            return filePath.includes('\\') ? updatedPath.replace(/\//g, '\\') : updatedPath;
        }

        // function used to combine paths to open the correct log file, used in combination with a file server
        function combine_paths(baseUrlStr, relativePath) {
            const baseUrl = new URL(baseUrlStr);
            const baseParts = baseUrl.pathname.split('/').filter(Boolean);
            const relParts = relativePath.replaceAll('\\', '/').split('/').filter(Boolean);

            // Find the first matching folder name from the relative path in the base path
            let match = null;
            for (let i = 0; i < relParts.length; i++) {
                const folder = relParts[i];
                const baseMatchIndex = baseParts.lastIndexOf(folder);
                if (baseMatchIndex !== -1) {
                    match = { baseIndex: baseMatchIndex, relIndex: i };
                    break;
                }
            }

            let combinedParts;
            if (match) {
                const baseSlice = baseParts.slice(0, match.baseIndex);
                const relSlice = relParts.slice(match.relIndex);
                combinedParts = [...baseSlice, ...relSlice];
            } else {
                combinedParts = relParts;
            }

            // Resolve "." and ".."
            const resolvedParts = [];
            for (const part of combinedParts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (resolvedParts.length > 0) resolvedParts.pop();
                } else {
                    resolvedParts.push(part);
                }
            }

            return baseUrl.origin + '/' + resolvedParts.join('/');
        }

        //////////////////////////////
        // CUSTOMIZE VIEW FUNCTIONS //
        //////////////////////////////

        // function to update the arrows in the customize modal
        function setup_customize_view_arrow_eventlisteners() {
            // function to move the items from showing to hidden
            function move_items(fromId, toId) {
                const fromBox = document.getElementById(fromId);
                const toBox = document.getElementById(toId);
                const selectedItems = fromBox.querySelectorAll('.active');

                const fromStorage = JSON.parse(localStorage.getItem(fromId));
                const toStorage = JSON.parse(localStorage.getItem(toId));

                for (let item of selectedItems) {
                    const val = item.children[0].innerText;
                    if (toId.includes('Hide')) {
                        if (!toStorage.includes(val)) toStorage.push(val);
                        const identifier = val.split(" ")[0];
                        if (toId.includes('section')) disable_graphs_in_customize_view(true, identifier);
                    } else {
                        const index = fromStorage.indexOf(val);
                        if (index !== -1) fromStorage.splice(index, 1);
                        const identifier = val.split(" ")[0];
                        if (toId.includes('section')) disable_graphs_in_customize_view(false, identifier);
                    }
                }

                localStorage.setItem(fromId, JSON.stringify(fromStorage));
                localStorage.setItem(toId, JSON.stringify(toStorage));

                selectedItems.forEach(item => {
                    item.classList.remove('active');
                    if (toId === 'graphShow') {
                        const section = item.children[0].innerText.split(' ')[0];
                        const listItems = document.getElementById('graphShow').querySelectorAll('.hideItem');
                        let lastMatchingItem = Array.from(listItems).reverse().find(li => {
                            return li.children[0].innerText.startsWith(section);
                        }) || listItems[listItems.length - 1];
                        lastMatchingItem?.after(item);
                    } else {
                        toBox.appendChild(item);
                    }
                });
            }

            // Map the arrow actions and associated operations
            const arrowMappings = {
                'sectionRight': { from: 'sectionShow', to: 'sectionHide', content: arrowRight },
                'sectionLeft': { from: 'sectionHide', to: 'sectionShow', content: arrowLeft },
                'graphRight': { from: 'graphShow', to: 'graphHide', content: arrowRight },
                'graphLeft': { from: 'graphHide', to: 'graphShow', content: arrowLeft }
            };

            // Initialize arrows with their respective functionality and content
            for (let arrow in arrowMappings) {
                const { from, to, content } = arrowMappings[arrow];
                // Update button content based on direction
                update_arrow_button(arrow, content);
                // Add event listener to each arrow button
                document.getElementById(arrow).addEventListener("click", () => {
                    move_items(from, to);
                });
            }

            // Function to update arrow button content
            function update_arrow_button(id, content) {
                document.getElementById(id).innerHTML = content;
            }
        }

        // function to handle the setting of the localstorge for customized view
        function setup_customize_view_local_storage() {
            const adminDefaults = {
                sectionHide: "placeholder_admin_section_hide",
                sectionShow: "placeholder_admin_section_show",
                graphHide: "placeholder_admin_graph_hide",
                graphShow: "placeholder_admin_graph_show"
            };

            const keys = Object.keys(adminDefaults);

            // Helper: Convert legacy "'item1','item2'" string into array
            function migrate_legacy_string(value) {
                if (typeof value === 'string') {
                    return value.split(',')
                        .map(v => v.trim().replace(/^'+|'+$/g, '')) // strip surrounding single quotes
                        .filter(v => v !== '');
                }
                return [];
            }

            // Handle migration or init of all keys
            keys.forEach(key => {
                let raw = localStorage.getItem(key);

                if (raw === null) {
                    // Not present at all → store empty array
                    localStorage.setItem(key, JSON.stringify([]));
                } else {
                    try {
                        // Try parsing as JSON array (new format)
                        const parsed = JSON.parse(raw);
                        if (!Array.isArray(parsed)) throw new Error('Not an array');
                    } catch (e) {
                        // Legacy format → migrate to array
                        const migrated = migrate_legacy_string(raw);
                        localStorage.setItem(key, JSON.stringify(migrated));
                    }
                }
            });

            // Apply admin defaults only if all are still empty arrays
            const allEmpty = keys.every(key => {
                const val = JSON.parse(localStorage.getItem(key));
                return Array.isArray(val) && val.length === 0;
            });

            // Actually set the defaults, either admin or normal
            if (allEmpty) {
                if (
                    !adminDefaults.sectionHide.includes('placeholder_admin') &&
                    (
                        adminDefaults.sectionShow.length > 0 ||
                        adminDefaults.graphShow.length > 0 ||
                        adminDefaults.sectionHide.length > 0 ||
                        adminDefaults.graphHide.length > 0
                    )
                ) {
                    // the admin defaults are set
                    keys.forEach(key => {
                        localStorage.setItem(key, JSON.stringify(adminDefaults[key]));
                    });
                } else {
                    // there is no admin defaults so use the regular defaults
                    localStorage.setItem('sectionShow', JSON.stringify(hideSections))
                    localStorage.setItem('graphShow', JSON.stringify(hideGraphs))
                }
            }

            // Graph type defaults (unchanged)
            const defaultGraphTypes = {
                runStatisticsGraphType: "percentages",
                runDurationGraphType: "line",
                suiteStatisticsGraphType: "percentages",
                suiteDurationGraphType: "line",
                suiteMostFailedGraphType: "bar",
                testStatisticsGraphType: "timeline",
                testDurationGraphType: "line",
                testMostFlakyGraphType: "timeline",
                testRecentMostFlakyGraphType: "timeline",
                testDurationDeviationGraphType: "bar",
                testMostFailedGraphType: "timeline",
                testMessagesGraphType: "timeline",
                keywordStatisticsGraphType: "percentages",
                keywordTimesRunGraphType: "bar",
                keywordTotalDurationGraphType: "line",
                keywordAverageDurationGraphType: "line",
                keywordMinDurationGraphType: "bar",
                keywordMaxDurationGraphType: "bar"
            };

            let storedTypes = localStorage.getItem("graphTypes");
            if (!storedTypes) {
                localStorage.setItem("graphTypes", JSON.stringify(defaultGraphTypes));
                storedTypes = defaultGraphTypes;
            } else {
                storedTypes = JSON.parse(storedTypes);
            }

            for (let key in storedTypes) {
                window[key] = storedTypes[key];
                update_button_selection(key.replace('GraphType', ''), storedTypes[key]);
            }
        }

        // function to update the localstorage of the graphtypes
        function update_graph_type(graph, type) {
            const storedTypes = JSON.parse(localStorage.getItem("graphTypes") || '{}');
            storedTypes[graph] = type;
            localStorage.setItem("graphTypes", JSON.stringify(storedTypes));
            // Also update global variable
            window[graph] = type;
        }

        function update_button_selection(camelButtonName, graphType) {
            const buttons = ['Bar', 'Line', 'Timeline', 'Percentages', 'Amount']; // All possible button types
            buttons.forEach(button => {
                const buttonId = `${camelButtonName}Graph${button}`;
                if (document.getElementById(buttonId)) {
                    if (button.toLowerCase() === graphType) {
                        document.getElementById(buttonId).classList.add("disabled");
                        document.getElementById(buttonId).classList.remove("btn-outline-primary");
                        document.getElementById(buttonId).classList.add("btn-primary");
                    } else {
                        document.getElementById(buttonId).classList.remove("disabled");
                        document.getElementById(buttonId).classList.remove("btn-primary");
                        document.getElementById(buttonId).classList.add("btn-outline-primary");
                    }
                }
            });
        }

        // create the modal with the correct layout based on localstorage
        function setup_customize_view_content() {
            const graphShow = JSON.parse(localStorage.getItem('graphShow'));
            const graphHide = JSON.parse(localStorage.getItem('graphHide'));
            const sectionShow = JSON.parse(localStorage.getItem('sectionShow'));
            const sectionHide = JSON.parse(localStorage.getItem('sectionHide'));

            let graphShowItems = '', graphHideItems = '';
            let sectionShowItems = '', sectionHideItems = '';

            for (let graph of [...graphShow, ...graphHide]) {
                const element = hideItem.replaceAll('{value}', graph).replaceAll('{type}', 'graph');
                if (graphHide.includes(graph)) {
                    graphHideItems += element;
                } else {
                    graphShowItems += element;
                }
            }
            document.getElementById('graphShow').innerHTML = graphShowItems;
            document.getElementById('graphHide').innerHTML = graphHideItems;

            for (let section of [...sectionShow, ...sectionHide]) {
                const element = hideItem.replaceAll('{value}', section).replaceAll('{type}', 'section');
                if (sectionHide.includes(section)) {
                    const identifier = section.split(' ')[0];
                    disable_graphs_in_customize_view(true, identifier);
                    sectionHideItems += element;
                } else {
                    sectionShowItems += element;
                }
            }
            document.getElementById('sectionShow').innerHTML = sectionShowItems;
            document.getElementById('sectionHide').innerHTML = sectionHideItems;

            document.querySelectorAll('.graph .moveUp, .section .moveUp').forEach(item => {
                item.innerHTML = arrowUpVerySmall;
                item.addEventListener('click', function (event) {
                    const before = $(this).parent().prev();
                    if (before.length) $(this).parent().insertBefore(before);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll('.graph .moveDown, .section .moveDown').forEach(item => {
                item.innerHTML = arrowDownVerySmall;
                item.addEventListener('click', function (event) {
                    const after = $(this).parent().next();
                    if (after.length) $(this).parent().insertAfter(after);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll('.hideItem').forEach(item => {
                item.addEventListener('click', function () {
                    this.classList.toggle('active');
                });
            });
        }

        // function to add/remove disabled to the graphs in the customize view popup
        function disable_graphs_in_customize_view(disable, identifier) {
            const relatedGraphs1 = document.getElementById("graphShow").querySelectorAll(".hideItemText")
            const relatedGraphs2 = document.getElementById("graphHide").querySelectorAll(".hideItemText")
            const relatedGraphs = [...relatedGraphs1, ...relatedGraphs2]
            for (const graph of relatedGraphs) {
                if (graph.innerText.startsWith(identifier)) {
                    if (disable) {
                        graph.parentElement.classList.add('disabled');
                    } else {
                        graph.parentElement.classList.remove('disabled');
                    }
                }
            }
        }

        function update_customize_view_local_storage() {
            // Sync current order to localStorage
            const sectionOrder = Array.from(document.getElementById('sectionShow').querySelectorAll('.hideItem'))
                .map(item => item.children[0].innerText);
            const graphOrder = Array.from(document.getElementById('graphShow').querySelectorAll('.hideItem'))
                .map(item => item.children[0].innerText);

            localStorage.setItem('sectionShow', JSON.stringify(sectionOrder));
            localStorage.setItem('graphShow', JSON.stringify(graphOrder));
        }

        /////////////////////////////
        // EVENTLISTENER FUNCTIONS //
        /////////////////////////////

        // function to create customized view eventlisteners
        function setup_customize_view_button_eventlisteners() {
            // update all graphs based on new hidden graphs/sections
            document.getElementById('saveHide').addEventListener('click', function () {
                update_customize_view_local_storage();
                setup_data_and_graphs();
            });

            // remove the entire customized view configuration
            document.getElementById('resetHide').addEventListener('click', function () {
                document.getElementById('runs').focus()
                localStorage.setItem('sectionHide', JSON.stringify([]));
                localStorage.setItem('graphHide', JSON.stringify([]));
                localStorage.setItem('sectionShow', JSON.stringify(hideSections));
                localStorage.setItem('graphShow', JSON.stringify(hideGraphs));
                setup_customize_view_content();
                update_customize_view_local_storage();
                setup_data_and_graphs();
            });
        }

        // function to setup eventlisteners for filter buttons
        function setup_eventlisteners_filter_buttons() {
            // eventlisteners for filters (runTags is done separately because of different usage)
            const filters = ["runs", "fromDate", "fromTime", "toDate", "toTime", "amount"]
            for (let f of filters) {
                document.getElementById(f).addEventListener("change", setup_data_and_graphs);
            }

            // eventlisteners for fullscreen buttons
            const fullscreenButtons = ["runStatistics", "runDuration", "suiteStatistics",
                "suiteDuration", "suiteMostFailed", "testStatistics", "testDuration",
                "testMostFlaky", "testRecentMostFlaky", "testDurationDeviation", "testMostFailed", "testMessages",
                "keywordStatistics", "keywordTimesRun", "keywordTotalDuration",
                "keywordAverageDuration", "keywordMinDuration", "keywordMaxDuration"]
            for (let fullscreenButton of fullscreenButtons) {
                document.getElementById(`${fullscreenButton}Fullscreen`).addEventListener("click", (e) => {
                    $('#filterSection').hide()
                    document.getElementById(`${fullscreenButton}Canvas`).classList.add("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = false
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = true
                    document.body.style.overflow = 'hidden';
                });
                document.getElementById(`${fullscreenButton}Close`).addEventListener("click", (e) => {
                    $('#filterSection').show()
                    document.getElementById(`${fullscreenButton}Canvas`).classList.remove("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = true
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = false
                    document.body.style.overflow = 'auto';
                });
            }
        }

        // function to setup eventlisteners for changing the graph view buttons
        function setup_eventlisteners_graph_view_buttons() {
            // ignore skip button eventlisteners
            document.getElementById("ignoreSkips").addEventListener("change", (e) => {
                ignoreSkips = !ignoreSkips;
                create_test_most_flaky_graph();
            });
            document.getElementById("ignoreSkipsRecent").addEventListener("change", (e) => {
                ignoreSkipsRecent = !ignoreSkipsRecent;
                create_test_recent_most_flaky_graph();
            });

            // eventlisteners for buttons to change graph views
            const graphChangeButtons = {
                'run_statistics': 'Percentages,Line,Amount',
                'run_duration': 'Bar,Line',
                'suite_statistics': 'Percentages,Line,Amount',
                'suite_duration': 'Bar,Line',
                'suite_most_failed': 'Bar,Timeline',
                'test_duration': 'Bar,Line',
                'test_most_flaky': 'Bar,Timeline',
                'test_recent_most_flaky': 'Bar,Timeline',
                'test_duration_deviation': 'Bar',
                'test_most_failed': 'Bar,Timeline',
                'test_messages': 'Bar,Timeline',
                'keyword_statistics': 'Percentages,Line,Amount',
                'keyword_times_run': 'Bar,Line',
                'keyword_total_duration': 'Bar,Line',
                'keyword_average_duration': 'Bar,Line',
                'keyword_min_duration': 'Bar,Line',
                'keyword_max_duration': 'Bar,Line',
            };

            function handle_graph_change_type_button_click(graphChangeButton, graphType, camelButtonName) {
                // Dynamically trigger the graph creation function
                update_graph_type(`${camelButtonName}GraphType`, graphType)
                window[`create_${graphChangeButton}_graph`]();
                // Update the UI to enable/disable buttons accordingly
                update_button_selection(camelButtonName, graphType)
            }

            function add_graph_eventlisteners(graphChangeButton, buttonTypes) {
                const camelButtonName = underscore_to_camelcase(graphChangeButton);
                const graphTypes = buttonTypes.split(',');
                graphTypes.forEach((graphType, index) => {
                    const buttonId = `${camelButtonName}Graph${graphType}`;
                    if (document.getElementById(buttonId)) {
                        document.getElementById(buttonId).addEventListener("click", (e) => {
                            handle_graph_change_type_button_click(graphChangeButton, graphType.toLowerCase(), camelButtonName);
                        });
                    }
                });
            }

            // Iterate over the graphChangeButtons object to attach event listeners
            Object.entries(graphChangeButtons).forEach(([graphChangeButton, buttonTypes]) => {
                add_graph_eventlisteners(graphChangeButton, buttonTypes);
            });
        }

        // function to handle the eventlisteners for all filter options in the sections
        function setup_eventlisteners_section_filter_buttons() {
            // function to keep track of the checkboxes for the runtags
            function show_checkboxes() {
                const checkboxes = document.getElementById("checkboxes");
                showingRunTags = !showingRunTags;
                checkboxes.style.display = showingRunTags ? "block" : "none";
            }

            // eventlistener for run tags selection
            document.getElementById("selectRunTags").addEventListener("click", show_checkboxes);
            // eventlistener for reset filter button
            document.getElementById("resetFilters").addEventListener("click", function () {
                document.getElementById("runs").value = "All";
                document.getElementById("runTag").value = "All";
                setup_lowest_highest_dates(runs);
                setup_data_and_graphs();
            });
            // eventlistener for all selection boxes and their respective graphs that should be updated
            document.getElementById("suiteSelectSuites").addEventListener("change", (e) => {
                create_suite_duration_graph();
                create_suite_statistics_graph();
            });
            document.getElementById("showOnlySelectedtestStatistics").addEventListener("change", (e) => {
                showOnlySelectedtestStatistics = !showOnlySelectedtestStatistics;
                create_test_statistics_graph();
            });
            document.getElementById("suiteSelectTests").addEventListener("change", (e) => {
                setup_testtags_in_select();
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("testTagsSelect").addEventListener("change", (e) => {
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("testSelect").addEventListener("change", (e) => {
                if (showOnlySelectedtestStatistics) {
                    create_test_statistics_graph();
                }
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("keywordSelect").addEventListener("change", (e) => {
                create_keyword_statistics_graph();
                create_keyword_times_run_graph();
                create_keyword_total_duration_graph();
                create_keyword_average_duration_graph();
                create_keyword_min_duration_graph();
                create_keyword_max_duration_graph();
            });

            const checkboxesElement = document.getElementById('checkboxes');
            const runTagsSelectElement = document.getElementById('selectRunTags');
            // listen for click events on body to hide the run checkboxes when clicking outside of the select/checkboxes elements
            document.body.addEventListener('click', function (event) {
                if (showingRunTags == true && !checkboxesElement.contains(event.target) && !runTagsSelectElement.contains(event.target)) {
                    show_checkboxes()
                }
            });
        }

        /////////////////////////////////////
        // FILTER BUTTON CONTENT FUNCTIONS //
        /////////////////////////////////////

        // function to setup run 
        function setup_run_amount_filter() {
            document.getElementById('amount').setAttribute('max', runs.length)
        }

        // function that initializes the from date/time and to date/time selection boxes in the filters
        function setup_lowest_highest_dates() {
            var dates = [];
            for (run of runs) {
                dates.push(new Date(run.run_start));
            }
            if (dates.length == 0) {
                document.getElementById("fromDate").value = "1900-01-01";
                document.getElementById("fromTime").value = "00:00";
                document.getElementById("toDate").value = "9999-12-31";
                document.getElementById("toTime").value = "23:59";
                return
            }
            var lowest = new Date(Math.min.apply(null, dates));
            var highest = new Date(Math.max.apply(null, dates));
            var tzoffset = new Date().getTimezoneOffset() * 60000;
            lowest = new Date(new Date(lowest - tzoffset).getTime() + -1 * 60000); // this is to account for seconds in the initial filter value
            highest = new Date(new Date(highest - tzoffset).getTime() + 1 * 60000); // this is to account for seconds in the initial filter value
            lowest.setTime(lowest.getTime() - 1 * 60 * 60 * 1000) // minus 1 hour to account for possible daylight saving time switches of 1 hour!
            highest.setTime(highest.getTime() + 1 * 60 * 60 * 1000) // plus 1 hour to account for possible daylight saving time switches of 1 hour!
            document.getElementById("fromDate").value = lowest.toISOString().split("T")[0];
            document.getElementById("fromTime").value = lowest.toISOString().split("T")[1].substring(0, 5);
            document.getElementById("toDate").value = highest.toISOString().split("T")[0];
            document.getElementById("toTime").value = highest.toISOString().split("T")[1].substring(0, 5);
        }

        // function to update the available runs to select in the filters
        function setup_runs_in_select_filter_buttons() {
            // Use a Set to collect unique run names
            const runOptions = new Set();
            // Collect all unique run names
            runs.forEach(run => runOptions.add(run.name));
            // Build the options HTML (including "All" as the first option)
            const optionsHtml = Array.from(runOptions)
                .map(runName => `<option value="${runName}">${runName}</option>`)
                .join('');
            // Add the "All" option and append all other options
            const runsSelect = document.getElementById("runs");
            runsSelect.innerHTML = `<option value="All">All</option>` + optionsHtml;
        }

        // function to update the available runtags to select in the filters
        function setup_runtags_in_select_filter_buttons() {
            // Use a Set to collect unique tags
            const tags = new Set();
            // Collect all unique tags from the runs
            runs.forEach(run => {
                run.tags.split(",").forEach(tag => {
                    if (tag) { // Avoid adding empty tags
                        tags.add(tag);
                    }
                });
            });
            // Create the "Use OR" toggle item
            const andOrTags = `
                <li class="list-group-item d-flex small" onclick="setup_data_and_graphs()">
                    <div class="btn-group form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="useOrTags" />
                    </div>
                    <div class="btn-group">
                        <label class="form-check-label" for="useOrTags">Use OR (default AND)</label>
                    </div>
                </li>
            `;
            // Template for list items
            const listItemTemplate = (value) => `
                <li class="list-group-item list-group-item-action d-flex small" onclick="setup_data_and_graphs()">
                    <input class="form-check-input me-1" type="checkbox" value="" id="${value}">
                    <label class="form-check-label ms-2" for="${value}">${value}</label>
                </li>
            `;
            // Build the list items for all tags and the "All" tag
            const listItems = [listItemTemplate('All')].concat(
                Array.from(tags).map(tag => listItemTemplate(tag))
            ).join('');
            // Insert the generated HTML into the DOM
            const tagsSelect = document.getElementById("runTag");
            tagsSelect.innerHTML = andOrTags + listItems;
            // Set the "All" tag to be checked by default
            document.getElementById("All").checked = true;

        }

        // function to update the available suites to select in the filters
        // applies to the suite filter on the suite statistics level and the test statistics level
        function setup_suites_in_selects() {
            const suiteSelectTests = document.getElementById("suiteSelectTests");
            const suiteSelectSuites = document.getElementById("suiteSelectSuites");
            // Clear existing options
            suiteSelectTests.innerHTML = "";
            suiteSelectSuites.innerHTML = "";
            // Extract and sort suite names
            const suiteNames = [...new Set(filteredSuites.map(suite => suite.name))].sort();
            // Add "All" as default
            suiteSelectTests.options.add(new Option("All", "All"));
            suiteSelectSuites.options.add(new Option("All", "All"));
            // Add suite names to selects
            suiteNames.forEach(suiteName => {
                suiteSelectTests.options.add(new Option(suiteName, suiteName));
                suiteSelectSuites.options.add(new Option(suiteName, suiteName));
            });
            // Set the default selection to the second option (All is default)
            suiteSelectTests.selectedIndex = 1;
            suiteSelectSuites.selectedIndex = 1;
        }

        // function to update the available tests to select in the filters
        // applies to the test filter on the test statistics level
        function setup_tests_in_select() {
            const suiteSelect = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const testSelect = document.getElementById("testSelect");
            // Clear existing options
            testSelect.innerHTML = "";
            // Filter test names based on suite and tags
            const testNames = filteredTests.reduce((names, test) => {
                const isInSuite = test.full_name.includes(`.${suiteSelect}.${test.name}`) || suiteSelect === "All";
                const hasTag = testTagsSelect === "All" || test.tags.includes(testTagsSelect);

                if (isInSuite && hasTag && !names.includes(test.name)) {
                    names.push(test.name);
                }

                return names;
            }, []);
            // Add "All" as default
            testSelect.options.add(new Option("All", "All"));
            // Add filtered test names to select
            testNames.forEach(testName => testSelect.options.add(new Option(testName, testName)));
        }

        // function to update the available testtags to select in the filters
        // applies to the testtag filter on the test statistics level
        function setup_testtags_in_select() {
            const suiteSelect = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect");
            // Clear existing options
            testTagsSelect.innerHTML = "";
            // Extract unique tags for the selected suite
            const testTags = [...new Set(filteredTests.reduce((tags, test) => {
                if (test.full_name.includes(`.${suiteSelect}.${test.name}`) || suiteSelect === "All") {
                    test.tags.replace(/\[|\]/g, '').split(',').forEach(tag => tags.push(tag.trim()));
                }
                return tags;
            }, []))];
            // Add "All" as default
            testTagsSelect.options.add(new Option("All", "All"));
            // Add tags to select
            testTags.forEach(tag => testTagsSelect.options.add(new Option(tag, tag)));
        }

        // function to update the available keywords to select in the filters
        // applies to the keyword filter on the keyword statistics level
        function setup_keywords_in_select() {
            const keywordSelect = document.getElementById("keywordSelect");
            // Clear existing options
            keywordSelect.innerHTML = "";
            // Extract unique keyword names
            const keywordNames = [...new Set(filteredKeywords.map(keyword => keyword.name))].sort();
            // Add keywords to select
            keywordNames.forEach(keywordName => keywordSelect.options.add(new Option(keywordName, keywordName)));
            // Select the last keyword by default
            keywordSelect.selectedIndex = keywordNames.length - 1;
        }

        ///////////////////////////
        // DATA FILTER FUNCTIONS //
        ///////////////////////////

        // function to filter run data based on the runs (aka run name) filter
        function filter_runs(runs) {
            const selectedRun = document.getElementById("runs").value;
            // If "All" is selected, return the original array of runs
            if (selectedRun === "All") {
                var selectedRuns = runs
            } else {
                var selectedRuns = Object.values(runs).filter(run => run.name === selectedRun)
            }
            return selectedRuns;
        }

        // function to filter run data based on the run tags filter
        function filter_runtags(runs) {
            const tagElements = document.getElementById("runTag").getElementsByTagName("input");
            const useOrTags = document.getElementById("useOrTags").checked;
            const selectedTags = Array.from(tagElements)
                .filter(tagElement => tagElement.checked)
                .map(tagElement => tagElement.id);
            // If "All" is selected, return all runs
            if (selectedTags.includes("All")) {
                return runs;
            }
            // If no tags are selected, return an empty list
            if (selectedTags.length === 0) {
                return [];
            }
            return runs.filter(run => {
                const runTags = run.tags.split(",");
                // Use AND logic: the run must contain all selected tags
                if (!useOrTags) {
                    return selectedTags.every(selectedTag => runTags.includes(selectedTag));
                }
                // Use OR logic: the run must contain at least one selected tag
                return selectedTags.some(selectedTag => runTags.includes(selectedTag));
            });
        }

        // function to filter the run data based on the selected date range
        function filter_dates(runs) {
            const fromDate = document.getElementById("fromDate").value;
            const fromTime = document.getElementById("fromTime").value;
            const toDate = document.getElementById("toDate").value;
            const toTime = document.getElementById("toTime").value;
            // Return all runs if any date/time values are missing
            if (!fromDate || !fromTime || !toDate || !toTime) {
                return runs;
            }
            const fromDateTime = new Date(`${fromDate} ${fromTime}:00`);
            const toDateTime = new Date(`${toDate} ${toTime}:00`);
            // Check for valid date range
            if (fromDateTime > toDateTime) {
                alert("Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!");
                return runs;  // Return all runs if invalid range
            }
            // Use the array filter method for a cleaner approach
            return runs.filter(run => {
                const runStart = new Date(run.run_start);
                return runStart >= fromDateTime && runStart <= toDateTime;
            });
        }

        function filter_amount(filteredRuns) {
            var selectedAmount = document.getElementById("amount").value;
            // Handle weird selectedAmountValues:
            if (selectedAmount == '') {
                $("#amount").val(10).trigger('change.amount');
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount > runs.length) {
                $("#amount").val(runs.length).trigger('change.amount');
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount < 0) {
                $("#amount").val(0).trigger('change.amount');
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes(',')) {
                $("#amount").val(selectedAmount.split(',')[0]).trigger('change.amount');
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes('.')) {
                $("#amount").val(selectedAmount.split('.')[0]).trigger('change.amount');
                selectedAmount = document.getElementById("amount").value;
            }
            filteredAmount = filteredRuns.length
            if (selectedAmount == 0) { return [] }
            filteredRuns = filteredRuns.slice(- selectedAmount)
            return filteredRuns
        }

        // function to filter suites/tests/keywords based on the already filtered runs
        function filter_data(dataType) {
            var validRunStarts = [];
            for (value of filteredRuns) {
                validRunStarts.push(value.run_start);
            }
            var filteredData = [];
            for (value of window[dataType]) {
                if (validRunStarts.includes(value.run_start)) {
                    filteredData.push(value);
                }
            }
            return filteredData;
        }

        //////////////////////////////////////
        // GRAPH & TABLE CREATION FUNCTIONS //
        //////////////////////////////////////

        // function to create run statistics graph in the run section
        function create_run_statistics_graph() {
            if (runStatisticsGraph) {
                runStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("run", runStatisticsGraphType, filteredRuns);
            const graphData = data[0]
            var config;
            if (runStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests (Line)", "Date", "amount", false);
            } else if (runStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Run Statistics (Bar)", "Run", "Amount Of Tests");
            } else if (runStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Run Statistics (Bar)", "Run", "Percentage");
            }
            runStatisticsGraph = new Chart("runStatisticsGraph", config);
            runStatisticsGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(runStatisticsGraph, event)
            });
        }

        // function to create run duration graph in the run section
        function create_run_duration_graph() {
            if (runDurationGraph) {
                runDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("run", runDurationGraphType, "elapsed_s", filteredRuns);
            var config;
            if (runDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Run Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (runDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Run Duration (Line)", "Date", "Duration");
            }
            runDurationGraph = new Chart("runDurationGraph", config);
            runDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(runDurationGraph, event)
            });
        }

        // function to create run table in the run section
        function create_run_table() {
            if (runTable) {
                runTable.destroy();
            }
            data = [];
            for (run of filteredRuns) {
                data.push([
                    run.run_start,
                    run.full_name,
                    run.name,
                    run.total,
                    run.passed,
                    run.failed,
                    run.skipped,
                    run.elapsed_s,
                    run.start_time,
                    run.tags,
                    run.run_alias,
                ]);
            }
            runTable = new DataTable("#runTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "tags" },
                    { title: "alias" }
                ],
                data: data,
            });
        }

        // function to create suite statistics graph in the suite section
        function create_suite_statistics_graph() {
            if (suiteStatisticsGraph) {
                suiteStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("suite", suiteStatisticsGraphType, filteredSuites);
            const graphData = data[0]
            const callbackData = data[1]
            var config;
            if (suiteStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests (Line)", "Date", "amount", false);
                config.options.plugins.tooltip = {
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Suite Statistics (Bar)", "Run", "Amount Of Tests");
                // overwrite tooltip title
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Suite Statistics (Bar)", "Run", "Percentage");
                // overwrite tooltip title
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            }
            suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            suiteStatisticsGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(suiteStatisticsGraph, event)
            });
        }

        // function to create suite duration graph in the suite section
        function create_suite_duration_graph() {
            if (suiteDurationGraph) {
                suiteDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("suite", suiteDurationGraphType, "elapsed_s", filteredSuites);
            var config;
            if (suiteDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Suite Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (suiteDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Suite Duration (Line)", "Date", "Duration");
            }
            suiteDurationGraph = new Chart("suiteDurationGraph", config);
            suiteDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(suiteDurationGraph, event)
            });
        }

        // function to create suite most failed graph in the suite section
        function create_suite_most_failed_graph() {
            if (suiteMostFailedGraph) {
                suiteMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("suite", suiteMostFailedGraphType, filteredSuites);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            if (suiteMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Top 10 Most Failed Suites", "Suite Name", "Times Failed");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                // no onClick on the bar chart
                delete config.options.onClick
            } else if (suiteMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, "Top 10 Most Failed Suites");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                // overwrite the click callback to use the callbackData
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
            }
            suiteMostFailedGraph = new Chart("suiteMostFailedGraph", config);
            suiteMostFailedGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(suiteMostFailedGraph, event)
            });
        }

        // function to create suite table in the suite section
        function create_suite_table() {
            if (suiteTable) {
                suiteTable.destroy();
            }
            data = [];
            for (suite of filteredSuites) {
                data.push([
                    suite.run_start,
                    suite.full_name,
                    suite.name,
                    suite.total,
                    suite.passed,
                    suite.failed,
                    suite.skipped,
                    suite.elapsed_s,
                    suite.start_time,
                    suite.run_alias,
                    suite.id,
                ]);
            }
            suiteTable = new DataTable("#suiteTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to create test statistics graph in the test section
        function create_test_statistics_graph() {
            if (testStatisticsGraph) {
                testStatisticsGraph.destroy();
            }
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            var [labels, runStarts, datasets] = [[], [], []];
            for (test of filteredTests) {
                if (suiteSelectTests != "All" && !test.full_name.includes(`.${suiteSelectTests}.${test.name}`) && test.full_name != `${suiteSelectTests}.${test.name}`) {
                    continue;
                }
                if (showOnlySelectedtestStatistics && testSelect != "All" && test.name != testSelect) {
                    continue;
                }
                if (testTagsSelect != "All" && !test.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) {
                    continue
                }
                if (!labels.includes(test.name)) {
                    labels.push(test.name);
                }
                if (use_run_aliases) {
                    if (!runStarts.includes(test.run_alias)) {
                        runStarts.push(test.run_alias);
                    }
                    var runAxis = runStarts.indexOf(test.run_alias)
                } else {
                    if (!runStarts.includes(test.run_start)) {
                        runStarts.push(test.run_start);
                    }
                    var runAxis = runStarts.indexOf(test.run_start)
                }
                if (test.passed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: passedBackgroundColor,
                        borderColor: passedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                } else if (test.failed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                } else if (test.skipped == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: skippedBackgroundColor,
                        borderColor: skippedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                }
            }
            var graphData = {
                labels: labels,
                datasets: datasets,
            };
            var config = get_graph_config("timeline", graphData, "Test Statistics (Bar)");
            // overwrite tooltip and x scale with callbacks
            config.options.plugins.tooltip = {
                callbacks: {
                    label: function (context) {
                        return runStarts[context.raw.x[0]];
                    },
                },
            };
            config.options.scales.x = {
                ticks: {
                    minRotation: 45,
                    maxRotation: 45,
                    callback: function (value, index, ticks) {
                        return runStarts[this.getLabelForValue(value)];
                    },
                },
            };
            // overwrite the click callback to use the callbackData
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, runStarts)
                }
            };
            testStatisticsGraph = new Chart("testStatisticsGraph", config);
            update_height('testStatisticsVertical', testStatisticsGraph)
            testStatisticsGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testStatisticsGraph, event)
            });
        }

        // function to create test duration graph in the test section
        function create_test_duration_graph() {
            if (testDurationGraph) {
                testDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("test", testDurationGraphType, "elapsed_s", filteredTests);
            var config;
            if (testDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Test Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (testDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Test Duration (Line)", "Date", "Duration");
            }
            testDurationGraph = new Chart("testDurationGraph", config);
            testDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testDurationGraph, event)
            });
        }

        // function to create test most flaky graph in test section
        function create_test_most_flaky_graph() {
            if (testMostFlakyGraph) {
                testMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testMostFlakyGraphType, filteredTests, ignoreSkips, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            if (testMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Top 10 Most Flaky Tests (most status flips)", "Test Name", "Times Status Flipped");
                // disable lenged in bar graph
                config.options.plugins.legend = false
                // no onClick on the bar chart
                delete config.options.onClick
            } else if (testMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, "Top 10 Most Flaky Tests (most status flips)");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                // overwrite the click callback to use the callbackData
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                }
            }
            testMostFlakyGraph = new Chart("testMostFlakyGraph", config);
            testMostFlakyGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testMostFlakyGraph, event)
            });
        }

        // function to create test recent most flaky graph in test section
        function create_test_recent_most_flaky_graph() {
            if (testRecentMostFlakyGraph) {
                testRecentMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testRecentMostFlakyGraphType, filteredTests, ignoreSkipsRecent, true);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            if (testRecentMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Top 10 Recent Most Flaky Tests (most status flips)", "Test Name", "Times Status Flipped");
                // disable lenged in bar graph
                config.options.plugins.legend = false
                // no onClick on the bar chart
                delete config.options.onClick
            } else if (testRecentMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, "Top 10 Recent Most Flaky Tests (most status flips)");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                // overwrite the click callback to use the callbackData
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                }
            }
            testRecentMostFlakyGraph = new Chart("testRecentMostFlakyGraph", config);
            testRecentMostFlakyGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testRecentMostFlakyGraph, event)
            });
        }

        // function to create test duration deviation graph in test section
        function create_test_duration_deviation_graph() {
            if (testDurationDeviationGraph) {
                testDurationDeviationGraph.destroy();
            }
            const graphData = get_duration_deviation_data("test", testDurationDeviationGraphType, filteredTests)
            const config = get_graph_config("boxplot", graphData, "Duration Deviation", "Test Name", "Duration");
            // no onClick on the boxplot chart
            delete config.options.onClick
            testDurationDeviationGraph = new Chart("testDurationDeviationGraph", config);
            testDurationDeviationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testDurationDeviationGraph, event)
            });
        }

        // function to create test most failed graph in the test section
        function create_test_most_failed_graph() {
            if (typeof type === "string") {
                testMostFailedGraphType = type;
            }
            if (testMostFailedGraph) {
                testMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("test", testMostFailedGraphType, filteredTests);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            if (testMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Top 10 Most Failed Tests", "Test Name", "Times Failed");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                // no onClick on the bar chart
                delete config.options.onClick
            } else if (testMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, "Top 10 Most Failed Tests");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                // overwrite the click callback to use the callbackData
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                }
            }
            testMostFailedGraph = new Chart("testMostFailedGraph", config);
            testMostFailedGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testMostFailedGraph, event)
            });
        }

        // function to create test messages graph in the test section
        function create_test_messages_graph() {
            if (testMessagesGraph) {
                testMessagesGraph.destroy();
            }
            const data = get_messages_data("test", testMessagesGraphType, filteredTests);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            if (testMessagesGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Top 10 Fail Messages", "Message", "Times");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                };
                // no onClick on the bar chart
                delete config.options.onClick
            } else if (testMessagesGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, "Top 10 Fail Messages");
                // overwrite tooltip and x and y scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                // overwrite the click callback to use the callbackData
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                config.options.scales.y.ticks = {
                    callback: function (value, index, ticks) {
                        return this.getLabelForValue(value).slice(0, 40);
                    },
                };
            }
            testMessagesGraph = new Chart("testMessagesGraph", config);
            testMessagesGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(testMessagesGraph, event)
            });
        }

        // function to create test table in the test section
        function create_test_table() {
            if (testTable) {
                testTable.destroy();
            }
            data = [];
            for (test of filteredTests) {
                data.push([
                    test.run_start,
                    test.full_name,
                    test.name,
                    test.passed,
                    test.failed,
                    test.skipped,
                    test.elapsed_s,
                    test.start_time,
                    test.message,
                    test.tags,
                    test.run_alias,
                    test.id
                ]);
            }
            testTable = new DataTable("#testTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "message" },
                    { title: "tags" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to keyword statistics graph in the keyword section
        function create_keyword_statistics_graph() {
            if (keywordStatisticsGraph) {
                keywordStatisticsGraph.destroy();
            }
            Chart.register(ChartDataLabels);
            const data = get_statistics_graph_data("keyword", keywordStatisticsGraphType, filteredKeywords);
            const graphData = data[0]
            var config;
            if (keywordStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Keyword Statistics (Line)", "Date", "Amount", false);
            } else if (keywordStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Keyword Statistics (Bar)", "Run", "Amount");
            } else if (keywordStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Keyword Statistics (Bar)", "Run", "Percentage");
            }
            keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            keywordStatisticsGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordStatisticsGraph, event)
            });
        }

        // function to keyword times run graph in the keyword section
        function create_keyword_times_run_graph() {
            if (keywordTimesRunGraph) {
                keywordTimesRunGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTimesRunGraphType, "times_run", filteredKeywords);
            var config;
            if (keywordTimesRunGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Times Run (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (keywordTimesRunGraphType == "line") {
                config = get_graph_config("line", graphData, "Times Run (Line)", "Date", "Duration");
            }
            keywordTimesRunGraph = new Chart("keywordTimesRunGraph", config);
            keywordTimesRunGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordTimesRunGraph, event)
            });
        }

        // function to keyword total time graph in the keyword section
        function create_keyword_total_duration_graph() {
            if (typeof type === "string") {
                keywordTotalDurationGraphType = type;
            }
            if (keywordTotalDurationGraph) {
                keywordTotalDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTotalDurationGraphType, "total_time_s", filteredKeywords);
            var config;
            if (keywordTotalDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Total Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (keywordTotalDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Total Duration (Line)", "Date", "Duration");
            }
            keywordTotalDurationGraph = new Chart("keywordTotalDurationGraph", config);
            keywordTotalDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordTotalDurationGraph, event)
            });
        }

        // function to keyword average time graph in the keyword section
        function create_keyword_average_duration_graph() {
            if (keywordAverageDurationGraph) {
                keywordAverageDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordAverageDurationGraphType, "average_time_s", filteredKeywords);
            var config;
            if (keywordAverageDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Average Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (keywordAverageDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Average Duration (Line)", "Date", "Duration");
            }
            keywordAverageDurationGraph = new Chart("keywordAverageDurationGraph", config);
            keywordAverageDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordAverageDurationGraph, event)
            });
        }

        // function to keyword min time graph in the keyword section
        function create_keyword_min_duration_graph() {
            if (keywordMinDurationGraph) {
                keywordMinDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMinDurationGraphType, "min_time_s", filteredKeywords);
            var config;
            if (keywordMinDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Min Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (keywordMinDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Min Duration (Line)", "Date", "Duration");
            }
            keywordMinDurationGraph = new Chart("keywordMinDurationGraph", config);
            keywordMinDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordMinDurationGraph, event)
            });
        }

        // function to keyword max time graph in the keyword section
        function create_keyword_max_duration_graph() {
            if (keywordMaxDurationGraph) {
                keywordMaxDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMaxDurationGraphType, "max_time_s", filteredKeywords);
            var config;
            if (keywordMaxDurationGraphType == "bar") {
                config = get_graph_config("bar", graphData, "Max Duration (Bar) First 30 Bars Only", "Run", "Duration");
            } else if (keywordMaxDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Max Duration (Line)", "Date", "Duration");
            }
            keywordMaxDurationGraph = new Chart("keywordMaxDurationGraph", config);
            keywordMaxDurationGraph.canvas.addEventListener('click', (event) => {
                open_log_from_label(keywordMaxDurationGraph, event)
            });
        }

        // function to keyword table in the keyword section
        function create_keyword_table() {
            if (keywordTable) {
                keywordTable.destroy();
            }
            data = [];
            for (keyword of filteredKeywords) {
                data.push([
                    keyword.run_start,
                    keyword.name,
                    keyword.passed,
                    keyword.failed,
                    keyword.skipped,
                    keyword.times_run,
                    keyword.total_time_s,
                    keyword.average_time_s,
                    keyword.min_time_s,
                    keyword.max_time_s,
                    keyword.run_alias,
                ]);
            }
            keywordTable = new DataTable("#keywordTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "times_run" },
                    { title: "total_execution_time" },
                    { title: "average_execution_time" },
                    { title: "min_execution_time" },
                    { title: "max_execution_time" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        ///////////////////////////////////
        // GRAPH DATA & CONFIG FUNCTIONS //
        ///////////////////////////////////

        function open_log_from_label(chart, click) {
            if (!use_logs) { return }
            let resetCoordinates = chart.canvas.getBoundingClientRect();
            const xCoor = click.clientX - resetCoordinates.left;
            const yCoor = click.clientY - resetCoordinates.top;

            const { data, scales: { x: { top, bottom, left, height, width, ticks } } } = chart;
            const right = width / ticks.length;

            for (let i = 0; i < ticks.length; i++) {
                if (xCoor >= left + (right * i) && xCoor <= left + right + (right * i) && yCoor >= top && yCoor <= bottom) {
                    console.log(data.labels[i])
                    var run = runs.find(run => run.run_start === data.labels[i])
                    if (run) {
                        const path = transform_file_path(run.path)
                        if (path == "") {
                            alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                            return
                        }
                        var fileUrl = ""
                        if (server) { // server url
                            fileUrl = `/log?path=${path}`
                        } else if (window.location.href.includes('file:///')) { // local machine url
                            fileUrl = `file:///${path}`
                        } else { // remote machine file server
                            fileUrl = combine_paths(window.location.href, path)
                        }
                        const win = window.open(fileUrl, '_blank')
                    }
                }
            }
        }

        function update_log_path_with_id(path, graphId, chartElement, event) {
            if (graphId.includes('run') || graphId.includes('keyword')) {
                return transform_file_path(path)
            } // can't select a run or keyword in the suite/log log.html
            const graphType = event.chart.config._config.type
            var name = ''
            var id = ''
            var runStart = runs.find(run => run.path === path).run_start
            if (graphId.includes('suite')) {
                if (graphId == 'suiteStatisticsGraph') {
                    name = event.chart.tooltip.title[0].split(': ').pop()
                } else if (graphId == 'suiteDurationGraph') {
                    name = event.chart.tooltip.body[0].lines[0].split(': ')[0]
                } else if (graphId == 'suiteMostFailedGraph') {
                    name = chartElement[0].element.$context.raw.y
                }
                id = suites.find(suite => suite.name === name && suite.run_start === runStart)
            } else { // it contains a test
                if (graphId == 'testStatisticsGraph' || graphId == 'testMostFlakyGraph' || graphId == 'testRecentMostFlakyGraph' || graphId == 'testMostFailedGraph') {
                    name = chartElement[0].element.$context.raw.y
                } else if (graphId == 'testDurationGraph') {
                    if (graphType == 'bar') {
                        name = event.chart.tooltip.dataPoints[0].dataset.label
                    } else {
                        const datasetIndex = chartElement[0].datasetIndex
                        name = event.chart.legend.legendItems[datasetIndex].text
                    }
                } else { // this exception is for the Test Messages graph as you can't tell which test it relates to (might be more than 1!)
                    return transform_file_path(path)
                }
                id = tests.find(test => test.name === name && test.run_start === runStart)
            }
            if (id == undefined) {
                return transform_file_path(path)
            }
            return `${transform_file_path(path)}#${id.id}`
        }

        function open_log_file(event, chartElement, callbackData = undefined) {
            if (!use_logs) { return }
            const graphType = event.chart.config._config.type
            const graphId = event.chart.canvas.id
            var runStart = ''
            if (callbackData) {
                const index = chartElement[0].element.$context.raw.x[0]
                runStart = callbackData[index]
            } else if (graphType == 'line' && !graphId.includes('Statistics')) {
                runStart = format_date_to_string(new Date(chartElement[0].element.$context.raw.x))
            } else {
                const index = chartElement[0].index
                runStart = event.chart.data.labels[index]
            }
            var output = runs.find(run => run.run_start === runStart)
            var path = output ? output.path : runs.find(run => run.run_alias === runStart).path
            if (path == "") {
                alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                return
            }
            path = update_log_path_with_id(path, graphId, chartElement, event)
            var fileUrl = ""
            if (server) { // server url
                fileUrl = `/log?path=${path}`
            } else if (window.location.href.includes('file:///')) { // local machine url
                fileUrl = `file:///${path}`
            } else { // remote machine file server
                fileUrl = combine_paths(window.location.href, path)
            }
            const win = window.open(fileUrl, '_blank')
        }

        // function to retrieve the required graph config for chartjs, based on the different type of graphs
        function get_graph_config(graphType, graphData, graphTitle, xTitle, yTitle, dataSets = true) {
            // Common base config to reduce repetition
            const baseConfig = {
                onClick: (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement)
                    }
                },
                normalized: true,
                animation: false,
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: graphTitle,
                    },
                    datalabels: {
                        display: false,
                    },
                },
            };
            // Common scales configuration
            const commonScales = {
                x: {
                    title: {
                        display: true,
                        text: xTitle,
                    },
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                    },
                },
                y: {
                    title: {
                        display: true,
                        text: yTitle,
                    },
                    grace: "5%",
                },
            };
            if (dataSets && graphType == "line") {
                graphData = { datasets: graphData };
            }
            // Configuration for 'line' graph
            if (graphType === "line") {
                return {
                    type: "line",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                type: "time",
                                time: {
                                    tooltipFormat: "dd.MM.yyyy - HH:mm:ss.SSS",
                                },
                            },
                        },
                    },
                };
            }
            // Configuration for 'bar' graph
            if (graphType === "bar") {
                return {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            y: {
                                ...commonScales.y,
                                stacked: true,
                            },
                        },
                        interaction: {
                            mode: "x",
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                filter: (tooltipItem) => tooltipItem.dataset.data[tooltipItem.dataIndex] > 0,
                            },
                            datalabels: {
                                color: "#000000",
                                align: "center",
                                anchor: "center",
                                formatter: (value) => value > 0 ? value : "",
                            },
                        },
                    },
                };
            }
            // Configuration for 'timeline' graph
            if (graphType === "timeline") {
                return {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        indexAxis: "y",
                        scales: {
                            y: {
                                stacked: true,
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }
            // Configuration for 'boxplot' graph
            if (graphType === "boxplot") {
                return {
                    type: "boxplot",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                ticks: {
                                    minRotation: 45,
                                    maxRotation: 45,
                                },
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                enabled: false,
                            },
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }
        }

        // function to prepare the data in the correct format for statistics graphs
        function get_statistics_graph_data(dataType, graphType, filteredData) {
            // Cache DOM values once for performance
            const keywordSelect = document.getElementById("keywordSelect").value;
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            // Initialize arrays to store the data
            const passed = [], failed = [], skipped = [], labels = [], aliases = [], names = [];
            // Helper function to calculate percentages
            const calculate_percentage = (value, total) => Math.round((value / total) * 100 * 100) / 100;
            // Helper function to process each value for graph data
            const process_value = (value) => {
                const total = value.passed + value.failed + value.skipped;
                const passedPercentage = calculate_percentage(value.passed, total);
                const failedPercentage = calculate_percentage(value.failed, total);
                const skippedPercentage = calculate_percentage(value.skipped, total);
                passed.push(passedPercentage);
                failed.push(failedPercentage);
                skipped.push(skippedPercentage);
                labels.push(value.run_start);
                aliases.push(value.run_alias);
                names.push(value.name)
            };
            // Loop through filtered data and process it based on the graph type
            for (const value of filteredData) {
                if (dataType === "suite" && suiteSelectSuites !== "All" && value.name !== suiteSelectSuites) continue;
                if (dataType === "keyword" && value.name !== keywordSelect) continue;
                // Process percentage-based data
                if (graphType === "percentages") {
                    if (dataType === "keyword") {
                        if (value.name === keywordSelect) {
                            process_value(value);
                        }
                    } else {
                        process_value(value);
                    }
                } else {
                    // Process raw count data
                    passed.push(value.passed);
                    failed.push(value.failed);
                    skipped.push(value.skipped);
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    names.push(value.name)
                }
            }
            // Determine if we need to use aliases for labels
            const finalLabels = graphType !== "line" ? (use_run_aliases ? aliases : labels) : labels;
            // Common dataset construction logic
            const create_data_set = (label, data, backgroundColor, borderColor) => ({
                label,
                data,
                backgroundColor,
                borderColor,
                borderWidth: 1,
                stack: graphType === "percentages" || "amount" ? "Stack 0" : undefined,
            });
            // Construct the statistics data based on the graph type
            const statisticsData = {
                labels: finalLabels,
                datasets: [
                    create_data_set("Failed", failed, failedBackgroundColor, failedBackgroundBorderColor),
                    create_data_set("Skipped", skipped, skippedBackgroundColor, skippedBackgroundBorderColor),
                    create_data_set("Passed", passed, passedBackgroundColor, passedBackgroundBorderColor),
                ],
            };
            return [statisticsData, names];
        }

        // function to prepare the data in the correct format for duration graphs
        function get_duration_graph_data(dataType, graphType, objectDataAttribute, filteredData) {
            // Cache DOM elements once for performance
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const keywordSelect = document.getElementById("keywordSelect").value;
            // Helper function for filtering based on selection criteria
            const should_include = (value) => {
                if (dataType === "keyword" && value.name !== keywordSelect) return false;
                if (dataType === "suite" && suiteSelectSuites !== "All" && value.name !== suiteSelectSuites) return false;
                if (dataType === "test" && suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                if (dataType === "test" && testSelect !== "All" && value.name !== testSelect) return false;
                if (dataType === "test" && testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) return false;
                return true;
            };
            // Bar graph construction
            if (graphType === "bar") {
                const labels = [];
                const data = new Map();
                const aliases = [];
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    for (const [key, arr] of data.entries()) {
                        arr.push(key === value.name ? roundedValue : 0); // Append to each dataset
                    }
                    if (!data.has(value.name)) {
                        const arr = Array(labels.length - 1).fill(0); // Fill up to current length
                        arr.push(roundedValue);
                        data.set(value.name, arr);
                    }
                    if (labels.length > 30) break;
                }
                if (use_run_aliases) {
                    labels.length = 0;
                    labels.push(...aliases);
                }
                // Prepare graph data for bar chart
                const graphData = {
                    labels,
                    datasets: Array.from(data.entries()).map(([label, dataset]) => ({
                        label,
                        data: dataset,
                        stack: "Stack 0",
                    })),
                };
                return graphData;
            }
            // Line graph construction
            else if (graphType === "line") {
                const labels = [];
                const sets = new Map();
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    const name = value.name;
                    const run_start = new Date(value.run_start);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    if (!sets.has(name)) {
                        labels.push(name);
                        sets.set(name, [{ x: run_start, y: roundedValue }]);
                    } else {
                        sets.get(name).push({ x: run_start, y: roundedValue });
                    }
                }
                // Prepare graph data for line chart
                const datasets = Array.from(sets.entries()).map(([key, values]) => ({
                    label: key,
                    fill: false,
                    data: values,
                }));
                return datasets;
            }
        }

        // function to prepare the data in the correct format for the duration deviation graph
        function get_duration_deviation_data(dataType, graphType, filteredData) {
            // Cache the DOM selections once to avoid repeated access
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            // Use a Map to store data for better performance and management
            const data = new Map();
            // Iterate over filteredData to collect elapsed times
            for (const value of filteredData) {
                // Apply filtering based on user selections
                if (dataType === "test") {
                    if (suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                        continue;
                    }
                    if (testSelect !== "All" && value.name !== testSelect) {
                        continue;
                    }
                    if (testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) {
                        continue;
                    }
                }
                // Add elapsed time data to the Map, grouping by test name
                if (data.has(value.name)) {
                    data.get(value.name).push(value.elapsed_s);
                } else {
                    data.set(value.name, [value.elapsed_s]);
                }
            }
            // Prepare the data for the graph (labels and datasets)
            const labels = [];
            const datasets = [];
            // Iterate over the Map and construct graph data
            for (const [testName, elapsedTimes] of data.entries()) {
                labels.push(testName);
                datasets.push(elapsedTimes);
            }
            // Return the graph data object
            return {
                labels,
                datasets: [{
                    itemRadius: 3,
                    data: datasets
                }],
            };
        }

        // function to prepare the data in the correct format for (recent) most flaky test graph
        function get_most_flaky_data(dataType, graphType, filteredData, ignore, recent) {
            var data = {};
            for (value of filteredData) {
                if (data[value.name]) {
                    data[value.name]['run_starts'].push(value.run_start)
                    var current_status
                    if (value.passed == 1) { current_status = 'passed' }
                    else if (value.failed == 1) {
                        current_status = 'failed'
                        data[value.name]['failed_run_starts'].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            current_status = 'skipped'
                            data[value.name]['failed_run_starts'].push(value.run_start)
                        }
                    }
                    if (current_status != data[value.name]['previous_status']) {
                        data[value.name]['flips'] += 1
                        data[value.name]['previous_status'] = current_status
                    }
                } else {
                    var previous_status
                    data[value.name] = {
                        'run_starts': [value.run_start],
                        'flips': 0,
                        'failed_run_starts': []
                    }
                    if (value.passed == 1) { previous_status = 'passed' }
                    else if (value.failed == 1) {
                        previous_status = 'failed'
                        data[value.name]['failed_run_starts'].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            previous_status = 'skipped'
                            data[value.name]['failed_run_starts'].push(value.run_start)
                        }
                    }
                    data[value.name]['previous_status'] = previous_status
                }
            }
            var sortedData = [];
            for (var test in data) {
                if (data[test].flips > 0) {
                    sortedData.push([test, data[test]]);
                }
            }
            sortedData.sort(function (a, b) {
                return b[1].flips - a[1].flips;
            });
            if (recent) { // do extra filtering to get most recent flaky tests at the top
                sortedData.sort(function (a, b) {
                    return new Date(b[1].failed_run_starts[b[1].failed_run_starts.length - 1]).getTime() - new Date(a[1].failed_run_starts[a[1].failed_run_starts.length - 1]).getTime()
                })
            }
            if (graphType == "bar") {
                var [datasets, labels, count] = [[], [], 0];
                for (key in sortedData) {
                    if (count > 9) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    datasets.push(sortedData[key][1].flips);
                    count += 1;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                return [graphData, data];
            } else if (graphType == "timeline") {
                var [labels, runStarts, count, run_aliases] = [[], [], 0, []];
                for (key in sortedData) {
                    if (count > 9) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    for (runStart of sortedData[key][1].run_starts) {
                        if (!runStarts.includes(runStart)) {
                            runStarts.push(runStart);
                        }
                    }
                    count += 1;
                }
                var datasets = [];
                var runAxis = 0;
                runStarts = runStarts.sort((a, b) => new Date(a).getTime() - new Date(b).getTime())
                for (runStart of runStarts) {
                    for (label of labels) {
                        var foundValues = [];
                        for (value of filteredData) {
                            if (value.name == label && value.run_start == runStart) {
                                foundValues.push(value);
                                if (!run_aliases.includes(value.run_alias)) { run_aliases.push(value.run_alias) }
                            }
                        }
                        if (foundValues.length > 0) {
                            var value = foundValues[0];
                            if (value.passed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: passedBackgroundColor,
                                    borderColor: passedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                            else if (value.failed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: failedBackgroundColor,
                                    borderColor: failedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                            else if (value.skipped == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: skippedBackgroundColor,
                                    borderColor: skippedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                        }
                    }
                    runAxis += 1;
                }
                if (use_run_aliases) { runStarts = run_aliases }
                var graphData = {
                    labels: labels,
                    datasets: datasets,
                };
                return [graphData, runStarts];
            }
        }

        // function to prepare the data in the correct format for most failed graphs
        function get_most_failed_data(dataType, graphType, filteredData) {
            // Maps to store data and aliases
            const data = new Map();
            const aliases = new Map();
            // Collect data and aliases
            for (const value of filteredData) {
                if (value.failed > 0) {
                    if (!data.has(value.name)) {
                        data.set(value.name, []);
                        aliases.set(value.name, []);
                    }
                    data.get(value.name).push(value.run_start);
                    aliases.get(value.name).push(value.run_alias);
                }
            }
            // Sort the data based on the number of failures (descending order)
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (graphType === 'bar') {
                const datasets = [];
                const labels = [];
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(name);
                    if (use_run_aliases) {
                        data.set(name, aliases.get(name));
                    }
                    datasets.push(runStarts.length);
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                const callbackData = Object.fromEntries(sortedData.map(([name, runs]) => [name, aliases.get(name)]));
                return [graphData, callbackData];
            } else if (graphType === 'timeline') {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                // Collect unique run starts and labels
                for (const [name, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(name);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                // Convert set to sorted array
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                // Build datasets
                const datasets = [];
                let runAxis = 0;
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => value.name === label && value.run_start === runStart && value.failed > 0);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundBorderColor,
                                borderWidth: 1,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                const runStartsArray = use_run_aliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to prepare the data in the correct format for messages graphs
        function get_messages_data(dataType, graphType, filteredData) {
            // Maps to store data and aliases
            const data = new Map();
            const aliases = new Map();
            // Build data and aliases
            for (const value of filteredData) {
                if (value.message && (value.failed === 1 || value.skipped === 1)) {
                    if (!data.has(value.message)) {
                        data.set(value.message, []);
                        aliases.set(value.message, []);
                    }
                    data.get(value.message).push(value.run_start);
                    aliases.get(value.message).push(value.run_alias);
                }
            }
            // If there is a message config use that to merge the data
            if (!message_config.includes('placeholder_message_config')) {
                function matches_message_config(str, rule) {
                    rule = rule.replace(/\$\{.*?\}/g, "*") // match any ${something} string
                    var escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"); // escape the test messages to prevent regex mismatches
                    return new RegExp("^" + rule.split("*").map(escapeRegex).join(".*") + "$").test(str);
                }
                for (const config of message_config) {
                    for (const [message, runStarts] of data) {
                        if (message == config) { continue }
                        if (matches_message_config(message, config)) {
                            if (!data.has(config)) {
                                data.set(config, []);
                            }
                            data.get(config).push(...runStarts);
                            data.delete(message)
                        }
                    }
                }

                for (const [message, runStarts] of data) {
                    arrayWithDuplicates = data.get(message)
                    data.set(message, [...new Set(arrayWithDuplicates)])
                }
            }

            // Sort messages by failure count
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (graphType === 'bar') {
                const [datasets, labels] = [[], []];
                let count = 0;

                for (const [message, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(message);
                    datasets.push(runStarts.length);
                    if (use_run_aliases) {
                        data.set(message, aliases.get(message));
                    }
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                const callbackData = Object.fromEntries(sortedData.map(([message, runs]) => [message, aliases.get(message)]));
                return [graphData, callbackData];
            } else if (graphType === 'timeline') {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                // Collect unique run starts and labels
                for (const [message, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(message);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                // Convert set to sorted array
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                // Build datasets
                const datasets = [];
                let runAxis = 0;
                function check_label(message, label) {
                    return !message_config.includes('placeholder_message_config')
                        ? matches_message_config(message, label)
                        : message === label;
                }
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => check_label(value.message, label) && value.run_start === runStart);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundBorderColor,
                                borderWidth: 1,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                const runStartsArray = use_run_aliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to update the height of the test statistics graph and enable scrolling
        function update_height(verticalId, graph) {
            document.getElementById(verticalId).style.height = `489px`
            if (graph.data.labels.length > 10) {
                var newHeight = 489 + (graph.data.labels.length - 10) * 25
                document.getElementById(verticalId).style.height = `${newHeight}px`
            }
        }

        ///////////////////////////////////
        // RENDER DATA & GRAPH FUNCTIONS //
        ///////////////////////////////////

        // function to update all graph data, function is called when updating filters and when the page loads
        function setup_data_and_graphs() {
            setup_spinner(false)

            // Let the browser render before continuing
            setTimeout(() => {
                setup_filtered_data_and_filters();
                setup_section_order();
                setup_graph_order();
                setup_collapsables();
                setup_eventlisteners_graph_view_buttons();
                setup_eventlisteners_filter_buttons();
                setup_all_graphs();
                setup_spinner(true);
            }, 0);
        }

        // function updates the data in the graphs whenever filters are updated
        function setup_filtered_data_and_filters() {
            // filter run data
            filteredRuns = filter_runs(runs);
            filteredRuns = filter_runtags(filteredRuns);
            filteredRuns = filter_dates(filteredRuns);
            filteredRuns = filter_amount(filteredRuns);
            // filter suites and tests based on filtered runs
            filteredSuites = filter_data("suites");
            filteredTests = filter_data("tests");
            filteredKeywords = filter_data("keywords");
            // set titles with amount of filtered items
            const runAmount = Object.keys(filteredRuns).length
            const message = `<h6>showing ${runAmount} of ${filteredAmount} runs<h6>`
            document.getElementById("runTitle").innerHTML = `Run Statistics (${runAmount}) ${message}`;
            document.getElementById("suiteTitle").innerHTML = `Suite Statistics (${Object.keys(filteredSuites).length}) ${message}`;
            document.getElementById("testTitle").innerHTML = `Test Statistics (${Object.keys(filteredTests).length}) ${message}`;
            document.getElementById("keywordTitle").innerHTML = `Keyword Statistics (${Object.keys(filteredKeywords).length}) ${message}`;
            // update tests select based on filtered runs
            setup_suites_in_selects();
            setup_testtags_in_select();
            setup_tests_in_select();
            setup_keywords_in_select();
        }

        // function that updates all graphs based on the new filtered data and hidden choices
        function setup_all_graphs() {
            create_run_statistics_graph();
            create_run_duration_graph();
            create_run_table();
            create_suite_statistics_graph();
            create_suite_duration_graph();
            create_suite_most_failed_graph();
            create_suite_table();
            create_test_statistics_graph();
            create_test_duration_graph();
            create_test_duration_deviation_graph();
            create_test_most_flaky_graph();
            create_test_recent_most_flaky_graph();
            create_test_most_failed_graph();
            create_test_messages_graph();
            create_test_table();
            create_keyword_statistics_graph();
            create_keyword_times_run_graph();
            create_keyword_total_duration_graph();
            create_keyword_average_duration_graph();
            create_keyword_min_duration_graph();
            create_keyword_max_duration_graph();
            create_keyword_table();
        }

        // function to order the sections according to the localstorage config
        function setup_section_order() {
            var prevId = '#loading'
            const sectionShowList = JSON.parse(localStorage.getItem('sectionShow'));
            for (let section of sectionShowList) {
                var nextId = `#${space_to_camelcase(section + ' Section')}`
                document.getElementById(`${space_to_camelcase(section + ' Section')}`).hidden = false
                $(nextId).insertAfter(prevId)
                prevId = nextId
            }
            const sectionHideList = JSON.parse(localStorage.getItem('sectionHide'));
            for (let section of sectionHideList) {
                document.getElementById(`${space_to_camelcase(section + ' Section')}`).hidden = true
            }
        }

        // function to order the grphs according to the localstorage config
        function setup_graph_order() {
            setup_graphs('Run')
            setup_graphs('Suite')
            setup_graphs('Test')
            setup_graphs('Keyword')
        }

        function setup_graphs(section) {
            const lowerCaseSection = section.toLowerCase()
            const sectionDataElement = document.getElementById(lowerCaseSection + 'Data')
            const sectionDataHiddenElement = document.getElementById(lowerCaseSection + 'DataHidden')
            const sectionDataHiddenTempElement = document.getElementById(lowerCaseSection + 'DataHiddenTemp')
            // first move all graphs from the {section}Data element to {section}DataHidden to have a clean start if it is not the first load
            if (sectionDataElement.children.length > 0) {
                sectionDataHiddenElement.innerHTML = sectionDataElement.innerHTML
                sectionDataElement.innerHTML = ''
                // also use the temphidden elements if it's not empty (they are placed there if they are hidden by the config)
                if (sectionDataHiddenTempElement.children.length > 0) {
                    while (sectionDataHiddenTempElement.children.length > 0) {
                        sectionDataHiddenElement.appendChild(sectionDataHiddenTempElement.children[0]);
                    }
                }
                // exception to handle tables because they are completely altered by the datatables module on creation
                const sectionTableElement = document.getElementById(lowerCaseSection + 'TableCanvas')
                sectionTableElement.innerHTML = `<table class="table table-striped" id="${lowerCaseSection}Table"></table>`
            }

            const chevronRow = `<div class="row" id="${lowerCaseSection}Chevron{index}">
                                    <div class="col-auto mt-1">
                                        <div class="btn btn-sm btn-secondary collapse-icon" id="${lowerCaseSection}ChevronButton{index}" data-bs-toggle="collapse"
                                            data-bs-target="#${lowerCaseSection}Data{index}" aria-expanded="true" aria-controls="${lowerCaseSection}Data{index}">
                                        </div>
                                    </div>
                                    <div class="col">
                                        <h5 class='sectionTitle'>{title}</h5>
                                    </div>
                                </div>`
            const dataRow = `<div class="row collapse show" id="${lowerCaseSection}Data{index}">
                                {canvas}
                            </div>`

            // helper function to create the chevron rows and data rows in the sections
            function position_graph(graph) {
                const camelCaseGraph = space_to_camelcase(graph)
                const graphDataElement = document.getElementById(camelCaseGraph + 'Canvas')
                const canvas = graphDataElement.outerHTML
                graphDataElement.remove()
                if (sectionDataElement.lastChild == null) {
                    // there is no data row yet > create a new row
                    if (graph.includes('Table')) {
                        sectionDataElement.innerHTML = chevronRow.replaceAll('{index}', '1').replace('{title}', graph).replace('collapse-icon', 'collapse-icon collapsed')
                        sectionDataElement.insertAdjacentHTML('beforeend', dataRow.replace('{index}', '1').replace('{canvas}', canvas).replace('collapse show', 'collapse'))
                    } else {
                        sectionDataElement.innerHTML = chevronRow.replaceAll('{index}', '1').replace('{title}', graph)
                        sectionDataElement.insertAdjacentHTML('beforeend', dataRow.replace('{index}', '1').replace('{canvas}', canvas))
                    }
                } else {
                    const index = parseInt(sectionDataElement.lastChild.id.match(/\d+/)[0], 10) + 1
                    if (graph.includes('Table')) {
                        // it's a table which automatically comes on a new row
                        sectionDataElement.insertAdjacentHTML('beforeend', chevronRow.replaceAll('{index}', `${index}`).replace('{title}', graph).replace('collapse-icon', 'collapse-icon collapsed'))
                        sectionDataElement.insertAdjacentHTML('beforeend', dataRow.replace('{index}', `${index}`).replace('{canvas}', canvas).replace('collapse show', 'collapse'))
                    } else if (sectionDataElement.lastChild.children.length == 1) {
                        // there is 1 canvas in the data row
                        if (sectionDataElement.lastChild.children[0].id.includes('Table')) {
                            // it's a table > create a new row
                            sectionDataElement.insertAdjacentHTML('beforeend', chevronRow.replaceAll('{index}', `${index}`).replace('{title}', graph))
                            sectionDataElement.insertAdjacentHTML('beforeend', dataRow.replace('{index}', `${index}`).replace('{canvas}', canvas))
                        } else {
                            // it's a graph > add it to the row
                            sectionDataElement.lastChild.insertAdjacentHTML('beforeend', canvas)
                            const titleElement = sectionDataElement.children[sectionDataElement.children.length - 2].querySelector('.sectionTitle')
                            const oldTitle = titleElement.innerText
                            titleElement.innerText = oldTitle + ` & ${graph}`
                        }
                    } else if (sectionDataElement.lastChild.children.length == 2) {
                        // there are 2 canvasses in the data row > create a new row
                        sectionDataElement.insertAdjacentHTML('beforeend', chevronRow.replaceAll('{index}', `${index}`).replace('{title}', graph))
                        sectionDataElement.insertAdjacentHTML('beforeend', dataRow.replace('{index}', `${index}`).replace('{canvas}', canvas))
                    }
                }
            }

            // order the graphs correctly
            const graphShowList = JSON.parse(localStorage.getItem('graphShow'));
            for (let graph of graphShowList) {
                if (graph.startsWith(section)) {
                    position_graph(graph)
                }
            }
            // move the hidden items to temp hidden to keep the HTML available for reconfiguration
            const graphHideList = JSON.parse(localStorage.getItem('graphHide'));
            for (let graph of graphHideList) {
                if (graph.startsWith(section)) {
                    const camelCaseGraph = space_to_camelcase(graph)
                    const graphDataElement = document.getElementById(camelCaseGraph + 'Canvas')
                    sectionDataHiddenTempElement.appendChild(graphDataElement)
                }
            }
        }

        ///////////////////////////
        // MAIN FUNCTION ON LOAD //
        ///////////////////////////

        // function that triggers all functions that should be executed when the dashboard is loaded first
        // in the correct order!
        function main() {
            setup_theme();
            setup_stats();
            setup_customize_view_button_eventlisteners();
            setup_customize_view_arrow_eventlisteners();
            setup_customize_view_local_storage();
            setup_customize_view_content();
            update_customize_view_local_storage();
            setup_eventlisteners_section_filter_buttons();
            setup_run_amount_filter();
            setup_lowest_highest_dates();
            setup_runs_in_select_filter_buttons();
            setup_runtags_in_select_filter_buttons();
            setup_data_and_graphs();
        }

        // trigger of first load
        main()
    </script>
</body>

</html>