(function(M,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],u):(M=typeof globalThis<"u"?globalThis:M||self,u(M.trame_vtklocal={},M.Vue))})(this,function(M,u){"use strict";const _="",b=[],y={};function W(){let r,e;return{promise:new Promise((t,s)=>{r=t,e=s}),resolve:r,reject:e}}function O(r){return y[r]||(y[r]=new Promise(function(e,n){if(b.indexOf(r)===-1){b.push(r);var t=document.createElement("script");t.type="module",t.src=r,t.onload=e,t.onerror=n,document.body.appendChild(t)}else e(!1)})),y[r]}class p{constructor(){this.updateInProgress=0,this.loaded=!1,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.loadingPending=null,this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e){if(!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:n,resolve:t}=W();this.loadingPending=n;const s=`${e}/vtkWasmSceneManager.mjs`;await O(s);const o=await window.createVTKWasmSceneManager({});o.initialize(),this.sceneManager=o,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWebAssemblyOpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkWin32OpenGLRenderWindow","vtkCocoaRenderWindow"].forEach(d=>this.sceneManager.skipProperty(d,"Size"))),this.loaded=!0,t()}}bindNetwork(e,n,t){this.networkFetchState=e,this.networkFetchHash=n,this.networkFetchStatus=t}freeMemory(e=0){const n=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(n>t){const s={};let o=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([d,h])=>{h<o&&(o=h);const c=h.toString();s[c]?s[c].push(d):s[c]=[d]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const d=s[o];if(d)for(let h=0;h<d.length;h++)this.sceneManager.unRegisterBlob(d[h]),delete this.hashesMTime[d[h]];o++}}}async fetchState(e){const n=await this.networkFetchState(e);return this.patchState(n)}patchState(e){var n;if(e.length>0){const t=JSON.parse(e),{Id:s,MTime:o}=t;if(this.stateMTimes[s]=o,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(s)&&((n=t==null?void 0:t.Interactor)!=null&&n.Id))return this.renderWindowIdToInteractorId.set(t.Interactor.Id,s),t.CanvasSelector=this.getCanvasSelector(s),delete t.Size,this.renderWindowSizes[s]&&(t.Size=this.renderWindowSizes[s]),t.ClassName="vtkCocoaRenderWindow",JSON.stringify(t);if(this.renderWindowIdToInteractorId.has(s))return t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(s)),JSON.stringify(t)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const n=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,n}pushHash(e,n){return this.pendingArrays[e]=new Promise(t=>{n.arrayBuffer?n.arrayBuffer().then(s=>{this.sceneManager.registerBlob(e,new Uint8Array(s)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e,n=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const t=await this.networkFetchStatus(e),s=[],o=[],d=t.force_push||[];for(let c=0;c<d.length;c++)delete this.stateMTimes[d[c]];t.ids.forEach(([c,a])=>{(!this.stateMTimes[c]||this.stateMTimes[c]<a)&&o.push(this.fetchState(c))}),t.hashes.forEach(c=>{this.hashesMTime[c]||s.push(this.fetchHash(c)),this.hashesMTime[c]=this.currentMTime}),t.cameras.forEach(c=>this.cameraIds.add(Number(c))),t.ignore_ids.forEach(c=>this.sceneManager.unRegisterState(c)),await Promise.all(s),await Promise.all(Object.values(this.pendingArrays));const h=await Promise.all(o);for(this.currentMTime++;h.length;){const c=h.pop();c&&this.sceneManager.registerState(c)}try{this.sceneManager.updateObjectsFromStates();const[c,a]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,c,a),n&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),this.sceneManager.render(e)}catch(c){console.error("WASM update failed"),console.log(c)}}catch(t){console.error("Error in update",t)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,n=!1){const t=Number(e);return n&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,n=!1){const t=Array.isArray(e)?e:[e];let s=null;for(let o=0;o<t.length;o++){const d=t[o];o===0?s=this.getState(d,n):(s=s[d],s.Id&&(s=this.getState(s.Id,n)))}return s}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,n){const t=this.getCanvasSelector(e);let s=this.offlineCanvasContainer.querySelector(t);return s||(s=document.createElement("canvas"),s.setAttribute("class",t.substring(1)),s.setAttribute("tabindex","0")),n.appendChild(s),t}unbindCanvasToDOM(e){const n=this.getCanvasSelector(e),t=document.querySelector(n);t&&this.offlineCanvasContainer.appendChild(t)}setSize(e,n,t){this.renderWindowSizes[e]=[n,t];const s=this.getCanvasSelector(e),o=document.querySelector(s);o&&(o.width=n,o.height=t,this.sceneManager.setSize(e,n,t),this.sceneManager.render(e))}}const m={};function v(r,e,n){return function(){e.clearStateCache();for(const[t,s]of Object.entries(n)){const o={};for(const[d,h]of Object.entries(s))o[d]=e.getStateValue(h,!0);r.state.set(t,o)}e.clearStateCache()}}const C={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},listeners:{type:Object}},setup(r,{emit:e}){r.useHandler&&!m[r.useHandler]&&(m[r.useHandler]=new p);const n=u.inject("trame"),t=n.state.get("__trame_vtklocal_wasm_url"),s=[],o=[],d=u.ref(null),h=r.wsClient||(n==null?void 0:n.client),c=u.toRef(r,"listeners"),a=r.useHandler?m[r.useHandler]:new p;let w=null;async function z(i){return await h.getConnection().getSession().call("vtklocal.get.state",[i])}async function j(i){const g=await h.getConnection().getSession().call("vtklocal.get.hash",[i]);return g.arrayBuffer?new Uint8Array(await g.arrayBuffer()):g}async function A(i){return await h.getConnection().getSession().call("vtklocal.get.status",[i])}function E([i]){i.type==="state"&&a.pushState(i.content),i.type==="blob"&&a.pushHash(i.hash,i.content)}async function P(){const i=h.getConnection().getSession();w=i.subscribe("vtklocal.subscriptions",E),await i.call("vtklocal.subscribe.update",[r.renderWindow,1])}async function R(){const i=h.getConnection().getSession();w&&(i.unsubscribe(w),w=null),await i.call("vtklocal.subscribe.update",[r.renderWindow,-1])}function L(){const{width:i,height:l}=d.value.getBoundingClientRect(),g=Math.floor(i*window.devicePixelRatio+.5),f=Math.floor(l*window.devicePixelRatio+.5);a.setSize(r.renderWindow,g,f)}let S=new ResizeObserver(L);function H(){a.freeMemory(r.cacheSize),e("memory-vtk",a.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",a.sceneManager.getTotalBlobMemoryUsage())}async function T(i=!1){a.loaded&&(await a.update(r.renderWindow,i),e("updated"),H())}function V(i){a.sceneManager.resetCamera(i),a.sceneManager.render(r.renderWindow)}async function F(i,l,g){const f=await a.sceneManager.invoke(i,l,g);return f.Id&&f.Success&&(f.Value=a.getState(f.Id)),e("invoke-response",f),f}function N(){a.sceneManager.printSceneManagerInformation()}u.onMounted(async()=>{a.bindNetwork(z,j,A),a.loaded||await a.load(t);const i=a.bindCanvasToDOM(r.renderWindow,u.unref(d));u.unref(d).querySelector(i).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),r.eagerSync&&P(),S&&S.observe(u.unref(d)),u.watchEffect(()=>{const l=r.verbosity;l.objectManager&&a.sceneManager.setObjectManagerLogVerbosity&&a.sceneManager.setObjectManagerLogVerbosity(l.objectManager),l.invoker&&a.sceneManager.setInvokerLogVerbosity&&a.sceneManager.setInvokerLogVerbosity(l.invoker),l.deserializer&&a.sceneManager.setDeserializerLogVerbosity&&a.sceneManager.setDeserializerLogVerbosity(l.deserializer),l.serializer&&a.sceneManager.setSerializerLogVerbosity&&a.sceneManager.setSerializerLogVerbosity(l.serializer)}),await T(!0),a.cameraIds.forEach(l=>{s.push([l,a.sceneManager.addObserver(l,"ModifiedEvent",()=>{e("camera",a.getState(l))})])}),u.watchEffect(()=>{for(;o.length;){const[l,g]=o.pop();a.sceneManager.removeObserver(l,g)}for(const[l,g]of Object.entries(c.value||{})){const f=Number(l);for(const[x,U]of Object.entries(g||{})){const k=v(n,a,U);o.push([f,a.sceneManager.addObserver(f,x,k)]),k()}}}),a.sceneManager.startEventLoop(r.renderWindow)||console.error("Could not startEventLoop for",r.renderWindow)}),u.onBeforeUnmount(()=>{for(w&&R();s.length;){const[i,l]=s.pop();a.sceneManager.removeObserver(i,l)}for(;o.length;){const[i,l]=o.pop();a.sceneManager.removeObserver(i,l)}a.sceneManager.stopEventLoop(r.renderWindow),S&&(S.disconnect(),S=null),a.unbindCanvasToDOM(r.renderWindow)});function B(i){v(n,a,i)()}function D(){r.useHandler&&m[r.useHandler]&&delete m[r.useHandler]}return{container:d,update:T,resetCamera:V,evalStateExtract:B,invoke:F,printSceneManagerInformation:N,detachHandler:D}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function I(r){Object.keys(C).forEach(e=>{r.component(e,C[e])})}M.install=I,Object.defineProperty(M,Symbol.toStringTag,{value:"Module"})});
