import json
import logging
from typing import Any

import ollama

from ..._core import Core, ToolSupport
from ..._util import (
    CreatorRole,
    ChatCompletionConfig,
    MessageBlock,
)
from ..._tool import Tool, ToolMetadata
from ..._util import TokenUsage
from .base import OllamaCore, TOOL_PROMPT

logger = logging.getLogger(__name__)


class T2T_OLM_Core(Core, OllamaCore, ToolSupport):
    """
    `T2T_OLM_Core` is a concrete implementation of abstract base classes `Core` and `ToolSupport`.
    `T2T_OLM_Core` is also a child class of `OllamaCore`.

    It facilitates synchronous and asynchronous communication with Ollama's API.

    Methods:
    - run(query: str, context: list[MessageBlock | dict] | None, **kwargs) -> tuple[list[MessageBlock | dict], TokenUsage]:
        Synchronously run the LLM model with the given query and context.
    - run_async(query: str, context: list[MessageBlock | dict] | None, **kwargs) -> tuple[list[MessageBlock | dict], TokenUsage]:
        Asynchronously run the LLM model with the given query and context.
    - call_tools_async(selected_tools: list) -> list[MessageBlock | dict]:
        Asynchronously call tools.
    - call_tools(selected_tools: list) -> list[MessageBlock | dict]:
        Synchronously call tools.

    Notes:
    - The caller is responsible for memory management, output parsing and error handling.
    - The caller is responsible for choosing models that support `Tools`.
    - If model is not available locally, an attempt to pull it from Ollama's server will be made.
    - `context_length` is configurable.
    - `max_output_tokens` is configurable.
    """

    def __init__(
        self,
        connection_string: str,
        system_prompt: str,
        config: ChatCompletionConfig,
        tools: list[Tool] | None = None,
    ):
        Core.__init__(self, system_prompt, config)
        OllamaCore.__init__(self, connection_string, config.name)
        ToolSupport.__init__(self, tools)
        self.profile = self.build_profile(model_name=config.name)
        if tools and self.profile.get("tool", False) is False:
            logger.warning("Tool might not work on this %s", self.model_name)

    async def run_async(
        self, query: str, context: list[MessageBlock | dict] | None, **kwargs
    ) -> tuple[list[MessageBlock | dict[str, Any]], TokenUsage]:
        """
        Asynchronously run the LLM model with the given query and context.

        Args:
            query (str): The query to be processed by the LLM model.
            context (list[MessageBlock | dict] | None): The context to be used for the LLM model.
            **kwargs: Additional keyword arguments.

        Returns:
            list[MessageBlock | dict]: The list of messages generated by the LLM model.
            TokenUsage: The recorded token usage.

        Notes:
        * Early Termination Condition:
                * If a solution is found.
                * If the maximum iteration is reached.
                * If the accumulated token count is greater than or equal to the maximum token count.
                * If the maximum output tokens are less than or equal to zero.
        """
        msgs: list[MessageBlock | dict] = [
            MessageBlock(role=CreatorRole.SYSTEM.value, content=self.system_prompt)
        ]

        if context:
            msgs.extend(context)
        msgs.append(MessageBlock(role=CreatorRole.USER.value, content=query))

        tools_metadata: list[ToolMetadata] | None = None
        if self.tools:
            tools_metadata = [tool.info for tool in self.tools]
            msgs.append(
                MessageBlock(role=CreatorRole.SYSTEM.value, content=TOOL_PROMPT)
            )

        NUMBER_OF_PRIMERS = len(msgs)  # later use this to skip the preloaded messages

        MAX_TOKENS = min(self.config.max_tokens, self.context_length)
        MAX_OUTPUT_TOKENS = min(
            MAX_TOKENS, self.max_output_tokens, self.config.max_output_tokens
        )
        prompt_token_count = self.calculate_token_count(msgs, tools_metadata, None)
        max_output_tokens = min(
            MAX_OUTPUT_TOKENS,
            self.context_length - prompt_token_count,
        )

        iteration, solved = 0, False
        token_usage = TokenUsage(input_tokens=0, output_tokens=0)
        try:
            client = ollama.AsyncClient(host=self.CONN_STRING)
            while (
                not solved
                and max_output_tokens > 0
                and iteration < self.config.max_iteration
                and token_usage.total_tokens < MAX_TOKENS
            ):
                # logger.debug("\n\nIteration: %d", iteration)
                if tools_metadata and iteration + 1 == self.config.max_iteration:
                    # Force the llm to provide answer
                    tools_metadata = None
                    msgs.remove(
                        {"role": CreatorRole.SYSTEM.value, "content": TOOL_PROMPT}
                    )
                response = await client.chat(
                    model=self.model_name,
                    messages=msgs,
                    tools=tools_metadata,
                    stream=False,
                    options={
                        "temperature": self.config.temperature,
                        "num_predict": max_output_tokens,
                    },
                )

                llm_generated_content: str = response["message"]["content"]
                if llm_generated_content:
                    msgs.append(
                        MessageBlock(
                            role=CreatorRole.ASSISTANT.value,
                            content=llm_generated_content,
                        )
                    )

                tool_calls = response["message"].get("tool_calls", None)
                if tool_calls:
                    output, ttku = await self.call_tools_async(tool_calls)
                    msgs.extend(output)
                    token_usage += ttku

                # Below are the early termination conditions
                solved = tool_calls is None
                prompt_token_count = self.calculate_token_count(
                    msgs, tools_metadata, None
                )
                max_output_tokens = min(
                    MAX_OUTPUT_TOKENS,
                    self.context_length - prompt_token_count,
                )
                iteration += 1

                token_usage = self.update_usage(response, token_usage)  # type: ignore
            # END while

            if not solved:
                warning_message = "Warning: "
                if iteration == self.config.max_iteration:
                    warning_message += f"Maximum iteration reached. {iteration}/{self.config.max_iteration}\n"
                elif token_usage.total_tokens >= MAX_TOKENS:
                    warning_message += f"Maximum token count reached. {token_usage.total_tokens}/{MAX_TOKENS}\n"
                elif max_output_tokens <= 0:
                    warning_message += f"Maximum output tokens <= 0. {prompt_token_count}/{self.context_length}\n"
                else:
                    warning_message += "Unknown reason"
                raise RuntimeError(warning_message)
            return msgs[
                NUMBER_OF_PRIMERS:
            ], token_usage  # Return only the generated messages
        except Exception as e:
            logger.error("Exception: %s", e, exc_info=True, stack_info=True)
            raise

    def run(
        self, query: str, context: list[MessageBlock | dict] | None, **kwargs
    ) -> tuple[list[MessageBlock | dict[str, Any]], TokenUsage]:
        """
        Synchronously generate text based on the given query and context.

        Args:
            query (str): The query to generate text for.
            context (list): A list of context messages or dictionaries.
            **kwargs: Additional keyword arguments.

        Returns:
            list[MessageBlock | dict]: The list of messages generated by the LLM model.
            TokenUsage: The recorded token usage.

        Notes:
        * Early Termination Condition:
                * If a solution is found.
                * If the maximum iteration is reached.
                * If the accumulated token count is greater than or equal to the maximum token count.
                * If the maximum output tokens are less than or equal to zero.
        """
        msgs: list[MessageBlock | dict] = [
            MessageBlock(role=CreatorRole.SYSTEM.value, content=self.system_prompt)
        ]

        if context:
            msgs.extend(context)
        msgs.append(MessageBlock(role=CreatorRole.USER.value, content=query))

        tools_metadata: list[ToolMetadata] | None
        if self.tools:
            tools_metadata = [tool.info for tool in self.tools]
            msgs.append(
                MessageBlock(role=CreatorRole.SYSTEM.value, content=TOOL_PROMPT)
            )
        else:
            tools_metadata = None

        NUMBER_OF_PRIMERS = len(msgs)  # Use this to skip the preloaded messages

        MAX_TOKENS = min(self.config.max_tokens, self.context_length)
        MAX_OUTPUT_TOKENS = min(
            MAX_TOKENS, self.max_output_tokens, self.config.max_output_tokens
        )
        prompt_token_count = self.calculate_token_count(msgs, tools_metadata, None)
        max_output_tokens = min(
            MAX_OUTPUT_TOKENS,
            self.context_length - prompt_token_count,
        )

        # accumulated_token_count = 0  # Accumulated token count across iterations
        iteration, solved = 0, False
        token_usage = TokenUsage(input_tokens=0, output_tokens=0)
        try:
            client = ollama.Client(host=self.CONN_STRING)
            while (
                not solved
                and max_output_tokens > 0
                and iteration < self.config.max_iteration
                and token_usage.total_tokens < MAX_TOKENS
            ):
                # logger.debug("\n\nIteration: %d", iteration)
                if tools_metadata and iteration + 1 == self.config.max_iteration:
                    # Force the llm to provide answer
                    tools_metadata = None
                    msgs.remove(
                        {"role": CreatorRole.SYSTEM.value, "content": TOOL_PROMPT}
                    )
                response = client.chat(
                    model=self.model_name,
                    messages=msgs,
                    tools=tools_metadata,
                    stream=False,
                    options={
                        "temperature": self.config.temperature,
                        "num_predict": max_output_tokens,
                    },
                )

                llm_generated_content = response["message"]["content"]
                if llm_generated_content:
                    msgs.append(
                        MessageBlock(
                            role=CreatorRole.ASSISTANT.value,
                            content=llm_generated_content,
                        )
                    )

                tool_calls = response["message"].get("tool_calls", None)
                if tool_calls:
                    output, ttku = self.call_tools(tool_calls)
                    msgs.extend(output)
                    token_usage += ttku

                # Below are the early termination conditions
                solved = tool_calls is None
                prompt_token_count = self.calculate_token_count(
                    msgs, tools_metadata, None
                )
                max_output_tokens = min(
                    MAX_OUTPUT_TOKENS,
                    self.context_length - prompt_token_count,
                )
                iteration += 1
                token_usage = self.update_usage(response, token_usage)  # type: ignore
            # END while

            if not solved:
                warning_message = "Warning: "
                if iteration == self.config.max_iteration:
                    warning_message += f"Maximum iteration reached. {iteration}/{self.config.max_iteration}\n"
                elif token_usage.total_tokens >= MAX_TOKENS:
                    warning_message += f"Maximum token count reached. {token_usage.total_tokens}/{MAX_TOKENS}\n"
                elif max_output_tokens <= 0:
                    warning_message += f"Maximum output tokens <= 0. {prompt_token_count}/{self.context_length}\n"
                else:
                    warning_message += "Unknown reason"
                raise RuntimeError(warning_message)
            return msgs[
                NUMBER_OF_PRIMERS:
            ], token_usage  # Return only the generated messages
        except Exception as e:
            logger.error("Exception: %s", e, exc_info=True, stack_info=True)
            raise

    async def call_tools_async(
        self, selected_tools: list
    ) -> tuple[list[MessageBlock | dict], TokenUsage]:
        """
        Asynchronously call every selected tools.

        Args:
            selected_tools (list): A list of selected tools.

        Returns:
            list: A list of messages generated by the tools.
            TokenUsage: The recorded token usage.

        Notes:
            - If more than one tool is selected, they are executed independently and separately.
            - Tools chaining is not supported.
            - Does not raise exception on failed tool execution, an error message is returned instead to guide the calling LLM.
        """
        output: list[MessageBlock | dict] = []
        token_usage = TokenUsage()
        for tool_call in selected_tools:
            for tool in self.tools:  # type: ignore
                if tool.token_usage.total_tokens > 0:
                    tool.reset_token_usage()

                if tool.info["function"]["name"] != tool_call.function.name:
                    continue
                args = json.dumps(tool_call.function.arguments)
                try:
                    result = await tool.run_async(args)
                    output.append(
                        MessageBlock(
                            role=CreatorRole.TOOL.value,
                            content=f"({args}) => {result}",
                            name=tool_call.function.name,
                        )
                    )
                except Exception as e:
                    output.append(
                        MessageBlock(
                            role=CreatorRole.TOOL.value,
                            content=f"({args}) => {e}",
                            name=tool_call.function.name,
                        )
                    )
                finally:
                    token_usage = token_usage + tool.token_usage
                    break

        return output, token_usage

    def call_tools(
        self, selected_tools: list
    ) -> tuple[list[MessageBlock | dict], TokenUsage]:
        """
        Synchronously call every selected tools.

        Args:
            selected_tools (list): A list of selected tools.

        Returns:
            list: A list of messages generated by the tools.
            TokenUsage: The recorded token usage.

        Notes:
            - If more than one tool is selected, they are executed independently and separately.
            - Tools chaining is not supported.
            - Does not raise exception on failed tool execution, an error message is returned instead to guide the calling LLM.
        """
        output: list[MessageBlock | dict] = []
        token_usage = TokenUsage()
        for tool_call in selected_tools:
            for tool in self.tools:  # type: ignore
                if tool.token_usage.total_tokens > 0:
                    tool.reset_token_usage()

                if tool.info["function"]["name"] != tool_call.function.name:
                    continue

                args = json.dumps(tool_call.function.arguments)
                try:
                    result = tool.run(args)
                    output.append(
                        MessageBlock(
                            role=CreatorRole.TOOL.value,
                            content=f"({args}) => {result}",
                            name=tool_call.function.name,
                        )
                    )
                except Exception as e:
                    output.append(
                        MessageBlock(
                            role=CreatorRole.TOOL.value,
                            content=f"({args}) => {e}",
                            name=tool_call.function.name,
                        )
                    )
                finally:
                    token_usage = token_usage + tool.token_usage
                    break

        return output, token_usage
