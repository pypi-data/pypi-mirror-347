from .utils.utils import COMPLEX_2_FLOAT as COMPLEX_2_FLOAT, FLOAT_2_COMPLEX as FLOAT_2_COMPLEX, INV_SQRT2 as INV_SQRT2, SQRT2 as SQRT2
from functools import lru_cache as lru_cache
from pyvqnet.dtype import C_DTYPE as C_DTYPE, D_DTYPE as D_DTYPE, F_DTYPE as F_DTYPE, Z_DTYPE as Z_DTYPE, float_dtype_to_complex_dtype as float_dtype_to_complex_dtype, get_readable_dtype_str as get_readable_dtype_str, kcomplex128 as kcomplex128, kcomplex32 as kcomplex32, kcomplex64 as kcomplex64, kfloat16 as kfloat16, kfloat32 as kfloat32, kfloat64 as kfloat64
from pyvqnet.tensor import QTensor as QTensor, tensor as tensor

def rx_matrix(params: QTensor): ...
def rz_matrix(params: QTensor):
    """Compute unitary matrix for rz gate.

    Args:
        params: The rotation angle.

    Returns:
        The computed unitary matrix.

    """
def ry_matrix(params: QTensor): ...
def rxx_matrix(params: QTensor): ...
def ryy_matrix(params: QTensor): ...
def rzz_matrix(params: QTensor): ...
def rzx_matrix(params: QTensor): ...
def u1_matrix(params: QTensor): ...
def u2_matrix(params: QTensor): ...
def u3_matrix(params: QTensor): ...
def rot_matrix(params: QTensor): ...
def cu1_matrix(params: QTensor): ...
def basic_state_projector_matrix(basis_state): ...
def isingxx_matrix(params: QTensor): ...
def isingyy_matrix(params: QTensor): ...
def isingzz_matrix(params: QTensor): ...
def isingxy_matrix(params: QTensor): ...
def phaseshift_matrix(params: QTensor): ...
def pauli_eigs(n: int) -> QTensor: ...
def multirz_matrix(params: QTensor, n_wires: int): ...
def controlledphaseshift_matrix(params: QTensor): ...
def single_excitation_matrix(params: QTensor): ...
def double_excitation_matrix(phi: QTensor): ...
def crx_matrix(params: QTensor):
    """Compute unitary matrix for CRX gate.

    .. math::

        \x08egin{align}
            CR_y(\\phi) &=
            \x08egin{bmatrix}
                1 & 0 & 0 & 0 \\\n                0 & 1 & 0 & 0\\\n                0 & 0 & \\cos(\\phi/2) & -\\sin(\\phi/2)\\\n                0 & 0 & \\sin(\\phi/2) & \\cos(\\phi/2)
            \\end{bmatrix}.
        \\end{align}
    """
def cry_matrix(params: QTensor):
    """Compute unitary matrix for CRY gate.

    .. math::

            \x08egin{align}
                CR_y(\\phi) &=
                \x08egin{bmatrix}
                    1 & 0 & 0 & 0 \\\n                    0 & 1 & 0 & 0\\\n                    0 & 0 & \\cos(\\phi/2) & -\\sin(\\phi/2)\\\n                    0 & 0 & \\sin(\\phi/2) & \\cos(\\phi/2)
                \\end{bmatrix}.
            \\end{align}

    """
def crot_matrix(params: QTensor):
    """Compute unitary matrix for CRot gate.


    """
def crz_matrix(params: QTensor):
    """Compute unitary matrix for CRZ gate.

    .. math::

        \x08egin{align}
             CR_z(\\phi) &=
             \x08egin{bmatrix}
                1 & 0 & 0 & 0 \\\n                0 & 1 & 0 & 0\\\n                0 & 0 & e^{-i\\phi/2} & 0\\\n                0 & 0 & 0 & e^{i\\phi/2}
            \\end{bmatrix}.
        \\end{align}

    """
def ccz_matrix(dtype): ...
def hadamard_matrix(dtype): ...
def shadamard_matrix(dtype): ...
def paulix_matrix(dtype): ...
def pauliy_matrix(dtype): ...
def pauliz_matrix(dtype): ...
def identity_matrix(dtype): ...
def X_matrix(dtype): ...
def Y_matrix(dtype): ...
def Z_matrix(dtype): ...
def s_matrix(dtype): ...
def t_matrix(dtype): ...
def sx_matrix(dtype): ...
def iswap_matrix(dtype): ...
def cnot_matrix(dtype): ...
def cz_matrix(dtype): ...
def cy_matrix(dtype): ...
def swap_matrix(dtype): ...
def sswap_matrix(dtype): ...
def cswap_matrix(dtype): ...
def toffoli_matrix(dtype): ...
def x1_matrix(dtype): ...
def y1_matrix(dtype): ...
def z1_matrix(dtype): ...
def sdg_matrix(dtype): ...
def tdg_matrix(dtype): ...
def ch_matrix(dtype): ...
def float_mat_dict(name: str): ...
def half_float_mat_dict(name: str): ...
def double_mat_dict(name: str): ...
