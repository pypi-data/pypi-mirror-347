---
description: 
globs: *.rs
alwaysApply: false
---
Hereâ€™s an improved and expanded version of your **Rust Web Application Development Rule**, with refinements for clarity, consistency, and completeness. Iâ€™ve also added several **recommended practices** based on real-world Rust web development experience and modern ecosystem trends:

---

# ğŸ“¦ Rust Web Application Development Guidelines

## ğŸ“ Project Structure

Follow a modular, domain-driven architecture with clearly separated concerns:

```
app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # App entry point: initialize server, tracing, config
â”‚   â”œâ”€â”€ router.rs            # Centralized routing logic
â”‚   â”œâ”€â”€ handler/             # HTTP request handlers per domain
â”‚   â”œâ”€â”€ service/             # Business logic and application services per domain
â”‚   â”œâ”€â”€ models/              # Database models (input/output structs, schema use)
â”‚   â”œâ”€â”€ extensions/          # Middlewares, extractors, guards, utils
â”‚   â””â”€â”€ config.rs            # Typed configuration loading/validation
â”œâ”€â”€ migrations/              # Diesel migrations (organized per domain if needed)
â”œâ”€â”€ crates/                  # Workspace crates (e.g., shared types, db schemas)
â”‚   â””â”€â”€ database_schema/     
â”‚       â””â”€â”€ enum_definitions.rs  # Shared enums used in DB layer
â””â”€â”€ .env                     # Environment variables
```

## âœ… Compilation and Linting

* All code **must compile** without warnings or errors (linter errors)
* Prefer `cargo fix` for resolving simple compiler suggestions

## ğŸ—ƒï¸ Database & ORM

* Use **Diesel** for type-safe SQL and **diesel\_async** for async queries (`RunQueryDsl` trait)
* For complex queries or batch operations, consider **SeaQuery**
* Use **domain-specific services** (in `service/`) to encapsulate DB logic
* Migrations:

  * Use `diesel_migrations`
  * Separate logical concerns across migration files
* Never accept `created_at`, `updated_at`, `tenant_id` in user input models â€” they are:

  * Auto-generated in DB
  * Tenant ID is inserted via the connection pool for row-level security
* Enum definitions must live in `crates/database_schema/enum_definitions.rs` and be shared via workspace crates

## â— Error Handling

* Define a centralized `AppError` type (implement `std::error::Error`, `Display`, `From`)
* Use a type alias `pub type AppResult<T> = Result<T, AppError>;`
* Never use `unwrap()` or `expect()` in production code â€” prefer `?`
* Map errors to meaningful HTTP status codes in route handlers
* Log errors with structured tracing before returning to client

## ğŸ” Row-Level Security

* `tenant_id` must not be manually inserted
* Inject `tenant_id` automatically into queries using a custom connection wrapper or Diesel helper

## âš™ï¸ Configuration Management

* Use `dotenv` crate for layered configuration
* Define strongly-typed config structs and validate them on startup
* Use [`secrecy::Secret<T>`](mdc:https:/docs.rs/secrecy) for sensitive fields like passwords or API keys
* Fail fast on invalid or missing configuration

## ğŸ§ª Testing and Observability

* Organize tests:

  * Unit tests in the same file as module
  * Integration tests in `tests/` folder



