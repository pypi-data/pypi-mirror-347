"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Language(_Language, metaclass=_LanguageEnumTypeWrapper):
    pass
class _Language:
    V = typing.NewType('V', builtins.int)
class _LanguageEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Language.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    CPP = Language.V(1)
    PYTHON = Language.V(2)
    TYPESCRIPT = Language.V(3)

CPP = Language.V(1)
PYTHON = Language.V(2)
TYPESCRIPT = Language.V(3)
global___Language = Language


class ValueRange(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    minimum: builtins.float = ...
    maximum: builtins.float = ...
    def __init__(self,
        *,
        minimum : typing.Optional[builtins.float] = ...,
        maximum : typing.Optional[builtins.float] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> None: ...
global___ValueRange = ValueRange

class OptionalValueRange(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    minimum: builtins.float = ...
    maximum: builtins.float = ...
    def __init__(self,
        *,
        minimum : typing.Optional[builtins.float] = ...,
        maximum : typing.Optional[builtins.float] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> None: ...
global___OptionalValueRange = OptionalValueRange

class SoftwareVersion(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    REVISION_FIELD_NUMBER: builtins.int
    CI_JOB_ID_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Tag or reference name of the version. It is not the the name of the software."""

    revision: typing.Text = ...
    """The GIT revision of the software version if available."""

    ci_job_id: builtins.int = ...
    """The unique continuous integration job ID if available."""

    def __init__(self,
        *,
        name : typing.Optional[typing.Text] = ...,
        revision : typing.Optional[typing.Text] = ...,
        ci_job_id : typing.Optional[builtins.int] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"ci_job_id",b"ci_job_id",u"name",b"name",u"revision",b"revision"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"ci_job_id",b"ci_job_id",u"name",b"name",u"revision",b"revision"]) -> None: ...
global___SoftwareVersion = SoftwareVersion

class HardwareModule(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERIAL_NUMBER_FIELD_NUMBER: builtins.int
    LEGACY_SERIAL_NUMBER_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    serial_number: typing.Text = ...
    """Serial number of the hardware module"""

    legacy_serial_number: typing.Text = ...
    """Deprecated legacy serial number format"""

    version: typing.Text = ...
    """Hardware version of the hardware module if available."""

    def __init__(self,
        *,
        serial_number : typing.Optional[typing.Text] = ...,
        legacy_serial_number : typing.Optional[typing.Text] = ...,
        version : typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"legacy_serial_number",b"legacy_serial_number",u"serial_number",b"serial_number",u"version",b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"legacy_serial_number",b"legacy_serial_number",u"serial_number",b"serial_number",u"version",b"version"]) -> None: ...
global___HardwareModule = HardwareModule

class Field(google.protobuf.message.Message):
    """*
    > Introduced in BSL v2.14 and firmware v1.14

    Describes a protobuf field inside a (nested) message to efficiently use reflection on all supported platforms
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Identifier(google.protobuf.message.Message):
        """Describes unique identifier of (sub) field"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ID_FIELD_NUMBER: builtins.int
        KEY_FIELD_NUMBER: builtins.int
        CAMELCASE_KEY_FIELD_NUMBER: builtins.int
        id: builtins.int = ...
        """Protobuf number of field"""

        key: typing.Text = ...
        """Protobuf key of field"""

        camelcase_key: typing.Text = ...
        """Protobuf camelcase key of field"""

        def __init__(self,
            *,
            id : typing.Optional[builtins.int] = ...,
            key : typing.Optional[typing.Text] = ...,
            camelcase_key : typing.Optional[typing.Text] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"camelcase_key",b"camelcase_key",u"id",b"id",u"key",b"key"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"camelcase_key",b"camelcase_key",u"id",b"id",u"key",b"key"]) -> None: ...

    IDENTIFIERS_FIELD_NUMBER: builtins.int
    SCALE_FIELD_NUMBER: builtins.int
    @property
    def identifiers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Field.Identifier]:
        """Path to field in relation to given top level message."""
        pass
    scale: builtins.float = ...
    """Numerical scale which is applied on a field value before using it for validation.
    This is required to prevent floating point precision issues due to rounding, which could fail a validation.<br>
    Validation example:
    Field value is stored as radian but is shown to the user as degree.
    Without scaling and rounding, a possible degree format could be rejected as it exceeded the maximum value of the radian respresentation after down-scaling.
    """

    def __init__(self,
        *,
        identifiers : typing.Optional[typing.Iterable[global___Field.Identifier]] = ...,
        scale : typing.Optional[builtins.float] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"scale",b"scale"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"identifiers",b"identifiers",u"scale",b"scale"]) -> None: ...
global___Field = Field

class Constraint(google.protobuf.message.Message):
    """*
    > Introduced in BSL v2.14 and firmware v1.14

    Describes a constraint for a single target field
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Constant(google.protobuf.message.Message):
        """Constant constraint which is used to apply min and/or max ranges"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MINIMUM_FIELD_NUMBER: builtins.int
        MAXIMUM_FIELD_NUMBER: builtins.int
        minimum: builtins.float = ...
        """Target value must be equals or higher than the specified minimum"""

        maximum: builtins.float = ...
        """Target value must be equals or smaller than the specified maximum"""

        def __init__(self,
            *,
            minimum : typing.Optional[builtins.float] = ...,
            maximum : typing.Optional[builtins.float] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum"]) -> None: ...

    class Polynomial(google.protobuf.message.Message):
        """Polynomial constraint which describe a value relationship to another field"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        REFERENCE_FIELD_NUMBER: builtins.int
        MINIMUM_FIELD_NUMBER: builtins.int
        MAXIMUM_FIELD_NUMBER: builtins.int
        @property
        def reference(self) -> global___Field:
            """Link to reference field. The value of the reference field is used as x input for the polynomial."""
            pass
        @property
        def minimum(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """Target value must be equals or higher than the specified minimum, which is described by the specified repeated coefficients: c0 + x * c1 + x^2 * c2 .."""
            pass
        @property
        def maximum(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """Target value must be equals or smaller than the specified maximum, which is described by the specified repeated coefficients: c0 + x * c1 + x^2 * c2 .."""
            pass
        def __init__(self,
            *,
            reference : typing.Optional[global___Field] = ...,
            minimum : typing.Optional[typing.Iterable[builtins.float]] = ...,
            maximum : typing.Optional[typing.Iterable[builtins.float]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"reference",b"reference"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"maximum",b"maximum",u"minimum",b"minimum",u"reference",b"reference"]) -> None: ...

    TARGET_FIELD_NUMBER: builtins.int
    REASON_FIELD_NUMBER: builtins.int
    CONSTANT_FIELD_NUMBER: builtins.int
    POLYNOMIAL_FIELD_NUMBER: builtins.int
    @property
    def target(self) -> global___Field:
        """Link to target field on which the contraint is applied"""
        pass
    reason: typing.Text = ...
    """Human-readable reason for the constraint and its failure"""

    @property
    def constant(self) -> global___Constraint.Constant: ...
    @property
    def polynomial(self) -> global___Constraint.Polynomial: ...
    def __init__(self,
        *,
        target : typing.Optional[global___Field] = ...,
        reason : typing.Optional[typing.Text] = ...,
        constant : typing.Optional[global___Constraint.Constant] = ...,
        polynomial : typing.Optional[global___Constraint.Polynomial] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"constant",b"constant",u"polynomial",b"polynomial",u"reason",b"reason",u"target",b"target",u"type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"constant",b"constant",u"polynomial",b"polynomial",u"reason",b"reason",u"target",b"target",u"type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"type",b"type"]) -> typing.Optional[typing_extensions.Literal["constant","polynomial"]]: ...
global___Constraint = Constraint
