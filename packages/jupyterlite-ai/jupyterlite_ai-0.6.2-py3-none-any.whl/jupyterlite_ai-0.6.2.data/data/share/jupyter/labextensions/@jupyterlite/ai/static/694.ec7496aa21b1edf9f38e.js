"use strict";(self.webpackChunk_jupyterlite_ai=self.webpackChunk_jupyterlite_ai||[]).push([[694,313],{93313:(e,t,s)=>{s.r(t),s.d(t,{ISecretsManager:()=>o,InMemoryConnector:()=>i,LocalStorageConnector:()=>l,SecretsManager:()=>c,default:()=>u});var n,a=s(3266),r=s(67262);class c{constructor(){this._onInput=async e=>{var t;await this.storing,this._storing=new r.PromiseDelegate;const s=e.target,{namespace:a,id:c}=null!==(t=n.secretPath.get(s))&&void 0!==t?t:{};if(a&&c){const e=n.buildConnectorId(a,c);await this.ready,await n.set(e,{namespace:a,id:c,value:s.value})}this._storing.resolve()},this._ready=new r.PromiseDelegate,this._storing=new r.PromiseDelegate,this._storing.resolve()}setConnector(e){n.setConnector(e),this._ready.resolve()}get ready(){return this._ready.promise}get storing(){return this._storing.promise}async get(e,t,s){return n.checkNamespace(e,t),await Promise.all([this.ready,this.storing]),n.get(n.buildConnectorId(t,s))}async set(e,t,s,a){return n.checkNamespace(e,t),await this.ready,n.set(n.buildConnectorId(t,s),a)}async list(e,t){return n.checkNamespace(e,t),await Promise.all([this.ready,this.storing]),n.list(t)}async remove(e,t,s){return n.checkNamespace(e,t),await this.ready,n.remove(n.buildConnectorId(t,s))}async attach(e,t,s,a,r){n.checkNamespace(e,t);const c=n.buildConnectorId(t,s);n.inputs.get(c)&&this.detach(e,t,s),n.inputs.set(c,a),n.secretPath.set(a,{namespace:t,id:s});const o=await n.get(c);!a.value&&o?(a.value=o.value,a.dispatchEvent(new Event("input")),r&&r(o.value)):a.value&&a.value!==(null==o?void 0:o.value)&&(await this.ready,n.set(c,{namespace:t,id:s,value:a.value})),a.addEventListener("input",this._onInput)}async detach(e,t,s){n.checkNamespace(e,t),this._detach(n.buildConnectorId(t,s))}async detachAll(e,t){n.checkNamespace(e,t);for(const e of n.secretPath.values())e.namespace===t&&this._detach(n.buildConnectorId(e.namespace,e.id))}_detach(e){const t=n.inputs.get(e);t&&(t.removeEventListener("input",this._onInput),n.secretPath.delete(t),n.inputs.delete(e))}}Object.freeze(c.prototype),function(e){e.sign=function(e,t){const{lock:s,isLocked:r,namespaces:c,symbols:o}=n,{isDisabled:i}=a.PageConfig.Extension;if(r())throw new Error("Secrets manager is locked, check errors.");i("jupyter-secrets-manager:manager")&&s("Secret registry is disabled."),i(e)&&s(`Sign error: plugin ${e} is disabled.`),o.has(e)&&s(`Sign error: another plugin signed as "${e}".`);const l=Symbol(e),u=t(l);return e!==u.id&&s(`Sign error: plugin ID mismatch "${u.id}"â‰ "${e}".`),c.set(l,e),o.set(e,l),u}}(c||(c={})),function(e){let t=!1;function s(e){throw t=!0,new Error(e)}function n(){return t}e.namespaces=new Map,e.symbols=new Map,e.lock=s,e.isLocked=n,e.checkNamespace=function(t,s){if(n()||e.namespaces.get(t)!==s)throw new Error(`The secrets namespace ${s} is not available with the provided token`)};let a=null;e.setConnector=function(e){null!==a&&s("A secrets manager connector already exists."),a=e},e.get=async function(e){if(null==a?void 0:a.fetch)return a.fetch(e)},e.list=async function(e){if(null==a?void 0:a.list)return a.list(e)},e.set=async function(e,t){if(null==a?void 0:a.save)return a.save(e,t)},e.remove=async function(e){if(null==a?void 0:a.remove)return a.remove(e)},e.inputs=new Map,e.secretPath=new Map,e.buildConnectorId=function(e,t){return`${e}:${t}`}}(n||(n={}));const o=new r.Token("jupyter-secret-manager:manager","The secrets manager");class i{constructor(){this._secrets=new Map}async fetch(e){return this._secrets.get(e)}async save(e,t){this._secrets.set(e,t)}async remove(e){this._secrets.delete(e)}async list(e){const t=[],s=[];return this._secrets.forEach(((n,a)=>{n.namespace===e&&(t.push(a),s.push(n))})),{ids:t,values:s}}}class l{constructor(){this.storage="jupyter-secrets:secrets",console.warn("\nThe secret connector used currently should not be used in production, since the\npasswords are stored as plain text in the local storage of the browser'\n    ")}async fetch(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");if(s&&s[e])return s[e]}async save(e,t){var s;const n=JSON.parse(null!==(s=localStorage.getItem(this.storage))&&void 0!==s?s:"{}");n[e]=t,localStorage.setItem(this.storage,JSON.stringify(n))}async remove(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");delete s[e],localStorage.setItem(this.storage,JSON.stringify(s))}async list(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");return Object.keys(s).filter((t=>s[t].namespace===e)).reduce(((e,t)=>(e.ids.push(t),e.values.push(s[t]),e)),{ids:[],values:[]})}}const u=[{id:"jupyter-secrets-manager:connector",description:"A JupyterLab extension to manage secrets.",autoStart:!0,requires:[o],activate:(e,t)=>{t.setConnector(new i)}},{id:"jupyter-secrets-manager:manager",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:o,activate:e=>(console.log("JupyterLab extension jupyter-secrets-manager is activated!"),new c)}]}}]);