import sys
import subprocess
from typing import Any
import requests
import datetime
from slugify import slugify
from rich.console import Console

cl = Console()


def printMessage(preamble: str, variable: Any) -> None:
    cl.print(f"[bold yellow]:::[/bold yellow] [green]{preamble:<15}[/green]:{variable}")


def makeSRCINFO() -> None:
    command = "makepkg --printsrcinfo > .SRCINFO"
    printMessage(preamble="Creating", variable=".SRCINFO")
    try:
        subprocess.run(command, shell=True, check=True)
        printMessage(preamble=".SRCINFO", variable="File created successfully.")
    except subprocess.CalledProcessError as e:
        cl.print(f":::[bold red]Error creating .SRCINFO file: {e}[/bold red]")
        sys.exit(1)


def fetchPkgInfo(pkg: str) -> dict[str, Any] | None:
    """
    Query the PyPI API and return all possible information about the latest version of the package.
    """
    url: str = f"https://pypi.org/pypi/{pkg}/json"
    try:
        resp: requests.Response = requests.get(url=url)
        resp.raise_for_status()
        data = resp.json()
        # cl.print(data)
        latest_version = data["info"]["version"]
        version_info = data["releases"].get(latest_version, [])
        return {
            "info": data["info"],
            "latest_version": latest_version,
            "release_files": version_info,
            "urls": data.get("urls", []),
        }
    except Exception as e:
        cl.print(f":::[bold red]Error fetching package info: {e}[/bold red]")
        return None


def appendLinesToFile(file_path: str, lines: list[str]) -> None:
    """
    Append multiple lines to a file.

    Args:
        file_path (str): The path to the file.
        lines (list[str]): The lines to append.
    """
    try:
        with open(file_path, "a") as file:
            for line in lines:
                file.write(line + "\n")

    except IOError as e:
        cl.print(f":::[bold red]Error writing to file {file_path}: {e}[/bold red]")
        sys.exit(1)


def createPKGBUILD(pypiPackage: str) -> None:
    printMessage(preamble="Creating", variable="PKGBUILD for pypi: [{pypiPackage}]...")
    printMessage(preamble="Fetching", variable="package info from PyPI...")
    pkg_info = fetchPkgInfo(pypiPackage)
    if pkg_info is None:
        cl.print(
            f":::[bold red]Error: {pypiPackage} does not exist on PyPI.[/bold red]"
        )
        printMessage(preamble=f"{pypiPackage}", variable="does not exist on PyPI.")
    else:
        printMessage(preamble=f"{pypiPackage}", variable="Info fetched successfully.")
        printMessage(
            preamble="latest version", variable=f"{pkg_info['latest_version']}"
        )
        # verify if PKGBUILD file exists
        try:
            with open("PKGBUILD", "r"):
                printMessage(preamble="PKGBUILD", variable="Already exists.")
                cl.print("Exiting...")
                sys.exit(1)
        except FileNotFoundError:
            printMessage(preamble="Status", variable="append lines to PKGBUILD...")
            # header
            appendLinesToFile(
                file_path="PKGBUILD",
                lines=[
                    "#",
                    f"# Generated by pypi2aur from pypi package {pypiPackage}",
                    f"# Date {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                    "#",
                ],
            )
            # body
            appendLinesToFile(
                file_path="PKGBUILD",
                lines=[
                    f"pkgname={pypiPackage}",
                    f"_origpkgname={slugify(text=pypiPackage, separator='_')}",
                    f"pkgver={pkg_info['latest_version']}",
                    "pkgrel=1",
                    f'pkgdesc="{pkg_info["info"]["summary"]}"',
                    'arch=("x86_64")',
                    f"url='{pkg_info['info']['project_url']}'",
                    f'license=("{pkg_info["info"]["license"]}")',
                    "depends=()",
                    "makedepends=(",
                    '\t"python-build"',
                    '\t"python-installer"',
                    '\t"python-wheel"',
                    '\t"python-setuptools"',
                    '\t"python-hatchling"',
                    ")",
                    f'source=("{pkg_info["release_files"][1]["url"]}")',
                    f'sha256sums=("{pkg_info["release_files"][1]["digests"]["sha256"]}")',
                    "package() {",
                    "\t" + 'cd "${_origpkgname}-${pkgver}" || exit',
                    "\t" + "python -m build --wheel --no-isolation",
                    "\t" + 'python -m installer --destdir="$pkgdir" dist/*.whl',
                    "\t"
                    + 'install -Dm644 LICENSE "$pkgdir/usr/share/licenses/$pkgname/LICENSE"',
                    "}",
                    "",
                    "# vim:set ts=2 sw=2 et:",
                ],
            )
            makeSRCINFO()


def readParameter(parameterName: str, filePath: str = "PKGBUILD") -> str | None:
    """
    Read the value of a parameter from the PKGBUILD file.

    Args:
        parameterName (str): The name of the parameter to read.
        filePath (str): The path to the PKGBUILD file (default: 'PKGBUILD').

    Returns:
        str | None: The value of the parameter, or None if not found.
    """
    try:
        with open(filePath, "r") as file:
            for line in file:
                line = line.strip()
                if line.startswith(parameterName + "="):
                    value = line.split("=", 1)[1].strip()
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    return value
        return None
    except IOError as e:
        cl.print(f"IOError: {e}")
        return None


def changeParameter(
    parameterName: str, newValue: str, filePath: str = "PKGBUILD"
) -> bool:
    """
    Change the value of a parameter in the PKGBUILD file and save it.

    Args:
        parameterName (str): The name of the parameter to change.
        newValue (str): The new value to set.
        filePath (str): The path to the PKGBUILD file (default: 'PKGBUILD').

    Returns:
        bool: True if the parameter was changed, False otherwise.
    """
    try:
        with open(filePath, "r") as file:
            lines = file.readlines()
        changed = False
        for i, line in enumerate(lines):
            if line.strip().startswith(parameterName + "="):
                prefix = line.split("=", 1)[0]
                lines[i] = f"{prefix}={newValue}\n"
                changed = True
                break
        if changed:
            with open(filePath, "w") as file:
                file.writelines(lines)
        return changed
    except IOError:
        return False


def printUpdateHelper(param: str, newValue: str) -> None:
    printMessage(preamble="Status", variable=f"Updating {param}")

    printMessage(
        preamble="from =>".ljust(15), variable=f"{readParameter(parameterName=param)}"
    )
    printMessage(preamble="to <=".ljust(15), variable=f"{newValue}")


def checkIfPKGBUILDExists() -> bool:
    """
    Check if the PKGBUILD file exists.

    Returns:
        bool: True if the PKGBUILD file exists, False otherwise.
    """
    try:
        with open("PKGBUILD", "r"):
            return True
    except FileNotFoundError:
        return False


def updatePKGBUILD() -> None:
    if checkIfPKGBUILDExists():
        pypiPackage = readParameter("pkgname")
        printMessage(preamble="pkgname", variable=f"{pypiPackage}")
        printMessage(preamble="Fetching", variable="Info for pypi...")
        pkg_info = fetchPkgInfo(f"{pypiPackage}")
        if pkg_info is None:
            cl.print(
                f":::[bold red]Error {pypiPackage} does not exist on PyPI.[/bold red]"
            )
        else:
            printMessage(
                preamble=f"{pypiPackage}", variable="info fetched successfully."
            )
            printMessage(
                preamble=f"{pypiPackage}",
                variable=f"latest version is {pkg_info['latest_version']}",
            )
            printMessage(
                preamble="Updating",
                variable="PKGBUILD...",
            )
            newPkgVer = pkg_info["latest_version"]
            printUpdateHelper(param="pkgver", newValue=newPkgVer)
            changeParameter(
                parameterName="pkgver",
                newValue=newPkgVer,
            )
            printUpdateHelper(param="pkgrel", newValue="1")
            changeParameter(
                parameterName="pkgrel",
                newValue="1",
            )

            newSource = f'("{pkg_info["release_files"][1]["url"]}")'
            printUpdateHelper(param="source", newValue=newSource)
            changeParameter(
                parameterName="source",
                newValue=newSource,
            )

            newSha256Sums = f'("{pkg_info["release_files"][1]["digests"]["sha256"]}")'
            printUpdateHelper(param="sha256sums", newValue=newSha256Sums)
            changeParameter(
                parameterName="sha256sums",
                newValue=newSha256Sums,
            )

            printMessage(
                preamble="PKGBUILD",
                variable="Updated successfully!",
            )
            makeSRCINFO()
    else:
        cl.print(":::[bold red]PKGBUILD file does not exist.[/bold red]")
        cl.print("::: Exiting...")
        sys.exit(1)


def readPyPiDeps(pypipackage: str) -> None:
    """
    Read and show pypi package dependencies.
    """
    pkg_info = fetchPkgInfo(pypipackage)
    if pkg_info is None:
        printMessage(
            preamble=f"{pypipackage}",
            variable="Does not exist on PyPI.",
        )
    else:
        cl.print(f"::: {pypipackage} info fetched successfully.")
        printMessage(
            preamble=f"{pypipackage}",
            variable="Info fetched successfully.",
        )
        printMessage(
            preamble=f"{pypipackage}",
            variable=f"Latest version is {pkg_info['latest_version']}",
        )
        printMessage(
            preamble=f"{pypipackage}",
            variable="Dependencies:",
        )
        for dep in pkg_info["info"]["requires_dist"]:
            cl.print(f"[bold green]==>[/bold green] {dep}")
