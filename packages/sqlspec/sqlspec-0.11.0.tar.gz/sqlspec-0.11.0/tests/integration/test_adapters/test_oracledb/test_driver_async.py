"""Test OracleDB driver implementation - Asynchronous Tests."""

from __future__ import annotations

from typing import Any, Literal

import pyarrow as pa
import pytest
from pytest_databases.docker.oracle import OracleService

from sqlspec.adapters.oracledb import OracleAsyncConfig, OracleAsyncPoolConfig

ParamStyle = Literal["positional_binds", "dict_binds"]

pytestmark = pytest.mark.asyncio(loop_scope="session")

# --- Async Fixtures ---


@pytest.fixture
def oracle_async_session(oracle_23ai_service: OracleService) -> OracleAsyncConfig:
    """Create an Oracle asynchronous session."""
    return OracleAsyncConfig(
        pool_config=OracleAsyncPoolConfig(
            host=oracle_23ai_service.host,
            port=oracle_23ai_service.port,
            service_name=oracle_23ai_service.service_name,
            user=oracle_23ai_service.user,
            password=oracle_23ai_service.password,
        )
    )


# --- Async Tests ---


@pytest.mark.parametrize(
    ("params", "style"),
    [
        pytest.param(("test_name",), "positional_binds", id="positional_binds"),
        pytest.param({"name": "test_name"}, "dict_binds", id="dict_binds"),
    ],
)
@pytest.mark.skip(
    reason="Oracle does not support RETURNING multiple columns directly in the required syntax for this method."
)
@pytest.mark.xdist_group("oracle")
async def test_async_insert_returning(oracle_async_session: OracleAsyncConfig, params: Any, style: ParamStyle) -> None:
    """Test async insert returning functionality with Oracle parameter styles."""
    async with oracle_async_session.provide_session() as driver:
        # Manual cleanup at start of test
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )
        sql = """
        CREATE TABLE test_table (
            id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
            name VARCHAR2(50)
        )
        """
        await driver.execute_script(sql)

        if style == "positional_binds":
            sql = "INSERT INTO test_table (name) VALUES (:1) RETURNING id, name"
            exec_params = params
        else:  # dict_binds
            # Workaround: Use positional binds due to DPY-4009
            sql = "INSERT INTO test_table (name) VALUES (:1) RETURNING id, name"
            exec_params = (params["name"],)

        result = await driver.insert_update_delete_returning(sql, exec_params)
        assert result is not None
        assert result["NAME"] == "test_name"
        assert result["ID"] is not None
        assert isinstance(result["ID"], int)
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )


@pytest.mark.parametrize(
    ("params", "style"),
    [
        pytest.param(("test_name",), "positional_binds", id="positional_binds"),
        pytest.param({"name": "test_name"}, "dict_binds", id="dict_binds"),
    ],
)
@pytest.mark.xdist_group("oracle")
async def test_async_select(oracle_async_session: OracleAsyncConfig, params: Any, style: ParamStyle) -> None:
    """Test async select functionality with Oracle parameter styles."""
    async with oracle_async_session.provide_session() as driver:
        # Manual cleanup at start of test
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )
        sql = """
        CREATE TABLE test_table (
            id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
            name VARCHAR2(50)
        )
        """
        await driver.execute_script(sql)

        if style == "positional_binds":
            insert_sql = "INSERT INTO test_table (name) VALUES (:1)"
            select_sql = "SELECT name FROM test_table WHERE name = :1"
            insert_params = params
            select_params = params
        else:  # dict_binds
            # Workaround: Use positional binds due to DPY-4009
            insert_sql = "INSERT INTO test_table (name) VALUES (:1)"
            select_sql = "SELECT name FROM test_table WHERE name = :1"
            insert_params = (params["name"],)
            select_params = (params["name"],)

        await driver.insert_update_delete(insert_sql, insert_params)

        results = await driver.select(select_sql, select_params)
        assert len(results) == 1
        assert results[0]["NAME"] == "test_name"
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )


@pytest.mark.parametrize(
    ("params", "style"),  # Keep parametrization for structure
    [
        pytest.param(("test_name",), "positional_binds", id="positional_binds"),
        pytest.param({"name": "test_name"}, "dict_binds", id="dict_binds"),
    ],
)
@pytest.mark.xdist_group("oracle")
async def test_async_select_value(oracle_async_session: OracleAsyncConfig, params: Any, style: ParamStyle) -> None:
    """Test async select_value functionality with Oracle parameter styles."""
    async with oracle_async_session.provide_session() as driver:
        # Manual cleanup at start of test
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )
        sql = """
        CREATE TABLE test_table (
            id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
            name VARCHAR2(50)
        )
        """
        await driver.execute_script(sql)

        # Workaround: Use positional binds for setup insert due to DPY-4009 error with dict_binds
        if style == "positional_binds":
            setup_value = params[0]
        else:  # dict_binds
            setup_value = params["name"]
        setup_params_tuple = (setup_value,)
        insert_sql_setup = "INSERT INTO test_table (name) VALUES (:1)"
        await driver.insert_update_delete(insert_sql_setup, setup_params_tuple)

        select_sql = "SELECT 'test_value' FROM dual"
        value = await driver.select_value(select_sql)
        assert value == "test_value"
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )


@pytest.mark.xdist_group("oracle")
async def test_async_select_arrow(oracle_async_session: OracleAsyncConfig) -> None:
    """Test asynchronous select_arrow functionality."""
    async with oracle_async_session.provide_session() as driver:
        # Manual cleanup at start of test
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )
        sql = """
        CREATE TABLE test_table (
            id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
            name VARCHAR2(50)
        )
        """
        await driver.execute_script(sql)

        # Insert test record using positional binds
        insert_sql = "INSERT INTO test_table (name) VALUES (:1)"
        await driver.insert_update_delete(insert_sql, ("arrow_name",))

        # Select and verify with select_arrow using positional binds
        select_sql = "SELECT name, id FROM test_table WHERE name = :1"
        arrow_table = await driver.select_arrow(select_sql, ("arrow_name",))

        assert isinstance(arrow_table, pa.Table)
        assert arrow_table.num_rows == 1
        assert arrow_table.num_columns == 2
        # Oracle returns uppercase column names by default
        assert arrow_table.column_names == ["NAME", "ID"]
        assert arrow_table.column("NAME").to_pylist() == ["arrow_name"]
        # Check ID exists and is a number (exact value depends on IDENTITY)
        assert arrow_table.column("ID").to_pylist()[0] is not None
        assert isinstance(arrow_table.column("ID").to_pylist()[0], (int, float))  # Oracle NUMBER maps to float/Decimal
        await driver.execute_script(
            "BEGIN EXECUTE IMMEDIATE 'DROP TABLE test_table'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )
