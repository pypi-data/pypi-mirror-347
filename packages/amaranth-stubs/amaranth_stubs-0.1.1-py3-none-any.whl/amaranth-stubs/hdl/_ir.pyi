"""
This type stub file was generated by pyright.
"""

import enum
from typing import Any, Tuple
from .._utils import final
from .. import _unused
from . import _ast, _cd, _ir, _nir, _mem

"""
This type stub file was generated by pyright.
"""
__all__ = ["DomainRequirementFailed", "AlreadyElaborated", "UnusedElaboratable", "Elaboratable", "DuplicateElaboratable", "DriverConflict", "Fragment", "Instance", "IOBufferInstance", "RequirePosedge", "PortDirection", "Design", "build_netlist"]


@final
class AlreadyElaborated(Exception):
    """Exception raised when an elaboratable is being modified after elaboration."""


class UnusedElaboratable(_unused.UnusedMustUse):
    _MustUse__silence = ...


class Elaboratable(_unused.MustUse):
    ...


class DriverConflict(Exception):
    ...


class DuplicateElaboratable(Exception):
    ...


class DomainRequirementFailed(Exception):
    """Raised when a module has unsatisfied requirements about a clock domain, such as getting
    a negedge domain when only posedge domains are supported."""


class Fragment:
    @staticmethod
    def get(obj, platform):
        ...
    
    def __init__(self, *, src_loc=...) -> None:
        ...
    
    def add_domains(self, *domains):
        ...
    
    def iter_domains(self):
        ...
    
    def add_statements(self, domain, *stmts):
        ...
    
    def add_subfragment(self, subfragment, name=..., *, src_loc=...):
        ...
    
    def find_subfragment(self, name_or_index):
        ...
    
    def find_generated(self, *path):
        ...
    
    def elaborate(self, platform):
        ...
    
    def prepare(self, ports=..., *, hierarchy=..., missing_domain=..., propagate_domains=...):
        ...
    

class RequirePosedge(Fragment):
    """A special fragment that requires a given domain to have :py:`clk_edge="pos"`, failing
    elaboration otherwise.

    This is a private interface, without a stability guarantee.
    """
    def __init__(self, domain, *, src_loc_at=0, src_loc=None):
        ...


class Instance(Fragment):
    def __init__(self, type, *args, src_loc=..., src_loc_at=..., **kwargs) -> None:
        ...
    


class IOBufferInstance(Fragment):
    def __init__(self, port, *, i=..., o=..., oe=..., src_loc_at=..., src_loc=...) -> None:
        ...
    


class DesignFragmentInfo:
    def __init__(self, parent, depth) -> None:
        ...
    


class Design:
    """Represents a design ready for simulation or netlist building.

    Returned by ``Fragment.prepare``."""
    def __init__(self, fragment: Fragment, ports, *, hierarchy) -> None:
        ...
    


class PortDirection(enum.Enum):
    Input = ...
    Output = ...
    Inout = ...


class NetlistDriver:
    def __init__(self, module_idx: int, signal: _ast.Signal, domain: _cd.ClockDomain | None, *, src_loc) -> None:
        ...
    
    def emit_value(self, builder):
        ...
    


class NetlistEmitter:
    def __init__(self, netlist: _nir.Netlist, design, *, all_undef_to_ff=...) -> None:
        ...
    
    def emit_signal(self, signal) -> _nir.Value:
        ...
    
    def emit_io(self, value: _ast.IOValue) -> _nir.IOValue:
        ...
    
    def emit_io_use(self, value: _ast.IOValue, *, src_loc) -> _nir.IOValue:
        ...
    
    def emit_lhs(self, value: _ast.Value):
        ...
    
    def extend(self, value: _nir.Value, signed: bool, width: int):
        ...
    
    def emit_operator(self, module_idx: int, operator: str, *inputs: _nir.Value, src_loc):
        ...
    
    def unify_shapes_bitwise(self, operand_a: _nir.Value, signed_a: bool, operand_b: _nir.Value, signed_b: bool):
        ...
    
    def emit_rhs(self, module_idx: int, value: _ast.Value) -> Tuple[_nir.Value, bool]:
        """Emits a RHS value, returns a tuple of (value, is_signed)"""
        ...
    
    def connect(self, lhs: _nir.Value, rhs: _nir.Value, *, src_loc):
        ...
    
    def emit_assign(self, module_idx: int, cd: _cd.ClockDomain | None, lhs: _ast.Value, lhs_start: int, rhs: _nir.Value, cond: _nir.Net, *, src_loc):
        ...
    
    def emit_format(self, module_idx, format):
        ...
    
    def emit_stmt(self, module_idx: int, fragment: _ir.Fragment, domain: str, stmt: _ast.Statement, cond: _nir.Net):
        ...
    
    def emit_iobuffer(self, module_idx: int, instance: _ir.IOBufferInstance):
        ...
    
    def emit_memory(self, module_idx: int, fragment: _mem.MemoryInstance, name: str):
        ...
    
    def emit_write_port(self, module_idx: int, fragment: _mem.MemoryInstance, port: Any, memory: int):
        ...
    
    def emit_read_port(self, module_idx: int, fragment: _mem.MemoryInstance, port: Any, memory: int, write_ports: list[int]):
        ...
    
    def emit_instance(self, module_idx: int, instance: _ir.Instance, name: str):
        ...
    
    def emit_top_ports(self, fragment: _ir.Fragment):
        ...
    
    def emit_drivers(self):
        ...
    
    def emit_undef_ff(self):
        ...
    
    def emit_undriven(self):
        ...
    
    def emit_fragment(self, fragment: _ir.Fragment, parent_module_idx: int | None, *, cell_src_loc=...):
        ...
    


def build_netlist(fragment, ports=..., *, name=..., all_undef_to_ff=..., **kwargs):
    ...

