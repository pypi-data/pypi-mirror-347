"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable, MutableSequence
from typing import NoReturn, Optional, final
from ._ast import *
from ._ir import Elaboratable, Fragment

__all__ = ["MemoryData", "Memory", "ReadPort", "WritePort", "DummyPort"]


@final
class MemoryData:
    @final
    class Init(MutableSequence):
        """Memory initialization data.

        This is a special container used only for initial contents of memories. It is similar
        to :class:`list`, but does not support inserting or deleting elements; its length is always
        the same as the depth of the memory it belongs to.

        If :py:`shape` is a :ref:`custom shape-castable object <lang-shapecustom>`, then:

        * Each element must be convertible to :py:`shape` via :meth:`.ShapeCastable.const`, and
        * Elements that are not explicitly initialized default to :py:`shape.const(None)`.

        Otherwise (when :py:`shape` is a :class:`.Shape`):

        * Each element must be an :class:`int`, and
        * Elements that are not explicitly initialized default to :py:`0`.
        """
        def __init__(self, elems: Iterable[ValueLike], *, shape: ShapeLike, depth: int) -> None:
            ...
        
        @property
        def shape(self) -> ShapeLike:
            ...
        
        def __getitem__(self, index: int) -> ValueLike:
            ...
        
        def __setitem__(self, index: int, value: ValueLike) -> None:
            ...
        
        def __delitem__(self, index: int) -> NoReturn:
            ...
        
        def insert(self, index: int, value: ValueLike) -> NoReturn:
            ...
        
        def __len__(self) -> int:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    def __init__(self, *, shape: ShapeLike, depth: int, init: Iterable[ValueLike], src_loc_at: int = ...) -> None:
        ...
    
    def freeze(self) -> None:
        ...
    
    @property
    def shape(self) -> ShapeLike:
        ...
    
    @property
    def depth(self) -> int:
        ...
    
    @property
    def init(self) -> MemoryData.Init:
        ...
    
    @init.setter
    def init(self, init: Iterable[ValueLike]) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __getitem__(self, index) -> ValueLike:
        ...
    

class Memory:
    """A word addressable storage.
    Parameters
    ----------
    width : int
        Access granularity. Each storage element of this memory is ``width`` bits in size.
    depth : int
        Word count. This memory contains ``depth`` storage elements.
    init : list of int
        Initial values. At power on, each storage element in this memory is initialized to
        the corresponding element of ``init``, if any, or to zero otherwise.
        Uninitialized memories are not currently supported.
    name : str
        Name hint for this memory. If ``None`` (default) the name is inferred from the variable
        name this ``Signal`` is assigned to.
    attrs : dict
        Dictionary of synthesis attributes.
    Attributes
    ----------
    width : int
    depth : int
    init : list of int
    attrs : dict
    """
    width: int
    depth: int
    attrs: dict

    def __init__(self, *, width: int, depth: int, init: Optional[list[int]] = ..., name: Optional[str] = ..., attrs: dict = ..., simulate: bool = ...) -> None:
        ...
    
    @property
    def init(self) -> list[int]:
        ...
    
    @init.setter
    def init(self, new_init: list[int]) -> None:
        ...
    
    def read_port(self, *, src_loc_at=..., **kwargs) -> ReadPort:
        """Get a read port.

        See :c"""
        ...
    
    def write_port(self, *, src_loc_at=..., **kwargs) -> WritePort:
        """Get a write port.

        See :"""
        ...
    
    def __getitem__(self, index: int) -> ArrayProxy:
        """Simulation only."""
        ...
    


class ReadPort(Elaboratable):
    """A memory read port.

    Paramet"""
    memory: Memory
    domain: str
    transparent: bool
    addr: Signal
    data: Signal
    en: Signal | Const

    def __init__(self, memory, *, domain=..., transparent=..., src_loc_at=...) -> None:
        ...
    
    def elaborate(self, platform): # -> Instance:
        ...
    


class WritePort(Elaboratable):
    """A memory write port.

    Parame"""
    memory: Memory
    domain: str
    granularity: int
    addr: Signal
    data: Signal
    en: Signal

    def __init__(self, memory, *, domain=..., granularity=..., src_loc_at=...) -> None:
        ...
    
    def elaborate(self, platform): # -> Instance:
        ...
    


class DummyPort:
    """Dummy memory port.

    This por"""
    def __init__(self, *, data_width, addr_width, domain=..., name=..., granularity=...) -> None:
        ...
    

class MemoryInstance(Fragment):
    memory: Memory
    read_ports: list[ReadPort]
    write_ports: list[WritePort]
    attrs: dict
    def __init__(self, memory: Memory, read_ports: list[ReadPort], write_ports: list[WritePort]) -> None:
        ...
