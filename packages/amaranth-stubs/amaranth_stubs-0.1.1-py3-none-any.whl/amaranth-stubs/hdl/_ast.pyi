"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta, abstractmethod
from collections.abc import Callable, MutableMapping, MutableSequence, MutableSet
from typing import Any, Generic, Iterable, Iterator, Mapping, NoReturn, Optional, Sequence, TypeVar, final, overload
from enum import Enum, EnumMeta
from amaranth_types import ValueLike, FlatValueLike, ShapeLike, FlatShapeLike, StatementLike
from amaranth.lib.data import View
from amaranth_types.types import IOValueLike


__all__: list[str]  = [
    "SyntaxError", "SyntaxWarning",
    "Shape", "signed", "unsigned", "ShapeCastable", "ShapeLike",
    "Value", "Const", "C", "AnyValue", "AnyConst", "AnySeq", "Operator", "Mux", "Part", "Slice", "Cat", "Concat", "SwitchValue",
    "Array", "ArrayProxy",
    "Signal", "ClockSignal", "ResetSignal",
    "ValueCastable", "ValueLike",
    "Initial",
    "Format",
    "Statement", "Switch",
    "Property", "Assign", "Print", "Assert", "Assume", "Cover",
    "IOValue", "IOPort", "IOConcat", "IOSlice",
    "SignalKey", "SignalDict", "SignalSet",
]


T = TypeVar("T")
U = TypeVar("U")
_T_ShapeCastable = TypeVar("_T_ShapeCastable", bound=ShapeCastable, covariant=True)
Flattenable = T | Iterable[Flattenable[T]]
SwitchKey = str | int | Enum


class SyntaxError(Exception):
    pass
  

class SyntaxWarning(Warning):
    pass


class DUID:
    """Deterministic Unique IDentifier."""
    __next_uid = ...
    def __init__(self) -> None:
        ...
    

class ShapeCastable(Generic[U]):
    def __init__(self, *args, **kwargs) -> None:
        ...

    def __init_subclass__(cls, **kwargs) -> None:
        ...

    def as_shape(self, *args, **kwargs) -> Shape:
        ...

    def __call__(self, target: ValueLike) -> U:
        ...

    def const(self, *args, **kwargs) -> Const:
        ...

    def from_bits(self, raw: int):
        ...

    def format(self, obj: ValueLike, spec: str) -> Format:
        ...


class Shape:
    """Bit width and signedness of a va"""
    @property
    def width(self) -> int:
        ...

    @property
    def signed(self) -> int:
        ...

    def __init__(self, width: int =..., signed: bool =...) -> None:
        ...
    
    def __iter__(self) -> Iterator[int | bool]:
        ...
    
    @staticmethod
    def cast(obj: ShapeLike, *, src_loc_at=...) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...

    def __hash__(self) -> int:
        ...
    


def unsigned(width) -> Shape:
    """Shorthand for ``Shape(width, sig"""
    ...

def signed(width) -> Shape:
    """Shorthand for ``Shape(width, sig"""
    ...

class Value(metaclass=ABCMeta):
    @staticmethod
    def cast(obj: ValueLike) -> Value:
        """Converts ``obj`` to an Amaranth """
        ...
    
    def __init__(self, *, src_loc_at=...) -> None:
        ...
    
    def __bool__(self) -> NoReturn:
        ...
    
    def __invert__(self) -> Value:
        ...
    
    def __pos__(self) -> Value:
        ...
    
    def __neg__(self) -> Value:
        ...
    
    def __add__(self, other: ValueLike) -> Value:
        ...
    
    def __radd__(self, other: ValueLike) -> Value:
        ...
    
    def __sub__(self, other: ValueLike) -> Value:
        ...
    
    def __rsub__(self, other: ValueLike) -> Value:
        ...
    
    def __mul__(self, other: ValueLike) -> Value:
        ...
    
    def __rmul__(self, other: ValueLike) -> Value:
        ...
    
    def __mod__(self, other: ValueLike) -> Value:
        ...
    
    def __rmod__(self, other: ValueLike) -> Value:
        ...
    
    def __floordiv__(self, other: ValueLike) -> Value:
        ...
    
    def __rfloordiv__(self, other: ValueLike) -> Value:
        ...
    
    def __lshift__(self, other: ValueLike) -> Value:
        ...
    
    def __rlshift__(self, other: ValueLike) -> Value:
        ...
    
    def __rshift__(self, other: ValueLike) -> Value:
        ...
    
    def __rrshift__(self, other: ValueLike) -> Value:
        ...
    
    def __and__(self, other: ValueLike) -> Value:
        ...
    
    def __rand__(self, other: ValueLike) -> Value:
        ...
    
    def __xor__(self, other: ValueLike) -> Value:
        ...
    
    def __rxor__(self, other: ValueLike) -> Value:
        ...
    
    def __or__(self, other: ValueLike) -> Value:
        ...
    
    def __ror__(self, other: ValueLike) -> Value:
        ...
    
    def __eq__(self, other: ValueLike) -> Value:
        ...
    
    def __ne__(self, other: ValueLike) -> Value:
        ...
    
    def __lt__(self, other: ValueLike) -> Value:
        ...
    
    def __le__(self, other: ValueLike) -> Value:
        ...
    
    def __gt__(self, other: ValueLike) -> Value:
        ...
    
    def __ge__(self, other: ValueLike) -> Value:
        ...
    
    def __abs__(self) -> Value:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, key: int | slice) -> Value:
        ...

    def __contains__(self, other) -> NoReturn:
        ...

    def __format__(self, format_desc) -> NoReturn:
        ...

    def as_unsigned(self) -> Value:
        """Conversion to unsigned.

       """
        ...
    
    def as_signed(self) -> Value:
        """Conversion to signed.

        R"""
        ...
    
    def bool(self) -> Value:
        """Conversion to boolean.

        """
        ...
    
    def any(self) -> Value:
        """Check if any bits are ``1``.

  """
        ...
    
    def all(self) -> Value:
        """Check if all bits are ``1``.

  """
        ...
    
    def xor(self) -> Value:
        """Compute pairwise exclusive-or of"""
        ...
    
    def bit_select(self, offset: ValueLike, width: int) -> Value:
        """Part-select with bit granularity"""
        ...
    
    def word_select(self, offset: ValueLike, width: int) -> Value:
        """Part-select with word granularit"""
        ...
    
    def matches(self, *patterns) -> Value:
        """Pattern matching.

        Match"""
        ...
    
    def shift_left(self, amount: int) -> Value:
        """Shift left by constant amount.

"""
        ...
    
    def shift_right(self, amount: int) -> Value:
        """Shift right by constant amount.
"""
        ...
    
    def rotate_left(self, amount: int) -> Value:
        """Rotate left by constant amount.
"""
        ...
    
    def rotate_right(self, amount: int) -> Value:
        """Rotate right by constant amount."""
        ...
    
    def replicate(self, count : int) -> Value:
        """Replication.

        A ``Value`` is replicated (repeated) several times to be used
        on the RHS of assignments::

            len(v.replicate(n)) == len(v) * n

        Parameters
        ----------
        count : int
            Number of replications.

        Returns
        -------
        Value, out
            Replicated value.
        """
        ...

    def eq(self, value: ValueLike) -> Assign:
        """Assignment.

        Parameters
"""
        ...
    
    @abstractmethod
    def shape(self) -> Shape:
        """Bit width and signedness of a va"""
        ...
    
    __hash__ = ...


class _ConstMeta(ABCMeta):
    def __call__(cls, value: int | ShapeCastable, shape: Optional[ShapeLike] = ..., src_loc_at=0, **kwargs):
        ...


@final
class Const(Value, metaclass=_ConstMeta):
    """A constant, literal integer valu"""
    src_loc = ...
    @staticmethod
    def cast(obj: ValueLike) -> Const:
        ...

    def __init__(self, value: int, shape: Optional[ShapeLike] =..., *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...

    @property
    def value(self) -> int:
        ...

    def __repr__(self) -> str:
        ...
    


C = Const
class AnyValue(Value, DUID):
    def __init__(self, shape: ShapeLike, *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    


@final
class AnyConst(AnyValue):
    def __repr__(self) -> str:
        ...
    


@final
class AnySeq(AnyValue):
    def __repr__(self) -> str:
        ...
    


@final
class Operator(Value):
    def __init__(self, operator: str, operands: Iterable[ValueLike], *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


def Mux(sel: ValueLike, val1: ValueLike, val0: ValueLike) -> Value:
    """Choose between two values.

    """
    ...

@final
class Slice(Value):
    def __init__(self, value: ValueLike, start: int, stop: int, *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...

    value: Value
    start: int
    stop: int


@final
class Part(Value):
    def __init__(self, value: Value, offset: ValueLike, width: int, stride: int = ..., *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class Cat(Value):
    """Concatenate values.

    Form a """
    def __init__(self, *args: Flattenable[ValueLike], src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...


@final
class Concat(Value):
    def __init__(self, args: Iterable[ValueLike], src_loc_at=0) -> None:
        ...

    @property
    def parts(self) -> tuple[Value, ...]:
        ...

    def shape(self) -> Shape:
        ...

    def __repr__(self) -> str:
        ...


@final
class SwitchValue(Value):
    def __init__(self, test, cases, *, src_loc=None, src_loc_at=0) -> None:
        ...

    @property
    def test(self) -> Value:
        ...

    @property
    def cases(self) -> tuple[tuple[Optional[tuple[str, ...]], Value], ...]:
        ...

    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...


@final
class Repl(Value):
    """Replicate a value

    An input """
    def __init__(self, value: ValueLike, count: int, *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    

class _SignalMeta(ABCMeta):
    @overload
    def __call__(cls, shape: ShapeCastable[T], src_loc_at: int = ..., **kwargs) -> T:
        ...
    
    @overload
    def __call__(cls, shape: FlatShapeLike = ..., src_loc_at: int = ..., **kwargs) -> Signal:
        ...
    
    def __call__(cls, shape: ShapeLike = ..., src_loc_at: int = ..., **kwargs):
        ...


class Signal(Value, DUID, metaclass=_SignalMeta):
    """A varying integer value.

    Pa"""
    def __init__(self, shape: Optional[ShapeLike] = ..., *, name: Optional[str] = ..., init: int | Enum = ..., reset_less: bool = ..., attrs: dict = ..., decoder: type[Enum] | Callable[[int], str] = ..., src_loc_at=...) -> None:
        ...

    @overload
    @staticmethod
    def like(other: View[_T_ShapeCastable], *, name: Optional[str] = ..., name_suffix: Optional[str] =..., src_loc_at=..., **kwargs) -> View[_T_ShapeCastable]:
        ...

    @overload
    @staticmethod
    def like(other: FlatValueLike, *, name: Optional[str] = ..., name_suffix: Optional[str] =..., src_loc_at=..., **kwargs) -> Signal:
        ...

    @staticmethod
    def like(other: ValueLike, *, name: Optional[str] = ..., name_suffix: Optional[str] =..., src_loc_at=..., **kwargs):
        """Create Signal based on another.
"""
        ...

    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    
    name: str
    decoder: Any


@final
class ClockSignal(Value):
    """Clock signal for a clock domain."""
    def __init__(self, domain: str = ..., *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class ResetSignal(Value):
    """Reset signal for a clock domain."""
    def __init__(self, domain: str = ..., allow_reset_less: bool = ..., *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Array(MutableSequence[T]):
    """Addressable multiplexer.

    An"""

    def __init__(self, iterable: Iterable[T] = ()) -> None:
        ...
    
    @overload
    def __getitem__(self, index: int) -> T:
        ...
    
    @overload
    def __getitem__(self, index: Value) -> ArrayProxy:
        ...

    def __getitem__(self, index: int | Value) -> T | ArrayProxy:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __setitem__(self, index: int, value: T) -> None:
        ...
    
    def __delitem__(self, index: int) -> None:
        ...

    def insert(self, index: int, value: T) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class ArrayProxy(Value):
    elems: Sequence[ValueLike]
    index: Value

    def __init__(self, elems: Sequence[ValueLike], index: ValueLike, *, src_loc_at=...) -> None:
        ...
    
    def __getattr__(self, attr: str) -> ArrayProxy:
        ...
    
    def __getitem__(self, index: Value | int | str) -> ArrayProxy:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ValueCastable:
    """Base class for classes which can"""
    def __new__(cls, *args, **kwargs): # -> Self@ValueCastable:
        ...
    
    @staticmethod
    def lowermethod(func): # -> (self: Unknown, *args: Unknown, **kwargs: Unknown) -> Unknown:
        """Decorator to memoize lowering me"""
        ...

    @abstractmethod
    def as_value(self) -> Value:
        ...

    @abstractmethod
    def shape(self) -> ShapeLike:
        ...


@final
class Sample(Value):
    """Value from the past.

    A ``Sa"""
    def __init__(self, expr: ValueLike, clocks: int, domain: Optional[str], *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...
    


def Past(expr: ValueLike, clocks: int = ..., domain: Optional[str] = ...) -> Sample:
    ...

def Stable(expr: ValueLike, clocks: int = ..., domain: Optional[str] = ...) -> Value:
    ...

def Rose(expr: ValueLike, clocks: int = ..., domain: Optional[str] = ...) -> Value:
    ...

def Fell(expr: ValueLike, clocks: int = ..., domain: Optional[str] = ...) -> Value:
    ...

@final
class Initial(Value):
    """Start indicator, for model check"""
    def __init__(self, *, src_loc_at=...) -> None:
        ...
    
    def shape(self) -> Shape:
        ...
    
    def __repr__(self) -> str:
        ...


class _FormatLike:
    def __add__(self, other) -> Format:
        ...

    def __format__(self, format_desc) -> NoReturn:
        ...


@final
class Format(_FormatLike):
    def __init__(self, format: str, *args, **kwargs) -> None:
        ...

    def __repr__(self) -> str:
        ...

    class Enum(_FormatLike):
        def __init__(self, value: ValueLike, /, variants: EnumMeta | Mapping[int, str] | Iterable[tuple[int, str]], *, name: Optional[str] = ...):
            ...

        def __repr__(self) -> str:
            ...
    
    class Struct(_FormatLike):
        def __init__(self, value: ValueLike, /, fields: Mapping[str, _FormatLike] | Iterable[tuple[str, _FormatLike]]):
            ...

        def __repr__(self) -> str:
            ...

    
    class Array(_FormatLike):
        def __init__(self, value: ValueLike, /, fields: Iterable[_FormatLike]):
            ...

        def __repr__(self) -> str:
            ...



class _StatementList(list[Statement]):
    def __repr__(self) -> str:
        ...
    


class Statement:
    def __init__(self, *, src_loc_at=...) -> None:
        ...
    
    @staticmethod
    def cast(obj: StatementLike) -> _StatementList:
        ...
    


@final
class Assign(Statement):
    lhs: Value
    rhs: Value

    def __init__(self, lhs: ValueLike, rhs: ValueLike, *, src_loc_at=...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    

@final
class Print(Statement):
    def __init__(self, *args, sep: str = ..., end: str = ..., src_loc_at=...) -> None:
        ...

    @property
    def message(self) -> Format:
        ...
    
    def __repr__(self) -> str:
        ...


class Property(Statement):
    class Kind(Enum):
        Assert = ...
        Assume = ...
        Cover = ...

    def __init__(self, kind: str | Kind, test: ValueLike, message: Optional[str | Format] = ..., *, src_loc_at=...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...


def Assert(test: ValueLike, message: Optional[str | Format], *, src_loc_at=...) -> Property:
    ...


def Assume(test: ValueLike, message: Optional[str | Format], *, src_loc_at=...) -> Property:
    ...


def Cover(test: ValueLike, message: Optional[str | Format], *, src_loc_at=...) -> Property:
    ...


class Switch(Statement):
    def __init__(self, test: ValueLike, cases: Mapping[SwitchKey, StatementLike], *, src_loc=..., src_loc_at=..., case_src_locs=...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    

class IOValue(metaclass=ABCMeta):
    @staticmethod
    def cast(obj: IOValueLike) -> IOValue:
        ...

    def __init__(self, *, src_loc_at : int = ...) -> None:
        ...

    @property
    @abstractmethod
    def metadata(self) -> tuple:
        ...

    def __getitem__(self, key: int | slice) -> IOValue:
        ...


@final
class IOPort(IOValue):
    def __init__(self, width: int, *, name: Optional[str] = ..., attrs: Optional[dict] = ..., metadata: Optional[tuple] = ..., src_loc_at: int = ...) -> None:
        ...

    def __len__(self) -> int:
        ...

    @property
    def width(self) -> int:
        ...

    @property
    def attrs(self) -> dict:
        ...

    @property
    def metadata(self) -> tuple:
        ...

    def __repr__(self) -> str:
        ...


@final
class IOConcat(IOValue):
    def __init__(self, parts: Iterable[IOValue], src_loc_at: int = ...) -> None:
        ...

    @property
    def parts(self) -> tuple[IOValue]:
        ...

    def __len__(self) -> int:
        ...

    @property
    def metadata(self) -> tuple:
        ...

    def __repr__(self) -> str:
        ...


@final
class IOSlice(IOValue):
    def __init__(self, value: IOValueLike, start: int, stop: int, *, src_loc_at: int = ...) -> None:
        ...

    @property
    def value(self) -> IOValue:
        ...

    @property
    def start(self) -> int:
        ...

    @property
    def stop(self) -> int:
        ...

    def __len__(self) -> int:
        ...

    @property
    def metadata(self) -> tuple:
        ...

    def __repr__(self) -> str:
        ...


class _MappedKeyCollection(metaclass=ABCMeta):
    ...


class _MappedKeyDict(MutableMapping, _MappedKeyCollection):
    def __init__(self, pairs=...) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __iter__(self): # -> Generator[None, None, None]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _MappedKeySet(MutableSet, _MappedKeyCollection):
    def __init__(self, elements=...) -> None:
        ...
    
    def add(self, value): # -> None:
        ...
    
    def update(self, values): # -> None:
        ...
    
    def discard(self, value): # -> None:
        ...
    
    def __contains__(self, value): # -> bool:
        ...
    
    def __iter__(self): # -> Generator[None, None, None]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class SignalKey:
    def __init__(self, signal: Signal | ClockSignal | ResetSignal) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other: SignalKey) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class SignalDict(_MappedKeyDict):
    _map_key = ...
    _unmap_key = ...


class SignalSet(_MappedKeySet):
    _map_key = ...
    _unmap_key = ...


