# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GroupPolicyArgs',
    'GroupPolicyArgsDict',
    'GroupPolicyScaleInActionArgs',
    'GroupPolicyScaleInActionArgsDict',
    'GroupPolicyScaleOutActionArgs',
    'GroupPolicyScaleOutActionArgsDict',
    'GroupReplicaConfigurationArgs',
    'GroupReplicaConfigurationArgsDict',
    'GroupReplicaConfigurationNicArgs',
    'GroupReplicaConfigurationNicArgsDict',
    'GroupReplicaConfigurationNicFirewallRuleArgs',
    'GroupReplicaConfigurationNicFirewallRuleArgsDict',
    'GroupReplicaConfigurationNicFlowLogArgs',
    'GroupReplicaConfigurationNicFlowLogArgsDict',
    'GroupReplicaConfigurationNicTargetGroupArgs',
    'GroupReplicaConfigurationNicTargetGroupArgsDict',
    'GroupReplicaConfigurationVolumeArgs',
    'GroupReplicaConfigurationVolumeArgsDict',
]

MYPY = False

if not MYPY:
    class GroupPolicyArgsDict(TypedDict):
        metric: pulumi.Input[str]
        """
        [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
        """
        scale_in_action: pulumi.Input['GroupPolicyScaleInActionArgsDict']
        """
        [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        """
        scale_in_threshold: pulumi.Input[int]
        """
        [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        """
        scale_out_action: pulumi.Input['GroupPolicyScaleOutActionArgsDict']
        """
        [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        """
        scale_out_threshold: pulumi.Input[int]
        """
        [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
        """
        unit: pulumi.Input[str]
        """
        [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
        """
        range: NotRequired[pulumi.Input[str]]
        """
        [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
elif False:
    GroupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPolicyArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 scale_in_action: pulumi.Input['GroupPolicyScaleInActionArgs'],
                 scale_in_threshold: pulumi.Input[int],
                 scale_out_action: pulumi.Input['GroupPolicyScaleOutActionArgs'],
                 scale_out_threshold: pulumi.Input[int],
                 unit: pulumi.Input[str],
                 range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
        :param pulumi.Input['GroupPolicyScaleInActionArgs'] scale_in_action: [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        :param pulumi.Input[int] scale_in_threshold: [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        :param pulumi.Input['GroupPolicyScaleOutActionArgs'] scale_out_action: [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        :param pulumi.Input[int] scale_out_threshold: [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
        :param pulumi.Input[str] unit: [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
        :param pulumi.Input[str] range: [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "scale_in_action", scale_in_action)
        pulumi.set(__self__, "scale_in_threshold", scale_in_threshold)
        pulumi.set(__self__, "scale_out_action", scale_out_action)
        pulumi.set(__self__, "scale_out_threshold", scale_out_threshold)
        pulumi.set(__self__, "unit", unit)
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="scaleInAction")
    def scale_in_action(self) -> pulumi.Input['GroupPolicyScaleInActionArgs']:
        """
        [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        """
        return pulumi.get(self, "scale_in_action")

    @scale_in_action.setter
    def scale_in_action(self, value: pulumi.Input['GroupPolicyScaleInActionArgs']):
        pulumi.set(self, "scale_in_action", value)

    @property
    @pulumi.getter(name="scaleInThreshold")
    def scale_in_threshold(self) -> pulumi.Input[int]:
        """
        [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        """
        return pulumi.get(self, "scale_in_threshold")

    @scale_in_threshold.setter
    def scale_in_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_in_threshold", value)

    @property
    @pulumi.getter(name="scaleOutAction")
    def scale_out_action(self) -> pulumi.Input['GroupPolicyScaleOutActionArgs']:
        """
        [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        """
        return pulumi.get(self, "scale_out_action")

    @scale_out_action.setter
    def scale_out_action(self, value: pulumi.Input['GroupPolicyScaleOutActionArgs']):
        pulumi.set(self, "scale_out_action", value)

    @property
    @pulumi.getter(name="scaleOutThreshold")
    def scale_out_threshold(self) -> pulumi.Input[int]:
        """
        [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
        """
        return pulumi.get(self, "scale_out_threshold")

    @scale_out_threshold.setter
    def scale_out_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_out_threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range", value)


if not MYPY:
    class GroupPolicyScaleInActionArgsDict(TypedDict):
        amount: pulumi.Input[int]
        """
        [int] When `amountType == ABSOLUTE`, this is the number of VMs removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the autoscaling group's current `targetReplicaCount` in order to derive the number of VMs that will be removed in one step. There will always be at least one VM removed. For SCALE_IN operation new volumes are NOT deleted after the server deletion.
        """
        amount_type: pulumi.Input[str]
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        delete_volumes: pulumi.Input[bool]
        """
        [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        """
        cooldown_period: NotRequired[pulumi.Input[str]]
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        termination_policy_type: NotRequired[pulumi.Input[str]]
        """
        [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
        """
elif False:
    GroupPolicyScaleInActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPolicyScaleInActionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[int],
                 amount_type: pulumi.Input[str],
                 delete_volumes: pulumi.Input[bool],
                 cooldown_period: Optional[pulumi.Input[str]] = None,
                 termination_policy_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] amount: [int] When `amountType == ABSOLUTE`, this is the number of VMs removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the autoscaling group's current `targetReplicaCount` in order to derive the number of VMs that will be removed in one step. There will always be at least one VM removed. For SCALE_IN operation new volumes are NOT deleted after the server deletion.
        :param pulumi.Input[str] amount_type: [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        :param pulumi.Input[bool] delete_volumes: [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        :param pulumi.Input[str] cooldown_period: [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        :param pulumi.Input[str] termination_policy_type: [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        pulumi.set(__self__, "delete_volumes", delete_volumes)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if termination_policy_type is not None:
            pulumi.set(__self__, "termination_policy_type", termination_policy_type)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[int]:
        """
        [int] When `amountType == ABSOLUTE`, this is the number of VMs removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the autoscaling group's current `targetReplicaCount` in order to derive the number of VMs that will be removed in one step. There will always be at least one VM removed. For SCALE_IN operation new volumes are NOT deleted after the server deletion.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> pulumi.Input[str]:
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        return pulumi.get(self, "amount_type")

    @amount_type.setter
    def amount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "amount_type", value)

    @property
    @pulumi.getter(name="deleteVolumes")
    def delete_volumes(self) -> pulumi.Input[bool]:
        """
        [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        """
        return pulumi.get(self, "delete_volumes")

    @delete_volumes.setter
    def delete_volumes(self, value: pulumi.Input[bool]):
        pulumi.set(self, "delete_volumes", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter(name="terminationPolicyType")
    def termination_policy_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
        """
        return pulumi.get(self, "termination_policy_type")

    @termination_policy_type.setter
    def termination_policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "termination_policy_type", value)


if not MYPY:
    class GroupPolicyScaleOutActionArgsDict(TypedDict):
        amount: pulumi.Input[int]
        """
        [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        """
        amount_type: pulumi.Input[str]
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        cooldown_period: NotRequired[pulumi.Input[str]]
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
elif False:
    GroupPolicyScaleOutActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPolicyScaleOutActionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[int],
                 amount_type: pulumi.Input[str],
                 cooldown_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] amount: [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        :param pulumi.Input[str] amount_type: [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        :param pulumi.Input[str] cooldown_period: [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[int]:
        """
        [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> pulumi.Input[str]:
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        return pulumi.get(self, "amount_type")

    @amount_type.setter
    def amount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "amount_type", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cooldown_period", value)


if not MYPY:
    class GroupReplicaConfigurationArgsDict(TypedDict):
        availability_zone: pulumi.Input[str]
        """
        [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
        """
        cores: pulumi.Input[int]
        """
        [int] The total number of cores for the VMs.
        """
        ram: pulumi.Input[int]
        """
        [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        """
        cpu_family: NotRequired[pulumi.Input[str]]
        """
        [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
        """
        nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicArgsDict']]]]
        """
        Set of NICs associated with this Replica.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationVolumeArgsDict']]]]
        """
        [list] List of volumes associated with this Replica.
        """
elif False:
    GroupReplicaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 cores: pulumi.Input[int],
                 ram: pulumi.Input[int],
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 nics: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationVolumeArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
        :param pulumi.Input[int] cores: [int] The total number of cores for the VMs.
        :param pulumi.Input[int] ram: [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        :param pulumi.Input[str] cpu_family: [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
        :param pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicArgs']]] nics: Set of NICs associated with this Replica.
        :param pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationVolumeArgs']]] volumes: [list] List of volumes associated with this Replica.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "ram", ram)
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        [int] The total number of cores for the VMs.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def ram(self) -> pulumi.Input[int]:
        """
        [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        """
        return pulumi.get(self, "ram")

    @ram.setter
    def ram(self, value: pulumi.Input[int]):
        pulumi.set(self, "ram", value)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[pulumi.Input[str]]:
        """
        [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter
    def nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicArgs']]]]:
        """
        Set of NICs associated with this Replica.
        """
        return pulumi.get(self, "nics")

    @nics.setter
    def nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicArgs']]]]):
        pulumi.set(self, "nics", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationVolumeArgs']]]]:
        """
        [list] List of volumes associated with this Replica.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class GroupReplicaConfigurationNicArgsDict(TypedDict):
        lan: pulumi.Input[int]
        """
        Lan ID for this replica Nic.
        """
        name: pulumi.Input[str]
        """
        [string] User-defined name for the Autoscaling Group.
        """
        dhcp: NotRequired[pulumi.Input[bool]]
        """
        Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        """
        firewall_active: NotRequired[pulumi.Input[bool]]
        """
        Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        """
        firewall_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFirewallRuleArgsDict']]]]
        """
        List of all firewall rules for the specified NIC.
        """
        firewall_type: NotRequired[pulumi.Input[str]]
        """
        The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        """
        flow_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFlowLogArgsDict']]]]
        """
        List of all flow logs for the specified NIC.
        """
        target_group: NotRequired[pulumi.Input['GroupReplicaConfigurationNicTargetGroupArgsDict']]
        """
        In order to link VM to ALB, target group must be provided.
        """
elif False:
    GroupReplicaConfigurationNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 name: pulumi.Input[str],
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_rules: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFirewallRuleArgs']]]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 flow_logs: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFlowLogArgs']]]] = None,
                 target_group: Optional[pulumi.Input['GroupReplicaConfigurationNicTargetGroupArgs']] = None):
        """
        :param pulumi.Input[int] lan: Lan ID for this replica Nic.
        :param pulumi.Input[str] name: [string] User-defined name for the Autoscaling Group.
        :param pulumi.Input[bool] dhcp: Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        :param pulumi.Input[bool] firewall_active: Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        :param pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFirewallRuleArgs']]] firewall_rules: List of all firewall rules for the specified NIC.
        :param pulumi.Input[str] firewall_type: The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        :param pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFlowLogArgs']]] flow_logs: List of all flow logs for the specified NIC.
        :param pulumi.Input['GroupReplicaConfigurationNicTargetGroupArgs'] target_group: In order to link VM to ALB, target group must be provided.
        """
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "name", name)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_rules is not None:
            pulumi.set(__self__, "firewall_rules", firewall_rules)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if flow_logs is not None:
            pulumi.set(__self__, "flow_logs", flow_logs)
        if target_group is not None:
            pulumi.set(__self__, "target_group", target_group)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        """
        Lan ID for this replica Nic.
        """
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] User-defined name for the Autoscaling Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        """
        Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        """
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFirewallRuleArgs']]]]:
        """
        List of all firewall rules for the specified NIC.
        """
        return pulumi.get(self, "firewall_rules")

    @firewall_rules.setter
    def firewall_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFirewallRuleArgs']]]]):
        pulumi.set(self, "firewall_rules", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        """
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter(name="flowLogs")
    def flow_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFlowLogArgs']]]]:
        """
        List of all flow logs for the specified NIC.
        """
        return pulumi.get(self, "flow_logs")

    @flow_logs.setter
    def flow_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupReplicaConfigurationNicFlowLogArgs']]]]):
        pulumi.set(self, "flow_logs", value)

    @property
    @pulumi.getter(name="targetGroup")
    def target_group(self) -> Optional[pulumi.Input['GroupReplicaConfigurationNicTargetGroupArgs']]:
        """
        In order to link VM to ALB, target group must be provided.
        """
        return pulumi.get(self, "target_group")

    @target_group.setter
    def target_group(self, value: Optional[pulumi.Input['GroupReplicaConfigurationNicTargetGroupArgs']]):
        pulumi.set(self, "target_group", value)


if not MYPY:
    class GroupReplicaConfigurationNicFirewallRuleArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        """
        icmp_code: NotRequired[pulumi.Input[int]]
        """
        Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        """
        icmp_type: NotRequired[pulumi.Input[int]]
        """
        Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] User-defined name for the Autoscaling Group.
        """
        port_range_end: NotRequired[pulumi.Input[int]]
        """
        Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        port_range_start: NotRequired[pulumi.Input[int]]
        """
        Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        source_ip: NotRequired[pulumi.Input[str]]
        """
        Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        """
        source_mac: NotRequired[pulumi.Input[str]]
        """
        Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        """
        target_ip: NotRequired[pulumi.Input[str]]
        """
        If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
elif False:
    GroupReplicaConfigurationNicFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationNicFirewallRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        :param pulumi.Input[int] icmp_code: Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        :param pulumi.Input[int] icmp_type: Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        :param pulumi.Input[str] name: [string] User-defined name for the Autoscaling Group.
        :param pulumi.Input[int] port_range_end: Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param pulumi.Input[int] port_range_start: Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param pulumi.Input[str] source_ip: Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        :param pulumi.Input[str] source_mac: Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        :param pulumi.Input[str] target_ip: If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        :param pulumi.Input[str] type: The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] User-defined name for the Autoscaling Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        """
        Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        """
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        """
        If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        """
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GroupReplicaConfigurationNicFlowLogArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
        """
        bucket: pulumi.Input[str]
        """
        The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
        """
        direction: pulumi.Input[str]
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
        """
        name: pulumi.Input[str]
        """
        [string] User-defined name for the Autoscaling Group.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The resource's unique identifier.
        """
elif False:
    GroupReplicaConfigurationNicFlowLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationNicFlowLogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
        :param pulumi.Input[str] bucket: The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
        :param pulumi.Input[str] direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
        :param pulumi.Input[str] name: [string] User-defined name for the Autoscaling Group.
        :param pulumi.Input[str] id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] User-defined name for the Autoscaling Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GroupReplicaConfigurationNicTargetGroupArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port for the target group.
        """
        target_group_id: pulumi.Input[str]
        """
        The ID of the target group.
        """
        weight: pulumi.Input[int]
        """
        The weight for the target group.
        """
elif False:
    GroupReplicaConfigurationNicTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationNicTargetGroupArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 target_group_id: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: The port for the target group.
        :param pulumi.Input[str] target_group_id: The ID of the target group.
        :param pulumi.Input[int] weight: The weight for the target group.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port for the target group.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> pulumi.Input[str]:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @target_group_id.setter
    def target_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_group_id", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        The weight for the target group.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GroupReplicaConfigurationVolumeArgsDict(TypedDict):
        boot_order: pulumi.Input[str]
        """
        [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        """
        name: pulumi.Input[str]
        """
        [string] Name for this replica volume.
        """
        size: pulumi.Input[int]
        """
        [int] Name for this replica volume.
        """
        type: pulumi.Input[str]
        """
        [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        """
        backup_unit_id: NotRequired[pulumi.Input[str]]
        """
        [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
        """
        bus: NotRequired[pulumi.Input[str]]
        """
        [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        [string] The image installed on the volume. Only the UUID of the image is presently supported.
        """
        image_alias: NotRequired[pulumi.Input[str]]
        """
        [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
        """
        image_password: NotRequired[pulumi.Input[str]]
        """
        [string] Image password for this replica volume.
        """
        ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ssh keys, supports values or paths to files. Cannot be changed at update.
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
        """
elif False:
    GroupReplicaConfigurationVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupReplicaConfigurationVolumeArgs:
    def __init__(__self__, *,
                 boot_order: pulumi.Input[str],
                 name: pulumi.Input[str],
                 size: pulumi.Input[int],
                 type: pulumi.Input[str],
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 image_alias: Optional[pulumi.Input[str]] = None,
                 image_password: Optional[pulumi.Input[str]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_order: [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
               Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        :param pulumi.Input[str] name: [string] Name for this replica volume.
        :param pulumi.Input[int] size: [int] Name for this replica volume.
        :param pulumi.Input[str] type: [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        :param pulumi.Input[str] backup_unit_id: [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
        :param pulumi.Input[str] bus: [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
        :param pulumi.Input[str] image: [string] The image installed on the volume. Only the UUID of the image is presently supported.
        :param pulumi.Input[str] image_alias: [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
        :param pulumi.Input[str] image_password: [string] Image password for this replica volume.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_keys: List of ssh keys, supports values or paths to files. Cannot be changed at update.
        :param pulumi.Input[str] user_data: [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
        """
        pulumi.set(__self__, "boot_order", boot_order)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_alias is not None:
            pulumi.set(__self__, "image_alias", image_alias)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="bootOrder")
    def boot_order(self) -> pulumi.Input[str]:
        """
        [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        """
        return pulumi.get(self, "boot_order")

    @boot_order.setter
    def boot_order(self, value: pulumi.Input[str]):
        pulumi.set(self, "boot_order", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        [int] Name for this replica volume.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
        """
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The image installed on the volume. Only the UUID of the image is presently supported.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="imageAlias")
    def image_alias(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
        """
        return pulumi.get(self, "image_alias")

    @image_alias.setter
    def image_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_alias", value)

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Image password for this replica volume.
        """
        return pulumi.get(self, "image_password")

    @image_password.setter
    def image_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_password", value)

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ssh keys, supports values or paths to files. Cannot be changed at update.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_keys", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


