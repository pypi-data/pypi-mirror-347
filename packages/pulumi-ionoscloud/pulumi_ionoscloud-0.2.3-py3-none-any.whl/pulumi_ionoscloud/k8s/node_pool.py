# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['NodePoolArgs', 'NodePool']

@pulumi.input_type
class NodePoolArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 cores_count: pulumi.Input[int],
                 cpu_family: pulumi.Input[str],
                 datacenter_id: pulumi.Input[str],
                 k8s_cluster_id: pulumi.Input[str],
                 k8s_version: pulumi.Input[str],
                 node_count: pulumi.Input[int],
                 ram_size: pulumi.Input[int],
                 storage_size: pulumi.Input[int],
                 storage_type: pulumi.Input[str],
                 allow_replace: Optional[pulumi.Input[bool]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 auto_scaling: Optional[pulumi.Input['NodePoolAutoScalingArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 lans: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]] = None,
                 maintenance_window: Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a NodePool resource.
        :param pulumi.Input[str] availability_zone: [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[int] cores_count: [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        :param pulumi.Input[str] cpu_family: [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[str] datacenter_id: [string] A Datacenter's UUID
        :param pulumi.Input[str] k8s_cluster_id: [string] A k8s cluster's UUID
        :param pulumi.Input[str] k8s_version: [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        :param pulumi.Input[int] node_count: [int] - The desired number of nodes in the node pool
        :param pulumi.Input[int] ram_size: [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        :param pulumi.Input[int] storage_size: [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        :param pulumi.Input[str] storage_type: [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        :param pulumi.Input[bool] allow_replace: [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
               
               ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
               This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
               
               Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
               
               ⚠️ **Note**:
               
               Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
               `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
               from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
               This will also ignore the manual changes for `node_count` made in the `tf` plan.
               You can read more details about the `ignore_changes` attribute here.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: [map] A key/value map of annotations
        :param pulumi.Input['NodePoolAutoScalingArgs'] auto_scaling: [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: [map] A key/value map of labels
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]] lans: [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        :param pulumi.Input['NodePoolMaintenanceWindowArgs'] maintenance_window: See the **maintenance_window** section in the example above
        :param pulumi.Input[str] name: [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores_count", cores_count)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "k8s_cluster_id", k8s_cluster_id)
        pulumi.set(__self__, "k8s_version", k8s_version)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ram_size", ram_size)
        pulumi.set(__self__, "storage_size", storage_size)
        pulumi.set(__self__, "storage_type", storage_type)
        if allow_replace is not None:
            pulumi.set(__self__, "allow_replace", allow_replace)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if lans is not None:
            pulumi.set(__self__, "lans", lans)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="coresCount")
    def cores_count(self) -> pulumi.Input[int]:
        """
        [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        """
        return pulumi.get(self, "cores_count")

    @cores_count.setter
    def cores_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores_count", value)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> pulumi.Input[str]:
        """
        [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: pulumi.Input[str]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [string] A Datacenter's UUID
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="k8sClusterId")
    def k8s_cluster_id(self) -> pulumi.Input[str]:
        """
        [string] A k8s cluster's UUID
        """
        return pulumi.get(self, "k8s_cluster_id")

    @k8s_cluster_id.setter
    def k8s_cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "k8s_cluster_id", value)

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> pulumi.Input[str]:
        """
        [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        """
        return pulumi.get(self, "k8s_version")

    @k8s_version.setter
    def k8s_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "k8s_version", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[int]:
        """
        [int] - The desired number of nodes in the node pool
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="ramSize")
    def ram_size(self) -> pulumi.Input[int]:
        """
        [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        """
        return pulumi.get(self, "ram_size")

    @ram_size.setter
    def ram_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "ram_size", value)

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> pulumi.Input[int]:
        """
        [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_size")

    @storage_size.setter
    def storage_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_size", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[str]:
        """
        [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter(name="allowReplace")
    def allow_replace(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.

        ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
        This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**

        Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.

        ⚠️ **Note**:

        Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
        `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
        from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
        This will also ignore the manual changes for `node_count` made in the `tf` plan.
        You can read more details about the `ignore_changes` attribute here.
        """
        return pulumi.get(self, "allow_replace")

    @allow_replace.setter
    def allow_replace(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_replace", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        [map] A key/value map of annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional[pulumi.Input['NodePoolAutoScalingArgs']]:
        """
        [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        """
        return pulumi.get(self, "auto_scaling")

    @auto_scaling.setter
    def auto_scaling(self, value: Optional[pulumi.Input['NodePoolAutoScalingArgs']]):
        pulumi.set(self, "auto_scaling", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        [map] A key/value map of labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def lans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]]:
        """
        [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        """
        return pulumi.get(self, "lans")

    @lans.setter
    def lans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]]):
        pulumi.set(self, "lans", value)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']]:
        """
        See the **maintenance_window** section in the example above
        """
        return pulumi.get(self, "maintenance_window")

    @maintenance_window.setter
    def maintenance_window(self, value: Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']]):
        pulumi.set(self, "maintenance_window", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        """
        return pulumi.get(self, "public_ips")

    @public_ips.setter
    def public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "public_ips", value)


@pulumi.input_type
class _NodePoolState:
    def __init__(__self__, *,
                 allow_replace: Optional[pulumi.Input[bool]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 auto_scaling: Optional[pulumi.Input['NodePoolAutoScalingArgs']] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 cores_count: Optional[pulumi.Input[int]] = None,
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 k8s_cluster_id: Optional[pulumi.Input[str]] = None,
                 k8s_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 lans: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]] = None,
                 maintenance_window: Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ram_size: Optional[pulumi.Input[int]] = None,
                 storage_size: Optional[pulumi.Input[int]] = None,
                 storage_type: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering NodePool resources.
        :param pulumi.Input[bool] allow_replace: [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
               
               ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
               This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
               
               Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
               
               ⚠️ **Note**:
               
               Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
               `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
               from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
               This will also ignore the manual changes for `node_count` made in the `tf` plan.
               You can read more details about the `ignore_changes` attribute here.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: [map] A key/value map of annotations
        :param pulumi.Input['NodePoolAutoScalingArgs'] auto_scaling: [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        :param pulumi.Input[str] availability_zone: [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[int] cores_count: [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        :param pulumi.Input[str] cpu_family: [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[str] datacenter_id: [string] A Datacenter's UUID
        :param pulumi.Input[str] k8s_cluster_id: [string] A k8s cluster's UUID
        :param pulumi.Input[str] k8s_version: [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: [map] A key/value map of labels
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]] lans: [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        :param pulumi.Input['NodePoolMaintenanceWindowArgs'] maintenance_window: See the **maintenance_window** section in the example above
        :param pulumi.Input[str] name: [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        :param pulumi.Input[int] node_count: [int] - The desired number of nodes in the node pool
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        :param pulumi.Input[int] ram_size: [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        :param pulumi.Input[int] storage_size: [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        :param pulumi.Input[str] storage_type: [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        if allow_replace is not None:
            pulumi.set(__self__, "allow_replace", allow_replace)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if cores_count is not None:
            pulumi.set(__self__, "cores_count", cores_count)
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if k8s_cluster_id is not None:
            pulumi.set(__self__, "k8s_cluster_id", k8s_cluster_id)
        if k8s_version is not None:
            pulumi.set(__self__, "k8s_version", k8s_version)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if lans is not None:
            pulumi.set(__self__, "lans", lans)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if ram_size is not None:
            pulumi.set(__self__, "ram_size", ram_size)
        if storage_size is not None:
            pulumi.set(__self__, "storage_size", storage_size)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @property
    @pulumi.getter(name="allowReplace")
    def allow_replace(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.

        ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
        This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**

        Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.

        ⚠️ **Note**:

        Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
        `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
        from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
        This will also ignore the manual changes for `node_count` made in the `tf` plan.
        You can read more details about the `ignore_changes` attribute here.
        """
        return pulumi.get(self, "allow_replace")

    @allow_replace.setter
    def allow_replace(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_replace", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        [map] A key/value map of annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional[pulumi.Input['NodePoolAutoScalingArgs']]:
        """
        [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        """
        return pulumi.get(self, "auto_scaling")

    @auto_scaling.setter
    def auto_scaling(self, value: Optional[pulumi.Input['NodePoolAutoScalingArgs']]):
        pulumi.set(self, "auto_scaling", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="coresCount")
    def cores_count(self) -> Optional[pulumi.Input[int]]:
        """
        [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        """
        return pulumi.get(self, "cores_count")

    @cores_count.setter
    def cores_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores_count", value)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[str]]:
        """
        [string] A Datacenter's UUID
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="k8sClusterId")
    def k8s_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        [string] A k8s cluster's UUID
        """
        return pulumi.get(self, "k8s_cluster_id")

    @k8s_cluster_id.setter
    def k8s_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_cluster_id", value)

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        """
        return pulumi.get(self, "k8s_version")

    @k8s_version.setter
    def k8s_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_version", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        [map] A key/value map of labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def lans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]]:
        """
        [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        """
        return pulumi.get(self, "lans")

    @lans.setter
    def lans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolLanArgs']]]]):
        pulumi.set(self, "lans", value)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']]:
        """
        See the **maintenance_window** section in the example above
        """
        return pulumi.get(self, "maintenance_window")

    @maintenance_window.setter
    def maintenance_window(self, value: Optional[pulumi.Input['NodePoolMaintenanceWindowArgs']]):
        pulumi.set(self, "maintenance_window", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        [int] - The desired number of nodes in the node pool
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        """
        return pulumi.get(self, "public_ips")

    @public_ips.setter
    def public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "public_ips", value)

    @property
    @pulumi.getter(name="ramSize")
    def ram_size(self) -> Optional[pulumi.Input[int]]:
        """
        [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        """
        return pulumi.get(self, "ram_size")

    @ram_size.setter
    def ram_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ram_size", value)

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> Optional[pulumi.Input[int]]:
        """
        [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_size")

    @storage_size.setter
    def storage_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_size", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_type", value)


class NodePool(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_replace: Optional[pulumi.Input[bool]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 auto_scaling: Optional[pulumi.Input[Union['NodePoolAutoScalingArgs', 'NodePoolAutoScalingArgsDict']]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 cores_count: Optional[pulumi.Input[int]] = None,
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 k8s_cluster_id: Optional[pulumi.Input[str]] = None,
                 k8s_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 lans: Optional[pulumi.Input[Sequence[pulumi.Input[Union['NodePoolLanArgs', 'NodePoolLanArgsDict']]]]] = None,
                 maintenance_window: Optional[pulumi.Input[Union['NodePoolMaintenanceWindowArgs', 'NodePoolMaintenanceWindowArgsDict']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ram_size: Optional[pulumi.Input[int]] = None,
                 storage_size: Optional[pulumi.Input[int]] = None,
                 storage_type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Manages a **Managed Kubernetes Node Pool**, part of a managed Kubernetes cluster on IonosCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_ionoscloud as ionoscloud

        example = ionoscloud.compute.Datacenter("example",
            name="Datacenter Example",
            location="us/las",
            description="datacenter description",
            sec_auth_protection=False)
        example_lan = ionoscloud.compute.Lan("example",
            datacenter_id=example.id,
            public=False,
            name="Lan Example")
        example_ip_block = ionoscloud.compute.IPBlock("example",
            location="us/las",
            size=3,
            name="IP Block Example")
        example_cluster = ionoscloud.k8s.Cluster("example",
            name="k8sClusterExample",
            k8s_version="1.31.2",
            maintenance_window={
                "day_of_the_week": "Sunday",
                "time": "09:00:00Z",
            },
            api_subnet_allow_lists=["1.2.3.4/32"],
            s3_buckets=[{
                "name": "globally_unique_s3_bucket_name",
            }])
        example_node_pool = ionoscloud.k8s.NodePool("example",
            datacenter_id=example.id,
            k8s_cluster_id=example_cluster.id,
            name="k8sNodePoolExample",
            k8s_version=example_cluster.k8s_version,
            maintenance_window={
                "day_of_the_week": "Monday",
                "time": "09:00:00Z",
            },
            auto_scaling={
                "min_node_count": 1,
                "max_node_count": 2,
            },
            cpu_family="INTEL_XEON",
            availability_zone="AUTO",
            storage_type="SSD",
            node_count=1,
            cores_count=2,
            ram_size=2048,
            storage_size=40,
            public_ips=[
                example_ip_block.ips[0],
                example_ip_block.ips[1],
                example_ip_block.ips[2],
            ],
            lans=[{
                "id": example_lan.id,
                "dhcp": True,
                "routes": [{
                    "network": "1.2.3.5/24",
                    "gateway_ip": "10.1.5.17",
                }],
            }],
            labels={
                "lab1": "value1",
                "lab2": "value2",
            },
            annotations={
                "ann1": "value1",
                "ann2": "value2",
            })
        ```
        **Note:** Set `create_before_destroy` on the lan resource if you want to remove it from the nodepool during an update. This is to ensure that the nodepool is updated before the lan is destroyed.

        ## Import

        A Kubernetes Node Pool resource can be imported using its Kubernetes cluster's uuid as well as its own UUID, both of which you can retrieve from the cloud API: `resource id`, e.g.:

        ```sh
        $ pulumi import ionoscloud:k8s/nodePool:NodePool demo k8s_cluster_uuid/k8s_nodepool_id
        ```

        This can be helpful when you want to import kubernetes node pools which you have already created manually or using other means, outside of pulumi, towards the goal of managing them via Pulumi

        ⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent

        pulumi from doing a downgrade, as downgrading `k8s_version` is not supported._**

        ⚠️ **_Warning: **If you are upgrading from v5.x.x to v6.x.x**: You have to modify you plan for lans to match the new structure, by putting the ids from the old slice in lans.id fields. This is not backwards compatible._**

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] allow_replace: [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
               
               ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
               This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
               
               Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
               
               ⚠️ **Note**:
               
               Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
               `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
               from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
               This will also ignore the manual changes for `node_count` made in the `tf` plan.
               You can read more details about the `ignore_changes` attribute here.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: [map] A key/value map of annotations
        :param pulumi.Input[Union['NodePoolAutoScalingArgs', 'NodePoolAutoScalingArgsDict']] auto_scaling: [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        :param pulumi.Input[str] availability_zone: [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[int] cores_count: [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        :param pulumi.Input[str] cpu_family: [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[str] datacenter_id: [string] A Datacenter's UUID
        :param pulumi.Input[str] k8s_cluster_id: [string] A k8s cluster's UUID
        :param pulumi.Input[str] k8s_version: [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: [map] A key/value map of labels
        :param pulumi.Input[Sequence[pulumi.Input[Union['NodePoolLanArgs', 'NodePoolLanArgsDict']]]] lans: [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        :param pulumi.Input[Union['NodePoolMaintenanceWindowArgs', 'NodePoolMaintenanceWindowArgsDict']] maintenance_window: See the **maintenance_window** section in the example above
        :param pulumi.Input[str] name: [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        :param pulumi.Input[int] node_count: [int] - The desired number of nodes in the node pool
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        :param pulumi.Input[int] ram_size: [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        :param pulumi.Input[int] storage_size: [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        :param pulumi.Input[str] storage_type: [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: NodePoolArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a **Managed Kubernetes Node Pool**, part of a managed Kubernetes cluster on IonosCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_ionoscloud as ionoscloud

        example = ionoscloud.compute.Datacenter("example",
            name="Datacenter Example",
            location="us/las",
            description="datacenter description",
            sec_auth_protection=False)
        example_lan = ionoscloud.compute.Lan("example",
            datacenter_id=example.id,
            public=False,
            name="Lan Example")
        example_ip_block = ionoscloud.compute.IPBlock("example",
            location="us/las",
            size=3,
            name="IP Block Example")
        example_cluster = ionoscloud.k8s.Cluster("example",
            name="k8sClusterExample",
            k8s_version="1.31.2",
            maintenance_window={
                "day_of_the_week": "Sunday",
                "time": "09:00:00Z",
            },
            api_subnet_allow_lists=["1.2.3.4/32"],
            s3_buckets=[{
                "name": "globally_unique_s3_bucket_name",
            }])
        example_node_pool = ionoscloud.k8s.NodePool("example",
            datacenter_id=example.id,
            k8s_cluster_id=example_cluster.id,
            name="k8sNodePoolExample",
            k8s_version=example_cluster.k8s_version,
            maintenance_window={
                "day_of_the_week": "Monday",
                "time": "09:00:00Z",
            },
            auto_scaling={
                "min_node_count": 1,
                "max_node_count": 2,
            },
            cpu_family="INTEL_XEON",
            availability_zone="AUTO",
            storage_type="SSD",
            node_count=1,
            cores_count=2,
            ram_size=2048,
            storage_size=40,
            public_ips=[
                example_ip_block.ips[0],
                example_ip_block.ips[1],
                example_ip_block.ips[2],
            ],
            lans=[{
                "id": example_lan.id,
                "dhcp": True,
                "routes": [{
                    "network": "1.2.3.5/24",
                    "gateway_ip": "10.1.5.17",
                }],
            }],
            labels={
                "lab1": "value1",
                "lab2": "value2",
            },
            annotations={
                "ann1": "value1",
                "ann2": "value2",
            })
        ```
        **Note:** Set `create_before_destroy` on the lan resource if you want to remove it from the nodepool during an update. This is to ensure that the nodepool is updated before the lan is destroyed.

        ## Import

        A Kubernetes Node Pool resource can be imported using its Kubernetes cluster's uuid as well as its own UUID, both of which you can retrieve from the cloud API: `resource id`, e.g.:

        ```sh
        $ pulumi import ionoscloud:k8s/nodePool:NodePool demo k8s_cluster_uuid/k8s_nodepool_id
        ```

        This can be helpful when you want to import kubernetes node pools which you have already created manually or using other means, outside of pulumi, towards the goal of managing them via Pulumi

        ⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent

        pulumi from doing a downgrade, as downgrading `k8s_version` is not supported._**

        ⚠️ **_Warning: **If you are upgrading from v5.x.x to v6.x.x**: You have to modify you plan for lans to match the new structure, by putting the ids from the old slice in lans.id fields. This is not backwards compatible._**

        :param str resource_name: The name of the resource.
        :param NodePoolArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(NodePoolArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_replace: Optional[pulumi.Input[bool]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 auto_scaling: Optional[pulumi.Input[Union['NodePoolAutoScalingArgs', 'NodePoolAutoScalingArgsDict']]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 cores_count: Optional[pulumi.Input[int]] = None,
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 k8s_cluster_id: Optional[pulumi.Input[str]] = None,
                 k8s_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 lans: Optional[pulumi.Input[Sequence[pulumi.Input[Union['NodePoolLanArgs', 'NodePoolLanArgsDict']]]]] = None,
                 maintenance_window: Optional[pulumi.Input[Union['NodePoolMaintenanceWindowArgs', 'NodePoolMaintenanceWindowArgsDict']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ram_size: Optional[pulumi.Input[int]] = None,
                 storage_size: Optional[pulumi.Input[int]] = None,
                 storage_type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = NodePoolArgs.__new__(NodePoolArgs)

            __props__.__dict__["allow_replace"] = allow_replace
            __props__.__dict__["annotations"] = annotations
            __props__.__dict__["auto_scaling"] = auto_scaling
            if availability_zone is None and not opts.urn:
                raise TypeError("Missing required property 'availability_zone'")
            __props__.__dict__["availability_zone"] = availability_zone
            if cores_count is None and not opts.urn:
                raise TypeError("Missing required property 'cores_count'")
            __props__.__dict__["cores_count"] = cores_count
            if cpu_family is None and not opts.urn:
                raise TypeError("Missing required property 'cpu_family'")
            __props__.__dict__["cpu_family"] = cpu_family
            if datacenter_id is None and not opts.urn:
                raise TypeError("Missing required property 'datacenter_id'")
            __props__.__dict__["datacenter_id"] = datacenter_id
            if k8s_cluster_id is None and not opts.urn:
                raise TypeError("Missing required property 'k8s_cluster_id'")
            __props__.__dict__["k8s_cluster_id"] = k8s_cluster_id
            if k8s_version is None and not opts.urn:
                raise TypeError("Missing required property 'k8s_version'")
            __props__.__dict__["k8s_version"] = k8s_version
            __props__.__dict__["labels"] = labels
            __props__.__dict__["lans"] = lans
            __props__.__dict__["maintenance_window"] = maintenance_window
            __props__.__dict__["name"] = name
            if node_count is None and not opts.urn:
                raise TypeError("Missing required property 'node_count'")
            __props__.__dict__["node_count"] = node_count
            __props__.__dict__["public_ips"] = public_ips
            if ram_size is None and not opts.urn:
                raise TypeError("Missing required property 'ram_size'")
            __props__.__dict__["ram_size"] = ram_size
            if storage_size is None and not opts.urn:
                raise TypeError("Missing required property 'storage_size'")
            __props__.__dict__["storage_size"] = storage_size
            if storage_type is None and not opts.urn:
                raise TypeError("Missing required property 'storage_type'")
            __props__.__dict__["storage_type"] = storage_type
        super(NodePool, __self__).__init__(
            'ionoscloud:k8s/nodePool:NodePool',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allow_replace: Optional[pulumi.Input[bool]] = None,
            annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            auto_scaling: Optional[pulumi.Input[Union['NodePoolAutoScalingArgs', 'NodePoolAutoScalingArgsDict']]] = None,
            availability_zone: Optional[pulumi.Input[str]] = None,
            cores_count: Optional[pulumi.Input[int]] = None,
            cpu_family: Optional[pulumi.Input[str]] = None,
            datacenter_id: Optional[pulumi.Input[str]] = None,
            k8s_cluster_id: Optional[pulumi.Input[str]] = None,
            k8s_version: Optional[pulumi.Input[str]] = None,
            labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            lans: Optional[pulumi.Input[Sequence[pulumi.Input[Union['NodePoolLanArgs', 'NodePoolLanArgsDict']]]]] = None,
            maintenance_window: Optional[pulumi.Input[Union['NodePoolMaintenanceWindowArgs', 'NodePoolMaintenanceWindowArgsDict']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            node_count: Optional[pulumi.Input[int]] = None,
            public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            ram_size: Optional[pulumi.Input[int]] = None,
            storage_size: Optional[pulumi.Input[int]] = None,
            storage_type: Optional[pulumi.Input[str]] = None) -> 'NodePool':
        """
        Get an existing NodePool resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] allow_replace: [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
               
               ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
               This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
               
               Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
               
               ⚠️ **Note**:
               
               Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
               `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
               from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
               This will also ignore the manual changes for `node_count` made in the `tf` plan.
               You can read more details about the `ignore_changes` attribute here.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: [map] A key/value map of annotations
        :param pulumi.Input[Union['NodePoolAutoScalingArgs', 'NodePoolAutoScalingArgsDict']] auto_scaling: [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        :param pulumi.Input[str] availability_zone: [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[int] cores_count: [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        :param pulumi.Input[str] cpu_family: [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        :param pulumi.Input[str] datacenter_id: [string] A Datacenter's UUID
        :param pulumi.Input[str] k8s_cluster_id: [string] A k8s cluster's UUID
        :param pulumi.Input[str] k8s_version: [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: [map] A key/value map of labels
        :param pulumi.Input[Sequence[pulumi.Input[Union['NodePoolLanArgs', 'NodePoolLanArgsDict']]]] lans: [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        :param pulumi.Input[Union['NodePoolMaintenanceWindowArgs', 'NodePoolMaintenanceWindowArgsDict']] maintenance_window: See the **maintenance_window** section in the example above
        :param pulumi.Input[str] name: [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        :param pulumi.Input[int] node_count: [int] - The desired number of nodes in the node pool
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        :param pulumi.Input[int] ram_size: [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        :param pulumi.Input[int] storage_size: [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        :param pulumi.Input[str] storage_type: [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _NodePoolState.__new__(_NodePoolState)

        __props__.__dict__["allow_replace"] = allow_replace
        __props__.__dict__["annotations"] = annotations
        __props__.__dict__["auto_scaling"] = auto_scaling
        __props__.__dict__["availability_zone"] = availability_zone
        __props__.__dict__["cores_count"] = cores_count
        __props__.__dict__["cpu_family"] = cpu_family
        __props__.__dict__["datacenter_id"] = datacenter_id
        __props__.__dict__["k8s_cluster_id"] = k8s_cluster_id
        __props__.__dict__["k8s_version"] = k8s_version
        __props__.__dict__["labels"] = labels
        __props__.__dict__["lans"] = lans
        __props__.__dict__["maintenance_window"] = maintenance_window
        __props__.__dict__["name"] = name
        __props__.__dict__["node_count"] = node_count
        __props__.__dict__["public_ips"] = public_ips
        __props__.__dict__["ram_size"] = ram_size
        __props__.__dict__["storage_size"] = storage_size
        __props__.__dict__["storage_type"] = storage_type
        return NodePool(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="allowReplace")
    def allow_replace(self) -> pulumi.Output[Optional[bool]]:
        """
        [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.

        ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
        This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**

        Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.

        ⚠️ **Note**:

        Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
        `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
        from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
        This will also ignore the manual changes for `node_count` made in the `tf` plan.
        You can read more details about the `ignore_changes` attribute here.
        """
        return pulumi.get(self, "allow_replace")

    @property
    @pulumi.getter
    def annotations(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        [map] A key/value map of annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> pulumi.Output[Optional['outputs.NodePoolAutoScaling']]:
        """
        [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
        """
        return pulumi.get(self, "auto_scaling")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Output[str]:
        """
        [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="coresCount")
    def cores_count(self) -> pulumi.Output[int]:
        """
        [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
        """
        return pulumi.get(self, "cores_count")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> pulumi.Output[str]:
        """
        [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Output[str]:
        """
        [string] A Datacenter's UUID
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="k8sClusterId")
    def k8s_cluster_id(self) -> pulumi.Output[str]:
        """
        [string] A k8s cluster's UUID
        """
        return pulumi.get(self, "k8s_cluster_id")

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> pulumi.Output[str]:
        """
        [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
        """
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        [map] A key/value map of labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def lans(self) -> pulumi.Output[Optional[Sequence['outputs.NodePoolLan']]]:
        """
        [list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
        """
        return pulumi.get(self, "lans")

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> pulumi.Output['outputs.NodePoolMaintenanceWindow']:
        """
        See the **maintenance_window** section in the example above
        """
        return pulumi.get(self, "maintenance_window")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Output[int]:
        """
        [int] - The desired number of nodes in the node pool
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter(name="ramSize")
    def ram_size(self) -> pulumi.Output[int]:
        """
        [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
        """
        return pulumi.get(self, "ram_size")

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> pulumi.Output[int]:
        """
        [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_size")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Output[str]:
        """
        [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
        """
        return pulumi.get(self, "storage_type")

