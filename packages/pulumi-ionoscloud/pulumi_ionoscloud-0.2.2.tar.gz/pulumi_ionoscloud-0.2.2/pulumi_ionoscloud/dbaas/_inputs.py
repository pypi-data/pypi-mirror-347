# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InMemoryDBReplicaSetConnectionsArgs',
    'InMemoryDBReplicaSetConnectionsArgsDict',
    'InMemoryDBReplicaSetCredentialsArgs',
    'InMemoryDBReplicaSetCredentialsArgsDict',
    'InMemoryDBReplicaSetCredentialsHashedPasswordArgs',
    'InMemoryDBReplicaSetCredentialsHashedPasswordArgsDict',
    'InMemoryDBReplicaSetMaintenanceWindowArgs',
    'InMemoryDBReplicaSetMaintenanceWindowArgsDict',
    'InMemoryDBReplicaSetResourcesArgs',
    'InMemoryDBReplicaSetResourcesArgsDict',
    'MariaDBClusterConnectionsArgs',
    'MariaDBClusterConnectionsArgsDict',
    'MariaDBClusterCredentialsArgs',
    'MariaDBClusterCredentialsArgsDict',
    'MariaDBClusterMaintenanceWindowArgs',
    'MariaDBClusterMaintenanceWindowArgsDict',
    'MongoClusterBackupArgs',
    'MongoClusterBackupArgsDict',
    'MongoClusterBiConnectorArgs',
    'MongoClusterBiConnectorArgsDict',
    'MongoClusterConnectionsArgs',
    'MongoClusterConnectionsArgsDict',
    'MongoClusterMaintenanceWindowArgs',
    'MongoClusterMaintenanceWindowArgsDict',
    'MongoUserRoleArgs',
    'MongoUserRoleArgsDict',
    'PSQLClusterConnectionPoolerArgs',
    'PSQLClusterConnectionPoolerArgsDict',
    'PSQLClusterConnectionsArgs',
    'PSQLClusterConnectionsArgsDict',
    'PSQLClusterCredentialsArgs',
    'PSQLClusterCredentialsArgsDict',
    'PSQLClusterFromBackupArgs',
    'PSQLClusterFromBackupArgsDict',
    'PSQLClusterMaintenanceWindowArgs',
    'PSQLClusterMaintenanceWindowArgsDict',
    'GetMongoUserRoleArgs',
    'GetMongoUserRoleArgsDict',
]

MYPY = False

if not MYPY:
    class InMemoryDBReplicaSetConnectionsArgsDict(TypedDict):
        cidr: pulumi.Input[str]
        """
        [string] The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24.
        """
        datacenter_id: pulumi.Input[str]
        """
        [string] The datacenter to connect your instance to.
        """
        lan_id: pulumi.Input[str]
        """
        [string] The numeric LAN ID to connect your instance to.
        """
elif False:
    InMemoryDBReplicaSetConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InMemoryDBReplicaSetConnectionsArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str],
                 datacenter_id: pulumi.Input[str],
                 lan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr: [string] The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24.
        :param pulumi.Input[str] datacenter_id: [string] The datacenter to connect your instance to.
        :param pulumi.Input[str] lan_id: [string] The numeric LAN ID to connect your instance to.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[str]:
        """
        [string] The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [string] The datacenter to connect your instance to.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        [string] The numeric LAN ID to connect your instance to.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)


if not MYPY:
    class InMemoryDBReplicaSetCredentialsArgsDict(TypedDict):
        username: pulumi.Input[str]
        """
        [string] The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
        """
        hashed_password: NotRequired[pulumi.Input['InMemoryDBReplicaSetCredentialsHashedPasswordArgsDict']]
        """
        [object] The hashed password for a InMemoryDB user.
        """
        plain_text_password: NotRequired[pulumi.Input[str]]
        """
        [string] The password for a InMemoryDB user, this is a field that is marked as `Sensitive`.
        """
elif False:
    InMemoryDBReplicaSetCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InMemoryDBReplicaSetCredentialsArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str],
                 hashed_password: Optional[pulumi.Input['InMemoryDBReplicaSetCredentialsHashedPasswordArgs']] = None,
                 plain_text_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] username: [string] The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
        :param pulumi.Input['InMemoryDBReplicaSetCredentialsHashedPasswordArgs'] hashed_password: [object] The hashed password for a InMemoryDB user.
        :param pulumi.Input[str] plain_text_password: [string] The password for a InMemoryDB user, this is a field that is marked as `Sensitive`.
        """
        pulumi.set(__self__, "username", username)
        if hashed_password is not None:
            pulumi.set(__self__, "hashed_password", hashed_password)
        if plain_text_password is not None:
            pulumi.set(__self__, "plain_text_password", plain_text_password)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        [string] The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="hashedPassword")
    def hashed_password(self) -> Optional[pulumi.Input['InMemoryDBReplicaSetCredentialsHashedPasswordArgs']]:
        """
        [object] The hashed password for a InMemoryDB user.
        """
        return pulumi.get(self, "hashed_password")

    @hashed_password.setter
    def hashed_password(self, value: Optional[pulumi.Input['InMemoryDBReplicaSetCredentialsHashedPasswordArgs']]):
        pulumi.set(self, "hashed_password", value)

    @property
    @pulumi.getter(name="plainTextPassword")
    def plain_text_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The password for a InMemoryDB user, this is a field that is marked as `Sensitive`.
        """
        return pulumi.get(self, "plain_text_password")

    @plain_text_password.setter
    def plain_text_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plain_text_password", value)


if not MYPY:
    class InMemoryDBReplicaSetCredentialsHashedPasswordArgsDict(TypedDict):
        algorithm: pulumi.Input[str]
        """
        [string] The value can be only: "SHA-256".
        """
        hash: pulumi.Input[str]
        """
        [string] The hashed password.
        """
elif False:
    InMemoryDBReplicaSetCredentialsHashedPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InMemoryDBReplicaSetCredentialsHashedPasswordArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 hash: pulumi.Input[str]):
        """
        :param pulumi.Input[str] algorithm: [string] The value can be only: "SHA-256".
        :param pulumi.Input[str] hash: [string] The hashed password.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "hash", hash)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        [string] The value can be only: "SHA-256".
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def hash(self) -> pulumi.Input[str]:
        """
        [string] The hashed password.
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash", value)


if not MYPY:
    class InMemoryDBReplicaSetMaintenanceWindowArgsDict(TypedDict):
        day_of_the_week: pulumi.Input[str]
        """
        [string] The name of the week day.
        """
        time: pulumi.Input[str]
        """
        [string] Start of the maintenance window in UTC time.
        """
elif False:
    InMemoryDBReplicaSetMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InMemoryDBReplicaSetMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day_of_the_week: [string] The name of the week day.
        :param pulumi.Input[str] time: [string] Start of the maintenance window in UTC time.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input[str]:
        """
        [string] The name of the week day.
        """
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_the_week", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        [string] Start of the maintenance window in UTC time.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class InMemoryDBReplicaSetResourcesArgsDict(TypedDict):
        cores: pulumi.Input[int]
        """
        [int] The number of CPU cores per instance.
        """
        ram: pulumi.Input[int]
        """
        [int] The amount of memory per instance in gigabytes (GB).
        """
        storage: NotRequired[pulumi.Input[int]]
        """
        [int] The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
        """
elif False:
    InMemoryDBReplicaSetResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InMemoryDBReplicaSetResourcesArgs:
    def __init__(__self__, *,
                 cores: pulumi.Input[int],
                 ram: pulumi.Input[int],
                 storage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cores: [int] The number of CPU cores per instance.
        :param pulumi.Input[int] ram: [int] The amount of memory per instance in gigabytes (GB).
        :param pulumi.Input[int] storage: [int] The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "ram", ram)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        [int] The number of CPU cores per instance.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def ram(self) -> pulumi.Input[int]:
        """
        [int] The amount of memory per instance in gigabytes (GB).
        """
        return pulumi.get(self, "ram")

    @ram.setter
    def ram(self, value: pulumi.Input[int]):
        pulumi.set(self, "ram", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class MariaDBClusterConnectionsArgsDict(TypedDict):
        cidr: pulumi.Input[str]
        """
        [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        """
        datacenter_id: pulumi.Input[str]
        """
        [true] The datacenter to connect your cluster to.
        """
        lan_id: pulumi.Input[str]
        """
        [true] The numeric LAN ID to connect your cluster to.
        """
elif False:
    MariaDBClusterConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MariaDBClusterConnectionsArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str],
                 datacenter_id: pulumi.Input[str],
                 lan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr: [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        :param pulumi.Input[str] datacenter_id: [true] The datacenter to connect your cluster to.
        :param pulumi.Input[str] lan_id: [true] The numeric LAN ID to connect your cluster to.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[str]:
        """
        [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [true] The datacenter to connect your cluster to.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        [true] The numeric LAN ID to connect your cluster to.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)


if not MYPY:
    class MariaDBClusterCredentialsArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        [string] The password for a MariaDB user.
        """
        username: pulumi.Input[str]
        """
        [string] The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
        """
elif False:
    MariaDBClusterCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MariaDBClusterCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: [string] The password for a MariaDB user.
        :param pulumi.Input[str] username: [string] The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        [string] The password for a MariaDB user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        [string] The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class MariaDBClusterMaintenanceWindowArgsDict(TypedDict):
        day_of_the_week: pulumi.Input[str]
        """
        [string] The name of the week day.
        """
        time: pulumi.Input[str]
        """
        [string] Start of the maintenance window in UTC time.
        """
elif False:
    MariaDBClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MariaDBClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day_of_the_week: [string] The name of the week day.
        :param pulumi.Input[str] time: [string] Start of the maintenance window in UTC time.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input[str]:
        """
        [string] The name of the week day.
        """
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_the_week", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        [string] Start of the maintenance window in UTC time.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class MongoClusterBackupArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[str]]
        """
        [string] - The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.
        """
        point_in_time_window_hours: NotRequired[pulumi.Input[int]]
        """
        Number of hours in the past for which a point-in-time snapshot can be created.
        """
        snapshot_interval_hours: NotRequired[pulumi.Input[int]]
        """
        Number of hours between snapshots.
        """
elif False:
    MongoClusterBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoClusterBackupArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 point_in_time_window_hours: Optional[pulumi.Input[int]] = None,
                 snapshot_interval_hours: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] location: [string] - The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.
        :param pulumi.Input[int] point_in_time_window_hours: Number of hours in the past for which a point-in-time snapshot can be created.
        :param pulumi.Input[int] snapshot_interval_hours: Number of hours between snapshots.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if point_in_time_window_hours is not None:
            pulumi.set(__self__, "point_in_time_window_hours", point_in_time_window_hours)
        if snapshot_interval_hours is not None:
            pulumi.set(__self__, "snapshot_interval_hours", snapshot_interval_hours)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        [string] - The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="pointInTimeWindowHours")
    def point_in_time_window_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Number of hours in the past for which a point-in-time snapshot can be created.
        """
        return pulumi.get(self, "point_in_time_window_hours")

    @point_in_time_window_hours.setter
    def point_in_time_window_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "point_in_time_window_hours", value)

    @property
    @pulumi.getter(name="snapshotIntervalHours")
    def snapshot_interval_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Number of hours between snapshots.
        """
        return pulumi.get(self, "snapshot_interval_hours")

    @snapshot_interval_hours.setter
    def snapshot_interval_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshot_interval_hours", value)


if not MYPY:
    class MongoClusterBiConnectorArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        [bool] - The status of the BI Connector. If not set, the BI Connector is disabled.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        [string] - The host where this new BI Connector is installed.
        """
        port: NotRequired[pulumi.Input[str]]
        """
        [string] - Port number used when connecting to this new BI Connector.
        """
elif False:
    MongoClusterBiConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoClusterBiConnectorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: [bool] - The status of the BI Connector. If not set, the BI Connector is disabled.
        :param pulumi.Input[str] host: [string] - The host where this new BI Connector is installed.
        :param pulumi.Input[str] port: [string] - Port number used when connecting to this new BI Connector.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] - The status of the BI Connector. If not set, the BI Connector is disabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        [string] - The host where this new BI Connector is installed.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        [string] - Port number used when connecting to this new BI Connector.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class MongoClusterConnectionsArgsDict(TypedDict):
        cidr_lists: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        [List] The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Cluster Setup - Preparing the network](https://docs.ionos.com/cloud/databases/mongodb/api-howtos/create-a-cluster#preparing-the-network).
        """
        datacenter_id: pulumi.Input[str]
        """
        [string] The datacenter to connect your cluster to.
        """
        lan_id: pulumi.Input[str]
        """
        [string] The LAN to connect your cluster to.
        """
elif False:
    MongoClusterConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoClusterConnectionsArgs:
    def __init__(__self__, *,
                 cidr_lists: pulumi.Input[Sequence[pulumi.Input[str]]],
                 datacenter_id: pulumi.Input[str],
                 lan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_lists: [List] The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Cluster Setup - Preparing the network](https://docs.ionos.com/cloud/databases/mongodb/api-howtos/create-a-cluster#preparing-the-network).
        :param pulumi.Input[str] datacenter_id: [string] The datacenter to connect your cluster to.
        :param pulumi.Input[str] lan_id: [string] The LAN to connect your cluster to.
        """
        pulumi.set(__self__, "cidr_lists", cidr_lists)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        [List] The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Cluster Setup - Preparing the network](https://docs.ionos.com/cloud/databases/mongodb/api-howtos/create-a-cluster#preparing-the-network).
        """
        return pulumi.get(self, "cidr_lists")

    @cidr_lists.setter
    def cidr_lists(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cidr_lists", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [string] The datacenter to connect your cluster to.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        [string] The LAN to connect your cluster to.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)


if not MYPY:
    class MongoClusterMaintenanceWindowArgsDict(TypedDict):
        day_of_the_week: pulumi.Input[str]
        """
        [string]
        """
        time: pulumi.Input[str]
        """
        [string]
        """
elif False:
    MongoClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day_of_the_week: [string]
        :param pulumi.Input[str] time: [string]
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_the_week", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class MongoUserRoleArgsDict(TypedDict):
        database: NotRequired[pulumi.Input[str]]
        """
        [true] Database on which to apply the role.

        **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor.
        """
elif False:
    MongoUserRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoUserRoleArgs:
    def __init__(__self__, *,
                 database: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: [true] Database on which to apply the role.
               
               **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        :param pulumi.Input[str] role: [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        [true] Database on which to apply the role.

        **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class PSQLClusterConnectionPoolerArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        [bool]
        """
        pool_mode: pulumi.Input[str]
        """
        [string] Represents different modes of connection pooling for the connection pooler.
        """
elif False:
    PSQLClusterConnectionPoolerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSQLClusterConnectionPoolerArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 pool_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: [bool]
        :param pulumi.Input[str] pool_mode: [string] Represents different modes of connection pooling for the connection pooler.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "pool_mode", pool_mode)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        [bool]
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="poolMode")
    def pool_mode(self) -> pulumi.Input[str]:
        """
        [string] Represents different modes of connection pooling for the connection pooler.
        """
        return pulumi.get(self, "pool_mode")

    @pool_mode.setter
    def pool_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool_mode", value)


if not MYPY:
    class PSQLClusterConnectionsArgsDict(TypedDict):
        cidr: pulumi.Input[str]
        """
        [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        """
        datacenter_id: pulumi.Input[str]
        """
        [true] The datacenter to connect your cluster to.
        """
        lan_id: pulumi.Input[str]
        """
        [true] The LAN to connect your cluster to.
        """
elif False:
    PSQLClusterConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSQLClusterConnectionsArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str],
                 datacenter_id: pulumi.Input[str],
                 lan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr: [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        :param pulumi.Input[str] datacenter_id: [true] The datacenter to connect your cluster to.
        :param pulumi.Input[str] lan_id: [true] The LAN to connect your cluster to.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[str]:
        """
        [true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [true] The datacenter to connect your cluster to.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        [true] The LAN to connect your cluster to.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)


if not MYPY:
    class PSQLClusterCredentialsArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        [string]
        """
        username: pulumi.Input[str]
        """
        [string] The username for the initial postgres user. Some system usernames are restricted (e.g. "postgres", "admin", "standby")
        """
elif False:
    PSQLClusterCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSQLClusterCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: [string]
        :param pulumi.Input[str] username: [string] The username for the initial postgres user. Some system usernames are restricted (e.g. "postgres", "admin", "standby")
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        [string] The username for the initial postgres user. Some system usernames are restricted (e.g. "postgres", "admin", "standby")
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class PSQLClusterFromBackupArgsDict(TypedDict):
        backup_id: pulumi.Input[str]
        """
        [string] The unique ID of the backup you want to restore.
        """
        recovery_target_time: NotRequired[pulumi.Input[str]]
        """
        [string] If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
        """
elif False:
    PSQLClusterFromBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSQLClusterFromBackupArgs:
    def __init__(__self__, *,
                 backup_id: pulumi.Input[str],
                 recovery_target_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_id: [string] The unique ID of the backup you want to restore.
        :param pulumi.Input[str] recovery_target_time: [string] If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> pulumi.Input[str]:
        """
        [string] The unique ID of the backup you want to restore.
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[pulumi.Input[str]]:
        """
        [string] If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
        """
        return pulumi.get(self, "recovery_target_time")

    @recovery_target_time.setter
    def recovery_target_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_target_time", value)


if not MYPY:
    class PSQLClusterMaintenanceWindowArgsDict(TypedDict):
        day_of_the_week: pulumi.Input[str]
        """
        [string]
        """
        time: pulumi.Input[str]
        """
        [string]
        """
elif False:
    PSQLClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSQLClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day_of_the_week: [string]
        :param pulumi.Input[str] time: [string]
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_the_week", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class GetMongoUserRoleArgsDict(TypedDict):
        database: str
        """
        [true] Database on which to apply the role.

        **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        """
        role: str
        """
        [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor and enableSharding.
        """
elif False:
    GetMongoUserRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMongoUserRoleArgs:
    def __init__(__self__, *,
                 database: str,
                 role: str):
        """
        :param str database: [true] Database on which to apply the role.
               
               **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        :param str role: [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor and enableSharding.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        [true] Database on which to apply the role.

        **NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: str):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        [true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor and enableSharding.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)


