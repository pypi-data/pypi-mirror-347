# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CrossconnectConnectableDatacenterArgs',
    'CrossconnectConnectableDatacenterArgsDict',
    'CrossconnectPeerArgs',
    'CrossconnectPeerArgsDict',
    'CubeServerNicArgs',
    'CubeServerNicArgsDict',
    'CubeServerNicFirewallArgs',
    'CubeServerNicFirewallArgsDict',
    'CubeServerVolumeArgs',
    'CubeServerVolumeArgsDict',
    'DatacenterCpuArchitectureArgs',
    'DatacenterCpuArchitectureArgsDict',
    'GroupUserArgs',
    'GroupUserArgsDict',
    'IPBlockIpConsumerArgs',
    'IPBlockIpConsumerArgsDict',
    'LanIpFailoverArgs',
    'LanIpFailoverArgsDict',
    'NatGatewayLanArgs',
    'NatGatewayLanArgsDict',
    'NatGatewayRuleTargetPortRangeArgs',
    'NatGatewayRuleTargetPortRangeArgsDict',
    'NicFlowlogArgs',
    'NicFlowlogArgsDict',
    'ServerLabelArgs',
    'ServerLabelArgsDict',
    'ServerNicArgs',
    'ServerNicArgsDict',
    'ServerNicFirewallArgs',
    'ServerNicFirewallArgsDict',
    'ServerVolumeArgs',
    'ServerVolumeArgsDict',
    'TargetGroupHealthCheckArgs',
    'TargetGroupHealthCheckArgsDict',
    'TargetGroupHttpHealthCheckArgs',
    'TargetGroupHttpHealthCheckArgsDict',
    'TargetGroupTargetArgs',
    'TargetGroupTargetArgsDict',
    'VCPUServerLabelArgs',
    'VCPUServerLabelArgsDict',
    'VCPUServerNicArgs',
    'VCPUServerNicArgsDict',
    'VCPUServerNicFirewallArgs',
    'VCPUServerNicFirewallArgsDict',
    'VCPUServerVolumeArgs',
    'VCPUServerVolumeArgsDict',
    'GetServersFilterArgs',
    'GetServersFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CrossconnectConnectableDatacenterArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The UUID of the connectable datacenter
        """
        location: NotRequired[pulumi.Input[str]]
        """
        The physical location of the connectable datacenter
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the cross-connection.
        """
elif False:
    CrossconnectConnectableDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrossconnectConnectableDatacenterArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The UUID of the connectable datacenter
        :param pulumi.Input[str] location: The physical location of the connectable datacenter
        :param pulumi.Input[str] name: [string] The name of the cross-connection.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the connectable datacenter
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The physical location of the connectable datacenter
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the cross-connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CrossconnectPeerArgsDict(TypedDict):
        datacenter_id: NotRequired[pulumi.Input[str]]
        """
        The id of the cross-connected datacenter
        """
        datacenter_name: NotRequired[pulumi.Input[str]]
        """
        The name of the cross-connected datacenter
        """
        lan_id: NotRequired[pulumi.Input[str]]
        """
        The id of the cross-connected LAN
        """
        lan_name: NotRequired[pulumi.Input[str]]
        """
        The name of the cross-connected LAN
        """
        location: NotRequired[pulumi.Input[str]]
        """
        The location of the cross-connected datacenter
        """
elif False:
    CrossconnectPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrossconnectPeerArgs:
    def __init__(__self__, *,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 datacenter_name: Optional[pulumi.Input[str]] = None,
                 lan_id: Optional[pulumi.Input[str]] = None,
                 lan_name: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datacenter_id: The id of the cross-connected datacenter
        :param pulumi.Input[str] datacenter_name: The name of the cross-connected datacenter
        :param pulumi.Input[str] lan_id: The id of the cross-connected LAN
        :param pulumi.Input[str] lan_name: The name of the cross-connected LAN
        :param pulumi.Input[str] location: The location of the cross-connected datacenter
        """
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if lan_id is not None:
            pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_name")

    @datacenter_name.setter
    def datacenter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_name", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the cross-connected LAN
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lan_id", value)

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the cross-connected LAN
        """
        return pulumi.get(self, "lan_name")

    @lan_name.setter
    def lan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lan_name", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the cross-connected datacenter
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)


if not MYPY:
    class CubeServerNicArgsDict(TypedDict):
        lan: pulumi.Input[int]
        device_number: NotRequired[pulumi.Input[int]]
        dhcp: NotRequired[pulumi.Input[bool]]
        dhcpv6: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        firewall: NotRequired[pulumi.Input['CubeServerNicFirewallArgsDict']]
        firewall_active: NotRequired[pulumi.Input[bool]]
        firewall_type: NotRequired[pulumi.Input[str]]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        """
        IPv6 CIDR block assigned to the NIC.
        """
        ipv6_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        mac: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        pci_slot: NotRequired[pulumi.Input[int]]
        security_groups_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Security Group IDs for the resource.
        """
elif False:
    CubeServerNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CubeServerNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 device_number: Optional[pulumi.Input[int]] = None,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 dhcpv6: Optional[pulumi.Input[bool]] = None,
                 firewall: Optional[pulumi.Input['CubeServerNicFirewallArgs']] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 ipv6_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 security_groups_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param pulumi.Input[str] ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups_ids: The list of Security Group IDs for the resource.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall is not None:
            pulumi.set(__self__, "firewall", firewall)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @dhcpv6.setter
    def dhcpv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcpv6", value)

    @property
    @pulumi.getter
    def firewall(self) -> Optional[pulumi.Input['CubeServerNicFirewallArgs']]:
        return pulumi.get(self, "firewall")

    @firewall.setter
    def firewall(self, value: Optional[pulumi.Input['CubeServerNicFirewallArgs']]):
        pulumi.set(self, "firewall", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @ipv6_ips.setter
    def ipv6_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_ips", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Security Group IDs for the resource.
        """
        return pulumi.get(self, "security_groups_ids")

    @security_groups_ids.setter
    def security_groups_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups_ids", value)


if not MYPY:
    class CubeServerNicFirewallArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        icmp_code: NotRequired[pulumi.Input[str]]
        icmp_type: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        port_range_end: NotRequired[pulumi.Input[int]]
        port_range_start: NotRequired[pulumi.Input[int]]
        source_ip: NotRequired[pulumi.Input[str]]
        source_mac: NotRequired[pulumi.Input[str]]
        target_ip: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    CubeServerNicFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CubeServerNicFirewallArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[str]] = None,
                 icmp_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The name of the server.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CubeServerVolumeArgsDict(TypedDict):
        disk_type: pulumi.Input[str]
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        [string] The availability zone in which the server should exist. This property is immutable.
        """
        backup_unit_id: NotRequired[pulumi.Input[str]]
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        boot_server: NotRequired[pulumi.Input[str]]
        """
        The UUID of the attached server.
        """
        bus: NotRequired[pulumi.Input[str]]
        cpu_hot_plug: NotRequired[pulumi.Input[bool]]
        device_number: NotRequired[pulumi.Input[int]]
        disc_virtio_hot_plug: NotRequired[pulumi.Input[bool]]
        disc_virtio_hot_unplug: NotRequired[pulumi.Input[bool]]
        image_password: NotRequired[pulumi.Input[str]]
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        licence_type: NotRequired[pulumi.Input[str]]
        """
        [string] Sets the OS type of the server.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        nic_hot_plug: NotRequired[pulumi.Input[bool]]
        nic_hot_unplug: NotRequired[pulumi.Input[bool]]
        pci_slot: NotRequired[pulumi.Input[int]]
        ram_hot_plug: NotRequired[pulumi.Input[bool]]
        ssh_key_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
elif False:
    CubeServerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CubeServerVolumeArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[str],
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 boot_server: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 cpu_hot_plug: Optional[pulumi.Input[bool]] = None,
                 device_number: Optional[pulumi.Input[int]] = None,
                 disc_virtio_hot_plug: Optional[pulumi.Input[bool]] = None,
                 disc_virtio_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 image_password: Optional[pulumi.Input[str]] = None,
                 licence_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nic_hot_plug: Optional[pulumi.Input[bool]] = None,
                 nic_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 ram_hot_plug: Optional[pulumi.Input[bool]] = None,
                 ssh_key_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The availability zone in which the server should exist. This property is immutable.
        :param pulumi.Input[str] backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param pulumi.Input[str] boot_server: The UUID of the attached server.
        :param pulumi.Input[str] image_password: [string] Required if `ssh_key_path` is not provided.
        :param pulumi.Input[str] licence_type: [string] Sets the OS type of the server.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_key_paths: [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.
        :param pulumi.Input[str] user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            warnings.warn("""Please use image_password under server level""", DeprecationWarning)
            pulumi.log.warn("""image_password is deprecated: Please use image_password under server level""")
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if ssh_key_paths is not None:
            warnings.warn("""Please use ssh_key_path under server level""", DeprecationWarning)
            pulumi.log.warn("""ssh_key_paths is deprecated: Please use ssh_key_path under server level""")
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The availability zone in which the server should exist. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @boot_server.setter
    def boot_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_server", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cpu_hot_plug")

    @cpu_hot_plug.setter
    def cpu_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_hot_plug", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @disc_virtio_hot_plug.setter
    def disc_virtio_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_plug", value)

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @disc_virtio_hot_unplug.setter
    def disc_virtio_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_unplug", value)

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @image_password.setter
    def image_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_password", value)

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @licence_type.setter
    def licence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "licence_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_plug")

    @nic_hot_plug.setter
    def nic_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_plug", value)

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_unplug")

    @nic_hot_unplug.setter
    def nic_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_unplug", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ram_hot_plug")

    @ram_hot_plug.setter
    def ram_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ram_hot_plug", value)

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.
        """
        return pulumi.get(self, "ssh_key_paths")

    @ssh_key_paths.setter
    def ssh_key_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_key_paths", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class DatacenterCpuArchitectureArgsDict(TypedDict):
        cpu_family: NotRequired[pulumi.Input[str]]
        """
        A valid CPU family name
        """
        max_cores: NotRequired[pulumi.Input[int]]
        """
        The maximum number of cores available
        """
        max_ram: NotRequired[pulumi.Input[int]]
        """
        The maximum number of RAM in MB
        """
        vendor: NotRequired[pulumi.Input[str]]
        """
        A valid CPU vendor name
        """
elif False:
    DatacenterCpuArchitectureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatacenterCpuArchitectureArgs:
    def __init__(__self__, *,
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 max_cores: Optional[pulumi.Input[int]] = None,
                 max_ram: Optional[pulumi.Input[int]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_family: A valid CPU family name
        :param pulumi.Input[int] max_cores: The maximum number of cores available
        :param pulumi.Input[int] max_ram: The maximum number of RAM in MB
        :param pulumi.Input[str] vendor: A valid CPU vendor name
        """
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if max_ram is not None:
            pulumi.set(__self__, "max_ram", max_ram)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CPU family name
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of cores available
        """
        return pulumi.get(self, "max_cores")

    @max_cores.setter
    def max_cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_cores", value)

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of RAM in MB
        """
        return pulumi.get(self, "max_ram")

    @max_ram.setter
    def max_ram(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ram", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CPU vendor name
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class GroupUserArgsDict(TypedDict):
        administrator: NotRequired[pulumi.Input[bool]]
        email: NotRequired[pulumi.Input[str]]
        first_name: NotRequired[pulumi.Input[str]]
        force_sec_auth: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        last_name: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input[str]]
elif False:
    GroupUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupUserArgs:
    def __init__(__self__, *,
                 administrator: Optional[pulumi.Input[bool]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 force_sec_auth: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        if administrator is not None:
            pulumi.set(__self__, "administrator", administrator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if force_sec_auth is not None:
            pulumi.set(__self__, "force_sec_auth", force_sec_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def administrator(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "administrator")

    @administrator.setter
    def administrator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "administrator", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="forceSecAuth")
    def force_sec_auth(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force_sec_auth")

    @force_sec_auth.setter
    def force_sec_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_sec_auth", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class IPBlockIpConsumerArgsDict(TypedDict):
        datacenter_id: NotRequired[pulumi.Input[str]]
        datacenter_name: NotRequired[pulumi.Input[str]]
        ip: NotRequired[pulumi.Input[str]]
        k8s_cluster_uuid: NotRequired[pulumi.Input[str]]
        k8s_nodepool_uuid: NotRequired[pulumi.Input[str]]
        mac: NotRequired[pulumi.Input[str]]
        nic_id: NotRequired[pulumi.Input[str]]
        server_id: NotRequired[pulumi.Input[str]]
        server_name: NotRequired[pulumi.Input[str]]
elif False:
    IPBlockIpConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPBlockIpConsumerArgs:
    def __init__(__self__, *,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 datacenter_name: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 k8s_cluster_uuid: Optional[pulumi.Input[str]] = None,
                 k8s_nodepool_uuid: Optional[pulumi.Input[str]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 nic_id: Optional[pulumi.Input[str]] = None,
                 server_id: Optional[pulumi.Input[str]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if k8s_cluster_uuid is not None:
            pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        if k8s_nodepool_uuid is not None:
            pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datacenter_name")

    @datacenter_name.setter
    def datacenter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_name", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "k8s_cluster_uuid")

    @k8s_cluster_uuid.setter
    def k8s_cluster_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_cluster_uuid", value)

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @k8s_nodepool_uuid.setter
    def k8s_nodepool_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_nodepool_uuid", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_id", value)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_id", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class LanIpFailoverArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        nic_uuid: NotRequired[pulumi.Input[str]]
elif False:
    LanIpFailoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LanIpFailoverArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 nic_uuid: Optional[pulumi.Input[str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if nic_uuid is not None:
            pulumi.set(__self__, "nic_uuid", nic_uuid)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="nicUuid")
    def nic_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_uuid")

    @nic_uuid.setter
    def nic_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_uuid", value)


if not MYPY:
    class NatGatewayLanArgsDict(TypedDict):
        id: pulumi.Input[int]
        """
        [int] Id for the LAN connected to the NAT gateway.
        """
        gateway_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
        """
elif False:
    NatGatewayLanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatGatewayLanArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[int],
                 gateway_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] id: [int] Id for the LAN connected to the NAT gateway.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateway_ips: [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
        """
        pulumi.set(__self__, "id", id)
        if gateway_ips is not None:
            pulumi.set(__self__, "gateway_ips", gateway_ips)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[int]:
        """
        [int] Id for the LAN connected to the NAT gateway.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="gatewayIps")
    def gateway_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
        """
        return pulumi.get(self, "gateway_ips")

    @gateway_ips.setter
    def gateway_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_ips", value)


if not MYPY:
    class NatGatewayRuleTargetPortRangeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[int]]
        """
        [int] Target port range end associated with the NAT gateway rule.
        """
        start: NotRequired[pulumi.Input[int]]
        """
        [int] Target port range start associated with the NAT gateway rule.
        """
elif False:
    NatGatewayRuleTargetPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatGatewayRuleTargetPortRangeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[int]] = None,
                 start: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end: [int] Target port range end associated with the NAT gateway rule.
        :param pulumi.Input[int] start: [int] Target port range start associated with the NAT gateway rule.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Target port range end associated with the NAT gateway rule.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Target port range start associated with the NAT gateway rule.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class NicFlowlogArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        bucket: pulumi.Input[str]
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        direction: pulumi.Input[str]
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        name: pulumi.Input[str]
        """
        Specifies the name of the flow log.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the NIC.
        """
elif False:
    NicFlowlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicFlowlogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        :param pulumi.Input[str] bucket: Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        :param pulumi.Input[str] direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        :param pulumi.Input[str] name: Specifies the name of the flow log.
        :param pulumi.Input[str] id: The ID of the NIC.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the flow log.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the NIC.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ServerLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        [string] The key of the label.
        """
        value: pulumi.Input[str]
        """
        [string] The value of the label.
        """
elif False:
    ServerLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: [string] The key of the label.
        :param pulumi.Input[str] value: [string] The value of the label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        [string] The key of the label.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        [string] The value of the label.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServerNicArgsDict(TypedDict):
        lan: pulumi.Input[int]
        device_number: NotRequired[pulumi.Input[int]]
        dhcp: NotRequired[pulumi.Input[bool]]
        dhcpv6: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        firewall_active: NotRequired[pulumi.Input[bool]]
        firewall_type: NotRequired[pulumi.Input[str]]
        firewalls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgsDict']]]]
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        id: NotRequired[pulumi.Input[str]]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        """
        IPv6 CIDR block assigned to the NIC.
        """
        ipv6_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        mac: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        pci_slot: NotRequired[pulumi.Input[int]]
        security_groups_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Security Group IDs for the
        """
elif False:
    ServerNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 device_number: Optional[pulumi.Input[int]] = None,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 dhcpv6: Optional[pulumi.Input[bool]] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 firewalls: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 ipv6_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 security_groups_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param pulumi.Input[str] ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups_ids: The list of Security Group IDs for the
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @dhcpv6.setter
    def dhcpv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcpv6", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @firewalls.setter
    def firewalls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]]):
        pulumi.set(self, "firewalls", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @ipv6_ips.setter
    def ipv6_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_ips", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Security Group IDs for the
        """
        return pulumi.get(self, "security_groups_ids")

    @security_groups_ids.setter
    def security_groups_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups_ids", value)


if not MYPY:
    class ServerNicFirewallArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        icmp_code: NotRequired[pulumi.Input[str]]
        icmp_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        port_range_end: NotRequired[pulumi.Input[int]]
        port_range_start: NotRequired[pulumi.Input[int]]
        source_ip: NotRequired[pulumi.Input[str]]
        source_mac: NotRequired[pulumi.Input[str]]
        target_ip: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
elif False:
    ServerNicFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNicFirewallArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[str]] = None,
                 icmp_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[str] type: (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerVolumeArgsDict(TypedDict):
        disk_type: pulumi.Input[str]
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        backup_unit_id: NotRequired[pulumi.Input[str]]
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        boot_server: NotRequired[pulumi.Input[str]]
        """
        The UUID of the attached server.
        """
        bus: NotRequired[pulumi.Input[str]]
        cpu_hot_plug: NotRequired[pulumi.Input[bool]]
        device_number: NotRequired[pulumi.Input[int]]
        disc_virtio_hot_plug: NotRequired[pulumi.Input[bool]]
        disc_virtio_hot_unplug: NotRequired[pulumi.Input[bool]]
        image_password: NotRequired[pulumi.Input[str]]
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        licence_type: NotRequired[pulumi.Input[str]]
        """
        [string] Sets the OS type of the server.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        nic_hot_plug: NotRequired[pulumi.Input[bool]]
        nic_hot_unplug: NotRequired[pulumi.Input[bool]]
        pci_slot: NotRequired[pulumi.Input[int]]
        ram_hot_plug: NotRequired[pulumi.Input[bool]]
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the volume in GB.
        """
        ssh_key_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
elif False:
    ServerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerVolumeArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[str],
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 boot_server: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 cpu_hot_plug: Optional[pulumi.Input[bool]] = None,
                 device_number: Optional[pulumi.Input[int]] = None,
                 disc_virtio_hot_plug: Optional[pulumi.Input[bool]] = None,
                 disc_virtio_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 image_password: Optional[pulumi.Input[str]] = None,
                 licence_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nic_hot_plug: Optional[pulumi.Input[bool]] = None,
                 nic_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 ram_hot_plug: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 ssh_key_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param pulumi.Input[str] backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param pulumi.Input[str] boot_server: The UUID of the attached server.
        :param pulumi.Input[str] image_password: [string] Required if `ssh_key_path` is not provided.
        :param pulumi.Input[str] licence_type: [string] Sets the OS type of the server.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[int] size: The size of the volume in GB.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_key_paths: [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_keys: [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        :param pulumi.Input[str] user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            warnings.warn("""Please use image_password under server level""", DeprecationWarning)
            pulumi.log.warn("""image_password is deprecated: Please use image_password under server level""")
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_paths is not None:
            warnings.warn("""Please use ssh_key_path under server level""", DeprecationWarning)
            pulumi.log.warn("""ssh_key_paths is deprecated: Please use ssh_key_path under server level""")
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if ssh_keys is not None:
            warnings.warn("""Please use ssh_keys under server level""", DeprecationWarning)
            pulumi.log.warn("""ssh_keys is deprecated: Please use ssh_keys under server level""")
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @boot_server.setter
    def boot_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_server", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cpu_hot_plug")

    @cpu_hot_plug.setter
    def cpu_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_hot_plug", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @disc_virtio_hot_plug.setter
    def disc_virtio_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_plug", value)

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @disc_virtio_hot_unplug.setter
    def disc_virtio_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_unplug", value)

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @image_password.setter
    def image_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_password", value)

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @licence_type.setter
    def licence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "licence_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_plug")

    @nic_hot_plug.setter
    def nic_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_plug", value)

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_unplug")

    @nic_hot_unplug.setter
    def nic_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_unplug", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ram_hot_plug")

    @ram_hot_plug.setter
    def ram_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ram_hot_plug", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        return pulumi.get(self, "ssh_key_paths")

    @ssh_key_paths.setter
    def ssh_key_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_key_paths", value)

    @property
    @pulumi.getter(name="sshKeys")
    @_utilities.deprecated("""Please use ssh_keys under server level""")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_keys", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class TargetGroupHealthCheckArgsDict(TypedDict):
        check_interval: NotRequired[pulumi.Input[int]]
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        check_timeout: NotRequired[pulumi.Input[int]]
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
elif False:
    TargetGroupHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: Optional[pulumi.Input[int]] = None,
                 check_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] check_interval: [int] The interval in milliseconds between consecutive health checks; default is 2000.
        :param pulumi.Input[int] check_timeout: [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param pulumi.Input[int] retries: [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval", value)

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @check_timeout.setter
    def check_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


if not MYPY:
    class TargetGroupHttpHealthCheckArgsDict(TypedDict):
        match_type: pulumi.Input[str]
        """
        [string]
        """
        response: pulumi.Input[str]
        """
        [string] The response returned by the request, depending on the match type.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        [string] The method for the HTTP health check.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        [bool]
        """
        path: NotRequired[pulumi.Input[str]]
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        regex: NotRequired[pulumi.Input[bool]]
        """
        [bool]
        """
elif False:
    TargetGroupHttpHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupHttpHealthCheckArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[str],
                 response: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] match_type: [string]
        :param pulumi.Input[str] response: [string] The response returned by the request, depending on the match type.
        :param pulumi.Input[str] method: [string] The method for the HTTP health check.
        :param pulumi.Input[bool] negate: [bool]
        :param pulumi.Input[str] path: [string] The path (destination URL) for the HTTP health check request; the default is /.
        :param pulumi.Input[bool] regex: [bool]
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter
    def response(self) -> pulumi.Input[str]:
        """
        [string] The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: pulumi.Input[str]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class TargetGroupTargetArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        [string] The IP of the balanced target VM.
        """
        port: pulumi.Input[int]
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        weight: pulumi.Input[int]
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        health_check_enabled: NotRequired[pulumi.Input[bool]]
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        maintenance_enabled: NotRequired[pulumi.Input[bool]]
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        proxy_protocol: NotRequired[pulumi.Input[str]]
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
elif False:
    TargetGroupTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupTargetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 health_check_enabled: Optional[pulumi.Input[bool]] = None,
                 maintenance_enabled: Optional[pulumi.Input[bool]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: [string] The IP of the balanced target VM.
        :param pulumi.Input[int] port: [int] The port of the balanced target service; valid range is 1 to 65535.
        :param pulumi.Input[int] weight: [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param pulumi.Input[bool] health_check_enabled: [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param pulumi.Input[bool] maintenance_enabled: [bool] Maintenance mode prevents the target from receiving balanced traffic.
        :param pulumi.Input[str] proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        [string] The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @health_check_enabled.setter
    def health_check_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_enabled", value)

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @maintenance_enabled.setter
    def maintenance_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maintenance_enabled", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)


if not MYPY:
    class VCPUServerLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    VCPUServerLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VCPUServerLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VCPUServerNicArgsDict(TypedDict):
        lan: pulumi.Input[int]
        device_number: NotRequired[pulumi.Input[int]]
        dhcp: NotRequired[pulumi.Input[bool]]
        dhcpv6: NotRequired[pulumi.Input[bool]]
        firewall_active: NotRequired[pulumi.Input[bool]]
        firewall_type: NotRequired[pulumi.Input[str]]
        firewalls: NotRequired[pulumi.Input[Sequence[pulumi.Input['VCPUServerNicFirewallArgsDict']]]]
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        id: NotRequired[pulumi.Input[str]]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        ipv6_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        mac: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        pci_slot: NotRequired[pulumi.Input[int]]
        security_groups_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Security Group IDs for the resource.

        > ** WARNING**
        >
        > ssh_keys field is immutable.
        """
elif False:
    VCPUServerNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VCPUServerNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 device_number: Optional[pulumi.Input[int]] = None,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 dhcpv6: Optional[pulumi.Input[bool]] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 firewalls: Optional[pulumi.Input[Sequence[pulumi.Input['VCPUServerNicFirewallArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 ipv6_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 security_groups_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VCPUServerNicFirewallArgs']]] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups_ids: The list of Security Group IDs for the resource.
               
               > ** WARNING**
               >
               > ssh_keys field is immutable.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dhcpv6")

    @dhcpv6.setter
    def dhcpv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcpv6", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VCPUServerNicFirewallArgs']]]]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @firewalls.setter
    def firewalls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VCPUServerNicFirewallArgs']]]]):
        pulumi.set(self, "firewalls", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ipv6_ips")

    @ipv6_ips.setter
    def ipv6_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_ips", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Security Group IDs for the resource.

        > ** WARNING**
        >
        > ssh_keys field is immutable.
        """
        return pulumi.get(self, "security_groups_ids")

    @security_groups_ids.setter
    def security_groups_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups_ids", value)


if not MYPY:
    class VCPUServerNicFirewallArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        icmp_code: NotRequired[pulumi.Input[str]]
        icmp_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        port_range_end: NotRequired[pulumi.Input[int]]
        port_range_start: NotRequired[pulumi.Input[int]]
        source_ip: NotRequired[pulumi.Input[str]]
        source_mac: NotRequired[pulumi.Input[str]]
        target_ip: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    VCPUServerNicFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VCPUServerNicFirewallArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[str]] = None,
                 icmp_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The name of the server.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VCPUServerVolumeArgsDict(TypedDict):
        disk_type: pulumi.Input[str]
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        backup_unit_id: NotRequired[pulumi.Input[str]]
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        boot_server: NotRequired[pulumi.Input[str]]
        """
        The UUID of the attached server.
        """
        bus: NotRequired[pulumi.Input[str]]
        cpu_hot_plug: NotRequired[pulumi.Input[bool]]
        device_number: NotRequired[pulumi.Input[int]]
        disc_virtio_hot_plug: NotRequired[pulumi.Input[bool]]
        disc_virtio_hot_unplug: NotRequired[pulumi.Input[bool]]
        licence_type: NotRequired[pulumi.Input[str]]
        """
        [string] Sets the OS type of the server.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        nic_hot_plug: NotRequired[pulumi.Input[bool]]
        nic_hot_unplug: NotRequired[pulumi.Input[bool]]
        pci_slot: NotRequired[pulumi.Input[int]]
        ram_hot_plug: NotRequired[pulumi.Input[bool]]
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the volume in GB.
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
elif False:
    VCPUServerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VCPUServerVolumeArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[str],
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 boot_server: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 cpu_hot_plug: Optional[pulumi.Input[bool]] = None,
                 device_number: Optional[pulumi.Input[int]] = None,
                 disc_virtio_hot_plug: Optional[pulumi.Input[bool]] = None,
                 disc_virtio_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 licence_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nic_hot_plug: Optional[pulumi.Input[bool]] = None,
                 nic_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 ram_hot_plug: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param pulumi.Input[str] backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param pulumi.Input[str] boot_server: The UUID of the attached server.
        :param pulumi.Input[str] licence_type: [string] Sets the OS type of the server.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[int] size: The size of the volume in GB.
        :param pulumi.Input[str] user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @boot_server.setter
    def boot_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_server", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cpu_hot_plug")

    @cpu_hot_plug.setter
    def cpu_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_hot_plug", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @disc_virtio_hot_plug.setter
    def disc_virtio_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_plug", value)

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @disc_virtio_hot_unplug.setter
    def disc_virtio_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_unplug", value)

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @licence_type.setter
    def licence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "licence_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_plug")

    @nic_hot_plug.setter
    def nic_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_plug", value)

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_unplug")

    @nic_hot_unplug.setter
    def nic_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_unplug", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ram_hot_plug")

    @ram_hot_plug.setter
    def ram_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ram_hot_plug", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class GetServersFilterArgsDict(TypedDict):
        name: str
        value: str
elif False:
    GetServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


