# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DistributionRoutingRuleArgs',
    'DistributionRoutingRuleArgsDict',
    'DistributionRoutingRuleUpstreamArgs',
    'DistributionRoutingRuleUpstreamArgsDict',
    'DistributionRoutingRuleUpstreamGeoRestrictionsArgs',
    'DistributionRoutingRuleUpstreamGeoRestrictionsArgsDict',
]

MYPY = False

if not MYPY:
    class DistributionRoutingRuleArgsDict(TypedDict):
        prefix: pulumi.Input[str]
        """
        [string] The prefix of the routing rule.
        """
        scheme: pulumi.Input[str]
        """
        [string] The scheme of the routing rule.
        """
        upstream: pulumi.Input['DistributionRoutingRuleUpstreamArgsDict']
        """
        [map] - A map of properties for the rule
        """
elif False:
    DistributionRoutingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionRoutingRuleArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str],
                 scheme: pulumi.Input[str],
                 upstream: pulumi.Input['DistributionRoutingRuleUpstreamArgs']):
        """
        :param pulumi.Input[str] prefix: [string] The prefix of the routing rule.
        :param pulumi.Input[str] scheme: [string] The scheme of the routing rule.
        :param pulumi.Input['DistributionRoutingRuleUpstreamArgs'] upstream: [map] - A map of properties for the rule
        """
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "upstream", upstream)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        [string] The prefix of the routing rule.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        [string] The scheme of the routing rule.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def upstream(self) -> pulumi.Input['DistributionRoutingRuleUpstreamArgs']:
        """
        [map] - A map of properties for the rule
        """
        return pulumi.get(self, "upstream")

    @upstream.setter
    def upstream(self, value: pulumi.Input['DistributionRoutingRuleUpstreamArgs']):
        pulumi.set(self, "upstream", value)


if not MYPY:
    class DistributionRoutingRuleUpstreamArgsDict(TypedDict):
        caching: pulumi.Input[bool]
        """
        [bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
        """
        host: pulumi.Input[str]
        """
        [string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
        """
        rate_limit_class: pulumi.Input[str]
        """
        [string] Rate limit class that will be applied to limit the number of incoming requests per IP.
        """
        sni_mode: pulumi.Input[str]
        """
        [string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
        """
        waf: pulumi.Input[bool]
        """
        [bool] Enable or disable WAF to protect the upstream host.
        """
        geo_restrictions: NotRequired[pulumi.Input['DistributionRoutingRuleUpstreamGeoRestrictionsArgsDict']]
        """
        [map] - A map of geo_restrictions
        """
elif False:
    DistributionRoutingRuleUpstreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionRoutingRuleUpstreamArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[bool],
                 host: pulumi.Input[str],
                 rate_limit_class: pulumi.Input[str],
                 sni_mode: pulumi.Input[str],
                 waf: pulumi.Input[bool],
                 geo_restrictions: Optional[pulumi.Input['DistributionRoutingRuleUpstreamGeoRestrictionsArgs']] = None):
        """
        :param pulumi.Input[bool] caching: [bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
        :param pulumi.Input[str] host: [string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
        :param pulumi.Input[str] rate_limit_class: [string] Rate limit class that will be applied to limit the number of incoming requests per IP.
        :param pulumi.Input[str] sni_mode: [string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
        :param pulumi.Input[bool] waf: [bool] Enable or disable WAF to protect the upstream host.
        :param pulumi.Input['DistributionRoutingRuleUpstreamGeoRestrictionsArgs'] geo_restrictions: [map] - A map of geo_restrictions
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "rate_limit_class", rate_limit_class)
        pulumi.set(__self__, "sni_mode", sni_mode)
        pulumi.set(__self__, "waf", waf)
        if geo_restrictions is not None:
            pulumi.set(__self__, "geo_restrictions", geo_restrictions)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[bool]:
        """
        [bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[bool]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        [string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="rateLimitClass")
    def rate_limit_class(self) -> pulumi.Input[str]:
        """
        [string] Rate limit class that will be applied to limit the number of incoming requests per IP.
        """
        return pulumi.get(self, "rate_limit_class")

    @rate_limit_class.setter
    def rate_limit_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "rate_limit_class", value)

    @property
    @pulumi.getter(name="sniMode")
    def sni_mode(self) -> pulumi.Input[str]:
        """
        [string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
        """
        return pulumi.get(self, "sni_mode")

    @sni_mode.setter
    def sni_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "sni_mode", value)

    @property
    @pulumi.getter
    def waf(self) -> pulumi.Input[bool]:
        """
        [bool] Enable or disable WAF to protect the upstream host.
        """
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: pulumi.Input[bool]):
        pulumi.set(self, "waf", value)

    @property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Optional[pulumi.Input['DistributionRoutingRuleUpstreamGeoRestrictionsArgs']]:
        """
        [map] - A map of geo_restrictions
        """
        return pulumi.get(self, "geo_restrictions")

    @geo_restrictions.setter
    def geo_restrictions(self, value: Optional[pulumi.Input['DistributionRoutingRuleUpstreamGeoRestrictionsArgs']]):
        pulumi.set(self, "geo_restrictions", value)


if not MYPY:
    class DistributionRoutingRuleUpstreamGeoRestrictionsArgsDict(TypedDict):
        allow_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [string] List of allowed countries
        """
        block_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [string] List of blocked countries
        """
elif False:
    DistributionRoutingRuleUpstreamGeoRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionRoutingRuleUpstreamGeoRestrictionsArgs:
    def __init__(__self__, *,
                 allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_lists: [string] List of allowed countries
        :param pulumi.Input[Sequence[pulumi.Input[str]]] block_lists: [string] List of blocked countries
        """
        if allow_lists is not None:
            pulumi.set(__self__, "allow_lists", allow_lists)
        if block_lists is not None:
            pulumi.set(__self__, "block_lists", block_lists)

    @property
    @pulumi.getter(name="allowLists")
    def allow_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [string] List of allowed countries
        """
        return pulumi.get(self, "allow_lists")

    @allow_lists.setter
    def allow_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_lists", value)

    @property
    @pulumi.getter(name="blockLists")
    def block_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [string] List of blocked countries
        """
        return pulumi.get(self, "block_lists")

    @block_lists.setter
    def block_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "block_lists", value)


