# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CrossconnectConnectableDatacenter',
    'CrossconnectPeer',
    'CubeServerNic',
    'CubeServerNicFirewall',
    'CubeServerVolume',
    'DatacenterCpuArchitecture',
    'GroupUser',
    'IPBlockIpConsumer',
    'LanIpFailover',
    'NatGatewayLan',
    'NatGatewayRuleTargetPortRange',
    'NicFlowlog',
    'ServerLabel',
    'ServerNic',
    'ServerNicFirewall',
    'ServerVolume',
    'TargetGroupHealthCheck',
    'TargetGroupHttpHealthCheck',
    'TargetGroupTarget',
    'VCPUServerLabel',
    'VCPUServerNic',
    'VCPUServerNicFirewall',
    'VCPUServerVolume',
    'GetCrossconnectConnectableDatacenterResult',
    'GetCrossconnectPeerResult',
    'GetCubeServerCdromResult',
    'GetCubeServerNicResult',
    'GetCubeServerNicFirewallRuleResult',
    'GetCubeServerVolumeResult',
    'GetDatacenterCpuArchitectureResult',
    'GetGroupUserResult',
    'GetIPBlockIpConsumerResult',
    'GetLanIpFailoverResult',
    'GetLocationCpuArchitectureResult',
    'GetNatGatewayLanResult',
    'GetNatGatewayRuleTargetPortRangeResult',
    'GetNicFlowlogResult',
    'GetServerCdromResult',
    'GetServerLabelResult',
    'GetServerNicResult',
    'GetServerNicFirewallRuleResult',
    'GetServerVolumeResult',
    'GetServersFilterResult',
    'GetServersServerResult',
    'GetServersServerCdromResult',
    'GetServersServerLabelResult',
    'GetServersServerNicResult',
    'GetServersServerNicFirewallRuleResult',
    'GetServersServerVolumeResult',
    'GetTargetGroupHealthCheckResult',
    'GetTargetGroupHttpHealthCheckResult',
    'GetTargetGroupTargetResult',
    'GetUserGroupResult',
    'GetVCPUServerCdromResult',
    'GetVCPUServerLabelResult',
    'GetVCPUServerNicResult',
    'GetVCPUServerNicFirewallRuleResult',
    'GetVCPUServerVolumeResult',
]

@pulumi.output_type
class CrossconnectConnectableDatacenter(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The UUID of the connectable datacenter
        :param str location: The physical location of the connectable datacenter
        :param str name: [string] The name of the cross-connection.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The UUID of the connectable datacenter
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The physical location of the connectable datacenter
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the cross-connection.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CrossconnectPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "datacenterName":
            suggest = "datacenter_name"
        elif key == "lanId":
            suggest = "lan_id"
        elif key == "lanName":
            suggest = "lan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrossconnectPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrossconnectPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrossconnectPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: Optional[str] = None,
                 datacenter_name: Optional[str] = None,
                 lan_id: Optional[str] = None,
                 lan_name: Optional[str] = None,
                 location: Optional[str] = None):
        """
        :param str datacenter_id: The id of the cross-connected datacenter
        :param str datacenter_name: The name of the cross-connected datacenter
        :param str lan_id: The id of the cross-connected LAN
        :param str lan_name: The name of the cross-connected LAN
        :param str location: The location of the cross-connected datacenter
        """
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if lan_id is not None:
            pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[str]:
        """
        The id of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[str]:
        """
        The name of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_name")

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> Optional[str]:
        """
        The id of the cross-connected LAN
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[str]:
        """
        The name of the cross-connected LAN
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The location of the cross-connected datacenter
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class CubeServerNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceNumber":
            suggest = "device_number"
        elif key == "firewallActive":
            suggest = "firewall_active"
        elif key == "firewallType":
            suggest = "firewall_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "ipv6Ips":
            suggest = "ipv6_ips"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "securityGroupsIds":
            suggest = "security_groups_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CubeServerNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CubeServerNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CubeServerNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan: int,
                 device_number: Optional[int] = None,
                 dhcp: Optional[bool] = None,
                 dhcpv6: Optional[bool] = None,
                 firewall: Optional['outputs.CubeServerNicFirewall'] = None,
                 firewall_active: Optional[bool] = None,
                 firewall_type: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 ipv6_ips: Optional[Sequence[str]] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 pci_slot: Optional[int] = None,
                 security_groups_ids: Optional[Sequence[str]] = None):
        """
        :param bool dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param str ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param Sequence[str] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param str name: [string] The name of the server.
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the resource.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall is not None:
            pulumi.set(__self__, "firewall", firewall)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @property
    @pulumi.getter
    def firewall(self) -> Optional['outputs.CubeServerNicFirewall']:
        return pulumi.get(self, "firewall")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[bool]:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[str]:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[Sequence[str]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[Sequence[str]]:
        """
        The list of Security Group IDs for the resource.
        """
        return pulumi.get(self, "security_groups_ids")


@pulumi.output_type
class CubeServerNicFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "portRangeEnd":
            suggest = "port_range_end"
        elif key == "portRangeStart":
            suggest = "port_range_start"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourceMac":
            suggest = "source_mac"
        elif key == "targetIp":
            suggest = "target_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CubeServerNicFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CubeServerNicFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CubeServerNicFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 icmp_code: Optional[str] = None,
                 icmp_type: Optional[str] = None,
                 name: Optional[str] = None,
                 port_range_end: Optional[int] = None,
                 port_range_start: Optional[int] = None,
                 source_ip: Optional[str] = None,
                 source_mac: Optional[str] = None,
                 target_ip: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: [string] The name of the server.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[str]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[str]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[int]:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[int]:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[str]:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[str]:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CubeServerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "backupUnitId":
            suggest = "backup_unit_id"
        elif key == "bootServer":
            suggest = "boot_server"
        elif key == "cpuHotPlug":
            suggest = "cpu_hot_plug"
        elif key == "deviceNumber":
            suggest = "device_number"
        elif key == "discVirtioHotPlug":
            suggest = "disc_virtio_hot_plug"
        elif key == "discVirtioHotUnplug":
            suggest = "disc_virtio_hot_unplug"
        elif key == "imagePassword":
            suggest = "image_password"
        elif key == "licenceType":
            suggest = "licence_type"
        elif key == "nicHotPlug":
            suggest = "nic_hot_plug"
        elif key == "nicHotUnplug":
            suggest = "nic_hot_unplug"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "ramHotPlug":
            suggest = "ram_hot_plug"
        elif key == "sshKeyPaths":
            suggest = "ssh_key_paths"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CubeServerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CubeServerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CubeServerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: str,
                 availability_zone: Optional[str] = None,
                 backup_unit_id: Optional[str] = None,
                 boot_server: Optional[str] = None,
                 bus: Optional[str] = None,
                 cpu_hot_plug: Optional[bool] = None,
                 device_number: Optional[int] = None,
                 disc_virtio_hot_plug: Optional[bool] = None,
                 disc_virtio_hot_unplug: Optional[bool] = None,
                 image_password: Optional[str] = None,
                 licence_type: Optional[str] = None,
                 name: Optional[str] = None,
                 nic_hot_plug: Optional[bool] = None,
                 nic_hot_unplug: Optional[bool] = None,
                 pci_slot: Optional[int] = None,
                 ram_hot_plug: Optional[bool] = None,
                 ssh_key_paths: Optional[Sequence[str]] = None,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: [string] The availability zone in which the server should exist. This property is immutable.
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param str boot_server: The UUID of the attached server.
        :param str image_password: [string] Required if `ssh_key_path` is not provided.
        :param str licence_type: [string] Sets the OS type of the server.
        :param str name: [string] The name of the server.
        :param Sequence[str] ssh_key_paths: [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        [string] The availability zone in which the server should exist. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[str]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[str]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> Optional[str]:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[str]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[str]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[Sequence[str]]:
        """
        [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.
        """
        return pulumi.get(self, "ssh_key_paths")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class DatacenterCpuArchitecture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuFamily":
            suggest = "cpu_family"
        elif key == "maxCores":
            suggest = "max_cores"
        elif key == "maxRam":
            suggest = "max_ram"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatacenterCpuArchitecture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatacenterCpuArchitecture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatacenterCpuArchitecture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_family: Optional[str] = None,
                 max_cores: Optional[int] = None,
                 max_ram: Optional[int] = None,
                 vendor: Optional[str] = None):
        """
        :param str cpu_family: A valid CPU family name
        :param int max_cores: The maximum number of cores available
        :param int max_ram: The maximum number of RAM in MB
        :param str vendor: A valid CPU vendor name
        """
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if max_ram is not None:
            pulumi.set(__self__, "max_ram", max_ram)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[str]:
        """
        A valid CPU family name
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[int]:
        """
        The maximum number of cores available
        """
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> Optional[int]:
        """
        The maximum number of RAM in MB
        """
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        A valid CPU vendor name
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GroupUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "forceSecAuth":
            suggest = "force_sec_auth"
        elif key == "lastName":
            suggest = "last_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrator: Optional[bool] = None,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 force_sec_auth: Optional[bool] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 password: Optional[str] = None):
        if administrator is not None:
            pulumi.set(__self__, "administrator", administrator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if force_sec_auth is not None:
            pulumi.set(__self__, "force_sec_auth", force_sec_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def administrator(self) -> Optional[bool]:
        return pulumi.get(self, "administrator")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="forceSecAuth")
    def force_sec_auth(self) -> Optional[bool]:
        return pulumi.get(self, "force_sec_auth")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")


@pulumi.output_type
class IPBlockIpConsumer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "datacenterName":
            suggest = "datacenter_name"
        elif key == "k8sClusterUuid":
            suggest = "k8s_cluster_uuid"
        elif key == "k8sNodepoolUuid":
            suggest = "k8s_nodepool_uuid"
        elif key == "nicId":
            suggest = "nic_id"
        elif key == "serverId":
            suggest = "server_id"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPBlockIpConsumer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPBlockIpConsumer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPBlockIpConsumer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: Optional[str] = None,
                 datacenter_name: Optional[str] = None,
                 ip: Optional[str] = None,
                 k8s_cluster_uuid: Optional[str] = None,
                 k8s_nodepool_uuid: Optional[str] = None,
                 mac: Optional[str] = None,
                 nic_id: Optional[str] = None,
                 server_id: Optional[str] = None,
                 server_name: Optional[str] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if k8s_cluster_uuid is not None:
            pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        if k8s_nodepool_uuid is not None:
            pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[str]:
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[str]:
        return pulumi.get(self, "datacenter_name")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> Optional[str]:
        return pulumi.get(self, "k8s_cluster_uuid")

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> Optional[str]:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[str]:
        return pulumi.get(self, "nic_id")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[str]:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        return pulumi.get(self, "server_name")


@pulumi.output_type
class LanIpFailover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nicUuid":
            suggest = "nic_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LanIpFailover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LanIpFailover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LanIpFailover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 nic_uuid: Optional[str] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if nic_uuid is not None:
            pulumi.set(__self__, "nic_uuid", nic_uuid)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nicUuid")
    def nic_uuid(self) -> Optional[str]:
        return pulumi.get(self, "nic_uuid")


@pulumi.output_type
class NatGatewayLan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayIps":
            suggest = "gateway_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NatGatewayLan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NatGatewayLan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NatGatewayLan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 gateway_ips: Optional[Sequence[str]] = None):
        """
        :param int id: [int] Id for the LAN connected to the NAT gateway.
        :param Sequence[str] gateway_ips: [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
        """
        pulumi.set(__self__, "id", id)
        if gateway_ips is not None:
            pulumi.set(__self__, "gateway_ips", gateway_ips)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        [int] Id for the LAN connected to the NAT gateway.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="gatewayIps")
    def gateway_ips(self) -> Optional[Sequence[str]]:
        """
        [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
        """
        return pulumi.get(self, "gateway_ips")


@pulumi.output_type
class NatGatewayRuleTargetPortRange(dict):
    def __init__(__self__, *,
                 end: Optional[int] = None,
                 start: Optional[int] = None):
        """
        :param int end: [int] Target port range end associated with the NAT gateway rule.
        :param int start: [int] Target port range start associated with the NAT gateway rule.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        [int] Target port range end associated with the NAT gateway rule.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        [int] Target port range start associated with the NAT gateway rule.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class NicFlowlog(dict):
    def __init__(__self__, *,
                 action: str,
                 bucket: str,
                 direction: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str action: Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        :param str bucket: Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        :param str direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        :param str name: Specifies the name of the flow log.
        :param str id: The ID of the NIC.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the flow log.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the NIC.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ServerLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: [string] The key of the label.
        :param str value: [string] The value of the label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        [string] The key of the label.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        [string] The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceNumber":
            suggest = "device_number"
        elif key == "firewallActive":
            suggest = "firewall_active"
        elif key == "firewallType":
            suggest = "firewall_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "ipv6Ips":
            suggest = "ipv6_ips"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "securityGroupsIds":
            suggest = "security_groups_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan: int,
                 device_number: Optional[int] = None,
                 dhcp: Optional[bool] = None,
                 dhcpv6: Optional[bool] = None,
                 firewall_active: Optional[bool] = None,
                 firewall_type: Optional[str] = None,
                 firewalls: Optional[Sequence['outputs.ServerNicFirewall']] = None,
                 id: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 ipv6_ips: Optional[Sequence[str]] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 pci_slot: Optional[int] = None,
                 security_groups_ids: Optional[Sequence[str]] = None):
        """
        :param bool dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param Sequence['ServerNicFirewallArgs'] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param str ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param Sequence[str] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param str name: [string] The name of the server.
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[bool]:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[str]:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[Sequence['outputs.ServerNicFirewall']]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[Sequence[str]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[Sequence[str]]:
        """
        The list of Security Group IDs for the
        """
        return pulumi.get(self, "security_groups_ids")


@pulumi.output_type
class ServerNicFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "portRangeEnd":
            suggest = "port_range_end"
        elif key == "portRangeStart":
            suggest = "port_range_start"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourceMac":
            suggest = "source_mac"
        elif key == "targetIp":
            suggest = "target_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNicFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNicFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNicFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 icmp_code: Optional[str] = None,
                 icmp_type: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_range_end: Optional[int] = None,
                 port_range_start: Optional[int] = None,
                 source_ip: Optional[str] = None,
                 source_mac: Optional[str] = None,
                 target_ip: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: [string] The name of the server.
        :param str type: (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[str]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[str]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[int]:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[int]:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[str]:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[str]:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "backupUnitId":
            suggest = "backup_unit_id"
        elif key == "bootServer":
            suggest = "boot_server"
        elif key == "cpuHotPlug":
            suggest = "cpu_hot_plug"
        elif key == "deviceNumber":
            suggest = "device_number"
        elif key == "discVirtioHotPlug":
            suggest = "disc_virtio_hot_plug"
        elif key == "discVirtioHotUnplug":
            suggest = "disc_virtio_hot_unplug"
        elif key == "imagePassword":
            suggest = "image_password"
        elif key == "licenceType":
            suggest = "licence_type"
        elif key == "nicHotPlug":
            suggest = "nic_hot_plug"
        elif key == "nicHotUnplug":
            suggest = "nic_hot_unplug"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "ramHotPlug":
            suggest = "ram_hot_plug"
        elif key == "sshKeyPaths":
            suggest = "ssh_key_paths"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: str,
                 availability_zone: Optional[str] = None,
                 backup_unit_id: Optional[str] = None,
                 boot_server: Optional[str] = None,
                 bus: Optional[str] = None,
                 cpu_hot_plug: Optional[bool] = None,
                 device_number: Optional[int] = None,
                 disc_virtio_hot_plug: Optional[bool] = None,
                 disc_virtio_hot_unplug: Optional[bool] = None,
                 image_password: Optional[str] = None,
                 licence_type: Optional[str] = None,
                 name: Optional[str] = None,
                 nic_hot_plug: Optional[bool] = None,
                 nic_hot_unplug: Optional[bool] = None,
                 pci_slot: Optional[int] = None,
                 ram_hot_plug: Optional[bool] = None,
                 size: Optional[int] = None,
                 ssh_key_paths: Optional[Sequence[str]] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param str boot_server: The UUID of the attached server.
        :param str image_password: [string] Required if `ssh_key_path` is not provided.
        :param str licence_type: [string] Sets the OS type of the server.
        :param str name: [string] The name of the server.
        :param int size: The size of the volume in GB.
        :param Sequence[str] ssh_key_paths: [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        :param Sequence[str] ssh_keys: [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[str]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[str]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> Optional[str]:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[str]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[str]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[Sequence[str]]:
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        return pulumi.get(self, "ssh_key_paths")

    @property
    @pulumi.getter(name="sshKeys")
    @_utilities.deprecated("""Please use ssh_keys under server level""")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class TargetGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkInterval":
            suggest = "check_interval"
        elif key == "checkTimeout":
            suggest = "check_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_interval: Optional[int] = None,
                 check_timeout: Optional[int] = None,
                 retries: Optional[int] = None):
        """
        :param int check_interval: [int] The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[int]:
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[int]:
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class TargetGroupHttpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHttpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: str,
                 response: str,
                 method: Optional[str] = None,
                 negate: Optional[bool] = None,
                 path: Optional[str] = None,
                 regex: Optional[bool] = None):
        """
        :param str match_type: [string]
        :param str response: [string] The response returned by the request, depending on the match type.
        :param str method: [string] The method for the HTTP health check.
        :param bool negate: [bool]
        :param str path: [string] The path (destination URL) for the HTTP health check request; the default is /.
        :param bool regex: [bool]
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        """
        [string]
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        [string] The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        [string] The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        [bool]
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        [bool]
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class TargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "maintenanceEnabled":
            suggest = "maintenance_enabled"
        elif key == "proxyProtocol":
            suggest = "proxy_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 weight: int,
                 health_check_enabled: Optional[bool] = None,
                 maintenance_enabled: Optional[bool] = None,
                 proxy_protocol: Optional[str] = None):
        """
        :param str ip: [string] The IP of the balanced target VM.
        :param int port: [int] The port of the balanced target service; valid range is 1 to 65535.
        :param int weight: [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param bool health_check_enabled: [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param bool maintenance_enabled: [bool] Maintenance mode prevents the target from receiving balanced traffic.
        :param str proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        [string] The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[bool]:
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[bool]:
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[str]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")


@pulumi.output_type
class VCPUServerLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VCPUServerNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceNumber":
            suggest = "device_number"
        elif key == "firewallActive":
            suggest = "firewall_active"
        elif key == "firewallType":
            suggest = "firewall_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "ipv6Ips":
            suggest = "ipv6_ips"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "securityGroupsIds":
            suggest = "security_groups_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VCPUServerNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VCPUServerNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VCPUServerNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan: int,
                 device_number: Optional[int] = None,
                 dhcp: Optional[bool] = None,
                 dhcpv6: Optional[bool] = None,
                 firewall_active: Optional[bool] = None,
                 firewall_type: Optional[str] = None,
                 firewalls: Optional[Sequence['outputs.VCPUServerNicFirewall']] = None,
                 id: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 ipv6_ips: Optional[Sequence[str]] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 pci_slot: Optional[int] = None,
                 security_groups_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence['VCPUServerNicFirewallArgs'] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param str name: [string] The name of the server.
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the resource.
               
               > **⚠ WARNING**
               >
               > ssh_keys field is immutable.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[bool]:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[str]:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[Sequence['outputs.VCPUServerNicFirewall']]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[Sequence[str]]:
        """
        The list of Security Group IDs for the resource.

        > **⚠ WARNING**
        >
        > ssh_keys field is immutable.
        """
        return pulumi.get(self, "security_groups_ids")


@pulumi.output_type
class VCPUServerNicFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "portRangeEnd":
            suggest = "port_range_end"
        elif key == "portRangeStart":
            suggest = "port_range_start"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourceMac":
            suggest = "source_mac"
        elif key == "targetIp":
            suggest = "target_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VCPUServerNicFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VCPUServerNicFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VCPUServerNicFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 icmp_code: Optional[str] = None,
                 icmp_type: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_range_end: Optional[int] = None,
                 port_range_start: Optional[int] = None,
                 source_ip: Optional[str] = None,
                 source_mac: Optional[str] = None,
                 target_ip: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: [string] The name of the server.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[str]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[str]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[int]:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[int]:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[str]:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[str]:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class VCPUServerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "backupUnitId":
            suggest = "backup_unit_id"
        elif key == "bootServer":
            suggest = "boot_server"
        elif key == "cpuHotPlug":
            suggest = "cpu_hot_plug"
        elif key == "deviceNumber":
            suggest = "device_number"
        elif key == "discVirtioHotPlug":
            suggest = "disc_virtio_hot_plug"
        elif key == "discVirtioHotUnplug":
            suggest = "disc_virtio_hot_unplug"
        elif key == "licenceType":
            suggest = "licence_type"
        elif key == "nicHotPlug":
            suggest = "nic_hot_plug"
        elif key == "nicHotUnplug":
            suggest = "nic_hot_unplug"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "ramHotPlug":
            suggest = "ram_hot_plug"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VCPUServerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VCPUServerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VCPUServerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: str,
                 availability_zone: Optional[str] = None,
                 backup_unit_id: Optional[str] = None,
                 boot_server: Optional[str] = None,
                 bus: Optional[str] = None,
                 cpu_hot_plug: Optional[bool] = None,
                 device_number: Optional[int] = None,
                 disc_virtio_hot_plug: Optional[bool] = None,
                 disc_virtio_hot_unplug: Optional[bool] = None,
                 licence_type: Optional[str] = None,
                 name: Optional[str] = None,
                 nic_hot_plug: Optional[bool] = None,
                 nic_hot_unplug: Optional[bool] = None,
                 pci_slot: Optional[int] = None,
                 ram_hot_plug: Optional[bool] = None,
                 size: Optional[int] = None,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param str boot_server: The UUID of the attached server.
        :param str licence_type: [string] Sets the OS type of the server.
        :param str name: [string] The name of the server.
        :param int size: The size of the volume in GB.
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[str]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[str]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> Optional[str]:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[str]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetCrossconnectConnectableDatacenterResult(dict):
    def __init__(__self__, *,
                 id: str,
                 location: str,
                 name: str):
        """
        :param str id: ID of the cross connect you want to search for.
               
               Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
        :param str location: The physical location of the connectable datacenter
        :param str name: Name of an existing cross connect that you want to search for.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the cross connect you want to search for.

        Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The physical location of the connectable datacenter
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing cross connect that you want to search for.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCrossconnectPeerResult(dict):
    def __init__(__self__, *,
                 datacenter_id: str,
                 datacenter_name: str,
                 lan_id: str,
                 lan_name: str,
                 location: str):
        """
        :param str datacenter_id: The id of the cross-connected datacenter
        :param str datacenter_name: The name of the cross-connected datacenter
        :param str lan_id: The id of the cross-connected LAN
        :param str lan_name: The name of the cross-connected LAN
        :param str location: The physical location of the connectable datacenter
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "datacenter_name", datacenter_name)
        pulumi.set(__self__, "lan_id", lan_id)
        pulumi.set(__self__, "lan_name", lan_name)
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The id of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> str:
        """
        The name of the cross-connected datacenter
        """
        return pulumi.get(self, "datacenter_name")

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The id of the cross-connected LAN
        """
        return pulumi.get(self, "lan_id")

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> str:
        """
        The name of the cross-connected LAN
        """
        return pulumi.get(self, "lan_name")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The physical location of the connectable datacenter
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class GetCubeServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        """
        :param str cloud_init: Cloud init compatibility
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param bool cpu_hot_unplug: Is capable of CPU hot unplug (no reboot required)
        :param str description: Description of cdrom
        :param bool disc_scsi_hot_plug: Is capable of SCSI drive hot plug (no reboot required)
        :param bool disc_scsi_hot_unplug: Is capable of SCSI drive hot unplug (no reboot required)
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] image_aliases: List of image aliases mapped for this Image
        :param str image_type: Type of image
        :param str licence_type: OS type of this volume
        :param str location: Location of that image/snapshot
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param bool public: Indicates if the image is part of the public repository or not
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param bool ram_hot_unplug: Is capable of memory hot unplug (no reboot required)
        :param float size: The size of the image in GB
        """
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        """
        Cloud init compatibility
        """
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        """
        Is capable of CPU hot unplug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of cdrom
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        """
        Is capable of SCSI drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        """
        Is capable of SCSI drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        """
        List of image aliases mapped for this Image
        """
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        Type of image
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of that image/snapshot
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Indicates if the image is part of the public repository or not
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        """
        Is capable of memory hot unplug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the image in GB
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetCubeServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetCubeServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 security_groups_ids: Sequence[str],
                 dhcpv6: Optional[bool] = None):
        """
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool dhcp: Indicates if the nic will reserve an IP using DHCP
        :param bool firewall_active: Activate or deactivate the firewall
        :param Sequence['GetCubeServerNicFirewallRuleArgs'] firewall_rules: list of
        :param str firewall_type: The type of firewall rules that will be allowed on the NIC
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic
        :param int lan: The LAN ID the NIC will sit on
        :param str mac: The MAC address of the NIC
        :param str name: Name of an existing server that you want to search for.
        :param int pci_slot: The PCI slot number of the Nic
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the resource.
        """
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "security_groups_ids", security_groups_ids)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Indicates if the nic will reserve an IP using DHCP
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        """
        Activate or deactivate the firewall
        """
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetCubeServerNicFirewallRuleResult']:
        """
        list of
        """
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        """
        The type of firewall rules that will be allowed on the NIC
        """
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        Collection of IP addresses assigned to a nic
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        """
        The LAN ID the NIC will sit on
        """
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        The MAC address of the NIC
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Sequence[str]:
        """
        The list of Security Group IDs for the resource.
        """
        return pulumi.get(self, "security_groups_ids")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetCubeServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        """
        :param int icmp_code: Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        :param int icmp_type: Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str name: Name of an existing server that you want to search for.
        :param int port_range_end: Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        :param int port_range_start: Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        :param str protocol: he protocol for the rule
        :param str source_ip: Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        :param str source_mac: Only traffic originating from the respective MAC address is allowed
        :param str target_ip: In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        :param str type: The type of firewall rule
        """
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        """
        Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        """
        Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        """
        Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        """
        Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        he protocol for the rule
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        """
        Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        """
        Only traffic originating from the respective MAC address is allowed
        """
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        """
        In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        """
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCubeServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 ssh_keys: Sequence[str],
                 type: str,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: The availability zone in which the volume should exist
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to
        :param str boot_server: The UUID of the attached server.
        :param str bus: The bus type of the volume
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str image_password: Initial password to be set for installed OS
        :param str licence_type: OS type of this volume
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param int pci_slot: The PCI slot number of the Nic
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param Sequence[str] ssh_keys: Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        :param str type: The type of firewall rule
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "type", type)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The availability zone in which the volume should exist
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        """
        The uuid of the Backup Unit that user has access to
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        """
        The bus type of the volume
        """
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        """
        Initial password to be set for installed OS
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        """
        Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetDatacenterCpuArchitectureResult(dict):
    def __init__(__self__, *,
                 cpu_family: str,
                 max_cores: int,
                 max_ram: int,
                 vendor: str):
        """
        :param str cpu_family: A valid CPU family name
        :param int max_cores: The maximum number of cores available
        :param int max_ram: The maximum number of RAM in MB
        :param str vendor: A valid CPU vendor name
        """
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "max_cores", max_cores)
        pulumi.set(__self__, "max_ram", max_ram)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        A valid CPU family name
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> int:
        """
        The maximum number of cores available
        """
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> int:
        """
        The maximum number of RAM in MB
        """
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        """
        A valid CPU vendor name
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetGroupUserResult(dict):
    def __init__(__self__, *,
                 administrator: bool,
                 email: str,
                 first_name: str,
                 force_sec_auth: bool,
                 id: str,
                 last_name: str):
        """
        :param str id: ID of the group you want to search for.
               
               Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
        """
        pulumi.set(__self__, "administrator", administrator)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "force_sec_auth", force_sec_auth)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)

    @property
    @pulumi.getter
    def administrator(self) -> bool:
        return pulumi.get(self, "administrator")

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="forceSecAuth")
    def force_sec_auth(self) -> bool:
        return pulumi.get(self, "force_sec_auth")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the group you want to search for.

        Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        return pulumi.get(self, "last_name")


@pulumi.output_type
class GetIPBlockIpConsumerResult(dict):
    def __init__(__self__, *,
                 datacenter_id: str,
                 datacenter_name: str,
                 ip: str,
                 k8s_cluster_uuid: str,
                 k8s_nodepool_uuid: str,
                 mac: str,
                 nic_id: str,
                 server_id: str,
                 server_name: str):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "datacenter_name", datacenter_name)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "nic_id", nic_id)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> str:
        return pulumi.get(self, "datacenter_name")

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> str:
        return pulumi.get(self, "k8s_cluster_uuid")

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> str:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> str:
        return pulumi.get(self, "nic_id")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GetLanIpFailoverResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 nic_uuid: str):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "nic_uuid", nic_uuid)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nicUuid")
    def nic_uuid(self) -> str:
        return pulumi.get(self, "nic_uuid")


@pulumi.output_type
class GetLocationCpuArchitectureResult(dict):
    def __init__(__self__, *,
                 cpu_family: str,
                 max_cores: int,
                 max_ram: int,
                 vendor: str):
        """
        :param str cpu_family: A valid CPU family name.
        :param int max_cores: The maximum number of cores available.
        :param int max_ram: The maximum number of RAM in MB.
        :param str vendor: A valid CPU vendor name.
        """
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "max_cores", max_cores)
        pulumi.set(__self__, "max_ram", max_ram)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        A valid CPU family name.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> int:
        """
        The maximum number of cores available.
        """
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> int:
        """
        The maximum number of RAM in MB.
        """
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        """
        A valid CPU vendor name.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetNatGatewayLanResult(dict):
    def __init__(__self__, *,
                 gateway_ips: Sequence[str],
                 id: int):
        """
        :param Sequence[str] gateway_ips: Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
        :param int id: ID of the network load balancer forwarding rule you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        pulumi.set(__self__, "gateway_ips", gateway_ips)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="gatewayIps")
    def gateway_ips(self) -> Sequence[str]:
        """
        Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
        """
        return pulumi.get(self, "gateway_ips")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the network load balancer forwarding rule you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNatGatewayRuleTargetPortRangeResult(dict):
    def __init__(__self__, *,
                 end: int,
                 start: int):
        """
        :param int end: Target port range end associated with the NAT gateway rule.
        :param int start: Target port range start associated with the NAT gateway rule.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> int:
        """
        Target port range end associated with the NAT gateway rule.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> int:
        """
        Target port range start associated with the NAT gateway rule.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetNicFlowlogResult(dict):
    def __init__(__self__, *,
                 action: str,
                 bucket: str,
                 direction: str,
                 id: str,
                 name: str):
        """
        :param str action: Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
        :param str bucket: Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
        :param str direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
        :param str id: ID of the nic you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided.
               If none, are provided, the datasource will return an error.
        :param str name: [string] The name of the LAN.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the nic you want to search for.

        `datacenter_id` and either `name` or `id` must be provided.
        If none, are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        [string] The name of the LAN.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        """
        :param str cloud_init: Cloud init compatibility
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param bool cpu_hot_unplug: Is capable of CPU hot unplug (no reboot required)
        :param str description: Description of cdrom
        :param bool disc_scsi_hot_plug: Is capable of SCSI drive hot plug (no reboot required)
        :param bool disc_scsi_hot_unplug: Is capable of SCSI drive hot unplug (no reboot required)
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] image_aliases: List of image aliases mapped for this Image
        :param str image_type: Type of image
        :param str licence_type: OS type of this volume
        :param str location: Location of that image/snapshot
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param bool public: Indicates if the image is part of the public repository or not
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param bool ram_hot_unplug: Is capable of memory hot unplug (no reboot required)
        :param float size: The size of the volume in GB
        """
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        """
        Cloud init compatibility
        """
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        """
        Is capable of CPU hot unplug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of cdrom
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        """
        Is capable of SCSI drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        """
        Is capable of SCSI drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        """
        List of image aliases mapped for this Image
        """
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        Type of image
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of that image/snapshot
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Indicates if the image is part of the public repository or not
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        """
        Is capable of memory hot unplug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the volume in GB
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetServerLabelResult(dict):
    def __init__(__self__, *,
                 id: str,
                 key: str,
                 value: str):
        """
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str key: The key of the label
        :param str value: The value of the label
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the label
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 security_groups_ids: Sequence[str],
                 dhcpv6: Optional[bool] = None):
        """
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool dhcp: Indicates if the nic will reserve an IP using DHCP
        :param bool firewall_active: Activate or deactivate the firewall
        :param Sequence['GetServerNicFirewallRuleArgs'] firewall_rules: list of
        :param str firewall_type: The type of firewall rules that will be allowed on the NIC
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic
        :param int lan: The LAN ID the NIC will sit on
        :param str mac: The MAC address of the NIC
        :param str name: Name of an existing server that you want to search for.
        :param int pci_slot: The PCI slot number of the Nic
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the resource.
        """
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "security_groups_ids", security_groups_ids)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Indicates if the nic will reserve an IP using DHCP
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        """
        Activate or deactivate the firewall
        """
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetServerNicFirewallRuleResult']:
        """
        list of
        """
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        """
        The type of firewall rules that will be allowed on the NIC
        """
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        Collection of IP addresses assigned to a nic
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        """
        The LAN ID the NIC will sit on
        """
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        The MAC address of the NIC
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Sequence[str]:
        """
        The list of Security Group IDs for the resource.
        """
        return pulumi.get(self, "security_groups_ids")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        """
        :param int icmp_code: Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        :param int icmp_type: Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str name: Name of an existing server that you want to search for.
        :param int port_range_end: Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        :param int port_range_start: Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        :param str protocol: he protocol for the rule
        :param str source_ip: Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        :param str source_mac: Only traffic originating from the respective MAC address is allowed
        :param str target_ip: In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        :param str type: The type of firewall rule
        """
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        """
        Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        """
        Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        """
        Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        """
        Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        he protocol for the rule
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        """
        Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        """
        Only traffic originating from the respective MAC address is allowed
        """
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        """
        In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        """
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 size: int,
                 ssh_keys: Sequence[str],
                 type: str,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: The availability zone in which the volume should exist
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to
        :param str boot_server: The UUID of the attached server.
        :param str bus: The bus type of the volume
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str image_password: Initial password to be set for installed OS
        :param str licence_type: OS type of this volume
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param int pci_slot: The PCI slot number of the Nic
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param int size: The size of the volume in GB
        :param Sequence[str] ssh_keys: Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        :param str type: The type of firewall rule
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "type", type)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The availability zone in which the volume should exist
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        """
        The uuid of the Backup Unit that user has access to
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        """
        The bus type of the volume
        """
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        """
        Initial password to be set for installed OS
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the volume in GB
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        """
        Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetServersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 boot_cdrom: str,
                 boot_image: str,
                 boot_volume: str,
                 cdroms: Sequence['outputs.GetServersServerCdromResult'],
                 cores: int,
                 cpu_family: str,
                 hostname: str,
                 id: str,
                 labels: Sequence['outputs.GetServersServerLabelResult'],
                 nics: Sequence['outputs.GetServersServerNicResult'],
                 ram: int,
                 token: str,
                 type: str,
                 vm_state: str,
                 volumes: Sequence['outputs.GetServersServerVolumeResult'],
                 name: Optional[str] = None,
                 template_uuid: Optional[str] = None):
        """
        :param str id: The unique ID of the server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "boot_cdrom", boot_cdrom)
        pulumi.set(__self__, "boot_image", boot_image)
        pulumi.set(__self__, "boot_volume", boot_volume)
        pulumi.set(__self__, "cdroms", cdroms)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "nics", nics)
        pulumi.set(__self__, "ram", ram)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_state", vm_state)
        pulumi.set(__self__, "volumes", volumes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_uuid is not None:
            pulumi.set(__self__, "template_uuid", template_uuid)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="bootCdrom")
    def boot_cdrom(self) -> str:
        return pulumi.get(self, "boot_cdrom")

    @property
    @pulumi.getter(name="bootImage")
    def boot_image(self) -> str:
        return pulumi.get(self, "boot_image")

    @property
    @pulumi.getter(name="bootVolume")
    def boot_volume(self) -> str:
        return pulumi.get(self, "boot_volume")

    @property
    @pulumi.getter
    def cdroms(self) -> Sequence['outputs.GetServersServerCdromResult']:
        return pulumi.get(self, "cdroms")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetServersServerLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def nics(self) -> Sequence['outputs.GetServersServerNicResult']:
        return pulumi.get(self, "nics")

    @property
    @pulumi.getter
    def ram(self) -> int:
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vmState")
    def vm_state(self) -> str:
        return pulumi.get(self, "vm_state")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetServersServerVolumeResult']:
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> Optional[str]:
        return pulumi.get(self, "template_uuid")


@pulumi.output_type
class GetServersServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetServersServerLabelResult(dict):
    def __init__(__self__, *,
                 id: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetServersServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 security_groups_ids: Sequence[str],
                 dhcpv6: Optional[bool] = None):
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "security_groups_ids", security_groups_ids)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetServersServerNicFirewallRuleResult']:
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_groups_ids")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetServersServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServersServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 disk_type: str,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 size: int,
                 ssh_keys: Sequence[str],
                 user_data: Optional[str] = None):
        """
        :param str boot_server: The UUID of the attached server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetTargetGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 check_interval: int,
                 check_timeout: int,
                 retries: int):
        """
        :param int check_interval: The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        pulumi.set(__self__, "check_interval", check_interval)
        pulumi.set(__self__, "check_timeout", check_timeout)
        pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> int:
        """
        The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> int:
        """
        The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GetTargetGroupHttpHealthCheckResult(dict):
    def __init__(__self__, *,
                 match_type: str,
                 method: str,
                 negate: bool,
                 path: str,
                 regex: bool,
                 response: str):
        """
        :param str method: The method for the HTTP health check.
        :param str path: The path (destination URL) for the HTTP health check request; the default is /.
        :param str response: The response returned by the request, depending on the match type.
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "negate", negate)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> bool:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> bool:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 health_check_enabled: bool,
                 ip: str,
                 maintenance_enabled: bool,
                 port: int,
                 proxy_protocol: str,
                 weight: int):
        """
        :param bool health_check_enabled: Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param str ip: The IP of the balanced target VM.
        :param bool maintenance_enabled: Maintenance mode prevents the target from receiving balanced traffic.
        :param int port: The port of the balanced target service; valid range is 1 to 65535.
        :param str proxy_protocol: The proxy protocol version.
        :param int weight: Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "proxy_protocol", proxy_protocol)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> bool:
        """
        Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> bool:
        """
        Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        The proxy protocol version.
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetUserGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: ID of the user you want to search for.
               
               Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the user you want to search for.

        Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetVCPUServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        """
        :param str cloud_init: Cloud init compatibility
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param bool cpu_hot_unplug: Is capable of CPU hot unplug (no reboot required)
        :param str description: Description of cdrom
        :param bool disc_scsi_hot_plug: Is capable of SCSI drive hot plug (no reboot required)
        :param bool disc_scsi_hot_unplug: Is capable of SCSI drive hot unplug (no reboot required)
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] image_aliases: List of image aliases mapped for this Image
        :param str image_type: Type of image
        :param str licence_type: OS type of this volume
        :param str location: Location of that image/snapshot
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param bool public: Indicates if the image is part of the public repository or not
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param bool ram_hot_unplug: Is capable of memory hot unplug (no reboot required)
        :param float size: The size of the volume in GB
        """
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        """
        Cloud init compatibility
        """
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        """
        Is capable of CPU hot unplug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of cdrom
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        """
        Is capable of SCSI drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        """
        Is capable of SCSI drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        """
        List of image aliases mapped for this Image
        """
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        Type of image
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of that image/snapshot
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        Indicates if the image is part of the public repository or not
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        """
        Is capable of memory hot unplug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        The size of the volume in GB
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetVCPUServerLabelResult(dict):
    def __init__(__self__, *,
                 id: str,
                 key: str,
                 value: str):
        """
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str key: The key of the label
        :param str value: The value of the label
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the label
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVCPUServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetVCPUServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 security_groups_ids: Sequence[str],
                 dhcpv6: Optional[bool] = None):
        """
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool dhcp: Indicates if the nic will reserve an IP using DHCP
        :param bool firewall_active: Activate or deactivate the firewall
        :param Sequence['GetVCPUServerNicFirewallRuleArgs'] firewall_rules: list of
        :param str firewall_type: The type of firewall rules that will be allowed on the NIC
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic
        :param int lan: The LAN ID the NIC will sit on
        :param str mac: The MAC address of the NIC
        :param str name: Name of an existing server that you want to search for.
        :param int pci_slot: The PCI slot number of the Nic
        :param Sequence[str] security_groups_ids: The list of Security Group IDs for the resource.
        """
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "security_groups_ids", security_groups_ids)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Indicates if the nic will reserve an IP using DHCP
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        """
        Activate or deactivate the firewall
        """
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetVCPUServerNicFirewallRuleResult']:
        """
        list of
        """
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        """
        The type of firewall rules that will be allowed on the NIC
        """
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        Collection of IP addresses assigned to a nic
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        """
        The LAN ID the NIC will sit on
        """
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        The MAC address of the NIC
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Sequence[str]:
        """
        The list of Security Group IDs for the resource.
        """
        return pulumi.get(self, "security_groups_ids")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetVCPUServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        """
        :param int icmp_code: Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        :param int icmp_type: Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str name: Name of an existing server that you want to search for.
        :param int port_range_end: Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        :param int port_range_start: Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        :param str protocol: he protocol for the rule
        :param str source_ip: Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        :param str source_mac: Only traffic originating from the respective MAC address is allowed
        :param str target_ip: In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        :param str type: The type of firewall rule
        """
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        """
        Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        """
        Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        """
        Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        """
        Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
        """
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        he protocol for the rule
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        """
        Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        """
        Only traffic originating from the respective MAC address is allowed
        """
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        """
        In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
        """
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVCPUServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 size: int,
                 ssh_keys: Sequence[str],
                 type: str,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: The availability zone in which the volume should exist
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to
        :param str boot_server: The UUID of the attached server.
        :param str bus: The bus type of the volume
        :param bool cpu_hot_plug: Is capable of CPU hot plug (no reboot required)
        :param int device_number: The Logical Unit Number (LUN) of the storage volume
        :param bool disc_virtio_hot_plug: Is capable of Virt-IO drive hot plug (no reboot required)
        :param bool disc_virtio_hot_unplug: Is capable of Virt-IO drive hot unplug (no reboot required)
        :param str id: ID of the server you want to search for.
               
               `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        :param str image_password: Initial password to be set for installed OS
        :param str licence_type: OS type of this volume
        :param str name: Name of an existing server that you want to search for.
        :param bool nic_hot_plug: Is capable of nic hot plug (no reboot required)
        :param bool nic_hot_unplug: Is capable of nic hot unplug (no reboot required)
        :param int pci_slot: The PCI slot number of the Nic
        :param bool ram_hot_plug: Is capable of memory hot plug (no reboot required)
        :param int size: The size of the volume in GB
        :param Sequence[str] ssh_keys: Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        :param str type: The type of firewall rule
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "type", type)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The availability zone in which the volume should exist
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        """
        The uuid of the Backup Unit that user has access to
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        """
        The bus type of the volume
        """
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        """
        Is capable of CPU hot plug (no reboot required)
        """
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        """
        The Logical Unit Number (LUN) of the storage volume
        """
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        """
        Is capable of Virt-IO drive hot plug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        """
        Is capable of Virt-IO drive hot unplug (no reboot required)
        """
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the server you want to search for.

        `datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        """
        Initial password to be set for installed OS
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        """
        OS type of this volume
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing server that you want to search for.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        """
        Is capable of nic hot plug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        """
        Is capable of nic hot unplug (no reboot required)
        """
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        """
        The PCI slot number of the Nic
        """
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        """
        Is capable of memory hot plug (no reboot required)
        """
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the volume in GB
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        """
        Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of firewall rule
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string
        """
        return pulumi.get(self, "user_data")


