#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue May  6 18:39:13 2025 by generateDS.py version 2.44.3.
# Python 3.12.3 (main, Feb  4 2025, 14:48:35) [GCC 13.3.0]
#
# Command line options:
#   ('-o', 'mbrng/models.py')
#   ('-s', 'mbrng/mb_mmd_subs.py')
#   ('--super', 'mb')
#   ('--external-encoding', 'utf-8')
#   ('--export', 'write etree')
#
# Command line arguments:
#   musicbrainz_mmd.xsd
#
# Command line:
#   /home/reosarevok/mb-rngpy/venv/bin/generateDS.py -o "mbrng/models.py" -s "mbrng/mb_mmd_subs.py" --super="mb" --external-encoding="utf-8" --export="write etree" musicbrainz_mmd.xsd
#
# Current working directory (os.getcwd()):
#   mb-rngpy
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile('(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'{.*}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class def_direction16_impl(str, Enum):
    BOTH='both'
    FORWARD='forward'
    BACKWARD='backward'


class def_direction_impl(str, Enum):
    BOTH='both'
    FORWARD='forward'
    BACKWARD='backward'


class def_quality17_impl(str, Enum):
    LOW='low'
    NORMAL='normal'
    HIGH='high'


class def_quality_impl(str, Enum):
    LOW='low'
    NORMAL='normal'
    HIGH='high'


class fluencyType(str, Enum):
    BASIC='basic'
    INTERMEDIATE='intermediate'
    ADVANCED='advanced'
    NATIVE='native'


class fluencyType44(str, Enum):
    BASIC='basic'
    INTERMEDIATE='intermediate'
    ADVANCED='advanced'
    NATIVE='native'


#
# Start data representation classes
#
class def_area_element_inner1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, disambiguation=None, iso_3166_1_code_list=None, iso_3166_2_code_list=None, iso_3166_3_code_list=None, annotation=None, life_span=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.sort_name = sort_name
        self.sort_name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.iso_3166_1_code_list = iso_3166_1_code_list
        self.iso_3166_1_code_list_nsprefix_ = "mmd-2.0"
        self.iso_3166_2_code_list = iso_3166_2_code_list
        self.iso_3166_2_code_list_nsprefix_ = "mmd-2.0"
        self.iso_3166_3_code_list = iso_3166_3_code_list
        self.iso_3166_3_code_list_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_area_element_inner1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_area_element_inner1.subclass:
            return def_area_element_inner1.subclass(*args_, **kwargs_)
        else:
            return def_area_element_inner1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sort_name(self):
        return self.sort_name
    def set_sort_name(self, sort_name):
        self.sort_name = sort_name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_iso_3166_1_code_list(self):
        return self.iso_3166_1_code_list
    def set_iso_3166_1_code_list(self, iso_3166_1_code_list):
        self.iso_3166_1_code_list = iso_3166_1_code_list
    def get_iso_3166_2_code_list(self):
        return self.iso_3166_2_code_list
    def set_iso_3166_2_code_list(self, iso_3166_2_code_list):
        self.iso_3166_2_code_list = iso_3166_2_code_list
    def get_iso_3166_3_code_list(self):
        return self.iso_3166_3_code_list
    def set_iso_3166_3_code_list(self, iso_3166_3_code_list):
        self.iso_3166_3_code_list = iso_3166_3_code_list
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid15(self, value):
        # Validate type def_uuid15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid15_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid15_patterns_, ))
    validate_def_uuid15_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.disambiguation is not None or
            self.iso_3166_1_code_list is not None or
            self.iso_3166_2_code_list is not None or
            self.iso_3166_3_code_list is not None or
            self.annotation is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_area-element_inner1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_area-element_inner1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_area-element_inner1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_area-element_inner1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='def_area-element_inner1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_area-element_inner1'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_area-element_inner1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.sort_name is not None:
            namespaceprefix_ = self.sort_name_nsprefix_ + ':' if (UseCapturedNS_ and self.sort_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.iso_3166_1_code_list is not None:
            namespaceprefix_ = self.iso_3166_1_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_1_code_list_nsprefix_) else ''
            self.iso_3166_1_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-1-code-list', pretty_print=pretty_print)
        if self.iso_3166_2_code_list is not None:
            namespaceprefix_ = self.iso_3166_2_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_2_code_list_nsprefix_) else ''
            self.iso_3166_2_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-2-code-list', pretty_print=pretty_print)
        if self.iso_3166_3_code_list is not None:
            namespaceprefix_ = self.iso_3166_3_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_3_code_list_nsprefix_) else ''
            self.iso_3166_3_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-3-code-list', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def to_etree(self, parent_element=None, name_='def_area-element_inner1', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.iso_3166_1_code_list is not None:
            iso_3166_1_code_list_ = self.iso_3166_1_code_list
            iso_3166_1_code_list_.to_etree(element, name_='iso-3166-1-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.iso_3166_2_code_list is not None:
            iso_3166_2_code_list_ = self.iso_3166_2_code_list
            iso_3166_2_code_list_.to_etree(element, name_='iso-3166-2-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.iso_3166_3_code_list is not None:
            iso_3166_3_code_list_ = self.iso_3166_3_code_list
            iso_3166_3_code_list_.to_etree(element, name_='iso-3166-3-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.to_etree(element, mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid15(self.type_id)    # validate type def_uuid15
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'sort-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sort_name')
            value_ = self.gds_validate_string(value_, node, 'sort_name')
            self.sort_name = value_
            self.sort_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'iso-3166-1-code-list':
            obj_ = iso_3166_1_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_1_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-1-code-list'
        elif nodeName_ == 'iso-3166-2-code-list':
            obj_ = iso_3166_2_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_2_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-2-code-list'
        elif nodeName_ == 'iso-3166-3-code-list':
            obj_ = iso_3166_3_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_3_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-3-code-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        else:
            content_ = self.gds_build_any(child_, 'def_area-element_inner1')
            self.set_anytypeobjs_(content_)
# end class def_area_element_inner1


class def_track_data2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, position=None, number=None, title=None, length=None, artist_credit=None, recording=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = "mmd-2.0"
        self.number = number
        self.number_nsprefix_ = "mmd-2.0"
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.length = length
        self.length_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_track_data2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_track_data2.subclass:
            return def_track_data2.subclass(*args_, **kwargs_)
        else:
            return def_track_data2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            self.position is not None or
            self.number is not None or
            self.title is not None or
            self.length is not None or
            self.artist_credit is not None or
            self.recording is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_track-data2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_track-data2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_track-data2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_track-data2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='def_track-data2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_track-data2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_track-data2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespaceprefix_ , self.gds_format_integer(self.position, input_name='position'), namespaceprefix_ , eol_))
        if self.number is not None:
            namespaceprefix_ = self.number_nsprefix_ + ':' if (UseCapturedNS_ and self.number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespaceprefix_ , eol_))
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.recording is not None:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            self.recording.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='def_track-data2', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.position is not None:
            position_ = self.position
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}position').text = self.gds_format_integer(position_)
        if self.number is not None:
            number_ = self.number
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}number').text = self.gds_format_string(number_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'position')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
            self.position_nsprefix_ = child_.prefix
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
# end class def_track_data2


class metadata(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, generator=None, created=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None, genre=None, url=None, puid=None, isrc=None, disc=None, cdstub=None, rating=None, user_rating=None, collection=None, editor=None, artist_list=None, release_list=None, release_group_list=None, recording_list=None, label_list=None, work_list=None, area_list=None, place_list=None, instrument_list=None, series_list=None, event_list=None, url_list=None, isrc_list=None, annotation_list=None, cdstub_list=None, freedb_disc_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, collection_list=None, editor_list=None, entity_list=None, edit_note=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.generator = _cast(None, generator)
        self.generator_nsprefix_ = None
        if isinstance(created, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = created
        self.created = initvalue_
        self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
        self.release = release
        self.release_nsprefix_ = "mmd-2.0"
        self.release_group = release_group
        self.release_group_nsprefix_ = "mmd-2.0"
        self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
        self.label = label
        self.label_nsprefix_ = "mmd-2.0"
        self.work = work
        self.work_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.place = place
        self.place_nsprefix_ = "mmd-2.0"
        self.instrument = instrument
        self.instrument_nsprefix_ = "mmd-2.0"
        self.series = series
        self.series_nsprefix_ = "mmd-2.0"
        self.event = event
        self.event_nsprefix_ = "mmd-2.0"
        self.genre = genre
        self.genre_nsprefix_ = "mmd-2.0"
        self.url = url
        self.url_nsprefix_ = "mmd-2.0"
        self.puid = puid
        self.puid_nsprefix_ = "mmd-2.0"
        self.isrc = isrc
        self.isrc_nsprefix_ = "mmd-2.0"
        self.disc = disc
        self.disc_nsprefix_ = "mmd-2.0"
        self.cdstub = cdstub
        self.cdstub_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        self.collection = collection
        self.collection_nsprefix_ = "mmd-2.0"
        self.editor = editor
        self.editor_nsprefix_ = "mmd-2.0"
        self.artist_list = artist_list
        self.artist_list_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        self.release_group_list = release_group_list
        self.release_group_list_nsprefix_ = "mmd-2.0"
        self.recording_list = recording_list
        self.recording_list_nsprefix_ = "mmd-2.0"
        self.label_list = label_list
        self.label_list_nsprefix_ = "mmd-2.0"
        self.work_list = work_list
        self.work_list_nsprefix_ = "mmd-2.0"
        self.area_list = area_list
        self.area_list_nsprefix_ = "mmd-2.0"
        self.place_list = place_list
        self.place_list_nsprefix_ = "mmd-2.0"
        self.instrument_list = instrument_list
        self.instrument_list_nsprefix_ = "mmd-2.0"
        self.series_list = series_list
        self.series_list_nsprefix_ = "mmd-2.0"
        self.event_list = event_list
        self.event_list_nsprefix_ = "mmd-2.0"
        self.url_list = url_list
        self.url_list_nsprefix_ = "mmd-2.0"
        self.isrc_list = isrc_list
        self.isrc_list_nsprefix_ = "mmd-2.0"
        self.annotation_list = annotation_list
        self.annotation_list_nsprefix_ = "mmd-2.0"
        self.cdstub_list = cdstub_list
        self.cdstub_list_nsprefix_ = "mmd-2.0"
        self.freedb_disc_list = freedb_disc_list
        self.freedb_disc_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.collection_list = collection_list
        self.collection_list_nsprefix_ = "mmd-2.0"
        self.editor_list = editor_list
        self.editor_list_nsprefix_ = "mmd-2.0"
        self.entity_list = entity_list
        self.entity_list_nsprefix_ = "mmd-2.0"
        self.edit_note = edit_note
        self.edit_note_nsprefix_ = "mmd-2.0"
        self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metadata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metadata.subclass:
            return metadata.subclass(*args_, **kwargs_)
        else:
            return metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def get_release_group(self):
        return self.release_group
    def set_release_group(self, release_group):
        self.release_group = release_group
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def get_instrument(self):
        return self.instrument
    def set_instrument(self, instrument):
        self.instrument = instrument
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_genre(self):
        return self.genre
    def set_genre(self, genre):
        self.genre = genre
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_puid(self):
        return self.puid
    def set_puid(self, puid):
        self.puid = puid
    def get_isrc(self):
        return self.isrc
    def set_isrc(self, isrc):
        self.isrc = isrc
    def get_disc(self):
        return self.disc
    def set_disc(self, disc):
        self.disc = disc
    def get_cdstub(self):
        return self.cdstub
    def set_cdstub(self, cdstub):
        self.cdstub = cdstub
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_collection(self):
        return self.collection
    def set_collection(self, collection):
        self.collection = collection
    def get_editor(self):
        return self.editor
    def set_editor(self, editor):
        self.editor = editor
    def get_artist_list(self):
        return self.artist_list
    def set_artist_list(self, artist_list):
        self.artist_list = artist_list
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_release_group_list(self):
        return self.release_group_list
    def set_release_group_list(self, release_group_list):
        self.release_group_list = release_group_list
    def get_recording_list(self):
        return self.recording_list
    def set_recording_list(self, recording_list):
        self.recording_list = recording_list
    def get_label_list(self):
        return self.label_list
    def set_label_list(self, label_list):
        self.label_list = label_list
    def get_work_list(self):
        return self.work_list
    def set_work_list(self, work_list):
        self.work_list = work_list
    def get_area_list(self):
        return self.area_list
    def set_area_list(self, area_list):
        self.area_list = area_list
    def get_place_list(self):
        return self.place_list
    def set_place_list(self, place_list):
        self.place_list = place_list
    def get_instrument_list(self):
        return self.instrument_list
    def set_instrument_list(self, instrument_list):
        self.instrument_list = instrument_list
    def get_series_list(self):
        return self.series_list
    def set_series_list(self, series_list):
        self.series_list = series_list
    def get_event_list(self):
        return self.event_list
    def set_event_list(self, event_list):
        self.event_list = event_list
    def get_url_list(self):
        return self.url_list
    def set_url_list(self, url_list):
        self.url_list = url_list
    def get_isrc_list(self):
        return self.isrc_list
    def set_isrc_list(self, isrc_list):
        self.isrc_list = isrc_list
    def get_annotation_list(self):
        return self.annotation_list
    def set_annotation_list(self, annotation_list):
        self.annotation_list = annotation_list
    def get_cdstub_list(self):
        return self.cdstub_list
    def set_cdstub_list(self, cdstub_list):
        self.cdstub_list = cdstub_list
    def get_freedb_disc_list(self):
        return self.freedb_disc_list
    def set_freedb_disc_list(self, freedb_disc_list):
        self.freedb_disc_list = freedb_disc_list
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_collection_list(self):
        return self.collection_list
    def set_collection_list(self, collection_list):
        self.collection_list = collection_list
    def get_editor_list(self):
        return self.editor_list
    def set_editor_list(self, editor_list):
        self.editor_list = editor_list
    def get_entity_list(self):
        return self.entity_list
    def set_entity_list(self, entity_list):
        self.entity_list = entity_list
    def get_edit_note(self):
        return self.edit_note
    def set_edit_note(self, edit_note):
        self.edit_note = edit_note
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def get_created(self):
        return self.created
    def set_created(self, created):
        self.created = created
    def has__content(self):
        if (
            self.artist is not None or
            self.release is not None or
            self.release_group is not None or
            self.recording is not None or
            self.label is not None or
            self.work is not None or
            self.area is not None or
            self.place is not None or
            self.instrument is not None or
            self.series is not None or
            self.event is not None or
            self.genre is not None or
            self.url is not None or
            self.puid is not None or
            self.isrc is not None or
            self.disc is not None or
            self.cdstub is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.collection is not None or
            self.editor is not None or
            self.artist_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.recording_list is not None or
            self.label_list is not None or
            self.work_list is not None or
            self.area_list is not None or
            self.place_list is not None or
            self.instrument_list is not None or
            self.series_list is not None or
            self.event_list is not None or
            self.url_list is not None or
            self.isrc_list is not None or
            self.annotation_list is not None or
            self.cdstub_list is not None or
            self.freedb_disc_list is not None or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.collection_list is not None or
            self.editor_list is not None or
            self.entity_list is not None or
            self.edit_note is not None or
            self.def_extension_element is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='metadata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metadata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metadata':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metadata')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='metadata'):
        if self.generator is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            outfile.write(' generator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.generator), input_name='generator')), ))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_datetime(self.created, input_name='created'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='metadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            self.artist.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist', pretty_print=pretty_print)
        if self.release is not None:
            namespaceprefix_ = self.release_nsprefix_ + ':' if (UseCapturedNS_ and self.release_nsprefix_) else ''
            self.release.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release', pretty_print=pretty_print)
        if self.release_group is not None:
            namespaceprefix_ = self.release_group_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_nsprefix_) else ''
            self.release_group.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group', pretty_print=pretty_print)
        if self.recording is not None:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            self.recording.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
        if self.label is not None:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            self.label.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label', pretty_print=pretty_print)
        if self.work is not None:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            self.work.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.place is not None:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            self.place.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place', pretty_print=pretty_print)
        if self.instrument is not None:
            namespaceprefix_ = self.instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_nsprefix_) else ''
            self.instrument.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            self.series.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series', pretty_print=pretty_print)
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.genre is not None:
            namespaceprefix_ = self.genre_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_nsprefix_) else ''
            self.genre.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre', pretty_print=pretty_print)
        if self.url is not None:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            self.url.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='url', pretty_print=pretty_print)
        if self.puid is not None:
            namespaceprefix_ = self.puid_nsprefix_ + ':' if (UseCapturedNS_ and self.puid_nsprefix_) else ''
            self.puid.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='puid', pretty_print=pretty_print)
        if self.isrc is not None:
            namespaceprefix_ = self.isrc_nsprefix_ + ':' if (UseCapturedNS_ and self.isrc_nsprefix_) else ''
            self.isrc.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isrc', pretty_print=pretty_print)
        if self.disc is not None:
            namespaceprefix_ = self.disc_nsprefix_ + ':' if (UseCapturedNS_ and self.disc_nsprefix_) else ''
            self.disc.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='disc', pretty_print=pretty_print)
        if self.cdstub is not None:
            namespaceprefix_ = self.cdstub_nsprefix_ + ':' if (UseCapturedNS_ and self.cdstub_nsprefix_) else ''
            self.cdstub.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='cdstub', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        if self.collection is not None:
            namespaceprefix_ = self.collection_nsprefix_ + ':' if (UseCapturedNS_ and self.collection_nsprefix_) else ''
            self.collection.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='collection', pretty_print=pretty_print)
        if self.editor is not None:
            namespaceprefix_ = self.editor_nsprefix_ + ':' if (UseCapturedNS_ and self.editor_nsprefix_) else ''
            self.editor.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='editor', pretty_print=pretty_print)
        if self.artist_list is not None:
            namespaceprefix_ = self.artist_list_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_list_nsprefix_) else ''
            self.artist_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-list', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            namespaceprefix_ = self.release_group_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_list_nsprefix_) else ''
            self.release_group_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            namespaceprefix_ = self.recording_list_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_list_nsprefix_) else ''
            self.recording_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording-list', pretty_print=pretty_print)
        if self.label_list is not None:
            namespaceprefix_ = self.label_list_nsprefix_ + ':' if (UseCapturedNS_ and self.label_list_nsprefix_) else ''
            self.label_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label-list', pretty_print=pretty_print)
        if self.work_list is not None:
            namespaceprefix_ = self.work_list_nsprefix_ + ':' if (UseCapturedNS_ and self.work_list_nsprefix_) else ''
            self.work_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work-list', pretty_print=pretty_print)
        if self.area_list is not None:
            namespaceprefix_ = self.area_list_nsprefix_ + ':' if (UseCapturedNS_ and self.area_list_nsprefix_) else ''
            self.area_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area-list', pretty_print=pretty_print)
        if self.place_list is not None:
            namespaceprefix_ = self.place_list_nsprefix_ + ':' if (UseCapturedNS_ and self.place_list_nsprefix_) else ''
            self.place_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place-list', pretty_print=pretty_print)
        if self.instrument_list is not None:
            namespaceprefix_ = self.instrument_list_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_list_nsprefix_) else ''
            self.instrument_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument-list', pretty_print=pretty_print)
        if self.series_list is not None:
            namespaceprefix_ = self.series_list_nsprefix_ + ':' if (UseCapturedNS_ and self.series_list_nsprefix_) else ''
            self.series_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series-list', pretty_print=pretty_print)
        if self.event_list is not None:
            namespaceprefix_ = self.event_list_nsprefix_ + ':' if (UseCapturedNS_ and self.event_list_nsprefix_) else ''
            self.event_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event-list', pretty_print=pretty_print)
        if self.url_list is not None:
            namespaceprefix_ = self.url_list_nsprefix_ + ':' if (UseCapturedNS_ and self.url_list_nsprefix_) else ''
            self.url_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='url-list', pretty_print=pretty_print)
        if self.isrc_list is not None:
            namespaceprefix_ = self.isrc_list_nsprefix_ + ':' if (UseCapturedNS_ and self.isrc_list_nsprefix_) else ''
            self.isrc_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isrc-list', pretty_print=pretty_print)
        if self.annotation_list is not None:
            namespaceprefix_ = self.annotation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_list_nsprefix_) else ''
            self.annotation_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation-list', pretty_print=pretty_print)
        if self.cdstub_list is not None:
            namespaceprefix_ = self.cdstub_list_nsprefix_ + ':' if (UseCapturedNS_ and self.cdstub_list_nsprefix_) else ''
            self.cdstub_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='cdstub-list', pretty_print=pretty_print)
        if self.freedb_disc_list is not None:
            namespaceprefix_ = self.freedb_disc_list_nsprefix_ + ':' if (UseCapturedNS_ and self.freedb_disc_list_nsprefix_) else ''
            self.freedb_disc_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='freedb-disc-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.collection_list is not None:
            namespaceprefix_ = self.collection_list_nsprefix_ + ':' if (UseCapturedNS_ and self.collection_list_nsprefix_) else ''
            self.collection_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='collection-list', pretty_print=pretty_print)
        if self.editor_list is not None:
            namespaceprefix_ = self.editor_list_nsprefix_ + ':' if (UseCapturedNS_ and self.editor_list_nsprefix_) else ''
            self.editor_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='editor-list', pretty_print=pretty_print)
        if self.entity_list is not None:
            namespaceprefix_ = self.entity_list_nsprefix_ + ':' if (UseCapturedNS_ and self.entity_list_nsprefix_) else ''
            self.entity_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='entity-list', pretty_print=pretty_print)
        if self.edit_note is not None:
            namespaceprefix_ = self.edit_note_nsprefix_ + ':' if (UseCapturedNS_ and self.edit_note_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedit-note>%s</%sedit-note>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.edit_note), input_name='edit-note')), namespaceprefix_ , eol_))
        if self.def_extension_element is not None:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.def_extension_element), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='metadata', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.generator is not None:
            element.set('generator', self.gds_format_string(self.generator))
        if self.created is not None:
            element.set('created', self.gds_format_datetime(self.created))
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release is not None:
            release_ = self.release
            release_.to_etree(element, name_='release', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.work is not None:
            work_ = self.work
            work_.to_etree(element, name_='work', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.place is not None:
            place_ = self.place
            place_.to_etree(element, name_='place', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.instrument is not None:
            instrument_ = self.instrument
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.series is not None:
            series_ = self.series
            series_.to_etree(element, name_='series', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.event is not None:
            event_ = self.event
            event_.to_etree(element, name_='event', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre is not None:
            genre_ = self.genre
            genre_.to_etree(element, name_='genre', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.url is not None:
            url_ = self.url
            url_.to_etree(element, name_='url', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.puid is not None:
            puid_ = self.puid
            puid_.to_etree(element, name_='puid', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isrc is not None:
            isrc_ = self.isrc
            isrc_.to_etree(element, name_='isrc', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disc is not None:
            disc_ = self.disc
            disc_.to_etree(element, name_='disc', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.cdstub is not None:
            cdstub_ = self.cdstub
            cdstub_.to_etree(element, name_='cdstub', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        if self.collection is not None:
            collection_ = self.collection
            collection_.to_etree(element, name_='collection', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.editor is not None:
            editor_ = self.editor
            editor_.to_etree(element, name_='editor', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.artist_list is not None:
            artist_list_ = self.artist_list
            artist_list_.to_etree(element, name_='artist-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.label_list is not None:
            label_list_ = self.label_list
            label_list_.to_etree(element, name_='label-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area_list is not None:
            area_list_ = self.area_list
            area_list_.to_etree(element, name_='area-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.place_list is not None:
            place_list_ = self.place_list
            place_list_.to_etree(element, name_='place-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.instrument_list is not None:
            instrument_list_ = self.instrument_list
            instrument_list_.to_etree(element, name_='instrument-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.series_list is not None:
            series_list_ = self.series_list
            series_list_.to_etree(element, name_='series-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.event_list is not None:
            event_list_ = self.event_list
            event_list_.to_etree(element, name_='event-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.url_list is not None:
            url_list_ = self.url_list
            url_list_.to_etree(element, name_='url-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isrc_list is not None:
            isrc_list_ = self.isrc_list
            isrc_list_.to_etree(element, name_='isrc-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation_list is not None:
            annotation_list_ = self.annotation_list
            annotation_list_.to_etree(element, name_='annotation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.cdstub_list is not None:
            cdstub_list_ = self.cdstub_list
            cdstub_list_.to_etree(element, name_='cdstub-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.freedb_disc_list is not None:
            freedb_disc_list_ = self.freedb_disc_list
            freedb_disc_list_.to_etree(element, name_='freedb-disc-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.collection_list is not None:
            collection_list_ = self.collection_list
            collection_list_.to_etree(element, name_='collection-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.editor_list is not None:
            editor_list_ = self.editor_list
            editor_list_.to_etree(element, name_='editor-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.entity_list is not None:
            entity_list_ = self.entity_list
            entity_list_.to_etree(element, name_='entity-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.edit_note is not None:
            edit_note_ = self.edit_note
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edit-note').text = self.gds_format_string(edit_note_)
        if self.def_extension_element is not None:
            def_extension_element_ = self.def_extension_element
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generator', node)
        if value is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            self.generator = value
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (created): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artist':
            obj_ = artist.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release = obj_
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument = obj_
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series = obj_
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'genre':
            obj_ = genre.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre = obj_
            obj_.original_tagname_ = 'genre'
        elif nodeName_ == 'url':
            obj_ = url.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'puid':
            obj_ = puid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.puid = obj_
            obj_.original_tagname_ = 'puid'
        elif nodeName_ == 'isrc':
            obj_ = isrc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isrc = obj_
            obj_.original_tagname_ = 'isrc'
        elif nodeName_ == 'disc':
            obj_ = disc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.disc = obj_
            obj_.original_tagname_ = 'disc'
        elif nodeName_ == 'cdstub':
            obj_ = cdstub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cdstub = obj_
            obj_.original_tagname_ = 'cdstub'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'collection':
            obj_ = collection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.collection = obj_
            obj_.original_tagname_ = 'collection'
        elif nodeName_ == 'editor':
            obj_ = editor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editor = obj_
            obj_.original_tagname_ = 'editor'
        elif nodeName_ == 'artist-list':
            obj_ = artist_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_list = obj_
            obj_.original_tagname_ = 'artist-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'label-list':
            obj_ = label_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label_list = obj_
            obj_.original_tagname_ = 'label-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
        elif nodeName_ == 'area-list':
            obj_ = area_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area_list = obj_
            obj_.original_tagname_ = 'area-list'
        elif nodeName_ == 'place-list':
            obj_ = place_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place_list = obj_
            obj_.original_tagname_ = 'place-list'
        elif nodeName_ == 'instrument-list':
            obj_ = instrument_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument_list = obj_
            obj_.original_tagname_ = 'instrument-list'
        elif nodeName_ == 'series-list':
            obj_ = series_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series_list = obj_
            obj_.original_tagname_ = 'series-list'
        elif nodeName_ == 'event-list':
            obj_ = event_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event_list = obj_
            obj_.original_tagname_ = 'event-list'
        elif nodeName_ == 'url-list':
            obj_ = url_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url_list = obj_
            obj_.original_tagname_ = 'url-list'
        elif nodeName_ == 'isrc-list':
            obj_ = isrc_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isrc_list = obj_
            obj_.original_tagname_ = 'isrc-list'
        elif nodeName_ == 'annotation-list':
            obj_ = annotation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation_list = obj_
            obj_.original_tagname_ = 'annotation-list'
        elif nodeName_ == 'cdstub-list':
            obj_ = cdstub_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cdstub_list = obj_
            obj_.original_tagname_ = 'cdstub-list'
        elif nodeName_ == 'freedb-disc-list':
            obj_ = freedb_disc_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.freedb_disc_list = obj_
            obj_.original_tagname_ = 'freedb-disc-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'collection-list':
            obj_ = collection_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.collection_list = obj_
            obj_.original_tagname_ = 'collection-list'
        elif nodeName_ == 'editor-list':
            obj_ = editor_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editor_list = obj_
            obj_.original_tagname_ = 'editor-list'
        elif nodeName_ == 'entity-list':
            obj_ = entity_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entity_list = obj_
            obj_.original_tagname_ = 'entity-list'
        elif nodeName_ == 'edit-note':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'edit_note')
            value_ = self.gds_validate_string(value_, node, 'edit_note')
            self.edit_note = value_
            self.edit_note_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element = value_
            self.def_extension_element_nsprefix_ = child_.prefix
# end class metadata


class artist(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, gender=None, country=None, area=None, begin_area=None, end_area=None, annotation=None, disambiguation=None, ipi=None, ipi_list=None, isni_list=None, life_span=None, alias_list=None, recording_list=None, release_list=None, release_group_list=None, work_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.sort_name = sort_name
        self.sort_name_nsprefix_ = "mmd-2.0"
        self.gender = gender
        self.gender_nsprefix_ = "mmd-2.0"
        self.country = country
        self.country_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.begin_area = begin_area
        self.begin_area_nsprefix_ = "mmd-2.0"
        self.end_area = end_area
        self.end_area_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.ipi = ipi
        self.ipi_nsprefix_ = "mmd-2.0"
        self.ipi_list = ipi_list
        self.ipi_list_nsprefix_ = "mmd-2.0"
        self.isni_list = isni_list
        self.isni_list_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        self.recording_list = recording_list
        self.recording_list_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        self.release_group_list = release_group_list
        self.release_group_list_nsprefix_ = "mmd-2.0"
        self.work_list = work_list
        self.work_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist.subclass:
            return artist.subclass(*args_, **kwargs_)
        else:
            return artist(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sort_name(self):
        return self.sort_name
    def set_sort_name(self, sort_name):
        self.sort_name = sort_name
    def get_gender(self):
        return self.gender
    def set_gender(self, gender):
        self.gender = gender
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_begin_area(self):
        return self.begin_area
    def set_begin_area(self, begin_area):
        self.begin_area = begin_area
    def get_end_area(self):
        return self.end_area
    def set_end_area(self, end_area):
        self.end_area = end_area
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_ipi(self):
        return self.ipi
    def set_ipi(self, ipi):
        self.ipi = ipi
    def get_ipi_list(self):
        return self.ipi_list
    def set_ipi_list(self, ipi_list):
        self.ipi_list = ipi_list
    def get_isni_list(self):
        return self.isni_list
    def set_isni_list(self, isni_list):
        self.isni_list = isni_list
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_recording_list(self):
        return self.recording_list
    def set_recording_list(self, recording_list):
        self.recording_list = recording_list
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_release_group_list(self):
        return self.release_group_list
    def set_release_group_list(self, release_group_list):
        self.release_group_list = release_group_list
    def get_work_list(self):
        return self.work_list
    def set_work_list(self, work_list):
        self.work_list = work_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.gender is not None or
            self.country is not None or
            self.area is not None or
            self.begin_area is not None or
            self.end_area is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.ipi is not None or
            self.ipi_list is not None or
            self.isni_list is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.recording_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.work_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('artist')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'artist':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='artist')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='artist', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='artist'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.sort_name is not None:
            namespaceprefix_ = self.sort_name_nsprefix_ + ':' if (UseCapturedNS_ and self.sort_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespaceprefix_ , eol_))
        if self.gender is not None:
            namespaceprefix_ = self.gender_nsprefix_ + ':' if (UseCapturedNS_ and self.gender_nsprefix_) else ''
            self.gender.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='gender', pretty_print=pretty_print)
        if self.country is not None:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            self.country.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='country', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.begin_area is not None:
            namespaceprefix_ = self.begin_area_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_area_nsprefix_) else ''
            self.begin_area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='begin-area', pretty_print=pretty_print)
        if self.end_area is not None:
            namespaceprefix_ = self.end_area_nsprefix_ + ':' if (UseCapturedNS_ and self.end_area_nsprefix_) else ''
            self.end_area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='end-area', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.ipi is not None:
            namespaceprefix_ = self.ipi_nsprefix_ + ':' if (UseCapturedNS_ and self.ipi_nsprefix_) else ''
            self.ipi.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='ipi', pretty_print=pretty_print)
        if self.ipi_list is not None:
            namespaceprefix_ = self.ipi_list_nsprefix_ + ':' if (UseCapturedNS_ and self.ipi_list_nsprefix_) else ''
            self.ipi_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='ipi-list', pretty_print=pretty_print)
        if self.isni_list is not None:
            namespaceprefix_ = self.isni_list_nsprefix_ + ':' if (UseCapturedNS_ and self.isni_list_nsprefix_) else ''
            self.isni_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isni-list', pretty_print=pretty_print)
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            namespaceprefix_ = self.recording_list_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_list_nsprefix_) else ''
            self.recording_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording-list', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            namespaceprefix_ = self.release_group_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_list_nsprefix_) else ''
            self.release_group_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group-list', pretty_print=pretty_print)
        if self.work_list is not None:
            namespaceprefix_ = self.work_list_nsprefix_ + ':' if (UseCapturedNS_ and self.work_list_nsprefix_) else ''
            self.work_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='artist', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.gender is not None:
            gender_ = self.gender
            gender_.to_etree(element, name_='gender', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.country is not None:
            country_ = self.country
            country_.to_etree(element, name_='country', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.begin_area is not None:
            begin_area_ = self.begin_area
            begin_area_.to_etree(element, name_='begin-area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.end_area is not None:
            end_area_ = self.end_area
            end_area_.to_etree(element, name_='end-area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.ipi is not None:
            ipi_ = self.ipi
            ipi_.to_etree(element, name_='ipi', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ipi_list is not None:
            ipi_list_ = self.ipi_list
            ipi_list_.to_etree(element, name_='ipi-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isni_list is not None:
            isni_list_ = self.isni_list
            isni_list_.to_etree(element, name_='isni-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'sort-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sort_name')
            value_ = self.gds_validate_string(value_, node, 'sort_name')
            self.sort_name = value_
            self.sort_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'gender':
            obj_ = gender.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gender = obj_
            obj_.original_tagname_ = 'gender'
        elif nodeName_ == 'country':
            obj_ = def_iso_3166_1_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'begin-area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin_area = obj_
            obj_.original_tagname_ = 'begin-area'
        elif nodeName_ == 'end-area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end_area = obj_
            obj_.original_tagname_ = 'end-area'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'ipi':
            obj_ = def_ipi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipi = obj_
            obj_.original_tagname_ = 'ipi'
        elif nodeName_ == 'ipi-list':
            obj_ = ipi_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipi_list = obj_
            obj_.original_tagname_ = 'ipi-list'
        elif nodeName_ == 'isni-list':
            obj_ = isni_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isni_list = obj_
            obj_.original_tagname_ = 'isni-list'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class artist


class gender(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gender)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gender.subclass:
            return gender.subclass(*args_, **kwargs_)
        else:
            return gender(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='gender', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gender')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gender':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gender')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='gender'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='gender', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='gender', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class gender


class life_span(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None, ended=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.begin = begin
        self.begin_nsprefix_ = "mmd-2.0"
        self.end = end
        self.end_nsprefix_ = "mmd-2.0"
        self.ended = ended
        self.validate_ended(self.ended)
        self.ended_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_span)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_span.subclass:
            return life_span.subclass(*args_, **kwargs_)
        else:
            return life_span(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_ended(self):
        return self.ended
    def set_ended(self, ended):
        self.ended = ended
    def validate_ended(self, value):
        result = True
        # Validate type ended, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (
            self.begin is not None or
            self.end is not None or
            self.ended is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-span', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('life-span')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'life-span':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='life-span')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='life-span', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='life-span'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-span', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.ended is not None:
            namespaceprefix_ = self.ended_nsprefix_ + ':' if (UseCapturedNS_ and self.ended_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sended>%s</%sended>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ended), input_name='ended')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='life-span', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.begin is not None:
            begin_ = self.begin
            begin_.to_etree(element, name_='begin', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.end is not None:
            end_ = self.end
            end_.to_etree(element, name_='end', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ended is not None:
            ended_ = self.ended
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ended').text = self.gds_format_string(ended_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'begin':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'ended':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ended')
            value_ = self.gds_validate_string(value_, node, 'ended')
            self.ended = value_
            self.ended_nsprefix_ = child_.prefix
            # validate type ended
            self.validate_ended(self.ended)
# end class life_span


class release(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, status=None, quality=None, annotation=None, disambiguation=None, packaging=None, text_representation=None, artist_credit=None, alias_list=None, release_group=None, date=None, country=None, release_event_list=None, barcode=None, asin=None, cover_art_archive=None, label_info_list=None, medium_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, collection_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.status = status
        self.status_nsprefix_ = "mmd-2.0"
        self.quality = quality
        self.quality_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.packaging = packaging
        self.packaging_nsprefix_ = "mmd-2.0"
        self.text_representation = text_representation
        self.text_representation_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        self.release_group = release_group
        self.release_group_nsprefix_ = "mmd-2.0"
        self.date = date
        self.date_nsprefix_ = "mmd-2.0"
        self.country = country
        self.country_nsprefix_ = "mmd-2.0"
        self.release_event_list = release_event_list
        self.release_event_list_nsprefix_ = "mmd-2.0"
        self.barcode = barcode
        self.barcode_nsprefix_ = "mmd-2.0"
        self.asin = asin
        self.validate_asin(self.asin)
        self.asin_nsprefix_ = "mmd-2.0"
        self.cover_art_archive = cover_art_archive
        self.cover_art_archive_nsprefix_ = "mmd-2.0"
        self.label_info_list = label_info_list
        self.label_info_list_nsprefix_ = "mmd-2.0"
        self.medium_list = medium_list
        self.medium_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.collection_list = collection_list
        self.collection_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release.subclass:
            return release.subclass(*args_, **kwargs_)
        else:
            return release(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_quality(self):
        return self.quality
    def set_quality(self, quality):
        self.quality = quality
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_packaging(self):
        return self.packaging
    def set_packaging(self, packaging):
        self.packaging = packaging
    def get_text_representation(self):
        return self.text_representation
    def set_text_representation(self, text_representation):
        self.text_representation = text_representation
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_release_group(self):
        return self.release_group
    def set_release_group(self, release_group):
        self.release_group = release_group
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_release_event_list(self):
        return self.release_event_list
    def set_release_event_list(self, release_event_list):
        self.release_event_list = release_event_list
    def get_barcode(self):
        return self.barcode
    def set_barcode(self, barcode):
        self.barcode = barcode
    def get_asin(self):
        return self.asin
    def set_asin(self, asin):
        self.asin = asin
    def get_cover_art_archive(self):
        return self.cover_art_archive
    def set_cover_art_archive(self, cover_art_archive):
        self.cover_art_archive = cover_art_archive
    def get_label_info_list(self):
        return self.label_info_list
    def set_label_info_list(self, label_info_list):
        self.label_info_list = label_info_list
    def get_medium_list(self):
        return self.medium_list
    def set_medium_list(self, medium_list):
        self.medium_list = medium_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_collection_list(self):
        return self.collection_list
    def set_collection_list(self, collection_list):
        self.collection_list = collection_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_asin(self, value):
        result = True
        # Validate type asin, a restriction on xs:string.
        pass
        return result
    def has__content(self):
        if (
            self.title is not None or
            self.status is not None or
            self.quality is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.packaging is not None or
            self.text_representation is not None or
            self.artist_credit is not None or
            self.alias_list is not None or
            self.release_group is not None or
            self.date is not None or
            self.country is not None or
            self.release_event_list is not None or
            self.barcode is not None or
            self.asin is not None or
            self.cover_art_archive is not None or
            self.label_info_list is not None or
            self.medium_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.collection_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.status is not None:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            self.status.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='status', pretty_print=pretty_print)
        if self.quality is not None:
            namespaceprefix_ = self.quality_nsprefix_ + ':' if (UseCapturedNS_ and self.quality_nsprefix_) else ''
            self.quality.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='quality', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.packaging is not None:
            namespaceprefix_ = self.packaging_nsprefix_ + ':' if (UseCapturedNS_ and self.packaging_nsprefix_) else ''
            self.packaging.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='packaging', pretty_print=pretty_print)
        if self.text_representation is not None:
            namespaceprefix_ = self.text_representation_nsprefix_ + ':' if (UseCapturedNS_ and self.text_representation_nsprefix_) else ''
            self.text_representation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='text-representation', pretty_print=pretty_print)
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        if self.release_group is not None:
            namespaceprefix_ = self.release_group_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_nsprefix_) else ''
            self.release_group.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group', pretty_print=pretty_print)
        if self.date is not None:
            namespaceprefix_ = self.date_nsprefix_ + ':' if (UseCapturedNS_ and self.date_nsprefix_) else ''
            self.date.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='date', pretty_print=pretty_print)
        if self.country is not None:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            self.country.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='country', pretty_print=pretty_print)
        if self.release_event_list is not None:
            namespaceprefix_ = self.release_event_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_event_list_nsprefix_) else ''
            self.release_event_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-event-list', pretty_print=pretty_print)
        if self.barcode is not None:
            namespaceprefix_ = self.barcode_nsprefix_ + ':' if (UseCapturedNS_ and self.barcode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbarcode>%s</%sbarcode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.barcode), input_name='barcode')), namespaceprefix_ , eol_))
        if self.asin is not None:
            namespaceprefix_ = self.asin_nsprefix_ + ':' if (UseCapturedNS_ and self.asin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasin>%s</%sasin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.asin), input_name='asin')), namespaceprefix_ , eol_))
        if self.cover_art_archive is not None:
            namespaceprefix_ = self.cover_art_archive_nsprefix_ + ':' if (UseCapturedNS_ and self.cover_art_archive_nsprefix_) else ''
            self.cover_art_archive.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='cover-art-archive', pretty_print=pretty_print)
        if self.label_info_list is not None:
            namespaceprefix_ = self.label_info_list_nsprefix_ + ':' if (UseCapturedNS_ and self.label_info_list_nsprefix_) else ''
            self.label_info_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label-info-list', pretty_print=pretty_print)
        if self.medium_list is not None:
            namespaceprefix_ = self.medium_list_nsprefix_ + ':' if (UseCapturedNS_ and self.medium_list_nsprefix_) else ''
            self.medium_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='medium-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.collection_list is not None:
            namespaceprefix_ = self.collection_list_nsprefix_ + ':' if (UseCapturedNS_ and self.collection_list_nsprefix_) else ''
            self.collection_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='collection-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='release', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.status is not None:
            status_ = self.status
            status_.to_etree(element, name_='status', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.quality is not None:
            quality_ = self.quality
            quality_.to_etree(element, name_='quality', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.packaging is not None:
            packaging_ = self.packaging
            packaging_.to_etree(element, name_='packaging', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.text_representation is not None:
            text_representation_ = self.text_representation
            text_representation_.to_etree(element, name_='text-representation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.date is not None:
            date_ = self.date
            date_.to_etree(element, name_='date', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.country is not None:
            country_ = self.country
            country_.to_etree(element, name_='country', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_event_list is not None:
            release_event_list_ = self.release_event_list
            release_event_list_.to_etree(element, name_='release-event-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.barcode is not None:
            barcode_ = self.barcode
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}barcode').text = self.gds_format_string(barcode_)
        if self.asin is not None:
            asin_ = self.asin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}asin').text = self.gds_format_string(asin_)
        if self.cover_art_archive is not None:
            cover_art_archive_ = self.cover_art_archive
            cover_art_archive_.to_etree(element, name_='cover-art-archive', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.label_info_list is not None:
            label_info_list_ = self.label_info_list
            label_info_list_.to_etree(element, name_='label-info-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.medium_list is not None:
            medium_list_ = self.medium_list
            medium_list_.to_etree(element, name_='medium-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.collection_list is not None:
            collection_list_ = self.collection_list
            collection_list_.to_etree(element, name_='collection-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'status':
            obj_ = status.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'quality':
            obj_ = def_quality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quality = obj_
            obj_.original_tagname_ = 'quality'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'packaging':
            obj_ = packaging.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packaging = obj_
            obj_.original_tagname_ = 'packaging'
        elif nodeName_ == 'text-representation':
            obj_ = text_representation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text_representation = obj_
            obj_.original_tagname_ = 'text-representation'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'date':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.date = obj_
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'country':
            obj_ = def_iso_3166_1_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'release-event-list':
            obj_ = release_event_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_event_list = obj_
            obj_.original_tagname_ = 'release-event-list'
        elif nodeName_ == 'barcode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'barcode')
            value_ = self.gds_validate_string(value_, node, 'barcode')
            self.barcode = value_
            self.barcode_nsprefix_ = child_.prefix
        elif nodeName_ == 'asin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'asin')
            value_ = self.gds_validate_string(value_, node, 'asin')
            self.asin = value_
            self.asin_nsprefix_ = child_.prefix
            # validate type asin
            self.validate_asin(self.asin)
        elif nodeName_ == 'cover-art-archive':
            obj_ = cover_art_archive.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cover_art_archive = obj_
            obj_.original_tagname_ = 'cover-art-archive'
        elif nodeName_ == 'label-info-list':
            obj_ = label_info_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label_info_list = obj_
            obj_.original_tagname_ = 'label-info-list'
        elif nodeName_ == 'medium-list':
            obj_ = medium_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.medium_list = obj_
            obj_.original_tagname_ = 'medium-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'collection-list':
            obj_ = collection_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.collection_list = obj_
            obj_.original_tagname_ = 'collection-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class release


class status(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, status)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='status', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('status')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'status':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='status')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='status'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='status', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='status', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class status


class packaging(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packaging)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packaging.subclass:
            return packaging.subclass(*args_, **kwargs_)
        else:
            return packaging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='packaging', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('packaging')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'packaging':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='packaging')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='packaging'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='packaging', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='packaging', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class packaging


class text_representation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, script=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.language = language
        self.validate_def_iso_639(self.language)
        self.language_nsprefix_ = "mmd-2.0"
        self.script = script
        self.script_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, text_representation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if text_representation.subclass:
            return text_representation.subclass(*args_, **kwargs_)
        else:
            return text_representation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def validate_def_iso_639(self, value):
        result = True
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_639_patterns_, ))
                result = False
        return result
    validate_def_iso_639_patterns_ = [['^([a-z]{3})$']]
    def has__content(self):
        if (
            self.language is not None or
            self.script is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='text-representation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('text-representation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'text-representation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='text-representation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='text-representation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='text-representation'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='text-representation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.script is not None:
            namespaceprefix_ = self.script_nsprefix_ + ':' if (UseCapturedNS_ and self.script_nsprefix_) else ''
            self.script.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='script', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='text-representation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}language').text = self.gds_format_string(language_)
        if self.script is not None:
            script_ = self.script
            script_.to_etree(element, name_='script', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
            # validate type def_iso-639
            self.validate_def_iso_639(self.language)
        elif nodeName_ == 'script':
            obj_ = def_iso_15924.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.script = obj_
            obj_.original_tagname_ = 'script'
# end class text_representation


class asin(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, asin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if asin.subclass:
            return asin.subclass(*args_, **kwargs_)
        else:
            return asin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_asin(self, value):
        result = True
        # Validate type asin, a restriction on xs:string.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='asin', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('asin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'asin':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='asin')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='asin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='asin'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='asin', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='asin', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class asin


class release_group(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, title=None, annotation=None, disambiguation=None, first_release_date=None, primary_type=None, secondary_type_list=None, artist_credit=None, release_list=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.first_release_date = first_release_date
        self.first_release_date_nsprefix_ = "mmd-2.0"
        self.primary_type = primary_type
        self.primary_type_nsprefix_ = "mmd-2.0"
        self.secondary_type_list = secondary_type_list
        self.secondary_type_list_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_group.subclass:
            return release_group.subclass(*args_, **kwargs_)
        else:
            return release_group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_first_release_date(self):
        return self.first_release_date
    def set_first_release_date(self, first_release_date):
        self.first_release_date = first_release_date
    def get_primary_type(self):
        return self.primary_type
    def set_primary_type(self, primary_type):
        self.primary_type = primary_type
    def get_secondary_type_list(self):
        return self.secondary_type_list
    def set_secondary_type_list(self, secondary_type_list):
        self.secondary_type_list = secondary_type_list
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.title is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.first_release_date is not None or
            self.primary_type is not None or
            self.secondary_type_list is not None or
            self.artist_credit is not None or
            self.release_list is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-group', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release-group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release-group':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release-group')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release-group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release-group'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.first_release_date is not None:
            namespaceprefix_ = self.first_release_date_nsprefix_ + ':' if (UseCapturedNS_ and self.first_release_date_nsprefix_) else ''
            self.first_release_date.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='first-release-date', pretty_print=pretty_print)
        if self.primary_type is not None:
            namespaceprefix_ = self.primary_type_nsprefix_ + ':' if (UseCapturedNS_ and self.primary_type_nsprefix_) else ''
            self.primary_type.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='primary-type', pretty_print=pretty_print)
        if self.secondary_type_list is not None:
            namespaceprefix_ = self.secondary_type_list_nsprefix_ + ':' if (UseCapturedNS_ and self.secondary_type_list_nsprefix_) else ''
            self.secondary_type_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='secondary-type-list', pretty_print=pretty_print)
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='release-group', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.first_release_date is not None:
            first_release_date_ = self.first_release_date
            first_release_date_.to_etree(element, name_='first-release-date', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.primary_type is not None:
            primary_type_ = self.primary_type
            primary_type_.to_etree(element, name_='primary-type', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.secondary_type_list is not None:
            secondary_type_list_ = self.secondary_type_list
            secondary_type_list_.to_etree(element, name_='secondary-type-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'first-release-date':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first_release_date = obj_
            obj_.original_tagname_ = 'first-release-date'
        elif nodeName_ == 'primary-type':
            obj_ = primary_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primary_type = obj_
            obj_.original_tagname_ = 'primary-type'
        elif nodeName_ == 'secondary-type-list':
            obj_ = secondary_type_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondary_type_list = obj_
            obj_.original_tagname_ = 'secondary-type-list'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class release_group


class primary_type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primary_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primary_type.subclass:
            return primary_type.subclass(*args_, **kwargs_)
        else:
            return primary_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='primary-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('primary-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'primary-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='primary-type')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='primary-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='primary-type', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='primary-type', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class primary_type


class secondary_type_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, secondary_type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if secondary_type is None:
            self.secondary_type = []
        else:
            self.secondary_type = secondary_type
        self.secondary_type_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondary_type_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondary_type_list.subclass:
            return secondary_type_list.subclass(*args_, **kwargs_)
        else:
            return secondary_type_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_secondary_type(self):
        return self.secondary_type
    def set_secondary_type(self, secondary_type):
        self.secondary_type = secondary_type
    def add_secondary_type(self, value):
        self.secondary_type.append(value)
    def insert_secondary_type_at(self, index, value):
        self.secondary_type.insert(index, value)
    def replace_secondary_type_at(self, index, value):
        self.secondary_type[index] = value
    def has__content(self):
        if (
            self.secondary_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='secondary-type-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('secondary-type-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'secondary-type-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='secondary-type-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='secondary-type-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='secondary-type-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='secondary-type-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for secondary_type_ in self.secondary_type:
            namespaceprefix_ = self.secondary_type_nsprefix_ + ':' if (UseCapturedNS_ and self.secondary_type_nsprefix_) else ''
            secondary_type_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='secondary-type', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='secondary-type-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for secondary_type_ in self.secondary_type:
            secondary_type_.to_etree(element, name_='secondary-type', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'secondary-type':
            obj_ = secondary_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondary_type.append(obj_)
            obj_.original_tagname_ = 'secondary-type'
# end class secondary_type_list


class secondary_type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondary_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondary_type.subclass:
            return secondary_type.subclass(*args_, **kwargs_)
        else:
            return secondary_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='secondary-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('secondary-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'secondary-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='secondary-type')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='secondary-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='secondary-type', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='secondary-type', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class secondary_type


class recording(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, length=None, annotation=None, disambiguation=None, video=None, artist_credit=None, first_release_date=None, release_list=None, alias_list=None, puid_list=None, isrc_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.length = length
        self.length_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.video = video
        self.validate_video(self.video)
        self.video_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.first_release_date = first_release_date
        self.first_release_date_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        self.puid_list = puid_list
        self.puid_list_nsprefix_ = "mmd-2.0"
        self.isrc_list = isrc_list
        self.isrc_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording.subclass:
            return recording.subclass(*args_, **kwargs_)
        else:
            return recording(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_video(self):
        return self.video
    def set_video(self, video):
        self.video = video
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_first_release_date(self):
        return self.first_release_date
    def set_first_release_date(self, first_release_date):
        self.first_release_date = first_release_date
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_puid_list(self):
        return self.puid_list
    def set_puid_list(self, puid_list):
        self.puid_list = puid_list
    def get_isrc_list(self):
        return self.isrc_list
    def set_isrc_list(self, isrc_list):
        self.isrc_list = isrc_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_video(self, value):
        result = True
        # Validate type video, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (
            self.title is not None or
            self.length is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.video is not None or
            self.artist_credit is not None or
            self.first_release_date is not None or
            self.release_list is not None or
            self.alias_list is not None or
            self.puid_list is not None or
            self.isrc_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='recording', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recording')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'recording':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recording')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recording', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='recording'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='recording', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.video is not None:
            namespaceprefix_ = self.video_nsprefix_ + ':' if (UseCapturedNS_ and self.video_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svideo>%s</%svideo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.video), input_name='video')), namespaceprefix_ , eol_))
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.first_release_date is not None:
            namespaceprefix_ = self.first_release_date_nsprefix_ + ':' if (UseCapturedNS_ and self.first_release_date_nsprefix_) else ''
            self.first_release_date.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='first-release-date', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        if self.puid_list is not None:
            namespaceprefix_ = self.puid_list_nsprefix_ + ':' if (UseCapturedNS_ and self.puid_list_nsprefix_) else ''
            self.puid_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='puid-list', pretty_print=pretty_print)
        if self.isrc_list is not None:
            namespaceprefix_ = self.isrc_list_nsprefix_ + ':' if (UseCapturedNS_ and self.isrc_list_nsprefix_) else ''
            self.isrc_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isrc-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='recording', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.video is not None:
            video_ = self.video
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}video').text = self.gds_format_string(video_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.first_release_date is not None:
            first_release_date_ = self.first_release_date
            first_release_date_.to_etree(element, name_='first-release-date', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.puid_list is not None:
            puid_list_ = self.puid_list
            puid_list_.to_etree(element, name_='puid-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isrc_list is not None:
            isrc_list_ = self.isrc_list
            isrc_list_.to_etree(element, name_='isrc-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'video':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'video')
            value_ = self.gds_validate_string(value_, node, 'video')
            self.video = value_
            self.video_nsprefix_ = child_.prefix
            # validate type video
            self.validate_video(self.video)
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'first-release-date':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first_release_date = obj_
            obj_.original_tagname_ = 'first-release-date'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'puid-list':
            obj_ = puid_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.puid_list = obj_
            obj_.original_tagname_ = 'puid-list'
        elif nodeName_ == 'isrc-list':
            obj_ = isrc_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isrc_list = obj_
            obj_.original_tagname_ = 'isrc-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class recording


class label(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, label_code=None, ipi=None, ipi_list=None, isni_list=None, annotation=None, disambiguation=None, country=None, area=None, life_span=None, alias_list=None, release_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.sort_name = sort_name
        self.sort_name_nsprefix_ = "mmd-2.0"
        self.label_code = label_code
        self.label_code_nsprefix_ = "mmd-2.0"
        self.ipi = ipi
        self.ipi_nsprefix_ = "mmd-2.0"
        self.ipi_list = ipi_list
        self.ipi_list_nsprefix_ = "mmd-2.0"
        self.isni_list = isni_list
        self.isni_list_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.country = country
        self.country_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sort_name(self):
        return self.sort_name
    def set_sort_name(self, sort_name):
        self.sort_name = sort_name
    def get_label_code(self):
        return self.label_code
    def set_label_code(self, label_code):
        self.label_code = label_code
    def get_ipi(self):
        return self.ipi
    def set_ipi(self, ipi):
        self.ipi = ipi
    def get_ipi_list(self):
        return self.ipi_list
    def set_ipi_list(self, ipi_list):
        self.ipi_list = ipi_list
    def get_isni_list(self):
        return self.isni_list
    def set_isni_list(self, isni_list):
        self.isni_list = isni_list
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.label_code is not None or
            self.ipi is not None or
            self.ipi_list is not None or
            self.isni_list is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.country is not None or
            self.area is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.release_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'label':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='label'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.sort_name is not None:
            namespaceprefix_ = self.sort_name_nsprefix_ + ':' if (UseCapturedNS_ and self.sort_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespaceprefix_ , eol_))
        if self.label_code is not None:
            namespaceprefix_ = self.label_code_nsprefix_ + ':' if (UseCapturedNS_ and self.label_code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabel-code>%s</%slabel-code>%s' % (namespaceprefix_ , self.gds_format_integer(self.label_code, input_name='label-code'), namespaceprefix_ , eol_))
        if self.ipi is not None:
            namespaceprefix_ = self.ipi_nsprefix_ + ':' if (UseCapturedNS_ and self.ipi_nsprefix_) else ''
            self.ipi.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='ipi', pretty_print=pretty_print)
        if self.ipi_list is not None:
            namespaceprefix_ = self.ipi_list_nsprefix_ + ':' if (UseCapturedNS_ and self.ipi_list_nsprefix_) else ''
            self.ipi_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='ipi-list', pretty_print=pretty_print)
        if self.isni_list is not None:
            namespaceprefix_ = self.isni_list_nsprefix_ + ':' if (UseCapturedNS_ and self.isni_list_nsprefix_) else ''
            self.isni_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isni-list', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.country is not None:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            self.country.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='country', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='label', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.label_code is not None:
            label_code_ = self.label_code
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}label-code').text = self.gds_format_integer(label_code_)
        if self.ipi is not None:
            ipi_ = self.ipi
            ipi_.to_etree(element, name_='ipi', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ipi_list is not None:
            ipi_list_ = self.ipi_list
            ipi_list_.to_etree(element, name_='ipi-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.isni_list is not None:
            isni_list_ = self.isni_list
            isni_list_.to_etree(element, name_='isni-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.country is not None:
            country_ = self.country
            country_.to_etree(element, name_='country', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'sort-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sort_name')
            value_ = self.gds_validate_string(value_, node, 'sort_name')
            self.sort_name = value_
            self.sort_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'label-code' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'label_code')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'label_code')
            self.label_code = ival_
            self.label_code_nsprefix_ = child_.prefix
        elif nodeName_ == 'ipi':
            obj_ = def_ipi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipi = obj_
            obj_.original_tagname_ = 'ipi'
        elif nodeName_ == 'ipi-list':
            obj_ = ipi_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipi_list = obj_
            obj_.original_tagname_ = 'ipi-list'
        elif nodeName_ == 'isni-list':
            obj_ = isni_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isni_list = obj_
            obj_.original_tagname_ = 'isni-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'country':
            obj_ = def_iso_3166_1_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class label


class work(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, title=None, language=None, language_list=None, artist_credit=None, iswc=None, iswc_list=None, attribute_list=None, annotation=None, disambiguation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.language = language
        self.validate_def_iso_639(self.language)
        self.language_nsprefix_ = "mmd-2.0"
        self.language_list = language_list
        self.language_list_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.iswc = iswc
        self.validate_iswc(self.iswc)
        self.iswc_nsprefix_ = "mmd-2.0"
        self.iswc_list = iswc_list
        self.iswc_list_nsprefix_ = "mmd-2.0"
        self.attribute_list = attribute_list
        self.attribute_list_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, work)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if work.subclass:
            return work.subclass(*args_, **kwargs_)
        else:
            return work(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_language_list(self):
        return self.language_list
    def set_language_list(self, language_list):
        self.language_list = language_list
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_iswc(self):
        return self.iswc
    def set_iswc(self, iswc):
        self.iswc = iswc
    def get_iswc_list(self):
        return self.iswc_list
    def set_iswc_list(self, iswc_list):
        self.iswc_list = iswc_list
    def get_attribute_list(self):
        return self.attribute_list
    def set_attribute_list(self, attribute_list):
        self.attribute_list = attribute_list
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_iso_639(self, value):
        result = True
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_639_patterns_, ))
                result = False
        return result
    validate_def_iso_639_patterns_ = [['^([a-z]{3})$']]
    def validate_iswc(self, value):
        result = True
        # Validate type iswc, a restriction on xs:token.
        pass
        return result
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.title is not None or
            self.language is not None or
            self.language_list is not None or
            self.artist_credit is not None or
            self.iswc is not None or
            self.iswc_list is not None or
            self.attribute_list is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='work', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('work')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'work':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='work')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='work', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='work'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='work', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.language_list is not None:
            namespaceprefix_ = self.language_list_nsprefix_ + ':' if (UseCapturedNS_ and self.language_list_nsprefix_) else ''
            self.language_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='language-list', pretty_print=pretty_print)
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.iswc is not None:
            namespaceprefix_ = self.iswc_nsprefix_ + ':' if (UseCapturedNS_ and self.iswc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siswc>%s</%siswc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.iswc), input_name='iswc')), namespaceprefix_ , eol_))
        if self.iswc_list is not None:
            namespaceprefix_ = self.iswc_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iswc_list_nsprefix_) else ''
            self.iswc_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iswc-list', pretty_print=pretty_print)
        if self.attribute_list is not None:
            namespaceprefix_ = self.attribute_list_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_list_nsprefix_) else ''
            self.attribute_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute-list', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='work', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}language').text = self.gds_format_string(language_)
        if self.language_list is not None:
            language_list_ = self.language_list
            language_list_.to_etree(element, name_='language-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.iswc is not None:
            iswc_ = self.iswc
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iswc').text = self.gds_format_string(iswc_)
        if self.iswc_list is not None:
            iswc_list_ = self.iswc_list
            iswc_list_.to_etree(element, name_='iswc-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.attribute_list is not None:
            attribute_list_ = self.attribute_list
            attribute_list_.to_etree(element, name_='attribute-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
            # validate type def_iso-639
            self.validate_def_iso_639(self.language)
        elif nodeName_ == 'language-list':
            obj_ = language_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language_list = obj_
            obj_.original_tagname_ = 'language-list'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'iswc':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'iswc')
            value_ = self.gds_validate_string(value_, node, 'iswc')
            self.iswc = value_
            self.iswc_nsprefix_ = child_.prefix
            # validate type iswc
            self.validate_iswc(self.iswc)
        elif nodeName_ == 'iswc-list':
            obj_ = iswc_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iswc_list = obj_
            obj_.original_tagname_ = 'iswc-list'
        elif nodeName_ == 'attribute-list':
            obj_ = attribute_listType31.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute_list = obj_
            obj_.original_tagname_ = 'attribute-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class work


class def_area_element_inner(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, disambiguation=None, iso_3166_1_code_list=None, iso_3166_2_code_list=None, iso_3166_3_code_list=None, annotation=None, life_span=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.sort_name = sort_name
        self.sort_name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.iso_3166_1_code_list = iso_3166_1_code_list
        self.iso_3166_1_code_list_nsprefix_ = "mmd-2.0"
        self.iso_3166_2_code_list = iso_3166_2_code_list
        self.iso_3166_2_code_list_nsprefix_ = "mmd-2.0"
        self.iso_3166_3_code_list = iso_3166_3_code_list
        self.iso_3166_3_code_list_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_area_element_inner)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_area_element_inner.subclass:
            return def_area_element_inner.subclass(*args_, **kwargs_)
        else:
            return def_area_element_inner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sort_name(self):
        return self.sort_name
    def set_sort_name(self, sort_name):
        self.sort_name = sort_name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_iso_3166_1_code_list(self):
        return self.iso_3166_1_code_list
    def set_iso_3166_1_code_list(self, iso_3166_1_code_list):
        self.iso_3166_1_code_list = iso_3166_1_code_list
    def get_iso_3166_2_code_list(self):
        return self.iso_3166_2_code_list
    def set_iso_3166_2_code_list(self, iso_3166_2_code_list):
        self.iso_3166_2_code_list = iso_3166_2_code_list
    def get_iso_3166_3_code_list(self):
        return self.iso_3166_3_code_list
    def set_iso_3166_3_code_list(self, iso_3166_3_code_list):
        self.iso_3166_3_code_list = iso_3166_3_code_list
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.disambiguation is not None or
            self.iso_3166_1_code_list is not None or
            self.iso_3166_2_code_list is not None or
            self.iso_3166_3_code_list is not None or
            self.annotation is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_area-element_inner', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_area-element_inner')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_area-element_inner':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_area-element_inner')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='def_area-element_inner', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='def_area-element_inner'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_area-element_inner', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.sort_name is not None:
            namespaceprefix_ = self.sort_name_nsprefix_ + ':' if (UseCapturedNS_ and self.sort_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.iso_3166_1_code_list is not None:
            namespaceprefix_ = self.iso_3166_1_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_1_code_list_nsprefix_) else ''
            self.iso_3166_1_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-1-code-list', pretty_print=pretty_print)
        if self.iso_3166_2_code_list is not None:
            namespaceprefix_ = self.iso_3166_2_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_2_code_list_nsprefix_) else ''
            self.iso_3166_2_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-2-code-list', pretty_print=pretty_print)
        if self.iso_3166_3_code_list is not None:
            namespaceprefix_ = self.iso_3166_3_code_list_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_3_code_list_nsprefix_) else ''
            self.iso_3166_3_code_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-3-code-list', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def to_etree(self, parent_element=None, name_='def_area-element_inner', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.iso_3166_1_code_list is not None:
            iso_3166_1_code_list_ = self.iso_3166_1_code_list
            iso_3166_1_code_list_.to_etree(element, name_='iso-3166-1-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.iso_3166_2_code_list is not None:
            iso_3166_2_code_list_ = self.iso_3166_2_code_list
            iso_3166_2_code_list_.to_etree(element, name_='iso-3166-2-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.iso_3166_3_code_list is not None:
            iso_3166_3_code_list_ = self.iso_3166_3_code_list
            iso_3166_3_code_list_.to_etree(element, name_='iso-3166-3-code-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.to_etree(element, mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'sort-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sort_name')
            value_ = self.gds_validate_string(value_, node, 'sort_name')
            self.sort_name = value_
            self.sort_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'iso-3166-1-code-list':
            obj_ = iso_3166_1_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_1_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-1-code-list'
        elif nodeName_ == 'iso-3166-2-code-list':
            obj_ = iso_3166_2_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_2_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-2-code-list'
        elif nodeName_ == 'iso-3166-3-code-list':
            obj_ = iso_3166_3_code_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_3_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-3-code-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        else:
            content_ = self.gds_build_any(child_, 'def_area-element_inner')
            self.set_anytypeobjs_(content_)
# end class def_area_element_inner


class place(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, address=None, coordinates=None, annotation=None, area=None, life_span=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.address = address
        self.address_nsprefix_ = "mmd-2.0"
        self.coordinates = coordinates
        self.coordinates_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if place.subclass:
            return place.subclass(*args_, **kwargs_)
        else:
            return place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def get_coordinates(self):
        return self.coordinates
    def set_coordinates(self, coordinates):
        self.coordinates = coordinates
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.address is not None or
            self.coordinates is not None or
            self.annotation is not None or
            self.area is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='place', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('place')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'place':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='place')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='place'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.address is not None:
            namespaceprefix_ = self.address_nsprefix_ + ':' if (UseCapturedNS_ and self.address_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.coordinates is not None:
            namespaceprefix_ = self.coordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.coordinates_nsprefix_) else ''
            self.coordinates.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='coordinates', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='place', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.address is not None:
            address_ = self.address
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}address').text = self.gds_format_string(address_)
        if self.coordinates is not None:
            coordinates_ = self.coordinates
            coordinates_.to_etree(element, name_='coordinates', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
        elif nodeName_ == 'coordinates':
            obj_ = coordinates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coordinates = obj_
            obj_.original_tagname_ = 'coordinates'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class place


class coordinates(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, latitude=None, longitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.latitude = latitude
        self.latitude_nsprefix_ = "mmd-2.0"
        self.longitude = longitude
        self.longitude_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, coordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if coordinates.subclass:
            return coordinates.subclass(*args_, **kwargs_)
        else:
            return coordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_latitude(self):
        return self.latitude
    def set_latitude(self, latitude):
        self.latitude = latitude
    def get_longitude(self):
        return self.longitude
    def set_longitude(self, longitude):
        self.longitude = longitude
    def has__content(self):
        if (
            self.latitude is not None or
            self.longitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='coordinates', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('coordinates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'coordinates':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='coordinates')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='coordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='coordinates'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='coordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.latitude is not None:
            namespaceprefix_ = self.latitude_nsprefix_ + ':' if (UseCapturedNS_ and self.latitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude>%s</%slatitude>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.latitude), input_name='latitude')), namespaceprefix_ , eol_))
        if self.longitude is not None:
            namespaceprefix_ = self.longitude_nsprefix_ + ':' if (UseCapturedNS_ and self.longitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.longitude), input_name='longitude')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='coordinates', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.latitude is not None:
            latitude_ = self.latitude
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}latitude').text = self.gds_format_string(latitude_)
        if self.longitude is not None:
            longitude_ = self.longitude
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}longitude').text = self.gds_format_string(longitude_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'latitude':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'latitude')
            value_ = self.gds_validate_string(value_, node, 'latitude')
            self.latitude = value_
            self.latitude_nsprefix_ = child_.prefix
        elif nodeName_ == 'longitude':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'longitude')
            value_ = self.gds_validate_string(value_, node, 'longitude')
            self.longitude = value_
            self.longitude_nsprefix_ = child_.prefix
# end class coordinates


class instrument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, description=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.description = description
        self.description_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument.subclass:
            return instrument.subclass(*args_, **kwargs_)
        else:
            return instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.description is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='instrument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instrument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instrument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instrument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='instrument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='instrument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='instrument', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}description').text = self.gds_format_string(description_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class instrument


class series(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, series)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if series.subclass:
            return series.subclass(*args_, **kwargs_)
        else:
            return series(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='series', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('series')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'series':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='series')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='series', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='series'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='series', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='series', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class series


class event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, cancelled=None, life_span=None, time=None, setlist=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, genre_list=None, user_genre_list=None, rating=None, user_rating=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.cancelled = cancelled
        self.validate_cancelled(self.cancelled)
        self.cancelled_nsprefix_ = "mmd-2.0"
        self.life_span = life_span
        self.life_span_nsprefix_ = "mmd-2.0"
        self.time = time
        self.time_nsprefix_ = "mmd-2.0"
        self.setlist = setlist
        self.setlist_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
        self.tag_list = tag_list
        self.tag_list_nsprefix_ = "mmd-2.0"
        self.user_tag_list = user_tag_list
        self.user_tag_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.user_genre_list = user_genre_list
        self.user_genre_list_nsprefix_ = "mmd-2.0"
        self.rating = rating
        self.rating_nsprefix_ = "mmd-2.0"
        self.user_rating = user_rating
        self.user_rating_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_cancelled(self):
        return self.cancelled
    def set_cancelled(self, cancelled):
        self.cancelled = cancelled
    def get_life_span(self):
        return self.life_span
    def set_life_span(self, life_span):
        self.life_span = life_span
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_setlist(self):
        return self.setlist
    def set_setlist(self, setlist):
        self.setlist = setlist
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_tag_list(self):
        return self.tag_list
    def set_tag_list(self, tag_list):
        self.tag_list = tag_list
    def get_user_tag_list(self):
        return self.user_tag_list
    def set_user_tag_list(self, user_tag_list):
        self.user_tag_list = user_tag_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_user_genre_list(self):
        return self.user_genre_list
    def set_user_genre_list(self, user_genre_list):
        self.user_genre_list = user_genre_list
    def get_rating(self):
        return self.rating
    def set_rating(self, rating):
        self.rating = rating
    def get_user_rating(self):
        return self.user_rating
    def set_user_rating(self, user_rating):
        self.user_rating = user_rating
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_cancelled(self, value):
        result = True
        # Validate type cancelled, a restriction on xs:token.
        pass
        return result
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.cancelled is not None or
            self.life_span is not None or
            self.time is not None or
            self.setlist is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.genre_list is not None or
            self.user_genre_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='event')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='event'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.cancelled is not None:
            namespaceprefix_ = self.cancelled_nsprefix_ + ':' if (UseCapturedNS_ and self.cancelled_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelled>%s</%scancelled>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cancelled), input_name='cancelled')), namespaceprefix_ , eol_))
        if self.life_span is not None:
            namespaceprefix_ = self.life_span_nsprefix_ + ':' if (UseCapturedNS_ and self.life_span_nsprefix_) else ''
            self.life_span.export(outfile, level, namespaceprefix_, namespacedef_='', name_='life-span', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.setlist is not None:
            namespaceprefix_ = self.setlist_nsprefix_ + ':' if (UseCapturedNS_ and self.setlist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetlist>%s</%ssetlist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.setlist), input_name='setlist')), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            namespaceprefix_ = self.tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_list_nsprefix_) else ''
            self.tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            namespaceprefix_ = self.user_tag_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_list_nsprefix_) else ''
            self.user_tag_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.user_genre_list is not None:
            namespaceprefix_ = self.user_genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_list_nsprefix_) else ''
            self.user_genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre-list', pretty_print=pretty_print)
        if self.rating is not None:
            namespaceprefix_ = self.rating_nsprefix_ + ':' if (UseCapturedNS_ and self.rating_nsprefix_) else ''
            self.rating.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            namespaceprefix_ = self.user_rating_nsprefix_ + ':' if (UseCapturedNS_ and self.user_rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespaceprefix_ , self.gds_format_integer(self.user_rating, input_name='user-rating'), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='event', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.cancelled is not None:
            cancelled_ = self.cancelled
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}cancelled').text = self.gds_format_string(cancelled_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.time is not None:
            time_ = self.time
            time_.to_etree(element, name_='time', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.setlist is not None:
            setlist_ = self.setlist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}setlist').text = self.gds_format_string(setlist_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_genre_list is not None:
            user_genre_list_ = self.user_genre_list
            user_genre_list_.to_etree(element, name_='user-genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'cancelled':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'cancelled')
            value_ = self.gds_validate_string(value_, node, 'cancelled')
            self.cancelled = value_
            self.cancelled_nsprefix_ = child_.prefix
            # validate type cancelled
            self.validate_cancelled(self.cancelled)
        elif nodeName_ == 'life-span':
            obj_ = life_spanType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'time':
            obj_ = def_time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'setlist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'setlist')
            value_ = self.gds_validate_string(value_, node, 'setlist')
            self.setlist = value_
            self.setlist_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'user-genre-list':
            obj_ = user_genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre_list = obj_
            obj_.original_tagname_ = 'user-genre-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'user_rating')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
            self.user_rating_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class event


class url(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, resource=None, relation_list=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.resource = resource
        self.resource_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if url.subclass:
            return url.subclass(*args_, **kwargs_)
        else:
            return url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_resource(self):
        return self.resource
    def set_resource(self, resource):
        self.resource = resource
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            self.resource is not None or
            self.relation_list
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='url', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'url':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='url')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='url'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='url', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resource is not None:
            namespaceprefix_ = self.resource_nsprefix_ + ':' if (UseCapturedNS_ and self.resource_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresource>%s</%sresource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.resource), input_name='resource')), namespaceprefix_ , eol_))
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='url', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.resource is not None:
            resource_ = self.resource
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}resource').text = self.gds_format_string(resource_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'resource':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'resource')
            value_ = self.gds_validate_string(value_, node, 'resource')
            self.resource = value_
            self.resource_nsprefix_ = child_.prefix
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
# end class url


class disc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sectors=None, offset_list=None, release_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sectors = sectors
        self.sectors_nsprefix_ = "mmd-2.0"
        self.offset_list = offset_list
        self.offset_list_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, disc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if disc.subclass:
            return disc.subclass(*args_, **kwargs_)
        else:
            return disc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sectors(self):
        return self.sectors
    def set_sectors(self, sectors):
        self.sectors = sectors
    def get_offset_list(self):
        return self.offset_list
    def set_offset_list(self, offset_list):
        self.offset_list = offset_list
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_idType34(self, value):
        # Validate type idType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType34_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType34_patterns_, ))
    validate_idType34_patterns_ = [['^([a-zA-Z0-9._]{27}-)$']]
    def has__content(self):
        if (
            self.sectors is not None or
            self.offset_list is not None or
            self.release_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='disc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'disc':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disc')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='disc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='disc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='disc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sectors is not None:
            namespaceprefix_ = self.sectors_nsprefix_ + ':' if (UseCapturedNS_ and self.sectors_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssectors>%s</%ssectors>%s' % (namespaceprefix_ , self.gds_format_integer(self.sectors, input_name='sectors'), namespaceprefix_ , eol_))
        if self.offset_list is not None:
            namespaceprefix_ = self.offset_list_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_list_nsprefix_) else ''
            self.offset_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='offset-list', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='disc', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.sectors is not None:
            sectors_ = self.sectors
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sectors').text = self.gds_format_integer(sectors_)
        if self.offset_list is not None:
            offset_list_ = self.offset_list
            offset_list_.to_etree(element, name_='offset-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType34(self.id)    # validate type idType34
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sectors' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sectors')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sectors')
            self.sectors = ival_
            self.sectors_nsprefix_ = child_.prefix
        elif nodeName_ == 'offset-list':
            obj_ = offset_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset_list = obj_
            obj_.original_tagname_ = 'offset-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class disc


class puid(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, recording_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.recording_list = recording_list
        self.recording_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puid.subclass:
            return puid.subclass(*args_, **kwargs_)
        else:
            return puid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_recording_list(self):
        return self.recording_list
    def set_recording_list(self, recording_list):
        self.recording_list = recording_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.recording_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='puid', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('puid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'puid':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puid')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='puid', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='puid'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='puid', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_list is not None:
            namespaceprefix_ = self.recording_list_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_list_nsprefix_) else ''
            self.recording_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='puid', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'recording-list':
            obj_ = recording_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class puid


class isrc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, recording_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.recording_list = recording_list
        self.recording_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isrc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isrc.subclass:
            return isrc.subclass(*args_, **kwargs_)
        else:
            return isrc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_recording_list(self):
        return self.recording_list
    def set_recording_list(self, recording_list):
        self.recording_list = recording_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_isrc(self, value):
        # Validate type mmd-2.0:def_isrc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_isrc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_isrc_patterns_, ))
    validate_def_isrc_patterns_ = [['^([A-Z]{2}[A-Z0-9]{3}[0-9]{2}[0-9]{5})$']]
    def has__content(self):
        if (
            self.recording_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isrc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isrc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'isrc':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isrc')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='isrc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='isrc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isrc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_list is not None:
            namespaceprefix_ = self.recording_list_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_list_nsprefix_) else ''
            self.recording_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='isrc', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_isrc(self.id)    # validate type def_isrc
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'recording-list':
            obj_ = recording_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class isrc


class artist_credit(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name_credit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if name_credit is None:
            self.name_credit = []
        else:
            self.name_credit = name_credit
        self.name_credit_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist_credit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist_credit.subclass:
            return artist_credit.subclass(*args_, **kwargs_)
        else:
            return artist_credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name_credit(self):
        return self.name_credit
    def set_name_credit(self, name_credit):
        self.name_credit = name_credit
    def add_name_credit(self, value):
        self.name_credit.append(value)
    def insert_name_credit_at(self, index, value):
        self.name_credit.insert(index, value)
    def replace_name_credit_at(self, index, value):
        self.name_credit[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name_credit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist-credit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('artist-credit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'artist-credit':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='artist-credit')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='artist-credit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='artist-credit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist-credit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_credit_ in self.name_credit:
            namespaceprefix_ = self.name_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.name_credit_nsprefix_) else ''
            name_credit_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='name-credit', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='artist-credit', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for name_credit_ in self.name_credit:
            name_credit_.to_etree(element, name_='name-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name-credit':
            obj_ = name_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name_credit.append(obj_)
            obj_.original_tagname_ = 'name-credit'
# end class artist_credit


class name_credit(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, joinphrase=None, name=None, artist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.joinphrase = _cast(None, joinphrase)
        self.joinphrase_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, name_credit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if name_credit.subclass:
            return name_credit.subclass(*args_, **kwargs_)
        else:
            return name_credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_joinphrase(self):
        return self.joinphrase
    def set_joinphrase(self, joinphrase):
        self.joinphrase = joinphrase
    def has__content(self):
        if (
            self.name is not None or
            self.artist is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='name-credit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('name-credit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'name-credit':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='name-credit')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='name-credit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='name-credit'):
        if self.joinphrase is not None and 'joinphrase' not in already_processed:
            already_processed.add('joinphrase')
            outfile.write(' joinphrase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.joinphrase), input_name='joinphrase')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='name-credit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            self.artist.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='name-credit', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.joinphrase is not None:
            element.set('joinphrase', self.gds_format_string(self.joinphrase))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('joinphrase', node)
        if value is not None and 'joinphrase' not in already_processed:
            already_processed.add('joinphrase')
            self.joinphrase = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            obj_ = artist.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
# end class name_credit


class relation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, target=None, ordering_key=None, direction=None, attribute_list=None, begin=None, end=None, ended=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None, def_extension_element=None, source_credit=None, target_credit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.target = target
        self.target_nsprefix_ = "mmd-2.0"
        self.ordering_key = ordering_key
        self.ordering_key_nsprefix_ = "mmd-2.0"
        self.direction = direction
        self.direction_nsprefix_ = "mmd-2.0"
        self.attribute_list = attribute_list
        self.attribute_list_nsprefix_ = "mmd-2.0"
        self.begin = begin
        self.begin_nsprefix_ = "mmd-2.0"
        self.end = end
        self.end_nsprefix_ = "mmd-2.0"
        self.ended = ended
        self.validate_ended(self.ended)
        self.ended_nsprefix_ = "mmd-2.0"
        self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
        self.release = release
        self.release_nsprefix_ = "mmd-2.0"
        self.release_group = release_group
        self.release_group_nsprefix_ = "mmd-2.0"
        self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
        self.label = label
        self.label_nsprefix_ = "mmd-2.0"
        self.work = work
        self.work_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.place = place
        self.place_nsprefix_ = "mmd-2.0"
        self.instrument = instrument
        self.instrument_nsprefix_ = "mmd-2.0"
        self.series = series
        self.series_nsprefix_ = "mmd-2.0"
        self.event = event
        self.event_nsprefix_ = "mmd-2.0"
        self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
        self.source_credit = source_credit
        self.source_credit_nsprefix_ = "mmd-2.0"
        self.target_credit = target_credit
        self.target_credit_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_ordering_key(self):
        return self.ordering_key
    def set_ordering_key(self, ordering_key):
        self.ordering_key = ordering_key
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_attribute_list(self):
        return self.attribute_list
    def set_attribute_list(self, attribute_list):
        self.attribute_list = attribute_list
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_ended(self):
        return self.ended
    def set_ended(self, ended):
        self.ended = ended
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def get_release_group(self):
        return self.release_group
    def set_release_group(self, release_group):
        self.release_group = release_group
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def get_instrument(self):
        return self.instrument
    def set_instrument(self, instrument):
        self.instrument = instrument
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def get_source_credit(self):
        return self.source_credit
    def set_source_credit(self, source_credit):
        self.source_credit = source_credit
    def get_target_credit(self):
        return self.target_credit
    def set_target_credit(self, target_credit):
        self.target_credit = target_credit
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def validate_ended(self, value):
        result = True
        # Validate type ended, a restriction on xs:token.
        pass
        return result
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.target is not None or
            self.ordering_key is not None or
            self.direction is not None or
            self.attribute_list is not None or
            self.begin is not None or
            self.end is not None or
            self.ended is not None or
            self.artist is not None or
            self.release is not None or
            self.release_group is not None or
            self.recording is not None or
            self.label is not None or
            self.work is not None or
            self.area is not None or
            self.place is not None or
            self.instrument is not None or
            self.series is not None or
            self.event is not None or
            self.def_extension_element is not None or
            self.source_credit is not None or
            self.target_credit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='relation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('relation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'relation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='relation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='relation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='relation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='relation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.target is not None:
            namespaceprefix_ = self.target_nsprefix_ + ':' if (UseCapturedNS_ and self.target_nsprefix_) else ''
            self.target.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='target', pretty_print=pretty_print)
        if self.ordering_key is not None:
            namespaceprefix_ = self.ordering_key_nsprefix_ + ':' if (UseCapturedNS_ and self.ordering_key_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sordering-key>%s</%sordering-key>%s' % (namespaceprefix_ , self.gds_format_integer(self.ordering_key, input_name='ordering-key'), namespaceprefix_ , eol_))
        if self.direction is not None:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            self.direction.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='direction', pretty_print=pretty_print)
        if self.attribute_list is not None:
            namespaceprefix_ = self.attribute_list_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_list_nsprefix_) else ''
            self.attribute_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute-list', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.ended is not None:
            namespaceprefix_ = self.ended_nsprefix_ + ':' if (UseCapturedNS_ and self.ended_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sended>%s</%sended>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ended), input_name='ended')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            self.artist.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist', pretty_print=pretty_print)
        if self.release is not None:
            namespaceprefix_ = self.release_nsprefix_ + ':' if (UseCapturedNS_ and self.release_nsprefix_) else ''
            self.release.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release', pretty_print=pretty_print)
        if self.release_group is not None:
            namespaceprefix_ = self.release_group_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_nsprefix_) else ''
            self.release_group.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group', pretty_print=pretty_print)
        if self.recording is not None:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            self.recording.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
        if self.label is not None:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            self.label.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label', pretty_print=pretty_print)
        if self.work is not None:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            self.work.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.place is not None:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            self.place.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place', pretty_print=pretty_print)
        if self.instrument is not None:
            namespaceprefix_ = self.instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_nsprefix_) else ''
            self.instrument.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument', pretty_print=pretty_print)
        if self.series is not None:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            self.series.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series', pretty_print=pretty_print)
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.def_extension_element is not None:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.def_extension_element), input_name='def_extension_element')), namespaceprefix_ , eol_))
        if self.source_credit is not None:
            namespaceprefix_ = self.source_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.source_credit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-credit>%s</%ssource-credit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source_credit), input_name='source-credit')), namespaceprefix_ , eol_))
        if self.target_credit is not None:
            namespaceprefix_ = self.target_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.target_credit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget-credit>%s</%starget-credit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target_credit), input_name='target-credit')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='relation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.target is not None:
            target_ = self.target
            target_.to_etree(element, name_='target', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ordering_key is not None:
            ordering_key_ = self.ordering_key
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ordering-key').text = self.gds_format_integer(ordering_key_)
        if self.direction is not None:
            direction_ = self.direction
            direction_.to_etree(element, name_='direction', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.attribute_list is not None:
            attribute_list_ = self.attribute_list
            attribute_list_.to_etree(element, name_='attribute-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.begin is not None:
            begin_ = self.begin
            begin_.to_etree(element, name_='begin', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.end is not None:
            end_ = self.end
            end_.to_etree(element, name_='end', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.ended is not None:
            ended_ = self.ended
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ended').text = self.gds_format_string(ended_)
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release is not None:
            release_ = self.release
            release_.to_etree(element, name_='release', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.work is not None:
            work_ = self.work
            work_.to_etree(element, name_='work', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.place is not None:
            place_ = self.place
            place_.to_etree(element, name_='place', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.instrument is not None:
            instrument_ = self.instrument
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.series is not None:
            series_ = self.series
            series_.to_etree(element, name_='series', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.event is not None:
            event_ = self.event
            event_.to_etree(element, name_='event', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.def_extension_element is not None:
            def_extension_element_ = self.def_extension_element
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if self.source_credit is not None:
            source_credit_ = self.source_credit
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}source-credit').text = self.gds_format_string(source_credit_)
        if self.target_credit is not None:
            target_credit_ = self.target_credit
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}target-credit').text = self.gds_format_string(target_credit_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'target':
            obj_ = target.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target = obj_
            obj_.original_tagname_ = 'target'
        elif nodeName_ == 'ordering-key' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ordering_key')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ordering_key')
            self.ordering_key = ival_
            self.ordering_key_nsprefix_ = child_.prefix
        elif nodeName_ == 'direction':
            obj_ = def_direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction = obj_
            obj_.original_tagname_ = 'direction'
        elif nodeName_ == 'attribute-list':
            obj_ = attribute_listType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute_list = obj_
            obj_.original_tagname_ = 'attribute-list'
        elif nodeName_ == 'begin':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'ended':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ended')
            value_ = self.gds_validate_string(value_, node, 'ended')
            self.ended = value_
            self.ended_nsprefix_ = child_.prefix
            # validate type ended
            self.validate_ended(self.ended)
        elif nodeName_ == 'artist':
            obj_ = artist.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release = obj_
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument = obj_
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series = obj_
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element = value_
            self.def_extension_element_nsprefix_ = child_.prefix
        elif nodeName_ == 'source-credit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source_credit')
            value_ = self.gds_validate_string(value_, node, 'source_credit')
            self.source_credit = value_
            self.source_credit_nsprefix_ = child_.prefix
        elif nodeName_ == 'target-credit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'target_credit')
            value_ = self.gds_validate_string(value_, node, 'target_credit')
            self.target_credit = value_
            self.target_credit_nsprefix_ = child_.prefix
# end class relation


class target(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, target)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if target.subclass:
            return target.subclass(*args_, **kwargs_)
        else:
            return target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='target', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('target')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'target':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='target')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='target'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='target', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='target', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class target


class alias(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, locale=None, sort_name=None, type_=None, type_id=None, primary=None, begin_date=None, end_date=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.locale = _cast(None, locale)
        self.locale_nsprefix_ = None
        self.sort_name = _cast(None, sort_name)
        self.sort_name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.primary = _cast(None, primary)
        self.primary_nsprefix_ = None
        self.begin_date = _cast(None, begin_date)
        self.begin_date_nsprefix_ = None
        self.end_date = _cast(None, end_date)
        self.end_date_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alias)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alias.subclass:
            return alias.subclass(*args_, **kwargs_)
        else:
            return alias(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_locale(self):
        return self.locale
    def set_locale(self, locale):
        self.locale = locale
    def get_sort_name(self):
        return self.sort_name
    def set_sort_name(self, sort_name):
        self.sort_name = sort_name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_primary(self):
        return self.primary
    def set_primary(self, primary):
        self.primary = primary
    def get_begin_date(self):
        return self.begin_date
    def set_begin_date(self, begin_date):
        self.begin_date = begin_date
    def get_end_date(self):
        return self.end_date
    def set_end_date(self, end_date):
        self.end_date = end_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_locale(self, value):
        # Validate type mmd-2.0:def_locale, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_locale_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_locale_patterns_, ))
    validate_def_locale_patterns_ = [['^([a-z]{2}(_[A-Za-z]+)?)$']]
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='alias', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alias')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alias':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alias')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='alias'):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            outfile.write(' locale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.locale), input_name='locale')), ))
        if self.sort_name is not None and 'sort_name' not in already_processed:
            already_processed.add('sort_name')
            outfile.write(' sort-name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sort_name), input_name='sort-name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary), input_name='primary')), ))
        if self.begin_date is not None and 'begin_date' not in already_processed:
            already_processed.add('begin_date')
            outfile.write(' begin-date=%s' % (quote_attrib(self.begin_date), ))
        if self.end_date is not None and 'end_date' not in already_processed:
            already_processed.add('end_date')
            outfile.write(' end-date=%s' % (quote_attrib(self.end_date), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='alias', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='alias', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.locale is not None:
            element.set('locale', self.gds_format_string(self.locale))
        if self.sort_name is not None:
            element.set('sort-name', self.gds_format_string(self.sort_name))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.primary is not None:
            element.set('primary', self.gds_format_string(self.primary))
        if self.begin_date is not None:
            element.set('begin-date', self.begin_date)
        if self.end_date is not None:
            element.set('end-date', self.end_date)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            self.locale = value
            self.validate_def_locale(self.locale)    # validate type def_locale
        value = find_attr_value_('sort-name', node)
        if value is not None and 'sort-name' not in already_processed:
            already_processed.add('sort-name')
            self.sort_name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            self.primary = value
        value = find_attr_value_('begin-date', node)
        if value is not None and 'begin-date' not in already_processed:
            already_processed.add('begin-date')
            self.begin_date = value
        value = find_attr_value_('end-date', node)
        if value is not None and 'end-date' not in already_processed:
            already_processed.add('end-date')
            self.end_date = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class alias


class iswc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iswc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iswc.subclass:
            return iswc.subclass(*args_, **kwargs_)
        else:
            return iswc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_iswc(self, value):
        result = True
        # Validate type iswc, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iswc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iswc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'iswc':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iswc')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='iswc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='iswc'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iswc', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='iswc', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class iswc


class tag(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tag.subclass:
            return tag.subclass(*args_, **kwargs_)
        else:
            return tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def has__content(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='tag', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tag':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tag')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='tag'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='tag', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class tag


class user_tag(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_tag.subclass:
            return user_tag.subclass(*args_, **kwargs_)
        else:
            return user_tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def has__content(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-tag', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('user-tag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'user-tag':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user-tag')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='user-tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='user-tag'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='user-tag', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class user_tag


class genre(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, id=None, name=None, disambiguation=None, annotation=None, alias_list=None, relation_list=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
        self.alias_list = alias_list
        self.alias_list_nsprefix_ = "mmd-2.0"
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.relation_list_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, genre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if genre.subclass:
            return genre.subclass(*args_, **kwargs_)
        else:
            return genre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def get_alias_list(self):
        return self.alias_list
    def set_alias_list(self, alias_list):
        self.alias_list = alias_list
    def get_relation_list(self):
        return self.relation_list
    def set_relation_list(self, relation_list):
        self.relation_list = relation_list
    def add_relation_list(self, value):
        self.relation_list.append(value)
    def insert_relation_list_at(self, index, value):
        self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value):
        self.relation_list[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='genre', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('genre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'genre':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genre')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='genre', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='genre'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='genre', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            namespaceprefix_ = self.alias_list_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_list_nsprefix_) else ''
            self.alias_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            namespaceprefix_ = self.relation_list_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_list_nsprefix_) else ''
            relation_list_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='genre', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
# end class genre


class user_genre(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, disambiguation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_genre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_genre.subclass:
            return user_genre.subclass(*args_, **kwargs_)
        else:
            return user_genre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.disambiguation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-genre', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('user-genre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'user-genre':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user-genre')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='user-genre', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='user-genre'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-genre', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='user-genre', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
# end class user_genre


class rating(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, votes_count=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.votes_count = _cast(int, votes_count)
        self.votes_count_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rating.subclass:
            return rating.subclass(*args_, **kwargs_)
        else:
            return rating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_votes_count(self):
        return self.votes_count
    def set_votes_count(self, votes_count):
        self.votes_count = votes_count
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='rating', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rating')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rating':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rating')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='rating'):
        if self.votes_count is not None and 'votes_count' not in already_processed:
            already_processed.add('votes_count')
            outfile.write(' votes-count="%s"' % self.gds_format_integer(self.votes_count, input_name='votes-count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='rating', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='rating', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.votes_count is not None:
            element.set('votes-count', self.gds_format_integer(self.votes_count))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('votes-count', node)
        if value is not None and 'votes-count' not in already_processed:
            already_processed.add('votes-count')
            self.votes_count = self.gds_parse_integer(value, node, 'votes-count')
            if self.votes_count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rating


class label_info(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalog_number=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.catalog_number = catalog_number
        self.catalog_number_nsprefix_ = "mmd-2.0"
        self.label = label
        self.label_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_info)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_info.subclass:
            return label_info.subclass(*args_, **kwargs_)
        else:
            return label_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalog_number(self):
        return self.catalog_number
    def set_catalog_number(self, catalog_number):
        self.catalog_number = catalog_number
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def has__content(self):
        if (
            self.catalog_number is not None or
            self.label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-info', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label-info')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'label-info':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label-info')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='label-info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='label-info'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.catalog_number is not None:
            namespaceprefix_ = self.catalog_number_nsprefix_ + ':' if (UseCapturedNS_ and self.catalog_number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scatalog-number>%s</%scatalog-number>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.catalog_number), input_name='catalog-number')), namespaceprefix_ , eol_))
        if self.label is not None:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            self.label.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-info', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.catalog_number is not None:
            catalog_number_ = self.catalog_number
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}catalog-number').text = self.gds_format_string(catalog_number_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalog-number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'catalog_number')
            value_ = self.gds_validate_string(value_, node, 'catalog_number')
            self.catalog_number = value_
            self.catalog_number_nsprefix_ = child_.prefix
        elif nodeName_ == 'label':
            obj_ = label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
# end class label_info


class medium(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, position=None, format=None, disc_list=None, pregap=None, track_list=None, data_track_list=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.position = position
        self.position_nsprefix_ = "mmd-2.0"
        self.format = format
        self.format_nsprefix_ = "mmd-2.0"
        self.disc_list = disc_list
        self.disc_list_nsprefix_ = "mmd-2.0"
        self.pregap = pregap
        self.pregap_nsprefix_ = "mmd-2.0"
        self.track_list = track_list
        self.track_list_nsprefix_ = "mmd-2.0"
        self.data_track_list = data_track_list
        self.data_track_list_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medium)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medium.subclass:
            return medium.subclass(*args_, **kwargs_)
        else:
            return medium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_format(self):
        return self.format
    def set_format(self, format):
        self.format = format
    def get_disc_list(self):
        return self.disc_list
    def set_disc_list(self, disc_list):
        self.disc_list = disc_list
    def get_pregap(self):
        return self.pregap
    def set_pregap(self, pregap):
        self.pregap = pregap
    def get_track_list(self):
        return self.track_list
    def set_track_list(self, track_list):
        self.track_list = track_list
    def get_data_track_list(self):
        return self.data_track_list
    def set_data_track_list(self, data_track_list):
        self.data_track_list = data_track_list
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.title is not None or
            self.position is not None or
            self.format is not None or
            self.disc_list is not None or
            self.pregap is not None or
            self.track_list is not None or
            self.data_track_list is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='medium', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('medium')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'medium':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='medium')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='medium', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='medium'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='medium', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespaceprefix_ , self.gds_format_integer(self.position, input_name='position'), namespaceprefix_ , eol_))
        if self.format is not None:
            namespaceprefix_ = self.format_nsprefix_ + ':' if (UseCapturedNS_ and self.format_nsprefix_) else ''
            self.format.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='format', pretty_print=pretty_print)
        if self.disc_list is not None:
            namespaceprefix_ = self.disc_list_nsprefix_ + ':' if (UseCapturedNS_ and self.disc_list_nsprefix_) else ''
            self.disc_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='disc-list', pretty_print=pretty_print)
        if self.pregap is not None:
            namespaceprefix_ = self.pregap_nsprefix_ + ':' if (UseCapturedNS_ and self.pregap_nsprefix_) else ''
            self.pregap.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='pregap', pretty_print=pretty_print)
        if self.track_list is not None:
            namespaceprefix_ = self.track_list_nsprefix_ + ':' if (UseCapturedNS_ and self.track_list_nsprefix_) else ''
            self.track_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track-list', pretty_print=pretty_print)
        if self.data_track_list is not None:
            namespaceprefix_ = self.data_track_list_nsprefix_ + ':' if (UseCapturedNS_ and self.data_track_list_nsprefix_) else ''
            self.data_track_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='data-track-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='medium', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.position is not None:
            position_ = self.position
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}position').text = self.gds_format_integer(position_)
        if self.format is not None:
            format_ = self.format
            format_.to_etree(element, name_='format', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.disc_list is not None:
            disc_list_ = self.disc_list
            disc_list_.to_etree(element, name_='disc-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.pregap is not None:
            pregap_ = self.pregap
            pregap_.to_etree(element, name_='pregap', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.data_track_list is not None:
            data_track_list_ = self.data_track_list
            data_track_list_.to_etree(element, name_='data-track-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'position' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'position')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
            self.position_nsprefix_ = child_.prefix
        elif nodeName_ == 'format':
            obj_ = format.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.format = obj_
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'disc-list':
            obj_ = disc_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.disc_list = obj_
            obj_.original_tagname_ = 'disc-list'
        elif nodeName_ == 'pregap':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pregap = obj_
            obj_.original_tagname_ = 'pregap'
        elif nodeName_ == 'track-list':
            obj_ = track_listType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'data-track-list':
            obj_ = data_track_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.data_track_list = obj_
            obj_.original_tagname_ = 'data-track-list'
# end class medium


class format(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, format)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='format', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('format')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'format':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='format')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='format'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='format', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_def_uuid(self.id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class format


class def_track_data(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, position=None, number=None, title=None, length=None, artist_credit=None, recording=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = "mmd-2.0"
        self.number = number
        self.number_nsprefix_ = "mmd-2.0"
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.length = length
        self.length_nsprefix_ = "mmd-2.0"
        self.artist_credit = artist_credit
        self.artist_credit_nsprefix_ = "mmd-2.0"
        self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_track_data)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_track_data.subclass:
            return def_track_data.subclass(*args_, **kwargs_)
        else:
            return def_track_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_artist_credit(self):
        return self.artist_credit
    def set_artist_credit(self, artist_credit):
        self.artist_credit = artist_credit
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            self.position is not None or
            self.number is not None or
            self.title is not None or
            self.length is not None or
            self.artist_credit is not None or
            self.recording is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_track-data', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_track-data')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_track-data':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_track-data')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='def_track-data', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='def_track-data'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_track-data', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespaceprefix_ , self.gds_format_integer(self.position, input_name='position'), namespaceprefix_ , eol_))
        if self.number is not None:
            namespaceprefix_ = self.number_nsprefix_ + ':' if (UseCapturedNS_ and self.number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespaceprefix_ , eol_))
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
        if self.artist_credit is not None:
            namespaceprefix_ = self.artist_credit_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_credit_nsprefix_) else ''
            self.artist_credit.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-credit', pretty_print=pretty_print)
        if self.recording is not None:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            self.recording.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='def_track-data', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.position is not None:
            position_ = self.position
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}position').text = self.gds_format_integer(position_)
        if self.number is not None:
            number_ = self.number
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}number').text = self.gds_format_string(number_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'position')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
            self.position_nsprefix_ = child_.prefix
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
        elif nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
# end class def_track_data


class annotation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, entity=None, name=None, text=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.entity = entity
        self.entity_nsprefix_ = "mmd-2.0"
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.text = text
        self.text_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotation.subclass:
            return annotation.subclass(*args_, **kwargs_)
        else:
            return annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entity(self):
        return self.entity
    def set_entity(self, entity):
        self.entity = entity
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def has__content(self):
        if (
            self.entity is not None or
            self.name is not None or
            self.text is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='annotation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'annotation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='annotation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='annotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='annotation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='annotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entity is not None:
            namespaceprefix_ = self.entity_nsprefix_ + ':' if (UseCapturedNS_ and self.entity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentity>%s</%sentity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entity), input_name='entity')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stext>%s</%stext>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.text), input_name='text')), namespaceprefix_ , eol_))
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='annotation', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.entity is not None:
            entity_ = self.entity
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}entity').text = self.gds_format_string(entity_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.text is not None:
            text_ = self.text
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}text').text = self.gds_format_string(text_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entity')
            value_ = self.gds_validate_string(value_, node, 'entity')
            self.entity = value_
            self.entity_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'text')
            value_ = self.gds_validate_string(value_, node, 'text')
            self.text = value_
            self.text_nsprefix_ = child_.prefix
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class annotation


class cdstub(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, artist=None, barcode=None, disambiguation=None, track_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
        self.barcode = barcode
        self.barcode_nsprefix_ = "mmd-2.0"
        self.disambiguation = disambiguation
        self.disambiguation_nsprefix_ = "mmd-2.0"
        self.track_list = track_list
        self.track_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cdstub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cdstub.subclass:
            return cdstub.subclass(*args_, **kwargs_)
        else:
            return cdstub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_barcode(self):
        return self.barcode
    def set_barcode(self, barcode):
        self.barcode = barcode
    def get_disambiguation(self):
        return self.disambiguation
    def set_disambiguation(self, disambiguation):
        self.disambiguation = disambiguation
    def get_track_list(self):
        return self.track_list
    def set_track_list(self, track_list):
        self.track_list = track_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_idType39(self, value):
        # Validate type idType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType39_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType39_patterns_, ))
    validate_idType39_patterns_ = [['^([a-zA-Z0-9._]{27}-)$']]
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.barcode is not None or
            self.disambiguation is not None or
            self.track_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cdstub', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cdstub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cdstub':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdstub')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cdstub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='cdstub'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cdstub', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.barcode is not None:
            namespaceprefix_ = self.barcode_nsprefix_ + ':' if (UseCapturedNS_ and self.barcode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbarcode>%s</%sbarcode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.barcode), input_name='barcode')), namespaceprefix_ , eol_))
        if self.disambiguation is not None:
            namespaceprefix_ = self.disambiguation_nsprefix_ + ':' if (UseCapturedNS_ and self.disambiguation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespaceprefix_ , eol_))
        if self.track_list is not None:
            namespaceprefix_ = self.track_list_nsprefix_ + ':' if (UseCapturedNS_ and self.track_list_nsprefix_) else ''
            self.track_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='cdstub', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.barcode is not None:
            barcode_ = self.barcode
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}barcode').text = self.gds_format_string(barcode_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType39(self.id)    # validate type idType39
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'barcode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'barcode')
            value_ = self.gds_validate_string(value_, node, 'barcode')
            self.barcode = value_
            self.barcode_nsprefix_ = child_.prefix
        elif nodeName_ == 'disambiguation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'disambiguation')
            value_ = self.gds_validate_string(value_, node, 'disambiguation')
            self.disambiguation = value_
            self.disambiguation_nsprefix_ = child_.prefix
        elif nodeName_ == 'track-list':
            obj_ = track_listType38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class cdstub


class freedb_disc(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, artist=None, category=None, year=None, track_list=None, def_extension_element=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "mmd-2.0"
        self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
        self.category = category
        self.category_nsprefix_ = "mmd-2.0"
        self.year = year
        self.validate_year(self.year)
        self.year_nsprefix_ = "mmd-2.0"
        self.track_list = track_list
        self.track_list_nsprefix_ = "mmd-2.0"
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
        self.def_extension_element_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, freedb_disc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if freedb_disc.subclass:
            return freedb_disc.subclass(*args_, **kwargs_)
        else:
            return freedb_disc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_year(self):
        return self.year
    def set_year(self, year):
        self.year = year
    def get_track_list(self):
        return self.track_list
    def set_track_list(self, track_list):
        self.track_list = track_list
    def get_def_extension_element(self):
        return self.def_extension_element
    def set_def_extension_element(self, def_extension_element):
        self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value):
        self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value):
        self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value):
        self.def_extension_element[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_year(self, value):
        result = True
        # Validate type year, a restriction on xs:string.
        pass
        return result
    def validate_idType41(self, value):
        # Validate type idType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType41_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType41_patterns_, ))
    validate_idType41_patterns_ = [['^([a-zA-Z0-9]{8})$']]
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.category is not None or
            self.year is not None or
            self.track_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='freedb-disc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('freedb-disc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'freedb-disc':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='freedb-disc')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='freedb-disc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='freedb-disc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='freedb-disc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.category is not None:
            namespaceprefix_ = self.category_nsprefix_ + ':' if (UseCapturedNS_ and self.category_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.category), input_name='category')), namespaceprefix_ , eol_))
        if self.year is not None:
            namespaceprefix_ = self.year_nsprefix_ + ':' if (UseCapturedNS_ and self.year_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syear>%s</%syear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.year), input_name='year')), namespaceprefix_ , eol_))
        if self.track_list is not None:
            namespaceprefix_ = self.track_list_nsprefix_ + ':' if (UseCapturedNS_ and self.track_list_nsprefix_) else ''
            self.track_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            namespaceprefix_ = self.def_extension_element_nsprefix_ + ':' if (UseCapturedNS_ and self.def_extension_element_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='freedb-disc', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.category is not None:
            category_ = self.category
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}category').text = self.gds_format_string(category_)
        if self.year is not None:
            year_ = self.year
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}year').text = self.gds_format_string(year_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType41(self.id)    # validate type idType41
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'category':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'category')
            value_ = self.gds_validate_string(value_, node, 'category')
            self.category = value_
            self.category_nsprefix_ = child_.prefix
        elif nodeName_ == 'year':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'year')
            value_ = self.gds_validate_string(value_, node, 'year')
            self.year = value_
            self.year_nsprefix_ = child_.prefix
            # validate type year
            self.validate_year(self.year)
        elif nodeName_ == 'track-list':
            obj_ = track_listType40.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'def_extension_element':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'def_extension_element')
            value_ = self.gds_validate_string(value_, node, 'def_extension_element')
            self.def_extension_element.append(value_)
            self.def_extension_element_nsprefix_ = child_.prefix
# end class freedb_disc


class year(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, year)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if year.subclass:
            return year.subclass(*args_, **kwargs_)
        else:
            return year(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_year(self, value):
        result = True
        # Validate type year, a restriction on xs:string.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='year', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('year')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'year':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='year')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='year', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='year'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='year', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='year', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class year


class collection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, entity_type=None, name=None, description=None, editor=None, area_list=None, artist_list=None, event_list=None, genre_list=None, instrument_list=None, label_list=None, place_list=None, recording_list=None, release_list=None, release_group_list=None, series_list=None, work_list=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.entity_type = _cast(None, entity_type)
        self.entity_type_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.description = description
        self.description_nsprefix_ = "mmd-2.0"
        self.editor = editor
        self.editor_nsprefix_ = "mmd-2.0"
        self.area_list = area_list
        self.area_list_nsprefix_ = "mmd-2.0"
        self.artist_list = artist_list
        self.artist_list_nsprefix_ = "mmd-2.0"
        self.event_list = event_list
        self.event_list_nsprefix_ = "mmd-2.0"
        self.genre_list = genre_list
        self.genre_list_nsprefix_ = "mmd-2.0"
        self.instrument_list = instrument_list
        self.instrument_list_nsprefix_ = "mmd-2.0"
        self.label_list = label_list
        self.label_list_nsprefix_ = "mmd-2.0"
        self.place_list = place_list
        self.place_list_nsprefix_ = "mmd-2.0"
        self.recording_list = recording_list
        self.recording_list_nsprefix_ = "mmd-2.0"
        self.release_list = release_list
        self.release_list_nsprefix_ = "mmd-2.0"
        self.release_group_list = release_group_list
        self.release_group_list_nsprefix_ = "mmd-2.0"
        self.series_list = series_list
        self.series_list_nsprefix_ = "mmd-2.0"
        self.work_list = work_list
        self.work_list_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, collection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if collection.subclass:
            return collection.subclass(*args_, **kwargs_)
        else:
            return collection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_editor(self):
        return self.editor
    def set_editor(self, editor):
        self.editor = editor
    def get_area_list(self):
        return self.area_list
    def set_area_list(self, area_list):
        self.area_list = area_list
    def get_artist_list(self):
        return self.artist_list
    def set_artist_list(self, artist_list):
        self.artist_list = artist_list
    def get_event_list(self):
        return self.event_list
    def set_event_list(self, event_list):
        self.event_list = event_list
    def get_genre_list(self):
        return self.genre_list
    def set_genre_list(self, genre_list):
        self.genre_list = genre_list
    def get_instrument_list(self):
        return self.instrument_list
    def set_instrument_list(self, instrument_list):
        self.instrument_list = instrument_list
    def get_label_list(self):
        return self.label_list
    def set_label_list(self, label_list):
        self.label_list = label_list
    def get_place_list(self):
        return self.place_list
    def set_place_list(self, place_list):
        self.place_list = place_list
    def get_recording_list(self):
        return self.recording_list
    def set_recording_list(self, recording_list):
        self.recording_list = recording_list
    def get_release_list(self):
        return self.release_list
    def set_release_list(self, release_list):
        self.release_list = release_list
    def get_release_group_list(self):
        return self.release_group_list
    def set_release_group_list(self, release_group_list):
        self.release_group_list = release_group_list
    def get_series_list(self):
        return self.series_list
    def set_series_list(self, series_list):
        self.series_list = series_list
    def get_work_list(self):
        return self.work_list
    def set_work_list(self, work_list):
        self.work_list = work_list
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_entity_type(self):
        return self.entity_type
    def set_entity_type(self, entity_type):
        self.entity_type = entity_type
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            self.name is not None or
            self.description is not None or
            self.editor is not None or
            self.area_list is not None or
            self.artist_list is not None or
            self.event_list is not None or
            self.genre_list is not None or
            self.instrument_list is not None or
            self.label_list is not None or
            self.place_list is not None or
            self.recording_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.series_list is not None or
            self.work_list is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='collection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('collection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'collection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='collection')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='collection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='collection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.entity_type is not None and 'entity_type' not in already_processed:
            already_processed.add('entity_type')
            outfile.write(' entity-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.entity_type), input_name='entity-type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='collection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.editor is not None:
            namespaceprefix_ = self.editor_nsprefix_ + ':' if (UseCapturedNS_ and self.editor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seditor>%s</%seditor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.editor), input_name='editor')), namespaceprefix_ , eol_))
        if self.area_list is not None:
            namespaceprefix_ = self.area_list_nsprefix_ + ':' if (UseCapturedNS_ and self.area_list_nsprefix_) else ''
            self.area_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area-list', pretty_print=pretty_print)
        if self.artist_list is not None:
            namespaceprefix_ = self.artist_list_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_list_nsprefix_) else ''
            self.artist_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist-list', pretty_print=pretty_print)
        if self.event_list is not None:
            namespaceprefix_ = self.event_list_nsprefix_ + ':' if (UseCapturedNS_ and self.event_list_nsprefix_) else ''
            self.event_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event-list', pretty_print=pretty_print)
        if self.genre_list is not None:
            namespaceprefix_ = self.genre_list_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_list_nsprefix_) else ''
            self.genre_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre-list', pretty_print=pretty_print)
        if self.instrument_list is not None:
            namespaceprefix_ = self.instrument_list_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_list_nsprefix_) else ''
            self.instrument_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument-list', pretty_print=pretty_print)
        if self.label_list is not None:
            namespaceprefix_ = self.label_list_nsprefix_ + ':' if (UseCapturedNS_ and self.label_list_nsprefix_) else ''
            self.label_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label-list', pretty_print=pretty_print)
        if self.place_list is not None:
            namespaceprefix_ = self.place_list_nsprefix_ + ':' if (UseCapturedNS_ and self.place_list_nsprefix_) else ''
            self.place_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            namespaceprefix_ = self.recording_list_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_list_nsprefix_) else ''
            self.recording_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording-list', pretty_print=pretty_print)
        if self.release_list is not None:
            namespaceprefix_ = self.release_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_list_nsprefix_) else ''
            self.release_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            namespaceprefix_ = self.release_group_list_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_list_nsprefix_) else ''
            self.release_group_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group-list', pretty_print=pretty_print)
        if self.series_list is not None:
            namespaceprefix_ = self.series_list_nsprefix_ + ':' if (UseCapturedNS_ and self.series_list_nsprefix_) else ''
            self.series_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series-list', pretty_print=pretty_print)
        if self.work_list is not None:
            namespaceprefix_ = self.work_list_nsprefix_ + ':' if (UseCapturedNS_ and self.work_list_nsprefix_) else ''
            self.work_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='collection', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.entity_type is not None:
            element.set('entity-type', self.gds_format_string(self.entity_type))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}description').text = self.gds_format_string(description_)
        if self.editor is not None:
            editor_ = self.editor
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}editor').text = self.gds_format_string(editor_)
        if self.area_list is not None:
            area_list_ = self.area_list
            area_list_.to_etree(element, name_='area-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.artist_list is not None:
            artist_list_ = self.artist_list
            artist_list_.to_etree(element, name_='artist-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.event_list is not None:
            event_list_ = self.event_list
            event_list_.to_etree(element, name_='event-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.genre_list is not None:
            genre_list_ = self.genre_list
            genre_list_.to_etree(element, name_='genre-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.instrument_list is not None:
            instrument_list_ = self.instrument_list
            instrument_list_.to_etree(element, name_='instrument-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.label_list is not None:
            label_list_ = self.label_list
            label_list_.to_etree(element, name_='label-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.place_list is not None:
            place_list_ = self.place_list
            place_list_.to_etree(element, name_='place-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.series_list is not None:
            series_list_ = self.series_list
            series_list_.to_etree(element, name_='series-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('entity-type', node)
        if value is not None and 'entity-type' not in already_processed:
            already_processed.add('entity-type')
            self.entity_type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'editor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'editor')
            value_ = self.gds_validate_string(value_, node, 'editor')
            self.editor = value_
            self.editor_nsprefix_ = child_.prefix
        elif nodeName_ == 'area-list':
            obj_ = area_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area_list = obj_
            obj_.original_tagname_ = 'area-list'
        elif nodeName_ == 'artist-list':
            obj_ = artist_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist_list = obj_
            obj_.original_tagname_ = 'artist-list'
        elif nodeName_ == 'event-list':
            obj_ = event_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event_list = obj_
            obj_.original_tagname_ = 'event-list'
        elif nodeName_ == 'genre-list':
            obj_ = genre_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre_list = obj_
            obj_.original_tagname_ = 'genre-list'
        elif nodeName_ == 'instrument-list':
            obj_ = instrument_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument_list = obj_
            obj_.original_tagname_ = 'instrument-list'
        elif nodeName_ == 'label-list':
            obj_ = label_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label_list = obj_
            obj_.original_tagname_ = 'label-list'
        elif nodeName_ == 'place-list':
            obj_ = place_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place_list = obj_
            obj_.original_tagname_ = 'place-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'series-list':
            obj_ = series_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series_list = obj_
            obj_.original_tagname_ = 'series-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
# end class collection


class editor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, member_since=None, privs=None, gender=None, age=None, homepage=None, bio=None, area=None, language_list=None, edit_information=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "mmd-2.0"
        self.member_since = member_since
        self.member_since_nsprefix_ = "mmd-2.0"
        self.privs = privs
        self.privs_nsprefix_ = "mmd-2.0"
        self.gender = gender
        self.gender_nsprefix_ = "mmd-2.0"
        self.age = age
        self.age_nsprefix_ = "mmd-2.0"
        self.homepage = homepage
        self.homepage_nsprefix_ = "mmd-2.0"
        self.bio = bio
        self.bio_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        self.language_list = language_list
        self.language_list_nsprefix_ = "mmd-2.0"
        self.edit_information = edit_information
        self.edit_information_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editor.subclass:
            return editor.subclass(*args_, **kwargs_)
        else:
            return editor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_member_since(self):
        return self.member_since
    def set_member_since(self, member_since):
        self.member_since = member_since
    def get_privs(self):
        return self.privs
    def set_privs(self, privs):
        self.privs = privs
    def get_gender(self):
        return self.gender
    def set_gender(self, gender):
        self.gender = gender
    def get_age(self):
        return self.age
    def set_age(self, age):
        self.age = age
    def get_homepage(self):
        return self.homepage
    def set_homepage(self, homepage):
        self.homepage = homepage
    def get_bio(self):
        return self.bio
    def set_bio(self, bio):
        self.bio = bio
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_language_list(self):
        return self.language_list
    def set_language_list(self, language_list):
        self.language_list = language_list
    def get_edit_information(self):
        return self.edit_information
    def set_edit_information(self, edit_information):
        self.edit_information = edit_information
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            self.name is not None or
            self.member_since is not None or
            self.privs is not None or
            self.gender is not None or
            self.age is not None or
            self.homepage is not None or
            self.bio is not None or
            self.area is not None or
            self.language_list is not None or
            self.edit_information is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='editor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('editor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'editor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='editor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='editor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='editor'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='editor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.member_since is not None:
            namespaceprefix_ = self.member_since_nsprefix_ + ':' if (UseCapturedNS_ and self.member_since_nsprefix_) else ''
            self.member_since.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='member-since', pretty_print=pretty_print)
        if self.privs is not None:
            namespaceprefix_ = self.privs_nsprefix_ + ':' if (UseCapturedNS_ and self.privs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprivs>%s</%sprivs>%s' % (namespaceprefix_ , self.gds_format_integer(self.privs, input_name='privs'), namespaceprefix_ , eol_))
        if self.gender is not None:
            namespaceprefix_ = self.gender_nsprefix_ + ':' if (UseCapturedNS_ and self.gender_nsprefix_) else ''
            self.gender.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='gender', pretty_print=pretty_print)
        if self.age is not None:
            namespaceprefix_ = self.age_nsprefix_ + ':' if (UseCapturedNS_ and self.age_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sage>%s</%sage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.age), input_name='age')), namespaceprefix_ , eol_))
        if self.homepage is not None:
            namespaceprefix_ = self.homepage_nsprefix_ + ':' if (UseCapturedNS_ and self.homepage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomepage>%s</%shomepage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.homepage), input_name='homepage')), namespaceprefix_ , eol_))
        if self.bio is not None:
            namespaceprefix_ = self.bio_nsprefix_ + ':' if (UseCapturedNS_ and self.bio_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbio>%s</%sbio>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bio), input_name='bio')), namespaceprefix_ , eol_))
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        if self.language_list is not None:
            namespaceprefix_ = self.language_list_nsprefix_ + ':' if (UseCapturedNS_ and self.language_list_nsprefix_) else ''
            self.language_list.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='language-list', pretty_print=pretty_print)
        if self.edit_information is not None:
            namespaceprefix_ = self.edit_information_nsprefix_ + ':' if (UseCapturedNS_ and self.edit_information_nsprefix_) else ''
            self.edit_information.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='edit-information', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='editor', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.id is not None:
            element.set('id', self.gds_format_integer(self.id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.member_since is not None:
            member_since_ = self.member_since
            member_since_.to_etree(element, name_='member-since', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.privs is not None:
            privs_ = self.privs
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}privs').text = self.gds_format_integer(privs_)
        if self.gender is not None:
            gender_ = self.gender
            gender_.to_etree(element, name_='gender', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.age is not None:
            age_ = self.age
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}age').text = self.gds_format_string(age_)
        if self.homepage is not None:
            homepage_ = self.homepage
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}homepage').text = self.gds_format_string(homepage_)
        if self.bio is not None:
            bio_ = self.bio
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}bio').text = self.gds_format_string(bio_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.language_list is not None:
            language_list_ = self.language_list
            language_list_.to_etree(element, name_='language-list', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.edit_information is not None:
            edit_information_ = self.edit_information
            edit_information_.to_etree(element, name_='edit-information', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'member-since':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.member_since = obj_
            obj_.original_tagname_ = 'member-since'
        elif nodeName_ == 'privs' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'privs')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'privs')
            self.privs = ival_
            self.privs_nsprefix_ = child_.prefix
        elif nodeName_ == 'gender':
            obj_ = gender.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gender = obj_
            obj_.original_tagname_ = 'gender'
        elif nodeName_ == 'age':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'age')
            value_ = self.gds_validate_string(value_, node, 'age')
            self.age = value_
            self.age_nsprefix_ = child_.prefix
        elif nodeName_ == 'homepage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'homepage')
            value_ = self.gds_validate_string(value_, node, 'homepage')
            self.homepage = value_
            self.homepage_nsprefix_ = child_.prefix
        elif nodeName_ == 'bio':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bio')
            value_ = self.gds_validate_string(value_, node, 'bio')
            self.bio = value_
            self.bio_nsprefix_ = child_.prefix
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'language-list':
            obj_ = language_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language_list = obj_
            obj_.original_tagname_ = 'language-list'
        elif nodeName_ == 'edit-information':
            obj_ = edit_information.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.edit_information = obj_
            obj_.original_tagname_ = 'edit-information'
# end class editor


class edit_information(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, edits_accepted=None, edits_rejected=None, auto_edits_accepted=None, edits_failed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.edits_accepted = edits_accepted
        self.edits_accepted_nsprefix_ = "mmd-2.0"
        self.edits_rejected = edits_rejected
        self.edits_rejected_nsprefix_ = "mmd-2.0"
        self.auto_edits_accepted = auto_edits_accepted
        self.auto_edits_accepted_nsprefix_ = "mmd-2.0"
        self.edits_failed = edits_failed
        self.edits_failed_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, edit_information)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if edit_information.subclass:
            return edit_information.subclass(*args_, **kwargs_)
        else:
            return edit_information(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_edits_accepted(self):
        return self.edits_accepted
    def set_edits_accepted(self, edits_accepted):
        self.edits_accepted = edits_accepted
    def get_edits_rejected(self):
        return self.edits_rejected
    def set_edits_rejected(self, edits_rejected):
        self.edits_rejected = edits_rejected
    def get_auto_edits_accepted(self):
        return self.auto_edits_accepted
    def set_auto_edits_accepted(self, auto_edits_accepted):
        self.auto_edits_accepted = auto_edits_accepted
    def get_edits_failed(self):
        return self.edits_failed
    def set_edits_failed(self, edits_failed):
        self.edits_failed = edits_failed
    def has__content(self):
        if (
            self.edits_accepted is not None or
            self.edits_rejected is not None or
            self.auto_edits_accepted is not None or
            self.edits_failed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='edit-information', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('edit-information')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'edit-information':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='edit-information')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='edit-information', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='edit-information'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='edit-information', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.edits_accepted is not None:
            namespaceprefix_ = self.edits_accepted_nsprefix_ + ':' if (UseCapturedNS_ and self.edits_accepted_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-accepted>%s</%sedits-accepted>%s' % (namespaceprefix_ , self.gds_format_integer(self.edits_accepted, input_name='edits-accepted'), namespaceprefix_ , eol_))
        if self.edits_rejected is not None:
            namespaceprefix_ = self.edits_rejected_nsprefix_ + ':' if (UseCapturedNS_ and self.edits_rejected_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-rejected>%s</%sedits-rejected>%s' % (namespaceprefix_ , self.gds_format_integer(self.edits_rejected, input_name='edits-rejected'), namespaceprefix_ , eol_))
        if self.auto_edits_accepted is not None:
            namespaceprefix_ = self.auto_edits_accepted_nsprefix_ + ':' if (UseCapturedNS_ and self.auto_edits_accepted_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto-edits-accepted>%s</%sauto-edits-accepted>%s' % (namespaceprefix_ , self.gds_format_integer(self.auto_edits_accepted, input_name='auto-edits-accepted'), namespaceprefix_ , eol_))
        if self.edits_failed is not None:
            namespaceprefix_ = self.edits_failed_nsprefix_ + ':' if (UseCapturedNS_ and self.edits_failed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-failed>%s</%sedits-failed>%s' % (namespaceprefix_ , self.gds_format_integer(self.edits_failed, input_name='edits-failed'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='edit-information', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.edits_accepted is not None:
            edits_accepted_ = self.edits_accepted
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-accepted').text = self.gds_format_integer(edits_accepted_)
        if self.edits_rejected is not None:
            edits_rejected_ = self.edits_rejected
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-rejected').text = self.gds_format_integer(edits_rejected_)
        if self.auto_edits_accepted is not None:
            auto_edits_accepted_ = self.auto_edits_accepted
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}auto-edits-accepted').text = self.gds_format_integer(auto_edits_accepted_)
        if self.edits_failed is not None:
            edits_failed_ = self.edits_failed
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-failed').text = self.gds_format_integer(edits_failed_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'edits-accepted' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'edits_accepted')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_accepted')
            self.edits_accepted = ival_
            self.edits_accepted_nsprefix_ = child_.prefix
        elif nodeName_ == 'edits-rejected' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'edits_rejected')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_rejected')
            self.edits_rejected = ival_
            self.edits_rejected_nsprefix_ = child_.prefix
        elif nodeName_ == 'auto-edits-accepted' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'auto_edits_accepted')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'auto_edits_accepted')
            self.auto_edits_accepted = ival_
            self.auto_edits_accepted_nsprefix_ = child_.prefix
        elif nodeName_ == 'edits-failed' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'edits_failed')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_failed')
            self.edits_failed = ival_
            self.edits_failed_nsprefix_ = child_.prefix
# end class edit_information


class language_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, language=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, language_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if language_list.subclass:
            return language_list.subclass(*args_, **kwargs_)
        else:
            return language_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.language
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='language-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('language-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'language-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='language-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='language-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='language-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='language-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='language-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for language_ in self.language:
            language_.to_etree(element, name_='language', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            obj_ = languageType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
# end class language_list


class release_event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, date=None, area=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.date = date
        self.date_nsprefix_ = "mmd-2.0"
        self.area = area
        self.area_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_event.subclass:
            return release_event.subclass(*args_, **kwargs_)
        else:
            return release_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def has__content(self):
        if (
            self.date is not None or
            self.area is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release-event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release-event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release-event')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release-event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release-event'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.date is not None:
            namespaceprefix_ = self.date_nsprefix_ + ':' if (UseCapturedNS_ and self.date_nsprefix_) else ''
            self.date.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='date', pretty_print=pretty_print)
        if self.area is not None:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            self.area.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-event', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.date is not None:
            date_ = self.date
            date_.to_etree(element, name_='date', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'date':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.date = obj_
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
# end class release_event


class artist_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, artist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if artist is None:
            self.artist = []
        else:
            self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist_list.subclass:
            return artist_list.subclass(*args_, **kwargs_)
        else:
            return artist_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def add_artist(self, value):
        self.artist.append(value)
    def insert_artist_at(self, index, value):
        self.artist.insert(index, value)
    def replace_artist_at(self, index, value):
        self.artist[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.artist
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('artist-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'artist-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='artist-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='artist-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='artist-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artist-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artist_ in self.artist:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            artist_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='artist-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for artist_ in self.artist:
            artist_.to_etree(element, name_='artist', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artist':
            obj_ = artist.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist.append(obj_)
            obj_.original_tagname_ = 'artist'
# end class artist_list


class medium_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track_count=None, medium=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track_count = track_count
        self.track_count_nsprefix_ = "mmd-2.0"
        if medium is None:
            self.medium = []
        else:
            self.medium = medium
        self.medium_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medium_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medium_list.subclass:
            return medium_list.subclass(*args_, **kwargs_)
        else:
            return medium_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track_count(self):
        return self.track_count
    def set_track_count(self, track_count):
        self.track_count = track_count
    def get_medium(self):
        return self.medium
    def set_medium(self, medium):
        self.medium = medium
    def add_medium(self, value):
        self.medium.append(value)
    def insert_medium_at(self, index, value):
        self.medium.insert(index, value)
    def replace_medium_at(self, index, value):
        self.medium[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track_count is not None or
            self.medium
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='medium-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('medium-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'medium-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='medium-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='medium-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='medium-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='medium-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track_count is not None:
            namespaceprefix_ = self.track_count_nsprefix_ + ':' if (UseCapturedNS_ and self.track_count_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%strack-count>%s</%strack-count>%s' % (namespaceprefix_ , self.gds_format_integer(self.track_count, input_name='track-count'), namespaceprefix_ , eol_))
        for medium_ in self.medium:
            namespaceprefix_ = self.medium_nsprefix_ + ':' if (UseCapturedNS_ and self.medium_nsprefix_) else ''
            medium_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='medium', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='medium-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track_count is not None:
            track_count_ = self.track_count
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}track-count').text = self.gds_format_integer(track_count_)
        for medium_ in self.medium:
            medium_.to_etree(element, name_='medium', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track-count' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'track_count')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'track_count')
            self.track_count = ival_
            self.track_count_nsprefix_ = child_.prefix
        elif nodeName_ == 'medium':
            obj_ = medium.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.medium.append(obj_)
            obj_.original_tagname_ = 'medium'
# end class medium_list


class release_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if release is None:
            self.release = []
        else:
            self.release = release
        self.release_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_list.subclass:
            return release_list.subclass(*args_, **kwargs_)
        else:
            return release_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def add_release(self, value):
        self.release.append(value)
    def insert_release_at(self, index, value):
        self.release.insert(index, value)
    def replace_release_at(self, index, value):
        self.release[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.release
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_ in self.release:
            namespaceprefix_ = self.release_nsprefix_ + ':' if (UseCapturedNS_ and self.release_nsprefix_) else ''
            release_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_ in self.release:
            release_.to_etree(element, name_='release', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'release':
            obj_ = release.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release.append(obj_)
            obj_.original_tagname_ = 'release'
# end class release_list


class release_group_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release_group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if release_group is None:
            self.release_group = []
        else:
            self.release_group = release_group
        self.release_group_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_group_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_group_list.subclass:
            return release_group_list.subclass(*args_, **kwargs_)
        else:
            return release_group_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_release_group(self):
        return self.release_group
    def set_release_group(self, release_group):
        self.release_group = release_group
    def add_release_group(self, value):
        self.release_group.append(value)
    def insert_release_group_at(self, index, value):
        self.release_group.insert(index, value)
    def replace_release_group_at(self, index, value):
        self.release_group[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.release_group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-group-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release-group-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release-group-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release-group-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release-group-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release-group-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-group-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_group_ in self.release_group:
            namespaceprefix_ = self.release_group_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_nsprefix_) else ''
            release_group_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-group-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_group_ in self.release_group:
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'release-group':
            obj_ = release_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group.append(obj_)
            obj_.original_tagname_ = 'release-group'
# end class release_group_list


class alias_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, alias=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if alias is None:
            self.alias = []
        else:
            self.alias = alias
        self.alias_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alias_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alias_list.subclass:
            return alias_list.subclass(*args_, **kwargs_)
        else:
            return alias_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def add_alias(self, value):
        self.alias.append(value)
    def insert_alias_at(self, index, value):
        self.alias.insert(index, value)
    def replace_alias_at(self, index, value):
        self.alias[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.alias
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='alias-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alias-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alias-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alias-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alias-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='alias-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='alias-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alias_ in self.alias:
            namespaceprefix_ = self.alias_nsprefix_ + ':' if (UseCapturedNS_ and self.alias_nsprefix_) else ''
            alias_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='alias', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='alias-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for alias_ in self.alias:
            alias_.to_etree(element, name_='alias', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alias':
            obj_ = alias.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alias.append(obj_)
            obj_.original_tagname_ = 'alias'
# end class alias_list


class recording_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, recording=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if recording is None:
            self.recording = []
        else:
            self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording_list.subclass:
            return recording_list.subclass(*args_, **kwargs_)
        else:
            return recording_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def add_recording(self, value):
        self.recording.append(value)
    def insert_recording_at(self, index, value):
        self.recording.insert(index, value)
    def replace_recording_at(self, index, value):
        self.recording[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.recording
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='recording-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recording-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'recording-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recording-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recording-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='recording-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='recording-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for recording_ in self.recording:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            recording_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='recording-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for recording_ in self.recording:
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording.append(obj_)
            obj_.original_tagname_ = 'recording'
# end class recording_list


class data_track_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if track is None:
            self.track = []
        else:
            self.track = track
        self.track_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, data_track_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if data_track_list.subclass:
            return data_track_list.subclass(*args_, **kwargs_)
        else:
            return data_track_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def add_track(self, value):
        self.track.append(value)
    def insert_track_at(self, index, value):
        self.track.insert(index, value)
    def replace_track_at(self, index, value):
        self.track[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='data-track-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data-track-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'data-track-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data-track-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='data-track-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='data-track-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='data-track-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            track_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='data-track-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class data_track_list


class offset_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset_attr=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset_attr = _cast(int, offset_attr)
        self.offset_attr_nsprefix_ = None
        if offset is None:
            self.offset = []
        else:
            self.offset = offset
        self.offset_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, offset_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if offset_list.subclass:
            return offset_list.subclass(*args_, **kwargs_)
        else:
            return offset_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def add_offset(self, value):
        self.offset.append(value)
    def insert_offset_at(self, index, value):
        self.offset.insert(index, value)
    def replace_offset_at(self, index, value):
        self.offset[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset_attr(self):
        return self.offset_attr
    def set_offset_attr(self, offset_attr):
        self.offset_attr = offset_attr
    def has__content(self):
        if (
            self.offset
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='offset-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('offset-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'offset-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='offset-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='offset-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='offset-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset_attr is not None and 'offset_attr' not in already_processed:
            already_processed.add('offset_attr')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset_attr, input_name='offset_attr'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='offset-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for offset_ in self.offset:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            offset_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='offset', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='offset-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset_attr is not None:
            element.set('offset_attr', self.gds_format_integer(self.offset_attr))
        for offset_ in self.offset:
            offset_.to_etree(element, name_='offset', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset_attr' not in already_processed:
            already_processed.add('offset_attr')
            self.offset_attr = self.gds_parse_integer(value, node, 'offset_attr')
            if self.offset_attr < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'offset':
            obj_ = offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset.append(obj_)
            obj_.original_tagname_ = 'offset'
# end class offset_list


class offset(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, position=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.position = _cast(int, position)
        self.position_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if offset.subclass:
            return offset.subclass(*args_, **kwargs_)
        else:
            return offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='offset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('offset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'offset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='offset')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='offset'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='offset', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='offset', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.position is not None:
            element.set('position', self.gds_format_integer(self.position))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = self.gds_parse_integer(value, node, 'position')
            if self.position < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class offset


class label_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if label is None:
            self.label = []
        else:
            self.label = label
        self.label_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_list.subclass:
            return label_list.subclass(*args_, **kwargs_)
        else:
            return label_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def add_label(self, value):
        self.label.append(value)
    def insert_label_at(self, index, value):
        self.label.insert(index, value)
    def replace_label_at(self, index, value):
        self.label[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.label
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'label-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='label-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='label-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for label_ in self.label:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            label_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for label_ in self.label:
            label_.to_etree(element, name_='label', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'label':
            obj_ = label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
# end class label_list


class label_info_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, label_info=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if label_info is None:
            self.label_info = []
        else:
            self.label_info = label_info
        self.label_info_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_info_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_info_list.subclass:
            return label_info_list.subclass(*args_, **kwargs_)
        else:
            return label_info_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label_info(self):
        return self.label_info
    def set_label_info(self, label_info):
        self.label_info = label_info
    def add_label_info(self, value):
        self.label_info.append(value)
    def insert_label_info_at(self, index, value):
        self.label_info.insert(index, value)
    def replace_label_info_at(self, index, value):
        self.label_info[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.label_info
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-info-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label-info-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'label-info-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label-info-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='label-info-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='label-info-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='label-info-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for label_info_ in self.label_info:
            namespaceprefix_ = self.label_info_nsprefix_ + ':' if (UseCapturedNS_ and self.label_info_nsprefix_) else ''
            label_info_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label-info', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-info-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for label_info_ in self.label_info:
            label_info_.to_etree(element, name_='label-info', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'label-info':
            obj_ = label_info.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label_info.append(obj_)
            obj_.original_tagname_ = 'label-info'
# end class label_info_list


class work_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, work=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if work is None:
            self.work = []
        else:
            self.work = work
        self.work_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, work_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if work_list.subclass:
            return work_list.subclass(*args_, **kwargs_)
        else:
            return work_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def add_work(self, value):
        self.work.append(value)
    def insert_work_at(self, index, value):
        self.work.insert(index, value)
    def replace_work_at(self, index, value):
        self.work[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.work
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='work-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('work-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'work-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='work-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='work-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='work-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='work-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for work_ in self.work:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            work_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='work-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for work_ in self.work:
            work_.to_etree(element, name_='work', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work.append(obj_)
            obj_.original_tagname_ = 'work'
# end class work_list


class area_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, area=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if area is None:
            self.area = []
        else:
            self.area = area
        self.area_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, area_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if area_list.subclass:
            return area_list.subclass(*args_, **kwargs_)
        else:
            return area_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.area
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='area-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('area-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'area-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='area-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='area-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='area-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='area-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            area_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='area-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for area_ in self.area:
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
# end class area_list


class place_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, place=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if place is None:
            self.place = []
        else:
            self.place = place
        self.place_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, place_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if place_list.subclass:
            return place_list.subclass(*args_, **kwargs_)
        else:
            return place_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def add_place(self, value):
        self.place.append(value)
    def insert_place_at(self, index, value):
        self.place.insert(index, value)
    def replace_place_at(self, index, value):
        self.place[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.place
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='place-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('place-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'place-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='place-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='place-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='place-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='place-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for place_ in self.place:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            place_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='place-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for place_ in self.place:
            place_.to_etree(element, name_='place', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'place':
            obj_ = place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place.append(obj_)
            obj_.original_tagname_ = 'place'
# end class place_list


class instrument_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, instrument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if instrument is None:
            self.instrument = []
        else:
            self.instrument = instrument
        self.instrument_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument_list.subclass:
            return instrument_list.subclass(*args_, **kwargs_)
        else:
            return instrument_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instrument(self):
        return self.instrument
    def set_instrument(self, instrument):
        self.instrument = instrument
    def add_instrument(self, value):
        self.instrument.append(value)
    def insert_instrument_at(self, index, value):
        self.instrument.insert(index, value)
    def replace_instrument_at(self, index, value):
        self.instrument[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.instrument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='instrument-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instrument-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instrument-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instrument-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instrument-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='instrument-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='instrument-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrument_ in self.instrument:
            namespaceprefix_ = self.instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_nsprefix_) else ''
            instrument_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='instrument-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for instrument_ in self.instrument:
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instrument':
            obj_ = instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument.append(obj_)
            obj_.original_tagname_ = 'instrument'
# end class instrument_list


class series_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, series=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if series is None:
            self.series = []
        else:
            self.series = series
        self.series_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, series_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if series_list.subclass:
            return series_list.subclass(*args_, **kwargs_)
        else:
            return series_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def add_series(self, value):
        self.series.append(value)
    def insert_series_at(self, index, value):
        self.series.insert(index, value)
    def replace_series_at(self, index, value):
        self.series[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.series
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='series-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('series-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'series-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='series-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='series-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='series-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='series-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for series_ in self.series:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            series_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='series-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for series_ in self.series:
            series_.to_etree(element, name_='series', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'series':
            obj_ = series.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series.append(obj_)
            obj_.original_tagname_ = 'series'
# end class series_list


class event_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, event=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event_list.subclass:
            return event_list.subclass(*args_, **kwargs_)
        else:
            return event_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='event-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'event-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='event-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='event-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='event-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='event-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='event-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for event_ in self.event:
            event_.to_etree(element, name_='event', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class event_list


class url_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, url=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if url is None:
            self.url = []
        else:
            self.url = url
        self.url_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, url_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if url_list.subclass:
            return url_list.subclass(*args_, **kwargs_)
        else:
            return url_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def add_url(self, value):
        self.url.append(value)
    def insert_url_at(self, index, value):
        self.url.insert(index, value)
    def replace_url_at(self, index, value):
        self.url[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='url-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('url-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'url-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='url-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='url-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='url-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='url-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for url_ in self.url:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            url_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='url', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='url-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for url_ in self.url:
            url_.to_etree(element, name_='url', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'url':
            obj_ = url.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
# end class url_list


class release_event_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release_event=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if release_event is None:
            self.release_event = []
        else:
            self.release_event = release_event
        self.release_event_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_event_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_event_list.subclass:
            return release_event_list.subclass(*args_, **kwargs_)
        else:
            return release_event_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_release_event(self):
        return self.release_event
    def set_release_event(self, release_event):
        self.release_event = release_event
    def add_release_event(self, value):
        self.release_event.append(value)
    def insert_release_event_at(self, index, value):
        self.release_event.insert(index, value)
    def replace_release_event_at(self, index, value):
        self.release_event[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.release_event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-event-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release-event-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release-event-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release-event-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release-event-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='release-event-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='release-event-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_event_ in self.release_event:
            namespaceprefix_ = self.release_event_nsprefix_ + ':' if (UseCapturedNS_ and self.release_event_nsprefix_) else ''
            release_event_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-event-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_event_ in self.release_event:
            release_event_.to_etree(element, name_='release-event', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'release-event':
            obj_ = release_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_event.append(obj_)
            obj_.original_tagname_ = 'release-event'
# end class release_event_list


class annotation_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, annotation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.annotation_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotation_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotation_list.subclass:
            return annotation_list.subclass(*args_, **kwargs_)
        else:
            return annotation_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_annotation(self):
        return self.annotation
    def set_annotation(self, annotation):
        self.annotation = annotation
    def add_annotation(self, value):
        self.annotation.append(value)
    def insert_annotation_at(self, index, value):
        self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value):
        self.annotation[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.annotation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='annotation-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotation-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'annotation-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='annotation-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='annotation-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='annotation-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='annotation-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotation_ in self.annotation:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            annotation_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='annotation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='annotation-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for annotation_ in self.annotation:
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'annotation':
            obj_ = annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
# end class annotation_list


class cdstub_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, cdstub=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if cdstub is None:
            self.cdstub = []
        else:
            self.cdstub = cdstub
        self.cdstub_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cdstub_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cdstub_list.subclass:
            return cdstub_list.subclass(*args_, **kwargs_)
        else:
            return cdstub_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cdstub(self):
        return self.cdstub
    def set_cdstub(self, cdstub):
        self.cdstub = cdstub
    def add_cdstub(self, value):
        self.cdstub.append(value)
    def insert_cdstub_at(self, index, value):
        self.cdstub.insert(index, value)
    def replace_cdstub_at(self, index, value):
        self.cdstub[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.cdstub
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cdstub-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cdstub-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cdstub-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdstub-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cdstub-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='cdstub-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cdstub-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cdstub_ in self.cdstub:
            namespaceprefix_ = self.cdstub_nsprefix_ + ':' if (UseCapturedNS_ and self.cdstub_nsprefix_) else ''
            cdstub_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='cdstub', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='cdstub-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for cdstub_ in self.cdstub:
            cdstub_.to_etree(element, name_='cdstub', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cdstub':
            obj_ = cdstub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cdstub.append(obj_)
            obj_.original_tagname_ = 'cdstub'
# end class cdstub_list


class freedb_disc_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, freedb_disc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if freedb_disc is None:
            self.freedb_disc = []
        else:
            self.freedb_disc = freedb_disc
        self.freedb_disc_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, freedb_disc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if freedb_disc_list.subclass:
            return freedb_disc_list.subclass(*args_, **kwargs_)
        else:
            return freedb_disc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_freedb_disc(self):
        return self.freedb_disc
    def set_freedb_disc(self, freedb_disc):
        self.freedb_disc = freedb_disc
    def add_freedb_disc(self, value):
        self.freedb_disc.append(value)
    def insert_freedb_disc_at(self, index, value):
        self.freedb_disc.insert(index, value)
    def replace_freedb_disc_at(self, index, value):
        self.freedb_disc[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.freedb_disc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='freedb-disc-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('freedb-disc-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'freedb-disc-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='freedb-disc-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='freedb-disc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='freedb-disc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='freedb-disc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for freedb_disc_ in self.freedb_disc:
            namespaceprefix_ = self.freedb_disc_nsprefix_ + ':' if (UseCapturedNS_ and self.freedb_disc_nsprefix_) else ''
            freedb_disc_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='freedb-disc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='freedb-disc-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for freedb_disc_ in self.freedb_disc:
            freedb_disc_.to_etree(element, name_='freedb-disc', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'freedb-disc':
            obj_ = freedb_disc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.freedb_disc.append(obj_)
            obj_.original_tagname_ = 'freedb-disc'
# end class freedb_disc_list


class disc_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, disc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if disc is None:
            self.disc = []
        else:
            self.disc = disc
        self.disc_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, disc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if disc_list.subclass:
            return disc_list.subclass(*args_, **kwargs_)
        else:
            return disc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_disc(self):
        return self.disc
    def set_disc(self, disc):
        self.disc = disc
    def add_disc(self, value):
        self.disc.append(value)
    def insert_disc_at(self, index, value):
        self.disc.insert(index, value)
    def replace_disc_at(self, index, value):
        self.disc[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.disc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='disc-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disc-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'disc-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disc-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='disc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='disc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='disc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disc_ in self.disc:
            namespaceprefix_ = self.disc_nsprefix_ + ':' if (UseCapturedNS_ and self.disc_nsprefix_) else ''
            disc_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='disc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='disc-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for disc_ in self.disc:
            disc_.to_etree(element, name_='disc', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'disc':
            obj_ = disc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.disc.append(obj_)
            obj_.original_tagname_ = 'disc'
# end class disc_list


class puid_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, puid=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if puid is None:
            self.puid = []
        else:
            self.puid = puid
        self.puid_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puid_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puid_list.subclass:
            return puid_list.subclass(*args_, **kwargs_)
        else:
            return puid_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_puid(self):
        return self.puid
    def set_puid(self, puid):
        self.puid = puid
    def add_puid(self, value):
        self.puid.append(value)
    def insert_puid_at(self, index, value):
        self.puid.insert(index, value)
    def replace_puid_at(self, index, value):
        self.puid[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.puid
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='puid-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('puid-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'puid-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puid-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='puid-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='puid-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='puid-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for puid_ in self.puid:
            namespaceprefix_ = self.puid_nsprefix_ + ':' if (UseCapturedNS_ and self.puid_nsprefix_) else ''
            puid_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='puid', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='puid-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for puid_ in self.puid:
            puid_.to_etree(element, name_='puid', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'puid':
            obj_ = puid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.puid.append(obj_)
            obj_.original_tagname_ = 'puid'
# end class puid_list


class isrc_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, isrc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if isrc is None:
            self.isrc = []
        else:
            self.isrc = isrc
        self.isrc_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isrc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isrc_list.subclass:
            return isrc_list.subclass(*args_, **kwargs_)
        else:
            return isrc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isrc(self):
        return self.isrc
    def set_isrc(self, isrc):
        self.isrc = isrc
    def add_isrc(self, value):
        self.isrc.append(value)
    def insert_isrc_at(self, index, value):
        self.isrc.insert(index, value)
    def replace_isrc_at(self, index, value):
        self.isrc[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.isrc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isrc-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isrc-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'isrc-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isrc-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='isrc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='isrc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isrc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for isrc_ in self.isrc:
            namespaceprefix_ = self.isrc_nsprefix_ + ':' if (UseCapturedNS_ and self.isrc_nsprefix_) else ''
            isrc_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isrc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='isrc-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for isrc_ in self.isrc:
            isrc_.to_etree(element, name_='isrc', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isrc':
            obj_ = isrc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isrc.append(obj_)
            obj_.original_tagname_ = 'isrc'
# end class isrc_list


class relation_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target_type=None, count=None, offset=None, relation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.target_type = _cast(None, target_type)
        self.target_type_nsprefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
        self.relation_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relation_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relation_list.subclass:
            return relation_list.subclass(*args_, **kwargs_)
        else:
            return relation_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_relation(self):
        return self.relation
    def set_relation(self, relation):
        self.relation = relation
    def add_relation(self, value):
        self.relation.append(value)
    def insert_relation_at(self, index, value):
        self.relation.insert(index, value)
    def replace_relation_at(self, index, value):
        self.relation[index] = value
    def get_target_type(self):
        return self.target_type
    def set_target_type(self, target_type):
        self.target_type = target_type
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.relation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='relation-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('relation-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'relation-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='relation-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='relation-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='relation-list'):
        if self.target_type is not None and 'target_type' not in already_processed:
            already_processed.add('target_type')
            outfile.write(' target-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target_type), input_name='target-type')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='relation-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relation_ in self.relation:
            namespaceprefix_ = self.relation_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_nsprefix_) else ''
            relation_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='relation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='relation-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.target_type is not None:
            element.set('target-type', self.gds_format_string(self.target_type))
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for relation_ in self.relation:
            relation_.to_etree(element, name_='relation', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target-type', node)
        if value is not None and 'target-type' not in already_processed:
            already_processed.add('target-type')
            self.target_type = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'relation':
            obj_ = relation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'relation'
# end class relation_list


class tag_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, tag=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if tag is None:
            self.tag = []
        else:
            self.tag = tag
        self.tag_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tag_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tag_list.subclass:
            return tag_list.subclass(*args_, **kwargs_)
        else:
            return tag_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def add_tag(self, value):
        self.tag.append(value)
    def insert_tag_at(self, index, value):
        self.tag.insert(index, value)
    def replace_tag_at(self, index, value):
        self.tag[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='tag-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tag-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tag-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tag-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tag-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='tag-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='tag-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_ in self.tag:
            namespaceprefix_ = self.tag_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_nsprefix_) else ''
            tag_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='tag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='tag-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for tag_ in self.tag:
            tag_.to_etree(element, name_='tag', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tag':
            obj_ = tag.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tag.append(obj_)
            obj_.original_tagname_ = 'tag'
# end class tag_list


class genre_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, genre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if genre is None:
            self.genre = []
        else:
            self.genre = genre
        self.genre_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, genre_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if genre_list.subclass:
            return genre_list.subclass(*args_, **kwargs_)
        else:
            return genre_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_genre(self):
        return self.genre
    def set_genre(self, genre):
        self.genre = genre
    def add_genre(self, value):
        self.genre.append(value)
    def insert_genre_at(self, index, value):
        self.genre.insert(index, value)
    def replace_genre_at(self, index, value):
        self.genre[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.genre
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='genre-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('genre-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'genre-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genre-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='genre-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='genre-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='genre-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for genre_ in self.genre:
            namespaceprefix_ = self.genre_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_nsprefix_) else ''
            genre_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='genre', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='genre-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for genre_ in self.genre:
            genre_.to_etree(element, name_='genre', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'genre':
            obj_ = genre.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre.append(obj_)
            obj_.original_tagname_ = 'genre'
# end class genre_list


class iswc_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, iswc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if iswc is None:
            self.iswc = []
        else:
            self.iswc = iswc
        self.iswc_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iswc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iswc_list.subclass:
            return iswc_list.subclass(*args_, **kwargs_)
        else:
            return iswc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_iswc(self):
        return self.iswc
    def set_iswc(self, iswc):
        self.iswc = iswc
    def add_iswc(self, value):
        self.iswc.append(value)
    def insert_iswc_at(self, index, value):
        self.iswc.insert(index, value)
    def replace_iswc_at(self, index, value):
        self.iswc[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def validate_iswc(self, value):
        result = True
        # Validate type iswc, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (
            self.iswc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iswc-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iswc-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'iswc-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iswc-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='iswc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='iswc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iswc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iswc_ in self.iswc:
            namespaceprefix_ = self.iswc_nsprefix_ + ':' if (UseCapturedNS_ and self.iswc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siswc>%s</%siswc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(iswc_), input_name='iswc')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='iswc-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for iswc_ in self.iswc:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iswc').text = self.gds_format_string(iswc_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'iswc':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'iswc')
            value_ = self.gds_validate_string(value_, node, 'iswc')
            self.iswc.append(value_)
            self.iswc_nsprefix_ = child_.prefix
            # validate type iswc
            self.validate_iswc(self.iswc[-1])
# end class iswc_list


class user_tag_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, user_tag=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if user_tag is None:
            self.user_tag = []
        else:
            self.user_tag = user_tag
        self.user_tag_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_tag_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_tag_list.subclass:
            return user_tag_list.subclass(*args_, **kwargs_)
        else:
            return user_tag_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_user_tag(self):
        return self.user_tag
    def set_user_tag(self, user_tag):
        self.user_tag = user_tag
    def add_user_tag(self, value):
        self.user_tag.append(value)
    def insert_user_tag_at(self, index, value):
        self.user_tag.insert(index, value)
    def replace_user_tag_at(self, index, value):
        self.user_tag[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.user_tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-tag-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('user-tag-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'user-tag-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user-tag-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='user-tag-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='user-tag-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-tag-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for user_tag_ in self.user_tag:
            namespaceprefix_ = self.user_tag_nsprefix_ + ':' if (UseCapturedNS_ and self.user_tag_nsprefix_) else ''
            user_tag_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-tag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='user-tag-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for user_tag_ in self.user_tag:
            user_tag_.to_etree(element, name_='user-tag', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'user-tag':
            obj_ = user_tag.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_tag.append(obj_)
            obj_.original_tagname_ = 'user-tag'
# end class user_tag_list


class user_genre_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, user_genre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if user_genre is None:
            self.user_genre = []
        else:
            self.user_genre = user_genre
        self.user_genre_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_genre_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_genre_list.subclass:
            return user_genre_list.subclass(*args_, **kwargs_)
        else:
            return user_genre_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_user_genre(self):
        return self.user_genre
    def set_user_genre(self, user_genre):
        self.user_genre = user_genre
    def add_user_genre(self, value):
        self.user_genre.append(value)
    def insert_user_genre_at(self, index, value):
        self.user_genre.insert(index, value)
    def replace_user_genre_at(self, index, value):
        self.user_genre[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.user_genre
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-genre-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('user-genre-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'user-genre-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user-genre-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='user-genre-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='user-genre-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='user-genre-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for user_genre_ in self.user_genre:
            namespaceprefix_ = self.user_genre_nsprefix_ + ':' if (UseCapturedNS_ and self.user_genre_nsprefix_) else ''
            user_genre_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='user-genre', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='user-genre-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for user_genre_ in self.user_genre:
            user_genre_.to_etree(element, name_='user-genre', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'user-genre':
            obj_ = user_genre.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user_genre.append(obj_)
            obj_.original_tagname_ = 'user-genre'
# end class user_genre_list


class collection_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, collection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if collection is None:
            self.collection = []
        else:
            self.collection = collection
        self.collection_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, collection_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if collection_list.subclass:
            return collection_list.subclass(*args_, **kwargs_)
        else:
            return collection_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_collection(self):
        return self.collection
    def set_collection(self, collection):
        self.collection = collection
    def add_collection(self, value):
        self.collection.append(value)
    def insert_collection_at(self, index, value):
        self.collection.insert(index, value)
    def replace_collection_at(self, index, value):
        self.collection[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='collection-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('collection-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'collection-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='collection-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='collection-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='collection-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='collection-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for collection_ in self.collection:
            namespaceprefix_ = self.collection_nsprefix_ + ':' if (UseCapturedNS_ and self.collection_nsprefix_) else ''
            collection_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='collection', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='collection-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for collection_ in self.collection:
            collection_.to_etree(element, name_='collection', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'collection':
            obj_ = collection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.collection.append(obj_)
            obj_.original_tagname_ = 'collection'
# end class collection_list


class editor_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, editor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if editor is None:
            self.editor = []
        else:
            self.editor = editor
        self.editor_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editor_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editor_list.subclass:
            return editor_list.subclass(*args_, **kwargs_)
        else:
            return editor_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_editor(self):
        return self.editor
    def set_editor(self, editor):
        self.editor = editor
    def add_editor(self, value):
        self.editor.append(value)
    def insert_editor_at(self, index, value):
        self.editor.insert(index, value)
    def replace_editor_at(self, index, value):
        self.editor[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.editor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='editor-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('editor-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'editor-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='editor-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='editor-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='editor-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='editor-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for editor_ in self.editor:
            namespaceprefix_ = self.editor_nsprefix_ + ':' if (UseCapturedNS_ and self.editor_nsprefix_) else ''
            editor_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='editor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='editor-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for editor_ in self.editor:
            editor_.to_etree(element, name_='editor', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'editor':
            obj_ = editor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editor.append(obj_)
            obj_.original_tagname_ = 'editor'
# end class editor_list


class entity_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if artist is None:
            self.artist = []
        else:
            self.artist = artist
        self.artist_nsprefix_ = "mmd-2.0"
        if release is None:
            self.release = []
        else:
            self.release = release
        self.release_nsprefix_ = "mmd-2.0"
        if release_group is None:
            self.release_group = []
        else:
            self.release_group = release_group
        self.release_group_nsprefix_ = "mmd-2.0"
        if recording is None:
            self.recording = []
        else:
            self.recording = recording
        self.recording_nsprefix_ = "mmd-2.0"
        if label is None:
            self.label = []
        else:
            self.label = label
        self.label_nsprefix_ = "mmd-2.0"
        if work is None:
            self.work = []
        else:
            self.work = work
        self.work_nsprefix_ = "mmd-2.0"
        if area is None:
            self.area = []
        else:
            self.area = area
        self.area_nsprefix_ = "mmd-2.0"
        if place is None:
            self.place = []
        else:
            self.place = place
        self.place_nsprefix_ = "mmd-2.0"
        if instrument is None:
            self.instrument = []
        else:
            self.instrument = instrument
        self.instrument_nsprefix_ = "mmd-2.0"
        if series is None:
            self.series = []
        else:
            self.series = series
        self.series_nsprefix_ = "mmd-2.0"
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, entity_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if entity_list.subclass:
            return entity_list.subclass(*args_, **kwargs_)
        else:
            return entity_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def add_artist(self, value):
        self.artist.append(value)
    def insert_artist_at(self, index, value):
        self.artist.insert(index, value)
    def replace_artist_at(self, index, value):
        self.artist[index] = value
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def add_release(self, value):
        self.release.append(value)
    def insert_release_at(self, index, value):
        self.release.insert(index, value)
    def replace_release_at(self, index, value):
        self.release[index] = value
    def get_release_group(self):
        return self.release_group
    def set_release_group(self, release_group):
        self.release_group = release_group
    def add_release_group(self, value):
        self.release_group.append(value)
    def insert_release_group_at(self, index, value):
        self.release_group.insert(index, value)
    def replace_release_group_at(self, index, value):
        self.release_group[index] = value
    def get_recording(self):
        return self.recording
    def set_recording(self, recording):
        self.recording = recording
    def add_recording(self, value):
        self.recording.append(value)
    def insert_recording_at(self, index, value):
        self.recording.insert(index, value)
    def replace_recording_at(self, index, value):
        self.recording[index] = value
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def add_label(self, value):
        self.label.append(value)
    def insert_label_at(self, index, value):
        self.label.insert(index, value)
    def replace_label_at(self, index, value):
        self.label[index] = value
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def add_work(self, value):
        self.work.append(value)
    def insert_work_at(self, index, value):
        self.work.insert(index, value)
    def replace_work_at(self, index, value):
        self.work[index] = value
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def add_place(self, value):
        self.place.append(value)
    def insert_place_at(self, index, value):
        self.place.insert(index, value)
    def replace_place_at(self, index, value):
        self.place[index] = value
    def get_instrument(self):
        return self.instrument
    def set_instrument(self, instrument):
        self.instrument = instrument
    def add_instrument(self, value):
        self.instrument.append(value)
    def insert_instrument_at(self, index, value):
        self.instrument.insert(index, value)
    def replace_instrument_at(self, index, value):
        self.instrument[index] = value
    def get_series(self):
        return self.series
    def set_series(self, series):
        self.series = series
    def add_series(self, value):
        self.series.append(value)
    def insert_series_at(self, index, value):
        self.series.insert(index, value)
    def replace_series_at(self, index, value):
        self.series[index] = value
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.artist or
            self.release or
            self.release_group or
            self.recording or
            self.label or
            self.work or
            self.area or
            self.place or
            self.instrument or
            self.series or
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='entity-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('entity-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'entity-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='entity-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='entity-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='entity-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='entity-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artist_ in self.artist:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            artist_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='artist', pretty_print=pretty_print)
        for release_ in self.release:
            namespaceprefix_ = self.release_nsprefix_ + ':' if (UseCapturedNS_ and self.release_nsprefix_) else ''
            release_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release', pretty_print=pretty_print)
        for release_group_ in self.release_group:
            namespaceprefix_ = self.release_group_nsprefix_ + ':' if (UseCapturedNS_ and self.release_group_nsprefix_) else ''
            release_group_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='release-group', pretty_print=pretty_print)
        for recording_ in self.recording:
            namespaceprefix_ = self.recording_nsprefix_ + ':' if (UseCapturedNS_ and self.recording_nsprefix_) else ''
            recording_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='recording', pretty_print=pretty_print)
        for label_ in self.label:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            label_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='label', pretty_print=pretty_print)
        for work_ in self.work:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            work_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='work', pretty_print=pretty_print)
        for area_ in self.area:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            area_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='area', pretty_print=pretty_print)
        for place_ in self.place:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            place_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='place', pretty_print=pretty_print)
        for instrument_ in self.instrument:
            namespaceprefix_ = self.instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_nsprefix_) else ''
            instrument_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='instrument', pretty_print=pretty_print)
        for series_ in self.series:
            namespaceprefix_ = self.series_nsprefix_ + ':' if (UseCapturedNS_ and self.series_nsprefix_) else ''
            series_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='series', pretty_print=pretty_print)
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='entity-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for artist_ in self.artist:
            artist_.to_etree(element, name_='artist', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for release_ in self.release:
            release_.to_etree(element, name_='release', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for release_group_ in self.release_group:
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for recording_ in self.recording:
            recording_.to_etree(element, name_='recording', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for label_ in self.label:
            label_.to_etree(element, name_='label', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for work_ in self.work:
            work_.to_etree(element, name_='work', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for area_ in self.area:
            area_.to_etree(element, name_='area', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for place_ in self.place:
            place_.to_etree(element, name_='place', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for instrument_ in self.instrument:
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for series_ in self.series:
            series_.to_etree(element, name_='series', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        for event_ in self.event:
            event_.to_etree(element, name_='event', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artist':
            obj_ = artist.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artist.append(obj_)
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release.append(obj_)
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release_group.append(obj_)
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recording.append(obj_)
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work.append(obj_)
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place.append(obj_)
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument.append(obj_)
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.series.append(obj_)
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class entity_list


class cover_art_archive(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, artwork=None, count=None, front=None, back=None, darkened=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.artwork = artwork
        self.validate_artwork(self.artwork)
        self.artwork_nsprefix_ = "mmd-2.0"
        self.count = count
        self.count_nsprefix_ = "mmd-2.0"
        self.front = front
        self.validate_front(self.front)
        self.front_nsprefix_ = "mmd-2.0"
        self.back = back
        self.validate_back(self.back)
        self.back_nsprefix_ = "mmd-2.0"
        self.darkened = darkened
        self.validate_darkened(self.darkened)
        self.darkened_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cover_art_archive)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cover_art_archive.subclass:
            return cover_art_archive.subclass(*args_, **kwargs_)
        else:
            return cover_art_archive(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artwork(self):
        return self.artwork
    def set_artwork(self, artwork):
        self.artwork = artwork
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_front(self):
        return self.front
    def set_front(self, front):
        self.front = front
    def get_back(self):
        return self.back
    def set_back(self, back):
        self.back = back
    def get_darkened(self):
        return self.darkened
    def set_darkened(self, darkened):
        self.darkened = darkened
    def validate_artwork(self, value):
        result = True
        # Validate type artwork, a restriction on xs:token.
        pass
        return result
    def validate_front(self, value):
        result = True
        # Validate type front, a restriction on xs:token.
        pass
        return result
    def validate_back(self, value):
        result = True
        # Validate type back, a restriction on xs:token.
        pass
        return result
    def validate_darkened(self, value):
        result = True
        # Validate type darkened, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (
            self.artwork is not None or
            self.count is not None or
            self.front is not None or
            self.back is not None or
            self.darkened is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cover-art-archive', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cover-art-archive')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cover-art-archive':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cover-art-archive')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cover-art-archive', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='cover-art-archive'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cover-art-archive', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artwork is not None:
            namespaceprefix_ = self.artwork_nsprefix_ + ':' if (UseCapturedNS_ and self.artwork_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartwork>%s</%sartwork>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artwork), input_name='artwork')), namespaceprefix_ , eol_))
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.front is not None:
            namespaceprefix_ = self.front_nsprefix_ + ':' if (UseCapturedNS_ and self.front_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfront>%s</%sfront>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.front), input_name='front')), namespaceprefix_ , eol_))
        if self.back is not None:
            namespaceprefix_ = self.back_nsprefix_ + ':' if (UseCapturedNS_ and self.back_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sback>%s</%sback>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.back), input_name='back')), namespaceprefix_ , eol_))
        if self.darkened is not None:
            namespaceprefix_ = self.darkened_nsprefix_ + ':' if (UseCapturedNS_ and self.darkened_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdarkened>%s</%sdarkened>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.darkened), input_name='darkened')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='cover-art-archive', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.artwork is not None:
            artwork_ = self.artwork
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artwork').text = self.gds_format_string(artwork_)
        if self.count is not None:
            count_ = self.count
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}count').text = self.gds_format_integer(count_)
        if self.front is not None:
            front_ = self.front
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}front').text = self.gds_format_string(front_)
        if self.back is not None:
            back_ = self.back
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}back').text = self.gds_format_string(back_)
        if self.darkened is not None:
            darkened_ = self.darkened
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}darkened').text = self.gds_format_string(darkened_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artwork':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'artwork')
            value_ = self.gds_validate_string(value_, node, 'artwork')
            self.artwork = value_
            self.artwork_nsprefix_ = child_.prefix
            # validate type artwork
            self.validate_artwork(self.artwork)
        elif nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'count')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
            self.count_nsprefix_ = child_.prefix
        elif nodeName_ == 'front':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'front')
            value_ = self.gds_validate_string(value_, node, 'front')
            self.front = value_
            self.front_nsprefix_ = child_.prefix
            # validate type front
            self.validate_front(self.front)
        elif nodeName_ == 'back':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'back')
            value_ = self.gds_validate_string(value_, node, 'back')
            self.back = value_
            self.back_nsprefix_ = child_.prefix
            # validate type back
            self.validate_back(self.back)
        elif nodeName_ == 'darkened':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'darkened')
            value_ = self.gds_validate_string(value_, node, 'darkened')
            self.darkened = value_
            self.darkened_nsprefix_ = child_.prefix
            # validate type darkened
            self.validate_darkened(self.darkened)
# end class cover_art_archive


class artwork(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artwork.subclass:
            return artwork.subclass(*args_, **kwargs_)
        else:
            return artwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_artwork(self, value):
        result = True
        # Validate type artwork, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artwork', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('artwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'artwork':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='artwork')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='artwork', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='artwork'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='artwork', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='artwork', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class artwork


class front(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, front)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if front.subclass:
            return front.subclass(*args_, **kwargs_)
        else:
            return front(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_front(self, value):
        result = True
        # Validate type front, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='front', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('front')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'front':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='front')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='front', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='front'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='front', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='front', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class front


class back(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, back)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if back.subclass:
            return back.subclass(*args_, **kwargs_)
        else:
            return back(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_back(self, value):
        result = True
        # Validate type back, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='back', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('back')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'back':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='back')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='back', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='back'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='back', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='back', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class back


class darkened(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, darkened)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if darkened.subclass:
            return darkened.subclass(*args_, **kwargs_)
        else:
            return darkened(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_darkened(self, value):
        result = True
        # Validate type darkened, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='darkened', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('darkened')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'darkened':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='darkened')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='darkened', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='darkened'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='darkened', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='darkened', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class darkened


class ipi_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ipi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if ipi is None:
            self.ipi = []
        else:
            self.ipi = ipi
        self.ipi_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipi_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipi_list.subclass:
            return ipi_list.subclass(*args_, **kwargs_)
        else:
            return ipi_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ipi(self):
        return self.ipi
    def set_ipi(self, ipi):
        self.ipi = ipi
    def add_ipi(self, value):
        self.ipi.append(value)
    def insert_ipi_at(self, index, value):
        self.ipi.insert(index, value)
    def replace_ipi_at(self, index, value):
        self.ipi[index] = value
    def has__content(self):
        if (
            self.ipi
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='ipi-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipi-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ipi-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ipi-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ipi-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='ipi-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='ipi-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipi_ in self.ipi:
            namespaceprefix_ = self.ipi_nsprefix_ + ':' if (UseCapturedNS_ and self.ipi_nsprefix_) else ''
            ipi_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='ipi', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ipi-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for ipi_ in self.ipi:
            ipi_.to_etree(element, name_='ipi', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ipi':
            obj_ = def_ipi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipi.append(obj_)
            obj_.original_tagname_ = 'ipi'
# end class ipi_list


class isni_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, isni=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if isni is None:
            self.isni = []
        else:
            self.isni = isni
        self.isni_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isni_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isni_list.subclass:
            return isni_list.subclass(*args_, **kwargs_)
        else:
            return isni_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isni(self):
        return self.isni
    def set_isni(self, isni):
        self.isni = isni
    def add_isni(self, value):
        self.isni.append(value)
    def insert_isni_at(self, index, value):
        self.isni.insert(index, value)
    def replace_isni_at(self, index, value):
        self.isni[index] = value
    def has__content(self):
        if (
            self.isni
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isni-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isni-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'isni-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isni-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='isni-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='isni-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='isni-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for isni_ in self.isni:
            namespaceprefix_ = self.isni_nsprefix_ + ':' if (UseCapturedNS_ and self.isni_nsprefix_) else ''
            isni_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='isni', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='isni-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for isni_ in self.isni:
            isni_.to_etree(element, name_='isni', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isni':
            obj_ = def_isni.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isni.append(obj_)
            obj_.original_tagname_ = 'isni'
# end class isni_list


class ended(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ended.subclass:
            return ended.subclass(*args_, **kwargs_)
        else:
            return ended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_ended(self, value):
        result = True
        # Validate type ended, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='ended', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ended')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ended':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ended')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ended', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='ended'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='ended', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ended', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ended


class cancelled(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelled)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelled.subclass:
            return cancelled.subclass(*args_, **kwargs_)
        else:
            return cancelled(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_cancelled(self, value):
        result = True
        # Validate type cancelled, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cancelled', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancelled')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancelled':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancelled')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancelled', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='cancelled'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='cancelled', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='cancelled', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cancelled


class video(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, video)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if video.subclass:
            return video.subclass(*args_, **kwargs_)
        else:
            return video(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_video(self, value):
        result = True
        # Validate type video, a restriction on xs:token.
        pass
        return result
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='video', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('video')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'video':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='video')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='video', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='video'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='video', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='video', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class video


class iso_3166_1_code_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, iso_3166_1_code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if iso_3166_1_code is None:
            self.iso_3166_1_code = []
        else:
            self.iso_3166_1_code = iso_3166_1_code
        self.iso_3166_1_code_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_1_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_1_code_list.subclass:
            return iso_3166_1_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_1_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_iso_3166_1_code(self):
        return self.iso_3166_1_code
    def set_iso_3166_1_code(self, iso_3166_1_code):
        self.iso_3166_1_code = iso_3166_1_code
    def add_iso_3166_1_code(self, value):
        self.iso_3166_1_code.append(value)
    def insert_iso_3166_1_code_at(self, index, value):
        self.iso_3166_1_code.insert(index, value)
    def replace_iso_3166_1_code_at(self, index, value):
        self.iso_3166_1_code[index] = value
    def has__content(self):
        if (
            self.iso_3166_1_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-1-code-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iso-3166-1-code-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'iso-3166-1-code-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iso-3166-1-code-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='iso-3166-1-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='iso-3166-1-code-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-1-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_1_code_ in self.iso_3166_1_code:
            namespaceprefix_ = self.iso_3166_1_code_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_1_code_nsprefix_) else ''
            iso_3166_1_code_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-1-code', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='iso-3166-1-code-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for iso_3166_1_code_ in self.iso_3166_1_code:
            iso_3166_1_code_.to_etree(element, name_='iso-3166-1-code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'iso-3166-1-code':
            obj_ = def_iso_3166_1_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_1_code.append(obj_)
            obj_.original_tagname_ = 'iso-3166-1-code'
# end class iso_3166_1_code_list


class iso_3166_2_code_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, iso_3166_2_code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if iso_3166_2_code is None:
            self.iso_3166_2_code = []
        else:
            self.iso_3166_2_code = iso_3166_2_code
        self.iso_3166_2_code_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_2_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_2_code_list.subclass:
            return iso_3166_2_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_2_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_iso_3166_2_code(self):
        return self.iso_3166_2_code
    def set_iso_3166_2_code(self, iso_3166_2_code):
        self.iso_3166_2_code = iso_3166_2_code
    def add_iso_3166_2_code(self, value):
        self.iso_3166_2_code.append(value)
    def insert_iso_3166_2_code_at(self, index, value):
        self.iso_3166_2_code.insert(index, value)
    def replace_iso_3166_2_code_at(self, index, value):
        self.iso_3166_2_code[index] = value
    def has__content(self):
        if (
            self.iso_3166_2_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-2-code-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iso-3166-2-code-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'iso-3166-2-code-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iso-3166-2-code-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='iso-3166-2-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='iso-3166-2-code-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-2-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_2_code_ in self.iso_3166_2_code:
            namespaceprefix_ = self.iso_3166_2_code_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_2_code_nsprefix_) else ''
            iso_3166_2_code_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-2-code', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='iso-3166-2-code-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for iso_3166_2_code_ in self.iso_3166_2_code:
            iso_3166_2_code_.to_etree(element, name_='iso-3166-2-code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'iso-3166-2-code':
            obj_ = def_iso_3166_2_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_2_code.append(obj_)
            obj_.original_tagname_ = 'iso-3166-2-code'
# end class iso_3166_2_code_list


class iso_3166_3_code_list(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, iso_3166_3_code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        if iso_3166_3_code is None:
            self.iso_3166_3_code = []
        else:
            self.iso_3166_3_code = iso_3166_3_code
        self.iso_3166_3_code_nsprefix_ = "mmd-2.0"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_3_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_3_code_list.subclass:
            return iso_3166_3_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_3_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_iso_3166_3_code(self):
        return self.iso_3166_3_code
    def set_iso_3166_3_code(self, iso_3166_3_code):
        self.iso_3166_3_code = iso_3166_3_code
    def add_iso_3166_3_code(self, value):
        self.iso_3166_3_code.append(value)
    def insert_iso_3166_3_code_at(self, index, value):
        self.iso_3166_3_code.insert(index, value)
    def replace_iso_3166_3_code_at(self, index, value):
        self.iso_3166_3_code[index] = value
    def has__content(self):
        if (
            self.iso_3166_3_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-3-code-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iso-3166-3-code-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'iso-3166-3-code-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iso-3166-3-code-list')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='iso-3166-3-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='mmd-2.0:', name_='iso-3166-3-code-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='iso-3166-3-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_3_code_ in self.iso_3166_3_code:
            namespaceprefix_ = self.iso_3166_3_code_nsprefix_ + ':' if (UseCapturedNS_ and self.iso_3166_3_code_nsprefix_) else ''
            iso_3166_3_code_.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='iso-3166-3-code', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='iso-3166-3-code-list', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for iso_3166_3_code_ in self.iso_3166_3_code:
            iso_3166_3_code_.to_etree(element, name_='iso-3166-3-code', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'iso-3166-3-code':
            obj_ = def_iso_3166_3_code.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iso_3166_3_code.append(obj_)
            obj_.original_tagname_ = 'iso-3166-3-code'
# end class iso_3166_3_code_list


class def_iso_3166_1_code8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_1_code8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_1_code8.subclass:
            return def_iso_3166_1_code8.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_1_code8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_1_code8_impl(self, value):
        result = True
        # Validate type def_iso-3166-1-code8_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code8_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_1_code8_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_1_code8_impl_patterns_ = [['^([A-Z]{2})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-1-code8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-1-code8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-1-code8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-1-code8')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-1-code8'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-1-code8', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-1-code8', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_1_code8


class def_ipi4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_ipi4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_ipi4.subclass:
            return def_ipi4.subclass(*args_, **kwargs_)
        else:
            return def_ipi4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_ipi4_impl(self, value):
        result = True
        # Validate type def_ipi4_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_ipi4_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_ipi4_impl_patterns_, ))
                result = False
        return result
    validate_def_ipi4_impl_patterns_ = [['^([0-9]{11})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_ipi4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_ipi4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_ipi4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_ipi4')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_ipi4'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_ipi4', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_ipi4', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_ipi4


class def_incomplete_date3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_incomplete_date3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_incomplete_date3.subclass:
            return def_incomplete_date3.subclass(*args_, **kwargs_)
        else:
            return def_incomplete_date3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_incomplete_date3_impl(self, value):
        result = True
        # Validate type def_incomplete-date3_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date3_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_incomplete_date3_impl_patterns_, ))
                result = False
        return result
    validate_def_incomplete_date3_impl_patterns_ = [['^([0-9]{4}(-[0-9]{2})?(-[0-9]{2})?)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_incomplete-date3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_incomplete-date3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_incomplete-date3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_incomplete-date3')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_incomplete-date3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_incomplete-date3', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_incomplete-date3', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_incomplete_date3


class def_quality17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_quality17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_quality17.subclass:
            return def_quality17.subclass(*args_, **kwargs_)
        else:
            return def_quality17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_quality17_impl(self, value):
        result = True
        # Validate type def_quality17_impl, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['low', 'normal', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on def_quality17_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_quality17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_quality17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_quality17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_quality17')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_quality17'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_quality17', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_quality17', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_quality17


class def_iso_1592412(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_1592412)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_1592412.subclass:
            return def_iso_1592412.subclass(*args_, **kwargs_)
        else:
            return def_iso_1592412(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_1592412_impl(self, value):
        result = True
        # Validate type def_iso-1592412_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_1592412_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_1592412_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_1592412_impl_patterns_ = [['^([A-Z][a-z]{3})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-1592412', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-1592412')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-1592412':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-1592412')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-1592412'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-1592412', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-1592412', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_1592412


class def_time7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_time7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_time7.subclass:
            return def_time7.subclass(*args_, **kwargs_)
        else:
            return def_time7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_time7_impl(self, value):
        result = True
        # Validate type def_time7_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_time7_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_time7_impl_patterns_, ))
                result = False
        return result
    validate_def_time7_impl_patterns_ = [['^(([01][0-9]|2[0-3]):[0-5][0-9])$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_time7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_time7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_time7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_time7')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_time7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_time7', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_time7', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_time7


class def_direction16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_direction16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_direction16.subclass:
            return def_direction16.subclass(*args_, **kwargs_)
        else:
            return def_direction16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_direction16_impl(self, value):
        result = True
        # Validate type def_direction16_impl, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['both', 'forward', 'backward']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on def_direction16_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_direction16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_direction16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_direction16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_direction16')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_direction16'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_direction16', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_direction16', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_direction16


class def_isni5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_isni5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_isni5.subclass:
            return def_isni5.subclass(*args_, **kwargs_)
        else:
            return def_isni5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_isni5_impl(self, value):
        result = True
        # Validate type def_isni5_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_isni5_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_isni5_impl_patterns_, ))
                result = False
        return result
    validate_def_isni5_impl_patterns_ = [['^([0-9]{15}[0-9X])$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_isni5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_isni5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_isni5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_isni5')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_isni5'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_isni5', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_isni5', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_isni5


class def_iso_3166_2_code9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_2_code9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_2_code9.subclass:
            return def_iso_3166_2_code9.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_2_code9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_2_code9_impl(self, value):
        result = True
        # Validate type def_iso-3166-2-code9_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_2_code9_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_2_code9_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_2_code9_impl_patterns_ = [['^([A-Z]{2}\\-[A-Z0-9]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-2-code9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-2-code9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-2-code9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-2-code9')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-2-code9'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-2-code9', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-2-code9', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_2_code9


class def_iso_3166_3_code10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_3_code10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_3_code10.subclass:
            return def_iso_3166_3_code10.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_3_code10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_3_code10_impl(self, value):
        result = True
        # Validate type def_iso-3166-3-code10_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_3_code10_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_3_code10_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_3_code10_impl_patterns_ = [['^([A-Z]{4})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-3-code10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-3-code10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-3-code10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-3-code10')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-3-code10'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-3-code10', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-3-code10', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_3_code10


class def_iso_3166_1_code(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_1_code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_1_code.subclass:
            return def_iso_3166_1_code.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_1_code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_1_code_impl(self, value):
        result = True
        # Validate type def_iso-3166-1-code_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_1_code_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_1_code_impl_patterns_ = [['^([A-Z]{2})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-1-code', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-1-code')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-1-code':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-1-code')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-1-code'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-1-code', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-1-code', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_1_code


class def_ipi(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_ipi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_ipi.subclass:
            return def_ipi.subclass(*args_, **kwargs_)
        else:
            return def_ipi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_ipi_impl(self, value):
        result = True
        # Validate type def_ipi_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_ipi_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_ipi_impl_patterns_, ))
                result = False
        return result
    validate_def_ipi_impl_patterns_ = [['^([0-9]{11})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_ipi', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_ipi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_ipi':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_ipi')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_ipi'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_ipi', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_ipi', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_ipi


class def_incomplete_date(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_incomplete_date)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_incomplete_date.subclass:
            return def_incomplete_date.subclass(*args_, **kwargs_)
        else:
            return def_incomplete_date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_incomplete_date_impl(self, value):
        result = True
        # Validate type def_incomplete-date_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_incomplete_date_impl_patterns_, ))
                result = False
        return result
    validate_def_incomplete_date_impl_patterns_ = [['^([0-9]{4}(-[0-9]{2})?(-[0-9]{2})?)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_incomplete-date', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_incomplete-date')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_incomplete-date':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_incomplete-date')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_incomplete-date'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_incomplete-date', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_incomplete-date', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_incomplete_date


class def_quality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_quality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_quality.subclass:
            return def_quality.subclass(*args_, **kwargs_)
        else:
            return def_quality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_quality_impl(self, value):
        result = True
        # Validate type def_quality_impl, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['low', 'normal', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on def_quality_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_quality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_quality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_quality':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_quality')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_quality'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_quality', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_quality', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_quality


class def_iso_15924(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_15924)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_15924.subclass:
            return def_iso_15924.subclass(*args_, **kwargs_)
        else:
            return def_iso_15924(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_15924_impl(self, value):
        result = True
        # Validate type def_iso-15924_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_15924_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_15924_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_15924_impl_patterns_ = [['^([A-Z][a-z]{3})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-15924', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-15924')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-15924':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-15924')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-15924'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-15924', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-15924', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_15924


class def_time(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_time)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_time.subclass:
            return def_time.subclass(*args_, **kwargs_)
        else:
            return def_time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_time_impl(self, value):
        result = True
        # Validate type def_time_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_time_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_time_impl_patterns_, ))
                result = False
        return result
    validate_def_time_impl_patterns_ = [['^(([01][0-9]|2[0-3]):[0-5][0-9])$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_time', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_time')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_time':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_time')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_time'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_time', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_time', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_time


class def_direction(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_direction.subclass:
            return def_direction.subclass(*args_, **kwargs_)
        else:
            return def_direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_direction_impl(self, value):
        result = True
        # Validate type def_direction_impl, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['both', 'forward', 'backward']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on def_direction_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_direction')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_direction'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_direction', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_direction', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_direction


class def_isni(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_isni)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_isni.subclass:
            return def_isni.subclass(*args_, **kwargs_)
        else:
            return def_isni(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_isni_impl(self, value):
        result = True
        # Validate type def_isni_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_isni_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_isni_impl_patterns_, ))
                result = False
        return result
    validate_def_isni_impl_patterns_ = [['^([0-9]{15}[0-9X])$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_isni', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_isni')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_isni':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_isni')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_isni'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_isni', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_isni', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_isni


class def_iso_3166_2_code(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_2_code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_2_code.subclass:
            return def_iso_3166_2_code.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_2_code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_2_code_impl(self, value):
        result = True
        # Validate type def_iso-3166-2-code_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_2_code_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_2_code_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_2_code_impl_patterns_ = [['^([A-Z]{2}\\-[A-Z0-9]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-2-code', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-2-code')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-2-code':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-2-code')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-2-code'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-2-code', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-2-code', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_2_code


class def_iso_3166_3_code(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "mmd-2.0"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_iso_3166_3_code)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_iso_3166_3_code.subclass:
            return def_iso_3166_3_code.subclass(*args_, **kwargs_)
        else:
            return def_iso_3166_3_code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_3166_3_code_impl(self, value):
        result = True
        # Validate type def_iso-3166-3-code_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_3_code_impl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_3166_3_code_impl_patterns_, ))
                result = False
        return result
    validate_def_iso_3166_3_code_impl_patterns_ = [['^([A-Z]{4})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-3-code', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('def_iso-3166-3-code')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'def_iso-3166-3-code':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='def_iso-3166-3-code')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='def_iso-3166-3-code'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='def_iso-3166-3-code', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='def_iso-3166-3-code', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class def_iso_3166_3_code


class attribute_listType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType.subclass:
            return attribute_listType.subclass(*args_, **kwargs_)
        else:
            return attribute_listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType


class attributeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value_id = _cast(None, value_id)
        self.value_id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType.subclass:
            return attributeType.subclass(*args_, **kwargs_)
        else:
            return attributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value_id(self):
        return self.value_id
    def set_value_id(self, value_id):
        self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value_id), input_name='value-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value_id is not None:
            element.set('value-id', self.gds_format_string(self.value_id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
            self.validate_def_uuid(self.value_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType


class life_spanType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.begin = begin
        self.begin_nsprefix_ = None
        self.end = end
        self.end_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_spanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_spanType.subclass:
            return life_spanType.subclass(*args_, **kwargs_)
        else:
            return life_spanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def has__content(self):
        if (
            self.begin is not None or
            self.end is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-spanType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('life-spanType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'life-spanType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='life-spanType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='life-spanType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='life-spanType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-spanType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='end', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='life-spanType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.begin is not None:
            begin_ = self.begin
            begin_.to_etree(element, name_='begin', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.end is not None:
            end_ = self.end
            end_.to_etree(element, name_='end', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'begin':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
# end class life_spanType


class attribute_listType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType18.subclass:
            return attribute_listType18.subclass(*args_, **kwargs_)
        else:
            return attribute_listType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType18')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType18'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType18', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType18


class attributeType19(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_id=None, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.credited_as = _cast(None, credited_as)
        self.credited_as_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType19.subclass:
            return attributeType19.subclass(*args_, **kwargs_)
        else:
            return attributeType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_credited_as(self):
        return self.credited_as
    def set_credited_as(self, credited_as):
        self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType19')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType19'):
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType19', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType19', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType19


class track_listType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType.subclass:
            return track_listType.subclass(*args_, **kwargs_)
        else:
            return track_listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType


class track_listType20(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType20.subclass:
            return track_listType20.subclass(*args_, **kwargs_)
        else:
            return track_listType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType20')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType20'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType20', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType20


class track_listType22(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType22.subclass:
            return track_listType22.subclass(*args_, **kwargs_)
        else:
            return track_listType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType22')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType22'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType22', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType22


class trackType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.artist = artist
        self.artist_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType.subclass:
            return trackType.subclass(*args_, **kwargs_)
        else:
            return trackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='trackType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
# end class trackType


class languageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fluency=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fluency = _cast(None, fluency)
        self.fluency_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fluency(self):
        return self.fluency
    def set_fluency(self, fluency):
        self.fluency = fluency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_639(self, value):
        result = True
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_639_patterns_, ))
                result = False
        return result
    validate_def_iso_639_patterns_ = [['^([a-z]{3})$']]
    def validate_fluencyType(self, value):
        # Validate type fluencyType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['basic', 'intermediate', 'advanced', 'native']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fluencyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='languageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'languageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageType'):
        if self.fluency is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            outfile.write(' fluency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fluency), input_name='fluency')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='languageType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='languageType', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.fluency is not None:
            element.set('fluency', self.gds_format_string(self.fluency))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluency', node)
        if value is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            self.fluency = value
            self.fluency = ' '.join(self.fluency.split())
            self.validate_fluencyType(self.fluency)    # validate type fluencyType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class languageType


class track_listType24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if track is None:
            self.track = []
        else:
            self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType24.subclass:
            return track_listType24.subclass(*args_, **kwargs_)
        else:
            return track_listType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def add_track(self, value):
        self.track.append(value)
    def insert_track_at(self, index, value):
        self.track.insert(index, value)
    def replace_track_at(self, index, value):
        self.track[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType24')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType24'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            track_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType24', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType24


class track_listType25(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if track is None:
            self.track = []
        else:
            self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType25.subclass:
            return track_listType25.subclass(*args_, **kwargs_)
        else:
            return track_listType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def add_track(self, value):
        self.track.append(value)
    def insert_track_at(self, index, value):
        self.track.insert(index, value)
    def replace_track_at(self, index, value):
        self.track[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType25')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType25'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            track_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType25', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType25


class trackType26(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.artist = artist
        self.artist_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType26.subclass:
            return trackType26.subclass(*args_, **kwargs_)
        else:
            return trackType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackType26')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackType26'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='trackType26', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
# end class trackType26


class attribute_listType27(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType27.subclass:
            return attribute_listType27.subclass(*args_, **kwargs_)
        else:
            return attribute_listType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType27':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType27')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType27'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType27', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType27


class attributeType28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_id=None, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.credited_as = _cast(None, credited_as)
        self.credited_as_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType28.subclass:
            return attributeType28.subclass(*args_, **kwargs_)
        else:
            return attributeType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_credited_as(self):
        return self.credited_as
    def set_credited_as(self, credited_as):
        self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType28')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType28'):
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType28', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType28', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType28


class attribute_listType29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType29.subclass:
            return attribute_listType29.subclass(*args_, **kwargs_)
        else:
            return attribute_listType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType29')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType29'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType29', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType29


class attributeType30(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value_id = _cast(None, value_id)
        self.value_id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType30.subclass:
            return attributeType30.subclass(*args_, **kwargs_)
        else:
            return attributeType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value_id(self):
        return self.value_id
    def set_value_id(self, value_id):
        self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType30')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType30'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value_id), input_name='value-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType30', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType30', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value_id is not None:
            element.set('value-id', self.gds_format_string(self.value_id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
            self.validate_def_uuid(self.value_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType30


class attribute_listType31(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType31.subclass:
            return attribute_listType31.subclass(*args_, **kwargs_)
        else:
            return attribute_listType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType31')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType31'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType31', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType32.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType31


class attributeType32(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value_id = _cast(None, value_id)
        self.value_id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType32.subclass:
            return attributeType32.subclass(*args_, **kwargs_)
        else:
            return attributeType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value_id(self):
        return self.value_id
    def set_value_id(self, value_id):
        self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType32')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType32'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value_id), input_name='value-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType32', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType32', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value_id is not None:
            element.set('value-id', self.gds_format_string(self.value_id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
            self.validate_def_uuid(self.value_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType32


class life_spanType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.begin = begin
        self.begin_nsprefix_ = None
        self.end = end
        self.end_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_spanType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_spanType33.subclass:
            return life_spanType33.subclass(*args_, **kwargs_)
        else:
            return life_spanType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def has__content(self):
        if (
            self.begin is not None or
            self.end is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-spanType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('life-spanType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'life-spanType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='life-spanType33')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='life-spanType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='life-spanType33'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='life-spanType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_='mmd-2.0:', namespacedef_='', name_='end', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='life-spanType33', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.begin is not None:
            begin_ = self.begin
            begin_.to_etree(element, name_='begin', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if self.end is not None:
            end_ = self.end
            end_.to_etree(element, name_='end', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'begin':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            obj_ = def_incomplete_date.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
# end class life_spanType33


class attribute_listType35(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType35.subclass:
            return attribute_listType35.subclass(*args_, **kwargs_)
        else:
            return attribute_listType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType35')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType35'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType35', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType35


class attributeType36(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_id=None, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.credited_as = _cast(None, credited_as)
        self.credited_as_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType36.subclass:
            return attributeType36.subclass(*args_, **kwargs_)
        else:
            return attributeType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_credited_as(self):
        return self.credited_as
    def set_credited_as(self, credited_as):
        self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType36')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType36'):
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType36', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType36', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType36


class track_listType37(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType37.subclass:
            return track_listType37.subclass(*args_, **kwargs_)
        else:
            return track_listType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType37':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType37')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType37'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType37', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType37', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType37


class track_listType38(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType38.subclass:
            return track_listType38.subclass(*args_, **kwargs_)
        else:
            return track_listType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType38':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType38')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType38'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType38', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType38


class track_listType40(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType40.subclass:
            return track_listType40.subclass(*args_, **kwargs_)
        else:
            return track_listType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType40', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType40':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType40')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType40', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType40'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType40', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType42.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType40


class trackType42(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.artist = artist
        self.artist_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType42.subclass:
            return trackType42.subclass(*args_, **kwargs_)
        else:
            return trackType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType42', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackType42':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackType42')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackType42', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackType42'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='trackType42', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
# end class trackType42


class languageType43(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fluency=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fluency = _cast(None, fluency)
        self.fluency_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType43.subclass:
            return languageType43.subclass(*args_, **kwargs_)
        else:
            return languageType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fluency(self):
        return self.fluency
    def set_fluency(self, fluency):
        self.fluency = fluency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_iso_639(self, value):
        result = True
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_iso_639_patterns_, ))
                result = False
        return result
    validate_def_iso_639_patterns_ = [['^([a-z]{3})$']]
    def validate_fluencyType44(self, value):
        # Validate type fluencyType44, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['basic', 'intermediate', 'advanced', 'native']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fluencyType44' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='languageType43', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'languageType43':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageType43')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageType43'):
        if self.fluency is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            outfile.write(' fluency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fluency), input_name='fluency')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='languageType43', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='languageType43', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.fluency is not None:
            element.set('fluency', self.gds_format_string(self.fluency))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluency', node)
        if value is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            self.fluency = value
            self.fluency = ' '.join(self.fluency.split())
            self.validate_fluencyType44(self.fluency)    # validate type fluencyType44
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class languageType43


class track_listType45(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if track is None:
            self.track = []
        else:
            self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType45.subclass:
            return track_listType45.subclass(*args_, **kwargs_)
        else:
            return track_listType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def add_track(self, value):
        self.track.append(value)
    def insert_track_at(self, index, value):
        self.track.insert(index, value)
    def replace_track_at(self, index, value):
        self.track[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType45', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType45':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType45')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType45'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            track_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType45', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType45


class track_listType46(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        if track is None:
            self.track = []
        else:
            self.track = track
        self.track_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType46.subclass:
            return track_listType46.subclass(*args_, **kwargs_)
        else:
            return track_listType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def add_track(self, value):
        self.track.append(value)
    def insert_track_at(self, index, value):
        self.track.insert(index, value)
    def replace_track_at(self, index, value):
        self.track[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType46', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('track-listType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'track-listType46':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='track-listType46')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='track-listType46', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='track-listType46'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='track-listType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            track_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType46', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'track':
            obj_ = trackType47.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType46


class trackType47(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.artist = artist
        self.artist_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType47.subclass:
            return trackType47.subclass(*args_, **kwargs_)
        else:
            return trackType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_artist(self):
        return self.artist
    def set_artist(self, artist):
        self.artist = artist
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def has__content(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType47', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trackType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trackType47':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trackType47')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trackType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trackType47'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='trackType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.artist is not None:
            namespaceprefix_ = self.artist_nsprefix_ + ':' if (UseCapturedNS_ and self.artist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespaceprefix_ , eol_))
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_integer(self.length, input_name='length'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='trackType47', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'artist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'artist')
            value_ = self.gds_validate_string(value_, node, 'artist')
            self.artist = value_
            self.artist_nsprefix_ = child_.prefix
        elif nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'length')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
            self.length_nsprefix_ = child_.prefix
# end class trackType47


class attribute_listType48(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType48.subclass:
            return attribute_listType48.subclass(*args_, **kwargs_)
        else:
            return attribute_listType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType48', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType48':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType48')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType48', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType48'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType48', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType48


class attributeType49(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_id=None, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.credited_as = _cast(None, credited_as)
        self.credited_as_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType49.subclass:
            return attributeType49.subclass(*args_, **kwargs_)
        else:
            return attributeType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_credited_as(self):
        return self.credited_as
    def set_credited_as(self, credited_as):
        self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType49', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType49':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType49')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType49'):
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType49', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType49', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType49


class attribute_listType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        self.attribute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType50.subclass:
            return attribute_listType50.subclass(*args_, **kwargs_)
        else:
            return attribute_listType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def add_attribute(self, value):
        self.attribute.append(value)
    def insert_attribute_at(self, index, value):
        self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value):
        self.attribute[index] = value
    def has__content(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType50', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attribute-listType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attribute-listType50':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attribute-listType50')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attribute-listType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attribute-listType50'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attribute-listType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            namespaceprefix_ = self.attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.attribute_nsprefix_) else ''
            attribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType50', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_, reverse_mapping_=reverse_mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attribute':
            obj_ = attributeType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType50


class attributeType51(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_id = _cast(None, type_id)
        self.type_id_nsprefix_ = None
        self.value_id = _cast(None, value_id)
        self.value_id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType51.subclass:
            return attributeType51.subclass(*args_, **kwargs_)
        else:
            return attributeType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type_id(self):
        return self.type_id
    def set_type_id(self, type_id):
        self.type_id = type_id
    def get_value_id(self):
        return self.value_id
    def set_value_id(self, value_id):
        self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_def_uuid(self, value):
        # Validate type mmd-2.0:def_uuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_def_uuid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_def_uuid_patterns_, ))
    validate_def_uuid_patterns_ = [['^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12})$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType51', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributeType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributeType51':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributeType51')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributeType51'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_id), input_name='type-id')), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value_id), input_name='value-id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', name_='attributeType51', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType51', mapping_=None, reverse_mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_, nsmap=nsmap_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.gds_format_string(self.type_id))
        if self.value_id is not None:
            element.set('value-id', self.gds_format_string(self.value_id))
        if self.has__content():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        if reverse_mapping_ is not None:
            reverse_mapping_[element] = self
        return element
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
            self.validate_def_uuid(self.type_id)    # validate type def_uuid
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
            self.validate_def_uuid(self.value_id)    # validate type def_uuid
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType51


#
# End data representation classes.
#


GDSClassesMapping = {
    'area': def_area_element_inner,
    'area': def_area_element_inner1,
    'begin': def_incomplete_date,
    'begin': def_incomplete_date3,
    'begin-area': def_area_element_inner,
    'begin-area': def_area_element_inner1,
    'country': def_iso_3166_1_code,
    'country': def_iso_3166_1_code8,
    'date': def_incomplete_date,
    'date': def_incomplete_date3,
    'direction': def_direction,
    'direction': def_direction16,
    'end': def_incomplete_date,
    'end': def_incomplete_date3,
    'end-area': def_area_element_inner,
    'end-area': def_area_element_inner1,
    'first-release-date': def_incomplete_date,
    'first-release-date': def_incomplete_date3,
    'ipi': def_ipi,
    'ipi': def_ipi4,
    'isni': def_isni,
    'isni': def_isni5,
    'iso-3166-1-code': def_iso_3166_1_code,
    'iso-3166-1-code': def_iso_3166_1_code8,
    'iso-3166-2-code': def_iso_3166_2_code,
    'iso-3166-2-code': def_iso_3166_2_code9,
    'iso-3166-3-code': def_iso_3166_3_code,
    'iso-3166-3-code': def_iso_3166_3_code10,
    'member-since': def_incomplete_date,
    'member-since': def_incomplete_date3,
    'pregap': def_track_data,
    'pregap': def_track_data2,
    'quality': def_quality,
    'quality': def_quality17,
    'script': def_iso_15924,
    'script': def_iso_1592412,
    'time': def_time,
    'time': def_time7,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner1'
        rootClass = def_area_element_inner1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner1'
        rootClass = def_area_element_inner1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner1'
        rootClass = def_area_element_inner1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner1'
        rootClass = def_area_element_inner1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from models import *\n\n')
        sys.stdout.write('import models as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{http://musicbrainz.org/ns/mmd-2.0#}def_area-element_inner": "def_area-element_inner1",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_direction": "def_direction16",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_incomplete-date": "def_incomplete-date3",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_ipi": "def_ipi4",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_isni": "def_isni5",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iso-15924": "def_iso-1592412",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iso-3166-1-code": "def_iso-3166-1-code8",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iso-3166-2-code": "def_iso-3166-2-code9",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iso-3166-3-code": "def_iso-3166-3-code10",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iso-639": "def_iso-63911",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_isrc": "def_isrc13",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_iswc": "def_iswc14",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_locale": "def_locale6",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_quality": "def_quality17",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_time": "def_time7",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_track-data": "def_track-data2",
    "{http://musicbrainz.org/ns/mmd-2.0#}def_uuid": "def_uuid15",
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://musicbrainz.org/ns/mmd-2.0#': [('def_incomplete-date',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_ipi',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_isni',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_locale',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_time',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-1-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-2-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-3-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-639',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-15924',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_isrc',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iswc',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_uuid',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_direction',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_quality',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_area_element_inner',
                                         'musicbrainz_mmd.xsd',
                                         'CT'),
                                        ('def_track_data',
                                         'musicbrainz_mmd.xsd',
                                         'CT'),
                                        ('def_incomplete-date',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_ipi',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_isni',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_locale',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_time',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-1-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-2-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-3166-3-code',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-639',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iso-15924',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_isrc',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_iswc',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_uuid',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_direction',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_quality',
                                         'musicbrainz_mmd.xsd',
                                         'ST'),
                                        ('def_area_element_inner',
                                         'musicbrainz_mmd.xsd',
                                         'CT'),
                                        ('def_track_data',
                                         'musicbrainz_mmd.xsd',
                                         'CT')]}

__all__ = [
    "alias",
    "alias_list",
    "annotation",
    "annotation_list",
    "area_list",
    "artist",
    "artist_credit",
    "artist_list",
    "artwork",
    "asin",
    "attributeType",
    "attributeType19",
    "attributeType28",
    "attributeType30",
    "attributeType32",
    "attributeType36",
    "attributeType49",
    "attributeType51",
    "attribute_listType",
    "attribute_listType18",
    "attribute_listType27",
    "attribute_listType29",
    "attribute_listType31",
    "attribute_listType35",
    "attribute_listType48",
    "attribute_listType50",
    "back",
    "cancelled",
    "cdstub",
    "cdstub_list",
    "collection",
    "collection_list",
    "coordinates",
    "cover_art_archive",
    "darkened",
    "data_track_list",
    "def_area_element_inner",
    "def_area_element_inner1",
    "def_direction",
    "def_direction16",
    "def_incomplete_date",
    "def_incomplete_date3",
    "def_ipi",
    "def_ipi4",
    "def_isni",
    "def_isni5",
    "def_iso_15924",
    "def_iso_1592412",
    "def_iso_3166_1_code",
    "def_iso_3166_1_code8",
    "def_iso_3166_2_code",
    "def_iso_3166_2_code9",
    "def_iso_3166_3_code",
    "def_iso_3166_3_code10",
    "def_quality",
    "def_quality17",
    "def_time",
    "def_time7",
    "def_track_data",
    "def_track_data2",
    "disc",
    "disc_list",
    "edit_information",
    "editor",
    "editor_list",
    "ended",
    "entity_list",
    "event",
    "event_list",
    "format",
    "freedb_disc",
    "freedb_disc_list",
    "front",
    "gender",
    "genre",
    "genre_list",
    "instrument",
    "instrument_list",
    "ipi_list",
    "isni_list",
    "iso_3166_1_code_list",
    "iso_3166_2_code_list",
    "iso_3166_3_code_list",
    "isrc",
    "isrc_list",
    "iswc",
    "iswc_list",
    "label",
    "label_info",
    "label_info_list",
    "label_list",
    "languageType",
    "languageType43",
    "language_list",
    "life_span",
    "life_spanType",
    "life_spanType33",
    "medium",
    "medium_list",
    "metadata",
    "name_credit",
    "offset",
    "offset_list",
    "packaging",
    "place",
    "place_list",
    "primary_type",
    "puid",
    "puid_list",
    "rating",
    "recording",
    "recording_list",
    "relation",
    "relation_list",
    "release",
    "release_event",
    "release_event_list",
    "release_group",
    "release_group_list",
    "release_list",
    "secondary_type",
    "secondary_type_list",
    "series",
    "series_list",
    "status",
    "tag",
    "tag_list",
    "target",
    "text_representation",
    "trackType",
    "trackType26",
    "trackType42",
    "trackType47",
    "track_listType",
    "track_listType20",
    "track_listType22",
    "track_listType24",
    "track_listType25",
    "track_listType37",
    "track_listType38",
    "track_listType40",
    "track_listType45",
    "track_listType46",
    "url",
    "url_list",
    "user_genre",
    "user_genre_list",
    "user_tag",
    "user_tag_list",
    "video",
    "work",
    "work_list",
    "year"
]
