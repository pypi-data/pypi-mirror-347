Index: tests/aws/_packaging/test_dependencies.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\nimport logging\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom stelvio.aws._packaging import dependencies as deps\nfrom stelvio.aws._packaging.dependencies import (\n    _ACTIVE_CACHE_FILENAME,\n    RequirementsSpec,\n    get_or_install_dependencies,\n)\n\nlogger = logging.getLogger(__name__)\n\n\"\"\"\nTesting get_or_install_dependencies.\n\nWe need to test:\n- [x] cache key calculation (implicitly tested via cache miss/hit)\n- [x] use cache (cache hit)\n- [x] uv install (cache miss)\n- [x] pip install (cache miss)\n- [ ] normalizing requirements content (implicitly tested via cache key)\n- [ ] following -r -c (file-based tests)\n- [x] not allowing -r -c in inline (validation test)\n- [x] installer failure handling\n- [x] missing installer handling (uv/pip not found)\n\"\"\"\n\n\"\"\"\nTesting scenarios:\n\n- [x] inline cache miss (uv)\n- [x] inline cache miss (pip)\n- [x] inline cache hit\n- [x] no pip or uv found error\n- [ ] file cache miss\n- [ ] file cache hit\n- [x] uv/pip returns non zero error\n- [x] requirements with -r/-c in inline list - validation test\n- [ ] requirements with recursive/circular -r/-c - validation test\n- [ ] file not found error - Handled by function and layer respectively\n- [ ] requirements path outside project root error -Handled by function and layer respectively\n- [ ] requirements path is not a file error -Handled by function and layer respectively\n- [ ] requirements list with invalid items (non-string) - handled by FunctionConfig validation\n- [ ] requirements boolean True - handled by FunctionConfig validation\n- [ ] requirements empty string path - handled by FunctionConfig validation\n- [ ] requirements empty list - handled by FunctionConfig validation\n- [ ] requirements False - handled by FunctionConfig validation\n- [ ] requirements None (default lookup) - Function specific\n\"\"\"\n\"\"\"\n\nWe need to test:\n- [ ] cache key\n- [ ] use cache\n- [ ] uv or pip install\n- [ ] normalizing\n- [ ] following -r -c\n- [x] not allowing -r -c in inline\n\"\"\"\n\n\"\"\"\nTesting scenarios:\n\n- [x] inline cache mis\n- [x] inline cache hit\n- [ ] file\n- [ ] file not found\n- [x] pip\n- [x] uv\n- [x] no pip or uv\n- [x] no cache found\n- [x] cache found\n- [x] uv/pip returns non zero\n\n\"\"\"\n\n\n@pytest.fixture\ndef project_root(tmp_path: Path) -> Path:\n    \"\"\"Creates a temporary directory simulating a project root.\"\"\"\n    proj_dir = tmp_path / \"project\"\n    proj_dir.mkdir()\n    return proj_dir\n\n\n@pytest.fixture\ndef dependencies_cache_base(tmp_path: Path, monkeypatch) -> Path:\n    \"\"\"\n    Creates a temporary directory for dependency caches and patches\n    _get_lambda_dependencies_dir to use it.\n    \"\"\"\n    cache_base = tmp_path / \"dot_stelvio\" / \"lambda_dependencies\"\n    cache_base.mkdir(parents=True)\n\n    monkeypatch.setattr(deps, \"_get_lambda_dependencies_dir\", lambda subdir: cache_base / subdir)\n    return cache_base\n\n\n@pytest.fixture\ndef patch_installer_calls(monkeypatch):\n    \"\"\"Patches subprocess.run and shutil.which, returning the mocks.\"\"\"\n    mock_run = MagicMock(spec=subprocess.run)\n    mock_which = MagicMock(spec=shutil.which)\n\n    # Default success return value for subprocess.run\n    mock_run.return_value = subprocess.CompletedProcess(\n        args=[], returncode=0, stdout=\"Success\", stderr=\"\"\n    )\n\n    # Use monkeypatch for reliable patching within fixtures/tests\n    monkeypatch.setattr(subprocess, \"run\", mock_run)\n    monkeypatch.setattr(shutil, \"which\", mock_which)\n\n    return mock_run, mock_which\n\n\ndef _get_expected_cache_details(\n    requirements_content: str,\n    runtime: str,\n    architecture: str,\n    dependencies_cache_base: Path,\n    cache_subdirectory: str,\n) -> tuple[str, Path, Path]:\n    \"\"\"\n    Calculates expected cache key, directory path, and active file path\n    by replicating the expected hashing logic for inline requirements.\n    \"\"\"\n    py_version = runtime[6:]\n\n    content_hash = hashlib.sha256(requirements_content.encode(\"utf-8\")).hexdigest()\n    cache_key = f\"{architecture}__{py_version}__{content_hash[:16]}\"\n\n    cache_dir = dependencies_cache_base / cache_subdirectory / cache_key\n    active_file = dependencies_cache_base / cache_subdirectory / _ACTIVE_CACHE_FILENAME\n    return cache_key, cache_dir, active_file\n\n\ndef _create_side_effect_simulation(packages_to_simulate: list[str], raise_: bool = False):\n    \"\"\"Returns a function that simulates installer file creation.\"\"\"\n\n    def side_effect_run(*args, **kwargs):\n        cmd_list = args[0]\n        target_path_str = None\n        if \"--target\" in cmd_list:\n            try:\n                target_index = cmd_list.index(\"--target\")\n                if target_index + 1 < len(cmd_list):\n                    target_path_str = cmd_list[target_index + 1]\n            except ValueError:\n                pass  # Let main assertions catch missing target\n\n        if target_path_str:\n            target_path = Path(target_path_str)\n            target_path.mkdir(parents=True, exist_ok=True)  # Ensure base dir exists\n            for pkg_name in packages_to_simulate:\n                pkg_dir = target_path / pkg_name\n                pkg_dir.mkdir(exist_ok=True)\n                (pkg_dir / \"__init__.py\").touch()  # Simple simulation\n        if raise_:\n            raise subprocess.CalledProcessError(2, [])\n\n        # Create and return a standard success object directly\n        return subprocess.CompletedProcess(\n            args=cmd_list, returncode=0, stdout=\"Simulated Success\", stderr=\"\"\n        )\n\n    return side_effect_run\n\n\ndef assert_installer_call(\n    mock_run: MagicMock,\n    expected_installer_path: str,\n    expected_target_dir: Path,\n    expected_py_version: str,\n    expected_architecture: str,\n    expected_req_path: Path | None = None, # Expected original path if not inline\n    expect_inline_reqs: bool = True, # True if expecting '-r -' for inline reqs\n):\n    \"\"\"Asserts that subprocess.run was called correctly for the installer.\"\"\"\n    assert mock_run.call_count == 1, \"subprocess.run should be called exactly once\"\n    call_args, call_kwargs = mock_run.call_args\n    cmd_list = call_args[0]\n\n    platform_arch = \"aarch64\" if expected_architecture == \"arm64\" else \"x86_64\"\n    assert cmd_list[0] == expected_installer_path, \"Installer path mismatch\"\n    if expected_installer_path.endswith(\"/uv\"):\n        assert cmd_list[1] == \"pip\", \"Expected 'pip' subcommand for uv\"\n\n        assert cmd_list[2] == \"install\", \"Expected 'install' command for uv\"\n        assert cmd_list[3] == \"-r\", \"Expected '-r' flag for requirements file\"\n\n        req_file_index = 4\n        target_flag_index = 5\n        target_dir_index = 6\n        flags_start_index = 7\n    elif expected_installer_path.endswith(\"/pip\"):\n        assert cmd_list[1] == \"install\", \"Expected 'install' command for pip\"\n        assert cmd_list[2] == \"-r\", \"Expected '-r' flag for requirements file\"\n        req_file_index = 3\n        target_flag_index = 4\n        target_dir_index = 5\n        flags_start_index = 6\n\n        assert cmd_list[7] == \"--python-platform\", \"Missing '--python-platform' for uv\"\n        assert cmd_list[8] == f\"{platform_arch}-manylinux2014\", \"Missing platform flag for uv\"\n\n        assert cmd_list[9] == \"--python-version\", \"Missing '--python-version' flag\"\n        assert cmd_list[10] == expected_py_version, \"Python version mismatch in flags\"\n        assert cmd_list[11] == \"--only-binary=:all:\", \"Missing '--only-binary=:all:' flag\"\n\n    elif expected_installer_path.endswith(\"/pip\"):\n        assert cmd_list[1] == \"install\", \"Expected 'install' command for pip\"\n        assert cmd_list[2] == \"-r\", \"Expected '-r' flag for requirements file\"\n\n    else:\n        pytest.fail(f\"Unrecognized installer path: {expected_installer_path}\")\n\n    # Check requirements source flag/path\n    req_flag = cmd_list[req_file_index]\n    if expect_inline_reqs:\n        assert req_flag == \"-\", \"Expected '-r -' for inline requirements\"\n        # Check that input was passed via stdin\n        assert \"input\" in call_kwargs, \"Expected 'input' kwarg for inline requirements\"\n        # Optionally decode and check input content if needed, but might be overkill\n        # assert call_kwargs['input'].decode('utf-8') == expected_inline_content\n    else:\n        # File-based requirements\n        req_file_path = Path(req_flag)\n        assert req_file_path.is_absolute(), \"Expected absolute path for requirements file\"\n        if expected_req_path:\n            assert req_file_path == expected_req_path, \"Requirements file path mismatch\"\n        # Original file should still exist (installer shouldn't delete it)\n        assert req_file_path.exists(), f\"Original requirements file missing: {req_file_path}\"\n        assert \"input\" not in call_kwargs, \"Did not expect 'input' kwarg for file requirements\"\n\n    assert cmd_list[target_flag_index] == \"--target\", \"Expected '--target' flag\"\n    assert cmd_list[target_dir_index] == str(expected_target_dir), \"Target directory path mismatch\"\n\n        assert cmd_list[6] == \"--implementation\", \"Expected '--implementation' flag\"\n        assert cmd_list[7] == \"cp\", \"Expected 'cp' flag\"\n\n        assert cmd_list[8] == \"--platform\", \"Missing '--python-platform' for pip\"\n        assert cmd_list[9] == f\"manylinux2014_{platform_arch}\", \"Missing platform flag for pip\"\n        assert cmd_list[10] == \"--python-version\", \"Missing '--python-version' flag\"\n        assert cmd_list[11] == expected_py_version, \"Python version mismatch in flags\"\n        assert cmd_list[12] == \"--only-binary=:all:\", \"Missing '--only-binary=:all:' flag\"\n\n    # Check flags based on installer type\n    flags_list = cmd_list[flags_start_index:]\n    if expected_installer_path.endswith(\"/uv\"):\n        assert \"--python-platform\" in flags_list, \"Missing '--python-platform' for uv\"\n        assert f\"{platform_arch}-manylinux2014\" in flags_list, \"Missing platform flag for uv\"\n        assert \"--python-version\" in flags_list, \"Missing '--python-version' flag\"\n        assert expected_py_version in flags_list, \"Python version mismatch in flags\"\n        assert \"--only-binary=:all:\" in flags_list, \"Missing '--only-binary=:all:' flag\"\n    elif expected_installer_path.endswith(\"/pip\"):\n        assert \"--implementation\" in flags_list, \"Expected '--implementation' flag\"\n        assert \"cp\" in flags_list, \"Expected 'cp' flag\"\n        assert \"--platform\" in flags_list, \"Missing '--platform' for pip\"\n        assert f\"manylinux2014_{platform_arch}\" in flags_list, \"Missing platform flag for pip\"\n        assert \"--python-version\" in flags_list, \"Missing '--python-version' flag\"\n        assert expected_py_version in flags_list, \"Python version mismatch in flags\"\n        assert \"--only-binary=:all:\" in flags_list, \"Missing '--only-binary=:all:' flag\"\n\n\ndef assert_active_cache_file(expected_active_file_path: Path, expected_cache_key: str):\n    \"\"\"Asserts the active cache file exists and contains the key.\"\"\"\n    assert expected_active_file_path.is_file(), \"Active cache file not found\"\n    # Read all keys, allow for multiple keys if tests run sequentially without cleanup\n    active_keys = set(expected_active_file_path.read_text().splitlines())\n    assert expected_cache_key in active_keys, \"Cache key not found in active cache file\"\n\n\ndef test_get_or_install_dependencies_inline_requirements_cache_miss_uv(\n    project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    requirements_list = [\"requests==2.28.1\", \"boto3>=1.20.0\"]\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n    installer_path = \"/fake/path/to/uv\"\n\n    # Configure mocks provided by the fixture\n    mock_shutil_which.side_effect = lambda cmd: installer_path if cmd == \"uv\" else None\n    mock_subprocess_run.side_effect = _create_side_effect_simulation([\"requests\", \"boto3\"])\n\n    expected_cache_key, expected_cache_dir, expected_active_file = _get_expected_cache_details(\n        requirements_content=\"\\n\".join(sorted(requirements_list)),\n        runtime=runtime,\n        architecture=architecture,\n        dependencies_cache_base=dependencies_cache_base,\n        cache_subdirectory=cache_subdirectory,\n    )\n\n    # Act\n    result_cache_dir = get_or_install_dependencies(\n        requirements_source=source,\n        runtime=runtime,\n        architecture=architecture,\n        project_root=project_root,\n        cache_subdirectory=cache_subdirectory,\n        log_context=\"TestFunction\",\n    )\n\n    # Assert\n    assert result_cache_dir == expected_cache_dir\n    assert expected_cache_dir.is_dir()\n\n    # Check that the simulated installed files exist (basic check)\n    assert (expected_cache_dir / \"requests\" / \"__init__.py\").is_file()\n    assert (expected_cache_dir / \"boto3\" / \"__init__.py\").is_file()\n\n    assert_installer_call(\n        mock_run=mock_subprocess_run,\n        expected_installer_path=installer_path,\n        expected_target_dir=expected_cache_dir,\n        expected_py_version=runtime[6:],\n        expected_architecture=architecture,\n        expect_inline_reqs=True, # Expect '-r -'\n    )\n    assert_active_cache_file(expected_active_file, expected_cache_key)\n\n\ndef test_get_or_install_dependencies_inline_requirements_cache_miss_pip(\n    project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    requirements_list = [\"requests==2.28.1\", \"boto3>=1.20.0\"]\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n    installer_path = \"/fake/path/to/pip\"\n\n    # Configure mocks provided by the fixture\n    mock_shutil_which.side_effect = lambda cmd: installer_path if cmd == \"pip\" else None\n    mock_subprocess_run.side_effect = _create_side_effect_simulation([\"requests\", \"boto3\"])\n\n    expected_cache_key, expected_cache_dir, expected_active_file = _get_expected_cache_details(\n        requirements_content=\"\\n\".join(sorted(requirements_list)),\n        runtime=runtime,\n        architecture=architecture,\n        dependencies_cache_base=dependencies_cache_base,\n        cache_subdirectory=cache_subdirectory,\n    )\n\n    # Act\n    result_cache_dir = get_or_install_dependencies(\n        requirements_source=source,\n        runtime=runtime,\n        architecture=architecture,\n        project_root=project_root,\n        cache_subdirectory=cache_subdirectory,\n        log_context=\"TestFunction\",\n    )\n\n    # Assert\n    assert result_cache_dir == expected_cache_dir\n    assert expected_cache_dir.is_dir()\n\n    # Check that the simulated installed files exist (basic check)\n    assert (expected_cache_dir / \"requests\" / \"__init__.py\").is_file()\n    assert (expected_cache_dir / \"boto3\" / \"__init__.py\").is_file()\n\n    assert_installer_call(\n        mock_run=mock_subprocess_run,\n        expected_installer_path=installer_path,\n        expected_target_dir=expected_cache_dir,\n        expected_py_version=runtime[6:],\n        expected_architecture=architecture,\n        expect_inline_reqs=True, # Expect '-r -'\n    )\n    assert_active_cache_file(expected_active_file, expected_cache_key)\n\n\ndef test_get_or_install_dependencies_inline_requirements_cache_miss_no_uv_or_pip_found(\n    project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    requirements_list = [\"requests==2.28.1\", \"boto3>=1.20.0\"]\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n\n    # Configure mocks provided by the fixture\n    mock_shutil_which.return_value = None\n\n    # Act & Assert\n    with pytest.raises(\n        RuntimeError,\n        match=\"Could not find 'pip' or 'uv'. Please ensure one is installed and in your PATH.\",\n    ):\n        get_or_install_dependencies(\n            requirements_source=source,\n            runtime=runtime,\n            architecture=architecture,\n            project_root=project_root,\n            cache_subdirectory=cache_subdirectory,\n            log_context=\"TestFunction\",\n        )\n    mock_subprocess_run.assert_not_called()\n\n\n@pytest.mark.parametrize(\n    \"requirements_list\",\n    [\n        [\"requests\", \"-r file.txt\", \"boto3>=1.20.0\"],\n        [\"requests\", \" -r file.txt\", \"boto3>=1.20.0\"],\n        [\"requests\", \"-c file.txt\", \"boto3>=1.20.0\"],\n        [\"requests\", \" -c file.txt\", \"boto3>=1.20.0\"],\n        [\"requests\", \" -c file.txt # some comment\", \"-r file.txt\", \"boto3>=1.20.0\"],\n    ],\n)\ndef test_get_or_install_dependencies_inline_requirements_raises_when_r_or_c(\n    requirements_list, project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    # TODO: Maybe we should validate this on layer/function level before we get to get or install?\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n\n    # Configure mocks provided by the fixture\n    mock_shutil_which.return_value = None\n\n    # Act & Assert\n    with pytest.raises(\n        ValueError,\n        match=\"'-r' or '-c' references are not allowed  when providing requirements as list. \",\n    ):\n        get_or_install_dependencies(\n            requirements_source=source,\n            runtime=runtime,\n            architecture=architecture,\n            project_root=project_root,\n            cache_subdirectory=cache_subdirectory,\n            log_context=\"TestFunction\",\n        )\n    mock_subprocess_run.assert_not_called()\n    mock_shutil_which.assert_not_called()\n\n\ndef test_get_or_install_dependencies_inline_requirements_cache_miss_install_fails(\n    project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    requirements_list = [\"requests==2.28.1\", \"boto3>=1.20.0\"]\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n\n    # Configure mocks provided by the fixture\n    mock_shutil_which.return_value = \"/fake/path/to/installer\"\n    mock_subprocess_run.side_effect = _create_side_effect_simulation(\n        [\"requests\", \"boto3\"], raise_=True\n    )\n\n    # Act & Assert\n    with pytest.raises(\n        RuntimeError,\n        match=r\"Stelvio: \\[TestFunction\\] Failed to install dependencies. Check logs for details.\",\n    ):\n        get_or_install_dependencies(\n            requirements_source=source,\n            runtime=runtime,\n            architecture=architecture,\n            project_root=project_root,\n            cache_subdirectory=cache_subdirectory,\n            log_context=\"TestFunction\",\n        )\n\n\ndef test_get_or_install_dependencies_inline_requirements_cache_hit(\n    project_root: Path, dependencies_cache_base: Path, patch_installer_calls\n):\n    \"\"\"\n    Tests that if the cache directory exists, it's returned directly\n    and the installer is not called.\n    \"\"\"\n    # Arrange\n    mock_subprocess_run, mock_shutil_which = patch_installer_calls\n    requirements_list = [\"requests==2.28.1\", \"boto3>=1.20.0\"]\n    runtime = \"python3.12\"\n    architecture = \"x86_64\"\n    cache_subdirectory = \"functions\"\n    source = RequirementsSpec(content=\"\\n\".join(requirements_list), path_from_root=None)\n    log_context = \"TestFunctionCacheHit\"\n\n    # Calculate expected paths/key\n    expected_cache_key, expected_cache_dir, expected_active_file = _get_expected_cache_details(\n        requirements_content=\"\\n\".join(sorted(requirements_list)),\n        runtime=runtime,\n        architecture=architecture,\n        dependencies_cache_base=dependencies_cache_base,\n        cache_subdirectory=cache_subdirectory,\n    )\n\n    # Pre-populate the cache directory\n    expected_cache_dir.mkdir(parents=True)\n    # Add a dummy file to simulate existing installed packages\n    dummy_package_file = expected_cache_dir / \"dummy_package.py\"\n    dummy_package_file.touch()\n\n    # Configure mocks (installer shouldn't be called, but mocks are active)\n    mock_shutil_which.side_effect = lambda cmd: \"/fake/path/to/uv\" if cmd == \"uv\" else None\n\n    # Act\n    result_cache_dir = get_or_install_dependencies(\n        requirements_source=source,\n        runtime=runtime,\n        architecture=architecture,\n        project_root=project_root,\n        cache_subdirectory=cache_subdirectory,\n        log_context=log_context,\n    )\n\n    # Assert\n    assert result_cache_dir == expected_cache_dir, (\n        \"Function should return the existing cache directory path\"\n    )\n    assert expected_cache_dir.is_dir(), \"Cache directory should still exist\"\n    assert dummy_package_file.is_file(), \"Pre-existing file in cache directory should remain\"\n\n    # Crucially, assert the installer was NOT called\n    mock_subprocess_run.assert_not_called()\n\n    # Active cache file should still be updated/contain the key\n    assert_active_cache_file(expected_active_file, expected_cache_key)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/aws/_packaging/test_dependencies.py b/tests/aws/_packaging/test_dependencies.py
--- a/tests/aws/_packaging/test_dependencies.py	(revision c8870e882ea165ec84f24f3e5362405cf4512ed8)
+++ b/tests/aws/_packaging/test_dependencies.py	(date 1745491791837)
@@ -179,8 +179,8 @@
     expected_target_dir: Path,
     expected_py_version: str,
     expected_architecture: str,
-    expected_req_path: Path | None = None, # Expected original path if not inline
-    expect_inline_reqs: bool = True, # True if expecting '-r -' for inline reqs
+    expected_req_path: Path | None = None,  # Expected original path if not inline
+    expect_inline_reqs: bool = True,  # True if expecting '-r -' for inline reqs
 ):
     """Asserts that subprocess.run was called correctly for the installer."""
     assert mock_run.call_count == 1, "subprocess.run should be called exactly once"
@@ -242,14 +242,14 @@
     assert cmd_list[target_flag_index] == "--target", "Expected '--target' flag"
     assert cmd_list[target_dir_index] == str(expected_target_dir), "Target directory path mismatch"
 
-        assert cmd_list[6] == "--implementation", "Expected '--implementation' flag"
-        assert cmd_list[7] == "cp", "Expected 'cp' flag"
+    assert cmd_list[6] == "--implementation", "Expected '--implementation' flag"
+    assert cmd_list[7] == "cp", "Expected 'cp' flag"
 
-        assert cmd_list[8] == "--platform", "Missing '--python-platform' for pip"
-        assert cmd_list[9] == f"manylinux2014_{platform_arch}", "Missing platform flag for pip"
-        assert cmd_list[10] == "--python-version", "Missing '--python-version' flag"
-        assert cmd_list[11] == expected_py_version, "Python version mismatch in flags"
-        assert cmd_list[12] == "--only-binary=:all:", "Missing '--only-binary=:all:' flag"
+    assert cmd_list[8] == "--platform", "Missing '--python-platform' for pip"
+    assert cmd_list[9] == f"manylinux2014_{platform_arch}", "Missing platform flag for pip"
+    assert cmd_list[10] == "--python-version", "Missing '--python-version' flag"
+    assert cmd_list[11] == expected_py_version, "Python version mismatch in flags"
+    assert cmd_list[12] == "--only-binary=:all:", "Missing '--only-binary=:all:' flag"
 
     # Check flags based on installer type
     flags_list = cmd_list[flags_start_index:]
@@ -325,7 +325,7 @@
         expected_target_dir=expected_cache_dir,
         expected_py_version=runtime[6:],
         expected_architecture=architecture,
-        expect_inline_reqs=True, # Expect '-r -'
+        expect_inline_reqs=True,  # Expect '-r -'
     )
     assert_active_cache_file(expected_active_file, expected_cache_key)
 
@@ -378,7 +378,7 @@
         expected_target_dir=expected_cache_dir,
         expected_py_version=runtime[6:],
         expected_architecture=architecture,
-        expect_inline_reqs=True, # Expect '-r -'
+        expect_inline_reqs=True,  # Expect '-r -'
     )
     assert_active_cache_file(expected_active_file, expected_cache_key)
 
