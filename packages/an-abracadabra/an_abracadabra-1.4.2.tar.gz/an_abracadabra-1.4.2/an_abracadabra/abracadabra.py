# -*- coding: utf-8 -*-
"""ABRA_20250511_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NfiOYvoTQ_WrxujsQfX7Kky3iHA-hKO-

# Abracadabra
シンボリックリンクを生成する。

リンク元をPersistent(GDrive), リンク先をLocalに置き、実行権限を持たない大量のストレージ領域を、持つものに変えることがAbracadabraの主目的である。


```
2025/05/10 1.1.0 暫定版完成
2025/05/11 1.2.3 完成
2025/05/11 1.3.0 シンボリックリンク削除ルーチンを改良
2025/05/11 1.4.2 FolderSymlinksUtilityを改良
```

---

# Abracadabra

## 1. モジュール定義
"""

# @title a. FileSymlinksUtility 定義
# abracadabra.py

import os
import shutil
import logging
from pathlib import Path

# モジュールロガー取得＆NullHandlerをアタッチ
logger = logging.getLogger(__name__)
logger.addHandler( logging.NullHandler() )

#―――――――――――――
# モジュールレベルのデフォルト定義
#―――――――――――――
FILE_PAIRS = {
    "config.json":       "config.json",
    "styles.csv":        "styles.csv",
    "webui-user.sh":     "webui-user.sh"
}


#―――――――――――――
# ファイル用シンボリックリンクユーティリティ
#―――――――――――――
class FileSymlinksUtility:
    def __init__(self,
                 gd_root: Path,
                 sd_root: Path,
                 extra_file_pairs: dict = None,
                 SD_mode: bool = False ):
        """
        ファイル間のシンボリックリンクを生成します。
        args:
            gd_root( Path ) : Google Drive 側 root パス
            sd_root( Path ) : SD WebUI 側 root パス
            extra_file_pairs( dict{ str: str } ): 追加/上書きするファイルペア {sd_rel: gd_rel, …}
            SD_mode( bool ) : True なら、StableDiffusion用にファイルを新設する。
        """
        self.gd_root    = Path(gd_root)
        self.sd_root    = Path(sd_root)
        self.file_pairs = FILE_PAIRS.copy()
        if extra_file_pairs:
            self.file_pairs.update(extra_file_pairs)

    def _create_symlink(self, sd_path: Path, gd_path: Path):
        """
        シンボリックリンクを作成（既存削除＋Unsupported時はコピーにフォールバック）
        """
        # 1. 既存のシンボリックリンクは unlink() で消す
        if sd_path.is_symlink():
            sd_path.unlink()
            logger.info(f"既存シンボリックリンク削除: {sd_path}")
        # 2. 実ファイル／フォルダが残っていたら削除
        elif sd_path.exists():
            sd_path.unlink()
            logger.info(f"既存ファイル削除: {sd_path}")

        # 親ディレクトリを作成
        sd_path.parent.mkdir(parents=True, exist_ok=True)

        # 3. シンボリックリンクを試みる
        try:
            sd_path.symlink_to(gd_path, target_is_directory=False)
            logger.info(f"ファイルリンク作成: {sd_path} → {gd_path}")
        except OSError as e:
            # Errno 95 (Operation not supported) 等ならコピーにフォールバック
            logger.warning(f"シンボリックリンク作成失敗 ({e.errno})。ファイルをコピーします: {sd_path}")
            shutil.copy2(gd_path, sd_path)
            logger.info(f"ファイルコピー完了: {gd_path} → {sd_path}")

    def create_file_symlinks(self):
        """ファイルタイプのリンクをすべて作成"""
        logger.info("=== ファイルのシンボリックリンク作成 ===")
        for sd_rel, gd_rel in self.file_pairs.items():
            sd_file = self.sd_root / sd_rel
            gd_file = self.gd_root / gd_rel

            if not gd_file.exists():
                logger.info( f"シンボリックリンクを生成しようとしましたが、ファイルが存在しません : { gd_file }" )
            else:
                self._create_symlink(sd_file, gd_file)

# @title b. FolderSymlinksUtility 定義
import os
import shutil
import logging
from pathlib import Path

# モジュールロガー取得＆NullHandlerをアタッチ
logger = logging.getLogger(__name__)
logger.addHandler( logging.NullHandler() )

#―――――――――――――
# モジュールレベルのデフォルト定義
#―――――――――――――
FOLDER_PAIRS = {
    "models/Stable-diffusion":  "CheckPoint",
    "models/Lora":              "Lora",
    "models/VAE":               "VAE",
    "models/ESRGAN":            "ESRGAN",
    "models/ControlNet":        "ControlNet",
    "models/hypernetworks":     "hypernetworks",
    "models/embeddings":        "embeddings",
    "models/extensions":        "extensions"
}

#―――――――――――――
# フォルダ用シンボリックリンクユーティリティ
#―――――――――――――
class FolderSymlinksUtility:
    def __init__(self,
                 gd_root: Path,
                 sd_root: Path,
                 extra_folder_pairs: dict = None,
                 use_defaults: bool = False):
        """
        フォルダ間のシンボリックリンクを生成します
        args:
            gd_root( Path ): Google Drive 側 root パス
            sd_root( Path ): SD WebUI 側 root パス
            extra_folder_pairs( dict{ str : str } ): 追加/上書きするフォルダペア {sd_rel: gd_rel, …}
            use_defaults( bool = False ): デフォルトの folder_pairs を実行するかどうか
        """
        self.gd_root     = Path(gd_root)
        self.sd_root     = Path(sd_root)
        # デフォルトマップを残すかどうか
        self.folder_pairs = FOLDER_PAIRS.copy() if use_defaults else {}
        if extra_folder_pairs:
            self.folder_pairs.update(extra_folder_pairs)

    # def _create_symlink(self, sd_path: Path, gd_path: Path):
        # """
        # シンボリックリンクを作成（既存解除＋Unsupported時はコピーにフォールバック）
        # """
        # # 1. 既存シンボリックリンクなら解除
        # if sd_path.is_symlink():
        #     sd_path.unlink()
        #     logger.info(f"既存フォルダシンボリックリンク削除: {sd_path}")
        # # 2. 実ディレクトリが残っていれば削除
        # elif sd_path.exists():
        #     shutil.rmtree(sd_path)
        #     logger.info(f"既存フォルダ削除: {sd_path}")

        # # 3. 親ディレクトリ確保
        # sd_path.parent.mkdir(parents=True, exist_ok=True)

        # # 4. リンク or コピー
        # try:
        #     sd_path.symlink_to(gd_path, target_is_directory=True)
        #     logger.info(f"フォルダリンク作成: {sd_path} → {gd_path}")
        # except OSError as e:
        #     logger.warning(f"シンボリックリンク作成失敗 ({e.errno})。フォルダをコピーします: {sd_path}")
        #     shutil.copytree(gd_path, sd_path)
        #     logger.info(f"フォルダコピー完了: {gd_path} → {sd_path}")

    def create_folder_symlinks(self):
        """フォルダタイプのリンクをすべて作成"""
        logger.info("=== フォルダのシンボリックリンク作成 ===")
        for sd_rel, gd_rel in self.folder_pairs.items():
            sd_dir = self.sd_root / sd_rel
            gd_dir = self.gd_root / gd_rel

            # ─────────────────────────────────────────────────
            # サイクル防止チェック：sd_dir と gd_dir が同じ先を指すならスキップ
            try:
                if sd_dir.resolve() == gd_dir.resolve():
                    logger.info(f"サイクル検出のためリンクをスキップ: {sd_dir} → {gd_dir}")
                    continue
            except Exception:
                # resolve() がエラーになる場合は無視して進める
                pass
             # ─────────────────────────────────────────────────

            # 既存シンボリックなら解除
            if gd_dir.is_symlink():
                gd_dir.unlink()
                logger.info(f"既存シンボリックリンク削除: {gd_dir}")
            # 実ディレクトリがあればそのまま／exist_ok=True で安全に
            if not gd_dir.exists():
                gd_dir.mkdir(parents=True, exist_ok=True)
                logger.info(f"Google Drive 側フォルダ作成: {gd_dir}")
            # 親ディレクトリ確保
            sd_dir.parent.mkdir(parents=True, exist_ok=True)
            # シンボリックリンク作成
            self._create_symlink( sd_dir=sd_dir, gd_dir=gd_dir )

    def _create_symlink(self, sd_dir: Path, gd_dir: Path):
        """
        シンボリックリンクを作成（既存解除＋Unsupported時はコピーにフォールバック）
        args:
            sd_dir( Path ): SD WebUI 側パス
            gd_dir( Path ): Google Drive 側パス
        """
        try:
            sd_dir.symlink_to(gd_dir, target_is_directory=True)
            logger.info(f"フォルダリンク作成: {sd_dir} → {gd_dir}")
        except OSError as e:
            logger.warning(f"シンボリックリンク失敗({e.errno})、コピーにフォールバック: {sd_dir}")
            shutil.copytree(gd_dir, sd_dir)
            logger.info(f"フォルダコピー完了: {gd_dir} → {sd_dir}")