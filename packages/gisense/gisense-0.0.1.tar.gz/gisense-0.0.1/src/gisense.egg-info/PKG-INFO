Metadata-Version: 2.2
Name: gisense
Version: 0.0.1
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: numpy
Requires-Dist: matplotlib
Provides-Extra: dev
Requires-Dist: pytest; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: geopandas; extra == "dev"
Dynamic: description
Dynamic: description-content-type
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python

# ğŸ§  åœ°ç†ç©ºé—´æ„ŸçŸ¥ç³»ç»Ÿï¼ˆGeospatial Sense Systemï¼‰å®Œæ•´é¡¹ç›®æ¨¡æ¿

## ğŸ“Œ é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ª**åœ°ç†ç©ºé—´æ„ŸçŸ¥ç³»ç»Ÿ**ï¼Œå¸®åŠ©æ™ºèƒ½ä½“ï¼ˆå¦‚è‡ªåŠ¨é©¾é©¶è½¦è¾†ã€æœºå™¨äººã€æ— äººæœºç­‰ï¼‰æ„ŸçŸ¥å’Œç†è§£å…¶å‘¨å›´çš„åœ°ç†ç¯å¢ƒã€‚è¯¥ç³»ç»Ÿæ”¯æŒä»å¤šç§æ•°æ®æºï¼ˆåŒ…æ‹¬æ‰‹åŠ¨è¾“å…¥ã€GeoJSON æ–‡ä»¶ã€Shapefile æ–‡ä»¶ï¼‰åŠ è½½åœ°ç†æ•°æ®ï¼Œå¹¶æä¾›è·¯å¾„è§„åˆ’ã€å¯è§†åŒ–ã€æ„ŸçŸ¥ç­‰åŠŸèƒ½ã€‚

---

## ğŸ§± ä¸€ã€æ€»ä½“æ¶æ„è®¾è®¡

### âœ… æ ¸å¿ƒç›®æ ‡
- **ç»Ÿä¸€å¤„ç†åœ°ç†æ•°æ®**ï¼šPOIã€é“è·¯ç½‘ç»œã€åæ ‡ç‚¹ã€‚
- **å¤šæ•°æ®æºæ”¯æŒ**ï¼šæ”¯æŒ `.geojson` å’Œ `.shp` æ–‡ä»¶å¯¼å…¥ã€‚
- **è‡ªåŠ¨èŠ‚ç‚¹åˆå¹¶**ï¼šé¿å…é‡å¤çš„ POI èŠ‚ç‚¹ã€‚
- **è·¯å¾„è§„åˆ’ä¸åˆ†æ**ï¼šDijkstraã€A* ç­‰ç®—æ³•ã€‚
- **å¯è§†åŒ–èƒ½åŠ›**ï¼šåœ°å›¾å±•ç¤ºã€è·¯å¾„é«˜äº®ã€çƒ­åŠ›å›¾ç­‰ã€‚
- **æ¨¡å—åŒ–ç»“æ„**ï¼šä¾¿äºæ‰©å±•ã€æµ‹è¯•å’Œç»´æŠ¤ã€‚

---

## ğŸ“ äºŒã€ç›®å½•ç»“æ„ï¼ˆæ¨èï¼‰

```
geospatial-awareness/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ gisense/
â”‚       â”œâ”€â”€ core/                 # æ ¸å¿ƒç±»å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ graph.py          # LocationGraph ä¸»ç±»
â”‚       â”‚   â”œâ”€â”€ exceptions.py     # è‡ªå®šä¹‰å¼‚å¸¸ç±»
â”‚       â”‚   â””â”€â”€ observer.py       # æ™ºèƒ½ä½“è§‚å¯Ÿè€…
â”‚       â”œâ”€â”€ entities/             # æ•°æ®å®ä½“å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ coordinate.py     # ç»çº¬åº¦å°è£…
â”‚       â”‚   â”œâ”€â”€ poi.py            # POI ç±»
â”‚       â”‚   â””â”€â”€ road.py           # Road ç±»
â”‚       â”œâ”€â”€ io/                   # è¾“å…¥è¾“å‡ºæ¨¡å—
â”‚       â”‚   â”œâ”€â”€ geojson_reader.py # GeoJSON è§£æ
â”‚       â”‚   â””â”€â”€ shapefile_reader.py # Shapefile è§£æ
â”‚       â”œâ”€â”€ algorithms/           # è·¯å¾„è§„åˆ’ç®—æ³•
â”‚       â”‚   â”œâ”€â”€ pathfinding.py    # Dijkstra/A*
â”‚       â”‚   â””â”€â”€ perception.py     # åœ°ç†æ„ŸçŸ¥é€»è¾‘
â”‚       â”œâ”€â”€ visualization/        # å¯è§†åŒ–æ¨¡å—
â”‚       â”‚   â””â”€â”€ map_visualizer.py # è·¯ç½‘/è·¯å¾„å¯è§†åŒ–
â”‚       â””â”€â”€ utils/                # å·¥å…·å‡½æ•°
â”‚           â”œâ”€â”€ distance.py       # è·ç¦»è®¡ç®—
â”‚           â””â”€â”€ geometry.py       # å‡ ä½•æ“ä½œ
â”œâ”€â”€ tests/                        # å•å…ƒæµ‹è¯•
â”œâ”€â”€ docs/                         # æ–‡æ¡£ï¼ˆSphinxï¼‰
â”œâ”€â”€ examples/                     # ä½¿ç”¨ç¤ºä¾‹è„šæœ¬
â”œâ”€â”€ pyproject.toml                # æ„å»ºé…ç½®æ–‡ä»¶
â”œâ”€â”€ requirements.txt              # ç¬¬ä¸‰æ–¹ä¾èµ–
â””â”€â”€ README.md                     # é¡¹ç›®è¯´æ˜æ–‡æ¡£
```

---

## ğŸ§© ä¸‰ã€æ ¸å¿ƒç±»ä¸æ¨¡å—è®¾è®¡

### 1. `LocationGraph`ï¼ˆsrc/gisense/core/graph.pyï¼‰

> ä½œä¸ºæ•´ä¸ªç³»ç»Ÿçš„ä¸»å…¥å£ï¼Œè´Ÿè´£ç®¡ç† POIã€Roadã€é‚»æ¥è¡¨ï¼Œå¹¶æä¾›è·¯å¾„æŸ¥æ‰¾ã€æ•°æ®å¯¼å…¥ã€æ„ŸçŸ¥æ¥å£ã€‚

```python
from typing import Dict, List, Optional
from gisense.entities.poi import POI
from gisense.entities.road import Road
from gisense.utils.geometry import CoordinateMatcher

class LocationGraph:
    def __init__(self):
        self.pois: Dict[str, POI] = {}
        self.roads: Dict[str, Road] = {}
        self.adjacency_list: Dict[str, Dict[str, str]] = {}
        self._coordinate_to_poi_id = CoordinateMatcher()  # è‡ªåŠ¨å»é‡ç›¸åŒåæ ‡çš„POI

    def add_poi(self, poi: POI) -> None:
        coord_key = (poi.coordinate.latitude, poi.coordinate.longitude)
        if coord_key in self._coordinate_to_poi_id:
            existing_id = self._coordinate_to_poi_id[coord_key]
            print(f"Coordinate conflict: '{poi.id}' merged with '{existing_id}'")
            return
        if poi.id in self.pois:
            raise ValueError(f"POI ID '{poi.id}' already exists")
        self.pois[poi.id] = poi
        self.adjacency_list[poi.id] = {}

    def add_road(self, road: Road) -> None:
        start_id = road.start_poi.id
        end_id = road.end_poi.id
        if start_id not in self.pois or end_id not in self.pois:
            raise ValueError("Start or End POI does not exist")
        self.roads[road.id] = road
        self.adjacency_list[start_id][end_id] = road.id
        if road.bidirectional:
            self.adjacency_list[end_id][start_id] = road.id

    def find_path(self, start_id: str, end_id: str) -> List[str]:
        # è°ƒç”¨ Dijkstra æˆ– A*
        from gisense.algorithms.pathfinding import dijkstra_shortest_path
        return dijkstra_shortest_path(self, start_id, end_id)
```

---

### 2. `CoordinateMatcher`ï¼ˆutils/geometry.pyï¼‰

> æ”¯æŒåæ ‡åŒ¹é…ä¸è‡ªåŠ¨å»é‡ã€‚

```python
from typing import Tuple, Dict

class CoordinateMatcher:
    def __init__(self, tolerance=1e-5):
        self.tolerance = tolerance
        self._map = {}  # {(lat, lon): poi_id}

    def __contains__(self, coord: Tuple[float, float]):
        for stored in self._map:
            if abs(stored[0] - coord[0]) < self.tolerance and \
               abs(stored[1] - coord[1]) < self.tolerance:
                return True
        return False

    def get_closest(self, coord: Tuple[float, float]) -> Optional[Tuple[float, float]]:
        for stored in self._map:
            if abs(stored[0] - coord[0]) < self.tolerance and \
               abs(stored[1] - coord[1]) < self.tolerance:
                return stored
        return None

    def add(self, coord: Tuple[float, float], poi_id: str):
        closest = self.get_closest(coord)
        if closest:
            return self._map[closest]
        self._map[coord] = poi_id
        return poi_id
```

---

### 3. `ShapefileReader`ï¼ˆio/shapefile_reader.pyï¼‰

> ä½¿ç”¨ `geopandas` åŠ è½½ `.shp` æ–‡ä»¶å¹¶æ„å»ºè·¯ç½‘ç»“æ„ã€‚

```python
import geopandas as gpd
from shapely.geometry import LineString
from gisense.entities.poi import POI
from gisense.entities.road import Road
from gisense.entities.coordinate import Coordinate

class ShapefileReader:
    @staticmethod
    def read(shapefile_path: str) -> dict:
        gdf = gpd.read_file(shapefile_path)
        pois = []
        roads = []

        for _, row in gdf.iterrows():
            geom = row.geometry
            if isinstance(geom, LineString):
                coords = list(geom.coords)
                start_lon, start_lat = coords[0]
                end_lon, end_lat = coords[-1]

                start_poi = POI(
                    id=f"poi_{start_lat}_{start_lon}",
                    name="Node Start",
                    type="Intersection",
                    coordinate=Coordinate(start_lat, start_lon)
                )
                end_poi = POI(
                    id=f"poi_{end_lat}_{end_lon}",
                    name="Node End",
                    type="Intersection",
                    coordinate=Coordinate(end_lat, end_lon)
                )

                road = Road(
                    id=row.get('road_id', f"road_{len(roads)}"),
                    start_poi=start_poi,
                    end_poi=end_poi,
                    road_type=row.get('type', 'unknown'),
                    speed_limit=row.get('speed', 50),
                    bidirectional=True
                )
                pois.append(start_poi)
                pois.append(end_poi)
                roads.append(road)

        return {'pois': pois, 'roads': roads}
```

---

### 4. `Observer`ï¼ˆcore/observer.pyï¼‰

> æ™ºèƒ½ä½“è§‚å¯Ÿè€…ï¼Œå¯åŸºäºä¸åŒå®šä½æ–¹å¼æ„ŸçŸ¥å‘¨å›´ç¯å¢ƒã€‚

```python
from typing import Union
from gisense.entities.poi import POI
from gisense.entities.coordinate import Coordinate
from gisense.core.graph import LocationGraph

class Observer:
    def __init__(self, position: Union[POI, Coordinate, str]):
        self.position = position

    def perceive(self, graph: LocationGraph):
        from gisense.algorithms.perception import perceive_surroundings
        return perceive_surroundings(graph, self.position)
```

---

### 5. `perceive_surroundings`ï¼ˆalgorithms/perception.pyï¼‰

```python
from typing import Union
from gisense.core.graph import LocationGraph
from gisense.entities.poi import POI
from gisense.entities.coordinate import Coordinate

def perceive_surroundings(
    graph: LocationGraph,
    position: Union[POI, Coordinate, str]
):
    # å®ç°æ„ŸçŸ¥é€»è¾‘
    nearby_pois = graph.find_nearby_pois(position)
    nearby_roads = graph.find_nearby_roads(position)
    return {
        "nearby_pois": nearby_pois,
        "nearby_roads": nearby_roads
    }
```

---

## ğŸ“¦ å››ã€ä¾èµ–ç®¡ç†ï¼ˆrequirements.txtï¼‰

```txt
geopandas>=0.13.0
shapely>=2.0.0
pyproj>=3.6.0
matplotlib>=3.7.0
networkx>=3.0
```

---

## ğŸ§ª äº”ã€ä½¿ç”¨ç¤ºä¾‹ï¼ˆexamples/example_usage.pyï¼‰

```python
from gisense.core.graph import LocationGraph
from gisense.io.shapefile_reader import ShapefileReader

graph = LocationGraph()

# ä» Shapefile åŠ è½½è·¯ç½‘
result = ShapefileReader.read("data/roads.shp")
for poi in result['pois']:
    graph.add_poi(poi)
for road in result['roads']:
    graph.add_road(road)

# æŸ¥æ‰¾è·¯å¾„
path = graph.find_path("poi_1", "poi_2")
print("Path:", path)
```

---

## ğŸ“˜ å…­ã€æ–‡æ¡£ç”Ÿæˆï¼ˆdocs/ï¼‰

ä½¿ç”¨ Sphinx + MyST Parser æ”¯æŒ Markdown ç¼–å†™ API æ–‡æ¡£ï¼š

```bash
sphinx-quickstart
pip install sphinx myst-parser
```

---

## ğŸ§ª ä¸ƒã€æµ‹è¯•æ¡†æ¶ï¼ˆtests/ï¼‰

ä½¿ç”¨ `pytest` è¿›è¡Œå•å…ƒæµ‹è¯•ï¼š

```bash
pytest tests/test_graph.py
```

---

## âœ… å…«ã€æ€»ç»“

| åŠŸèƒ½ | å®ç°æ–¹å¼ |
|------|----------|
| è‡ªåŠ¨èŠ‚ç‚¹åˆå¹¶ | ä½¿ç”¨ `CoordinateMatcher` å»é‡ç›¸åŒåæ ‡çš„ POI |
| æ”¯æŒ GeoJSON å¯¼å…¥ | `GeoJsonReader` è§£æ FeatureCollection |
| æ”¯æŒ Shapefile å¯¼å…¥ | `ShapefileReader` ä½¿ç”¨ `geopandas` |
| è·¯å¾„è§„åˆ’ | `Dijkstra`, `A*` ç®—æ³•å®ç° |
| è§‚å¯Ÿè€…æ¨¡å‹ | `Observer` æŠ½è±¡ç±»æ„ŸçŸ¥å‘¨å›´ä¿¡æ¯ |
| æ¨¡å—åŒ–è®¾è®¡ | åˆ†ä¸º core/io/entities/algorithms/visualization/utils |


