import uuid
from _typeshed import Incomplete
from pydantic import BaseModel
from src.almanak_library.enums import Chain as Chain, ExecutionStatus as ExecutionStatus, Network as Network
from src.almanak_library.models.action import Action as Action
from src.almanak_library.models.transaction import Transaction as Transaction
from src.utils.utils import deserialize_timestamp as deserialize_timestamp, get_web3_by_network_and_chain as get_web3_by_network_and_chain, serialize_timestamp as serialize_timestamp
from typing import Any

def default_list(): ...

class ActionBundle(BaseModel):
    actions: list[Action]
    network: Network
    chain: Chain
    id: uuid.UUID
    transactions: list[Transaction]
    signed_transactions: list[dict]
    raw_transactions: list[str]
    transaction_hashes: list[str]
    cached_receipts: dict[str, dict]
    deadline: float | None
    created_at: float
    executed_at: float | None
    status: ExecutionStatus
    strategy_id: str
    config: Any
    persistent_state: Any
    model_config: Incomplete
    def __init__(self, **data) -> None: ...
    def get_actions(self) -> list[Action]: ...
    def get_network(self) -> Network: ...
    def get_chain(self) -> Chain: ...
    def get_transactions(self) -> list[Transaction] | None: ...
    def get_signed_transactions(self) -> list[dict] | None: ...
    def get_raw_transactions(self) -> list[str] | None: ...
    def get_transaction_hashes(self) -> list[str] | None: ...
    def get_receipts(self) -> list[dict] | None: ...
    def get_deadline(self) -> float | None: ...
    def get_created_at(self) -> float: ...
    def get_executed_at(self) -> float | None: ...
    def get_status(self) -> ExecutionStatus | None: ...
    def get_action_types(self): ...
    def add_transaction(self, transaction: Transaction): ...
    def add_transactions(self, transactions: list[Transaction]): ...
    def add_signed_transaction(self, signed_transaction: dict): ...
    def model_dump(self, *args, **kwargs): ...
    @classmethod
    def model_validate(cls, obj): ...
    @classmethod
    def from_json(cls, json_str: str): ...
    def summary(self): ...
