#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Sep  5 16:04:48 2024 by generateDS.py version 2.43.3.
# Python 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0]
#
# Command line options:
#   ('-o', 'it_ext.py')
#
# Command line arguments:
#   schema/it_ext/CDA.xsd
#
# Command line:
#   ../../../../generateds/generateDS.py -o "it_ext.py" schema/it_ext/CDA.xsd
#
# Current working directory (os.getcwd()):
#   cda
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_
from typing import List as List_


Validate_simpletypes_ = True
SaveElementTreeNode = True
SaveNodeDict = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str
node_dict = dict()


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if instring is None:
                result = ""
            elif isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class AcknowledgementCondition(str, Enum):
    AL='AL'
    ER='ER'
    NE='NE'


class AcknowledgementDetailType(str, Enum):
    E='E'
    I='I'
    W='W'


class AcknowledgementType(str, Enum):
    AA='AA'
    AE='AE'
    AR='AR'
    CA='CA'
    CE='CE'
    CR='CR'


class ActClass(str, Enum):
    ACCM='ACCM'
    ACCT='ACCT'
    ACSN='ACSN'
    ACT='ACT'
    ACTN='ACTN'
    ADJUD='ADJUD'
    AEXPOS='AEXPOS'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CACT='CACT'
    CASE='CASE'
    CATEGORY='CATEGORY'
    CDALVLONE='CDALVLONE'
    CLNTRL='CLNTRL'
    CLUSTER='CLUSTER'
    CNOD='CNOD'
    CNTRCT='CNTRCT'
    COMPOSITION='COMPOSITION'
    CONC='CONC'
    COND='COND'
    CONS='CONS'
    CONTAINER='CONTAINER'
    CONTREG='CONTREG'
    COV='COV'
    CTTEVENT='CTTEVENT'
    DETPOL='DETPOL'
    DGIMG='DGIMG'
    DIET='DIET'
    DISPACT='DISPACT'
    DOC='DOC'
    DOCBODY='DOCBODY'
    DOCCLIN='DOCCLIN'
    DOCSECT='DOCSECT'
    EHR='EHR'
    ENC='ENC'
    EXP='EXP'
    EXPOS='EXPOS'
    EXTRACT='EXTRACT'
    FCNTRCT='FCNTRCT'
    FOLDER='FOLDER'
    GEN='GEN'
    GROUPER='GROUPER'
    INC='INC'
    INFO='INFO'
    INFRM='INFRM'
    INVE='INVE'
    INVSTG='INVSTG'
    JURISPOL='JURISPOL'
    LIST='LIST'
    LLD='LLD'
    LOC='LOC'
    MPROT='MPROT'
    OBS='OBS'
    OBSCOR='OBSCOR'
    OBSSER='OBSSER'
    ORGPOL='ORGPOL'
    OUTB='OUTB'
    PCPR='PCPR'
    PHN='PHN'
    POL='POL'
    POLICY='POLICY'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    PRN='PRN'
    PROC='PROC'
    REG='REG'
    REV='REV'
    RLD='RLD'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    RTRD='RTRD'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SCOPOL='SCOPOL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    SFWL='SFWL'
    SIT='SIT'
    SPCOBS='SPCOBS'
    SPCTRT='SPCTRT'
    SPECCOLLECT='SPECCOLLECT'
    SPLY='SPLY'
    STC='STC'
    STDPOL='STDPOL'
    STN='STN'
    STORE='STORE'
    SUBST='SUBST'
    SUP='SUP'
    TEXPOS='TEXPOS'
    TOPIC='TOPIC'
    TRD='TRD'
    TRFR='TRFR'
    TRNS='TRNS'
    VERIF='VERIF'
    XACT='XACT'


class ActClassAccession(str, Enum):
    ACSN='ACSN'


class ActClassAccommodation(str, Enum):
    ACCM='ACCM'


class ActClassAccount(str, Enum):
    ACCT='ACCT'


class ActClassAcquisitionExposure(str, Enum):
    AEXPOS='AEXPOS'


class ActClassAction(str, Enum):
    ACTN='ACTN'


class ActClassBattery(str, Enum):
    BATTERY='BATTERY'


class ActClassBioSequence(str, Enum):
    SEQ='SEQ'


class ActClassBioSequenceVariation(str, Enum):
    SEQVAR='SEQVAR'


class ActClassBoundedRoi(str, Enum):
    ROIBND='ROIBND'


class ActClassCareProvision(str, Enum):
    PCPR='PCPR'
    ENC='ENC'


class ActClassCategory(str, Enum):
    CATEGORY='CATEGORY'


class ActClassCdaLevelOneClinicalDocument(str, Enum):
    CDALVLONE='CDALVLONE'


class ActClassClinicalDocument(str, Enum):
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'


class ActClassClinicalTrial(str, Enum):
    CLNTRL='CLNTRL'


class ActClassClinicalTrialTimepointEvent(str, Enum):
    CTTEVENT='CTTEVENT'


class ActClassCluster(str, Enum):
    CLUSTER='CLUSTER'


class ActClassCompositeOrder(str, Enum):
    GROUPER='GROUPER'
    CLUSTER='CLUSTER'
    OBS='OBS'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    CONC='CONC'
    COND='COND'
    CASE='CASE'
    OUTB='OUTB'
    DGIMG='DGIMG'
    GEN='GEN'
    DETPOL='DETPOL'
    EXP='EXP'
    LOC='LOC'
    PHN='PHN'
    POL='POL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    INVSTG='INVSTG'
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    SPCOBS='SPCOBS'
    VERIF='VERIF'
    PROC='PROC'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SPECCOLLECT='SPECCOLLECT'
    SPLY='SPLY'
    DIET='DIET'


class ActClassComposition(str, Enum):
    COMPOSITION='COMPOSITION'
    DOC='DOC'
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'


class ActClassConcern(str, Enum):
    CONC='CONC'


class ActClassCondition(str, Enum):
    COND='COND'
    CASE='CASE'
    OUTB='OUTB'


class ActClassConditionNode(str, Enum):
    CNOD='CNOD'


class ActClassConsent(str, Enum):
    CONS='CONS'


class ActClassContainer(str, Enum):
    CONTAINER='CONTAINER'
    CATEGORY='CATEGORY'
    DOCBODY='DOCBODY'
    DOCSECT='DOCSECT'
    TOPIC='TOPIC'


class ActClassContainerRegistration(str, Enum):
    CONTREG='CONTREG'


class ActClassContract(str, Enum):
    CNTRCT='CNTRCT'
    FCNTRCT='FCNTRCT'
    COV='COV'


class ActClassControlAct(str, Enum):
    CACT='CACT'
    ACTN='ACTN'
    INFO='INFO'
    STC='STC'


class ActClassCorrelatedObservationSequences(str, Enum):
    OBSCOR='OBSCOR'


class ActClassCoverage(str, Enum):
    COV='COV'


class ActClassDetectedIssue(str, Enum):
    ALRT='ALRT'


class ActClassDeterminantPeptide(str, Enum):
    DETPOL='DETPOL'


class ActClassDiagnosticImage(str, Enum):
    DGIMG='DGIMG'


class ActClassDiet(str, Enum):
    DIET='DIET'


class ActClassDisciplinaryAction(str, Enum):
    DISPACT='DISPACT'


class ActClassDocument(str, Enum):
    DOC='DOC'
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'


class ActClassDocumentBody(str, Enum):
    DOCBODY='DOCBODY'


class ActClassDocumentSection(str, Enum):
    DOCSECT='DOCSECT'


class ActClassElectronicHealthRecord(str, Enum):
    EHR='EHR'


class ActClassEncounter(str, Enum):
    ENC='ENC'


class ActClassExposure(str, Enum):
    EXPOS='EXPOS'
    AEXPOS='AEXPOS'
    TEXPOS='TEXPOS'


class ActClassExpressionLevel(str, Enum):
    EXP='EXP'


class ActClassExtract(str, Enum):
    EXTRACT='EXTRACT'
    EHR='EHR'


class ActClassFinancialAdjudication(str, Enum):
    ADJUD='ADJUD'


class ActClassFinancialContract(str, Enum):
    FCNTRCT='FCNTRCT'
    COV='COV'


class ActClassFinancialTransaction(str, Enum):
    XACT='XACT'


class ActClassFolder(str, Enum):
    FOLDER='FOLDER'


class ActClassGenomicObservation(str, Enum):
    GEN='GEN'
    DETPOL='DETPOL'
    EXP='EXP'
    LOC='LOC'
    PHN='PHN'
    POL='POL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'


class ActClassGrouper(str, Enum):
    GROUPER='GROUPER'
    CLUSTER='CLUSTER'


class ActClassIncident(str, Enum):
    INC='INC'


class ActClassInform(str, Enum):
    INFRM='INFRM'


class ActClassInformation(str, Enum):
    INFO='INFO'


class ActClassInvestigation(str, Enum):
    INVSTG='INVSTG'


class ActClassInvoiceElement(str, Enum):
    INVE='INVE'


class ActClassJurisdictionalPolicy(str, Enum):
    JURISPOL='JURISPOL'


class ActClassLeftLateralDecubitus(str, Enum):
    LLD='LLD'


class ActClassLocus(str, Enum):
    LOC='LOC'


class ActClassMonitoringProgram(str, Enum):
    MPROT='MPROT'


class ActClassObservation(str, Enum):
    OBS='OBS'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    CONC='CONC'
    COND='COND'
    CASE='CASE'
    OUTB='OUTB'
    DGIMG='DGIMG'
    GEN='GEN'
    DETPOL='DETPOL'
    EXP='EXP'
    LOC='LOC'
    PHN='PHN'
    POL='POL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    INVSTG='INVSTG'
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    SPCOBS='SPCOBS'
    VERIF='VERIF'


class ActClassObservationSeries(str, Enum):
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'


class ActClassOrganizationalPolicy(str, Enum):
    ORGPOL='ORGPOL'


class ActClassOutbreak(str, Enum):
    OUTB='OUTB'


class ActClassOverlayRoi(str, Enum):
    ROIOVL='ROIOVL'


class ActClassPhenotype(str, Enum):
    PHN='PHN'


class ActClassPolicy(str, Enum):
    POLICY='POLICY'
    JURISPOL='JURISPOL'
    ORGPOL='ORGPOL'
    SCOPOL='SCOPOL'
    STDPOL='STDPOL'


class ActClassPolypeptide(str, Enum):
    POL='POL'


class ActClassPosition(str, Enum):
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'


class ActClassPositionAccuracy(str, Enum):
    POSACC='POSACC'


class ActClassPositionCoordinate(str, Enum):
    POSCOORD='POSCOORD'


class ActClassProcedure(str, Enum):
    PROC='PROC'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SPECCOLLECT='SPECCOLLECT'


class ActClassProcessStep(str, Enum):
    ACSN='ACSN'
    CONTREG='CONTREG'
    OBS='OBS'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    CONC='CONC'
    COND='COND'
    CASE='CASE'
    OUTB='OUTB'
    DGIMG='DGIMG'
    GEN='GEN'
    DETPOL='DETPOL'
    EXP='EXP'
    LOC='LOC'
    PHN='PHN'
    POL='POL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    INVSTG='INVSTG'
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    SPCOBS='SPCOBS'
    VERIF='VERIF'
    PROC='PROC'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SPECCOLLECT='SPECCOLLECT'
    SPCTRT='SPCTRT'
    SPECCOLLECT_1='SPECCOLLECT'
    STORE='STORE'
    TRNS='TRNS'


class ActClassProne(str, Enum):
    PRN='PRN'


class ActClassPublicHealthCase(str, Enum):
    CASE='CASE'
    OUTB='OUTB'


class ActClassROI(str, Enum):
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'


class ActClassRecordOrganizer(str, Enum):
    COMPOSITION='COMPOSITION'
    DOC='DOC'
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'
    CONTAINER='CONTAINER'
    CATEGORY='CATEGORY'
    DOCBODY='DOCBODY'
    DOCSECT='DOCSECT'
    TOPIC='TOPIC'
    EXTRACT='EXTRACT'
    EHR='EHR'
    FOLDER='FOLDER'
    GROUPER='GROUPER'
    CLUSTER='CLUSTER'


class ActClassRegistration(str, Enum):
    REG='REG'


class ActClassReverseTrendelenburg(str, Enum):
    RTRD='RTRD'


class ActClassReview(str, Enum):
    REV='REV'


class ActClassRightLateralDecubitus(str, Enum):
    RLD='RLD'


class ActClassRoot(str, Enum):
    ACT='ACT'
    COMPOSITION='COMPOSITION'
    DOC='DOC'
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'
    CONTAINER='CONTAINER'
    CATEGORY='CATEGORY'
    DOCBODY='DOCBODY'
    DOCSECT='DOCSECT'
    TOPIC='TOPIC'
    EXTRACT='EXTRACT'
    EHR='EHR'
    FOLDER='FOLDER'
    GROUPER='GROUPER'
    CLUSTER='CLUSTER'
    ACCM='ACCM'
    ACCT='ACCT'
    ACSN='ACSN'
    ADJUD='ADJUD'
    CACT='CACT'
    ACTN='ACTN'
    INFO='INFO'
    STC='STC'
    CNTRCT='CNTRCT'
    FCNTRCT='FCNTRCT'
    COV='COV'
    CONS='CONS'
    CONTREG='CONTREG'
    CTTEVENT='CTTEVENT'
    DISPACT='DISPACT'
    EXPOS='EXPOS'
    AEXPOS='AEXPOS'
    TEXPOS='TEXPOS'
    INC='INC'
    INFRM='INFRM'
    INVE='INVE'
    LIST='LIST'
    MPROT='MPROT'
    OBS='OBS'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    CONC='CONC'
    COND='COND'
    CASE='CASE'
    OUTB='OUTB'
    DGIMG='DGIMG'
    GEN='GEN'
    DETPOL='DETPOL'
    EXP='EXP'
    LOC='LOC'
    PHN='PHN'
    POL='POL'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    INVSTG='INVSTG'
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    SPCOBS='SPCOBS'
    VERIF='VERIF'
    PCPR='PCPR'
    ENC='ENC'
    POLICY='POLICY'
    JURISPOL='JURISPOL'
    ORGPOL='ORGPOL'
    SCOPOL='SCOPOL'
    STDPOL='STDPOL'
    PROC='PROC'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SPECCOLLECT='SPECCOLLECT'
    REG='REG'
    REV='REV'
    SPCTRT='SPCTRT'
    SPLY='SPLY'
    DIET='DIET'
    STORE='STORE'
    SUBST='SUBST'
    TRFR='TRFR'
    TRNS='TRNS'
    XACT='XACT'


class ActClassScopeOfPracticePolicy(str, Enum):
    SCOPOL='SCOPOL'


class ActClassSemiFowlers(str, Enum):
    SFWL='SFWL'


class ActClassSitting(str, Enum):
    SIT='SIT'


class ActClassSpecimenCollection(str, Enum):
    SPECCOLLECT='SPECCOLLECT'


class ActClassSpecimenObservation(str, Enum):
    SPCOBS='SPCOBS'


class ActClassSpecimenTreatment(str, Enum):
    SPCTRT='SPCTRT'


class ActClassStandardOfPracticePolicy(str, Enum):
    STDPOL='STDPOL'


class ActClassStanding(str, Enum):
    STN='STN'


class ActClassStateTransitionControl(str, Enum):
    STC='STC'


class ActClassSubjectBodyPosition(str, Enum):
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'


class ActClassSubjectPhysicalPosition(str, Enum):
    LLD='LLD'
    PRN='PRN'
    RLD='RLD'
    SFWL='SFWL'
    SIT='SIT'
    STN='STN'
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'


class ActClassSubstanceAdministration(str, Enum):
    SBADM='SBADM'


class ActClassSubstanceExtraction(str, Enum):
    SBEXT='SBEXT'
    SPECCOLLECT='SPECCOLLECT'


class ActClassSubstitution(str, Enum):
    SUBST='SUBST'


class ActClassSupine(str, Enum):
    SUP='SUP'
    RTRD='RTRD'
    TRD='TRD'


class ActClassSupply(str, Enum):
    SPLY='SPLY'
    DIET='DIET'


class ActClassTopic(str, Enum):
    TOPIC='TOPIC'


class ActClassTransfer(str, Enum):
    TRFR='TRFR'


class ActClassTransmissionExposure(str, Enum):
    TEXPOS='TEXPOS'


class ActClassTransportation(str, Enum):
    TRNS='TRNS'


class ActClassTrendelenburg(str, Enum):
    TRD='TRD'


class ActClassVerification(str, Enum):
    VERIF='VERIF'


class ActClassWorkingList(str, Enum):
    LIST='LIST'


class ActMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    EXPEC='EXPEC'
    GOL='GOL'
    INT='INT'
    OPT='OPT'
    PERM='PERM'
    PERMRQ='PERMRQ'
    PRMS='PRMS'
    PRP='PRP'
    RMD='RMD'
    RQO='RQO'
    RSK='RSK'
    SLOT='SLOT'


class ActMoodActRequest(str, Enum):
    ARQ='ARQ'
    PERMRQ='PERMRQ'
    RQO='RQO'


class ActMoodAppointment(str, Enum):
    APT='APT'


class ActMoodAppointmentRequest(str, Enum):
    ARQ='ARQ'


class ActMoodCompletionTrack(str, Enum):
    DEF='DEF'
    PERM='PERM'
    SLOT='SLOT'
    EVN='EVN'
    INT='INT'
    ARQ='ARQ'
    PERMRQ='PERMRQ'
    RQO='RQO'
    PRP='PRP'
    RMD='RMD'
    PRMS='PRMS'
    APT='APT'


class ActMoodCriterion(str, Enum):
    CRT='CRT'
    EVNCRT='EVN.CRT'


class ActMoodDefinition(str, Enum):
    DEF='DEF'


class ActMoodDesire(str, Enum):
    ARQ='ARQ'
    PERMRQ='PERMRQ'
    RQO='RQO'
    PRP='PRP'
    RMD='RMD'


class ActMoodEventCriterion(str, Enum):
    EVNCRT='EVN.CRT'


class ActMoodEventOccurrence(str, Enum):
    EVN='EVN'


class ActMoodExpectation(str, Enum):
    EXPEC='EXPEC'
    GOL='GOL'
    RSK='RSK'


class ActMoodGoal(str, Enum):
    GOL='GOL'


class ActMoodIntent(str, Enum):
    INT='INT'
    ARQ='ARQ'
    PERMRQ='PERMRQ'
    RQO='RQO'
    PRP='PRP'
    RMD='RMD'
    PRMS='PRMS'
    APT='APT'


class ActMoodOption(str, Enum):
    OPT='OPT'


class ActMoodPermission(str, Enum):
    PERM='PERM'


class ActMoodPermissionRequest(str, Enum):
    PERMRQ='PERMRQ'


class ActMoodPotential(str, Enum):
    DEF='DEF'
    PERM='PERM'
    SLOT='SLOT'


class ActMoodPredicate(str, Enum):
    CRT='CRT'
    EVNCRT='EVN.CRT'
    EXPEC='EXPEC'
    GOL='GOL'
    RSK='RSK'
    OPT='OPT'


class ActMoodPromise(str, Enum):
    PRMS='PRMS'
    APT='APT'


class ActMoodProposal(str, Enum):
    PRP='PRP'
    RMD='RMD'


class ActMoodRecommendation(str, Enum):
    RMD='RMD'


class ActMoodRequest(str, Enum):
    RQO='RQO'


class ActMoodResourceSlot(str, Enum):
    SLOT='SLOT'


class ActMoodRisk(str, Enum):
    RSK='RSK'


class ActRelationshipAccounting(str, Enum):
    CHRG='CHRG'
    COST='COST'
    CHRG_1='CHRG'
    COST_1='COST'
    CREDIT='CREDIT'
    DEBIT='DEBIT'
    CREDIT_1='CREDIT'
    DEBIT_1='DEBIT'


class ActRelationshipAdjunctCurativeIndication(str, Enum):
    CUREADJ='CURE.ADJ'


class ActRelationshipAdjunctMitigation(str, Enum):
    MTGTADJ='MTGT.ADJ'


class ActRelationshipArrival(str, Enum):
    ARR='ARR'


class ActRelationshipAssignsName(str, Enum):
    NAME='NAME'


class ActRelationshipAuthorizedBy(str, Enum):
    AUTH='AUTH'


class ActRelationshipBlocks(str, Enum):
    BLOCK='BLOCK'


class ActRelationshipCheckpoint(str, Enum):
    B='B'
    E='E'
    S='S'
    T='T'
    X='X'


class ActRelationshipCheckpointBeginning(str, Enum):
    B='B'


class ActRelationshipCheckpointEnd(str, Enum):
    E='E'


class ActRelationshipCheckpointEntry(str, Enum):
    S='S'


class ActRelationshipCheckpointExit(str, Enum):
    X='X'


class ActRelationshipCheckpointThrough(str, Enum):
    T='T'


class ActRelationshipConcurrentWith(str, Enum):
    CONCURRENT='CONCURRENT'


class ActRelationshipConditional(str, Enum):
    CIND='CIND'
    PRCN='PRCN'
    RSON='RSON'
    BLOCK='BLOCK'
    CURE='CURE'
    CUREADJ='CURE.ADJ'
    DIAG='DIAG'
    MITGT='MITGT'
    RCVY='RCVY'
    MTGTADJ='MTGT.ADJ'
    SYMP='SYMP'
    TRIG='TRIG'


class ActRelationshipCostTracking(str, Enum):
    CHRG='CHRG'
    COST='COST'


class ActRelationshipCoveredBy(str, Enum):
    COVBY='COVBY'


class ActRelationshipCurativeIndication(str, Enum):
    CURE='CURE'


class ActRelationshipDeparture(str, Enum):
    DEP='DEP'


class ActRelationshipDiagnosis(str, Enum):
    DIAG='DIAG'


class ActRelationshipDocuments(str, Enum):
    DOC='DOC'


class ActRelationshipDuring(str, Enum):
    DURING='DURING'


class ActRelationshipEndsAfterEndOf(str, Enum):
    EAE='EAE'


class ActRelationshipEndsAfterStartOf(str, Enum):
    EAS='EAS'
    EDU='EDU'


class ActRelationshipEndsBeforeStartOf(str, Enum):
    EBS='EBS'


class ActRelationshipEndsConcurrentWith(str, Enum):
    ECW='ECW'
    CONCURRENT='CONCURRENT'


class ActRelationshipEndsDuring(str, Enum):
    EDU='EDU'


class ActRelationshipEpisodelink(str, Enum):
    ELNK='ELNK'


class ActRelationshipEvaluatesGoal(str, Enum):
    GEVL='GEVL'


class ActRelationshipExacerbatredBy(str, Enum):
    EXACBY='EXACBY'


class ActRelationshipExcerpt(str, Enum):
    XCRPT='XCRPT'
    VRXCRPT='VRXCRPT'


class ActRelationshipExcerptVerbatim(str, Enum):
    VRXCRPT='VRXCRPT'


class ActRelationshipFulfills(str, Enum):
    FLFS='FLFS'
    OCCR='OCCR'
    OREF='OREF'
    SCH='SCH'


class ActRelationshipHasBaseline(str, Enum):
    BSLN='BSLN'


class ActRelationshipHasBoundedSupport(str, Enum):
    SPRTBND='SPRTBND'


class ActRelationshipHasCharge(str, Enum):
    CHRG='CHRG'


class ActRelationshipHasComponent(str, Enum):
    COMP='COMP'
    ARR='ARR'
    CTRLV='CTRLV'
    DEP='DEP'


class ActRelationshipHasContinuingObjective(str, Enum):
    OBJC='OBJC'


class ActRelationshipHasContra_indication(str, Enum):
    CIND='CIND'


class ActRelationshipHasControlVariable(str, Enum):
    CTRLV='CTRLV'


class ActRelationshipHasCost(str, Enum):
    COST='COST'


class ActRelationshipHasCredit(str, Enum):
    CREDIT='CREDIT'


class ActRelationshipHasDebit(str, Enum):
    DEBIT='DEBIT'


class ActRelationshipHasExplanation(str, Enum):
    EXPL='EXPL'


class ActRelationshipHasFinalObjective(str, Enum):
    OBJF='OBJF'


class ActRelationshipHasGeneralization(str, Enum):
    GEN='GEN'


class ActRelationshipHasGoal(str, Enum):
    GOAL='GOAL'


class ActRelationshipHasOption(str, Enum):
    OPTN='OPTN'


class ActRelationshipHasPre_condition(str, Enum):
    PRCN='PRCN'


class ActRelationshipHasPreviousInstance(str, Enum):
    PREV='PREV'


class ActRelationshipHasReferenceValues(str, Enum):
    REFV='REFV'


class ActRelationshipHasRisk(str, Enum):
    RISK='RISK'


class ActRelationshipHasSubject(str, Enum):
    SUBJ='SUBJ'


class ActRelationshipHasSupport(str, Enum):
    SPRT='SPRT'
    SPRTBND='SPRTBND'


class ActRelationshipHasTrigger(str, Enum):
    TRIG='TRIG'


class ActRelationshipICSRInvestigation(str, Enum):
    RPLC='RPLC'
    SEQL='SEQL'
    SPRT='SPRT'


class ActRelationshipInstantiatesMaster(str, Enum):
    INST='INST'


class ActRelationshipIsAppendage(str, Enum):
    APND='APND'


class ActRelationshipIsDerivedFrom(str, Enum):
    DRIV='DRIV'


class ActRelationshipIsEtiologyFor(str, Enum):
    CAUS='CAUS'


class ActRelationshipIsManifestationOf(str, Enum):
    MFST='MFST'


class ActRelationshipItemsLocated(str, Enum):
    ITEMSLOC='ITEMSLOC'


class ActRelationshipJoin(str, Enum):
    D='D'
    K='K'
    W='W'
    X='X'


class ActRelationshipJoinDetached(str, Enum):
    D='D'


class ActRelationshipJoinExclusiveWait(str, Enum):
    X='X'


class ActRelationshipJoinKill(str, Enum):
    K='K'


class ActRelationshipJoinWait(str, Enum):
    W='W'


class ActRelationshipLimitedBy(str, Enum):
    LIMIT='LIMIT'


class ActRelationshipMatchesTrigger(str, Enum):
    MTCH='MTCH'


class ActRelationshipMitigates(str, Enum):
    MITGT='MITGT'
    RCVY='RCVY'


class ActRelationshipModifies(str, Enum):
    MOD='MOD'


class ActRelationshipObjective(str, Enum):
    OBJC='OBJC'
    OBJF='OBJF'


class ActRelationshipOccurrence(str, Enum):
    OCCR='OCCR'


class ActRelationshipOutcome(str, Enum):
    OUTC='OUTC'
    OBJC='OBJC'
    OBJF='OBJF'
    GOAL='GOAL'
    RISK='RISK'


class ActRelationshipOverlapsWith(str, Enum):
    OVERLAP='OVERLAP'


class ActRelationshipPertains(str, Enum):
    PERT='PERT'
    EAE='EAE'
    EAS='EAS'
    EDU='EDU'
    EBS='EBS'
    ECW='ECW'
    CONCURRENT='CONCURRENT'
    EAE_1='EAE'
    EAS_1='EAS'
    EDU_1='EDU'
    EBS_1='EBS'
    ECW_1='ECW'
    CONCURRENT_1='CONCURRENT'
    SAE='SAE'
    SAS='SAS'
    SDU='SDU'
    SBS='SBS'
    SCW='SCW'
    CONCURRENT_2='CONCURRENT'
    SAE_1='SAE'
    SAS_1='SAS'
    SDU_1='SDU'
    SBS_1='SBS'
    SCW_1='SCW'
    CONCURRENT_3='CONCURRENT'
    DURING='DURING'
    DURING_1='DURING'
    OVERLAP='OVERLAP'
    OVERLAP_1='OVERLAP'
    EAE_2='EAE'
    EAS_2='EAS'
    EDU_2='EDU'
    EBS_2='EBS'
    ECW_2='ECW'
    CONCURRENT_4='CONCURRENT'
    EAE_3='EAE'
    EAS_3='EAS'
    EDU_3='EDU'
    EBS_3='EBS'
    ECW_3='ECW'
    CONCURRENT_5='CONCURRENT'
    SAE_2='SAE'
    SAS_2='SAS'
    SDU_2='SDU'
    SBS_2='SBS'
    SCW_2='SCW'
    CONCURRENT_6='CONCURRENT'
    SAE_3='SAE'
    SAS_3='SAS'
    SDU_3='SDU'
    SBS_3='SBS'
    SCW_3='SCW'
    CONCURRENT_7='CONCURRENT'
    DURING_2='DURING'
    DURING_3='DURING'
    OVERLAP_2='OVERLAP'
    OVERLAP_3='OVERLAP'
    CHRG='CHRG'
    COST='COST'
    CHRG_1='CHRG'
    COST_1='COST'
    CREDIT='CREDIT'
    DEBIT='DEBIT'
    CREDIT_1='CREDIT'
    DEBIT_1='DEBIT'
    CHRG_2='CHRG'
    COST_2='COST'
    CHRG_3='CHRG'
    COST_3='COST'
    CREDIT_2='CREDIT'
    DEBIT_2='DEBIT'
    CREDIT_3='CREDIT'
    DEBIT_3='DEBIT'
    AUTH='AUTH'
    CAUS='CAUS'
    COVBY='COVBY'
    DRIV='DRIV'
    ELNK='ELNK'
    EVID='EVID'
    EXACBY='EXACBY'
    EXPL='EXPL'
    ITEMSLOC='ITEMSLOC'
    LIMIT='LIMIT'
    META='META'
    MFST='MFST'
    NAME='NAME'
    PREV='PREV'
    REFR='REFR'
    USE='USE'
    REFV='REFV'
    RELVBY='RELVBY'
    SPRT='SPRT'
    SPRTBND='SPRTBND'
    SUBJ='SUBJ'
    SUMM='SUMM'


class ActRelationshipPosting(str, Enum):
    CREDIT='CREDIT'
    DEBIT='DEBIT'


class ActRelationshipProvidesEvidenceFor(str, Enum):
    EVID='EVID'


class ActRelationshipRe_challenge(str, Enum):
    RCHAL='RCHAL'


class ActRelationshipReason(str, Enum):
    RSON='RSON'
    BLOCK='BLOCK'
    CURE='CURE'
    CUREADJ='CURE.ADJ'
    DIAG='DIAG'
    MITGT='MITGT'
    RCVY='RCVY'
    MTGTADJ='MTGT.ADJ'
    SYMP='SYMP'


class ActRelationshipRecovery(str, Enum):
    RCVY='RCVY'


class ActRelationshipReferencesOrder(str, Enum):
    OREF='OREF'


class ActRelationshipRefersTo(str, Enum):
    REFR='REFR'
    USE='USE'


class ActRelationshipRelievedBy(str, Enum):
    RELVBY='RELVBY'


class ActRelationshipReplaces(str, Enum):
    RPLC='RPLC'


class ActRelationshipReverses(str, Enum):
    REV='REV'


class ActRelationshipSchedulesRequest(str, Enum):
    SCH='SCH'


class ActRelationshipSequel(str, Enum):
    SEQL='SEQL'
    APND='APND'
    BSLN='BSLN'
    COMPLY='COMPLY'
    DOC='DOC'
    FLFS='FLFS'
    OCCR='OCCR'
    OREF='OREF'
    SCH='SCH'
    GEN='GEN'
    GEVL='GEVL'
    INST='INST'
    MOD='MOD'
    MTCH='MTCH'
    OPTN='OPTN'
    RCHAL='RCHAL'
    REV='REV'
    RPLC='RPLC'
    SUCC='SUCC'
    UPDT='UPDT'
    XCRPT='XCRPT'
    VRXCRPT='VRXCRPT'
    XFRM='XFRM'


class ActRelationshipSplit(str, Enum):
    E_1='E1'
    EW='EW'
    I_1='I1'
    IW='IW'


class ActRelationshipSplitExclusiveTryOnce(str, Enum):
    E_1='E1'


class ActRelationshipSplitExclusiveWait(str, Enum):
    EW='EW'


class ActRelationshipSplitInclusiveTryOnce(str, Enum):
    I_1='I1'


class ActRelationshipSplitInclusiveWait(str, Enum):
    IW='IW'


class ActRelationshipStartsAfterEndOf(str, Enum):
    SAE='SAE'


class ActRelationshipStartsAfterStartOf(str, Enum):
    SAS='SAS'
    SDU='SDU'


class ActRelationshipStartsBeforeStartOf(str, Enum):
    SBS='SBS'


class ActRelationshipStartsConcurrentWith(str, Enum):
    SCW='SCW'
    CONCURRENT='CONCURRENT'


class ActRelationshipStartsDuring(str, Enum):
    SDU='SDU'


class ActRelationshipSucceeds(str, Enum):
    SUCC='SUCC'


class ActRelationshipSummarizedBy(str, Enum):
    SUMM='SUMM'


class ActRelationshipSymptomaticRelief(str, Enum):
    SYMP='SYMP'


class ActRelationshipTemporallyPertains(str, Enum):
    EAE='EAE'
    EAS='EAS'
    EDU='EDU'
    EBS='EBS'
    ECW='ECW'
    CONCURRENT='CONCURRENT'
    EAE_1='EAE'
    EAS_1='EAS'
    EDU_1='EDU'
    EBS_1='EBS'
    ECW_1='ECW'
    CONCURRENT_1='CONCURRENT'
    SAE='SAE'
    SAS='SAS'
    SDU='SDU'
    SBS='SBS'
    SCW='SCW'
    CONCURRENT_2='CONCURRENT'
    SAE_1='SAE'
    SAS_1='SAS'
    SDU_1='SDU'
    SBS_1='SBS'
    SCW_1='SCW'
    CONCURRENT_3='CONCURRENT'
    DURING='DURING'
    DURING_1='DURING'
    OVERLAP='OVERLAP'
    OVERLAP_1='OVERLAP'


class ActRelationshipTemporallyPertainsEnd(str, Enum):
    EAE='EAE'
    EAS='EAS'
    EDU='EDU'
    EBS='EBS'
    ECW='ECW'
    CONCURRENT='CONCURRENT'


class ActRelationshipTemporallyPertainsStart(str, Enum):
    SAE='SAE'
    SAS='SAS'
    SDU='SDU'
    SBS='SBS'
    SCW='SCW'
    CONCURRENT='CONCURRENT'


class ActRelationshipTransformation(str, Enum):
    XFRM='XFRM'


class ActRelationshipType(str, Enum):
    APND='APND'
    ARR='ARR'
    AUTH='AUTH'
    BLOCK='BLOCK'
    BSLN='BSLN'
    CAUS='CAUS'
    CHRG='CHRG'
    CIND='CIND'
    COMP='COMP'
    COMPLY='COMPLY'
    CONCURRENT='CONCURRENT'
    COST='COST'
    COVBY='COVBY'
    CREDIT='CREDIT'
    CTRLV='CTRLV'
    CURE='CURE'
    CUREADJ='CURE.ADJ'
    DEBIT='DEBIT'
    DEP='DEP'
    DIAG='DIAG'
    DOC='DOC'
    DRIV='DRIV'
    DURING='DURING'
    EAE='EAE'
    EAS='EAS'
    EBS='EBS'
    ECW='ECW'
    EDU='EDU'
    ELNK='ELNK'
    EVID='EVID'
    EXACBY='EXACBY'
    EXPL='EXPL'
    FLFS='FLFS'
    GEN='GEN'
    GEVL='GEVL'
    GOAL='GOAL'
    INST='INST'
    ITEMSLOC='ITEMSLOC'
    LIMIT='LIMIT'
    META='META'
    MFST='MFST'
    MITGT='MITGT'
    MOD='MOD'
    MTCH='MTCH'
    MTGTADJ='MTGT.ADJ'
    NAME='NAME'
    OBJC='OBJC'
    OBJF='OBJF'
    OCCR='OCCR'
    OPTN='OPTN'
    OREF='OREF'
    OUTC='OUTC'
    OVERLAP='OVERLAP'
    PERT='PERT'
    PRCN='PRCN'
    PREV='PREV'
    RCHAL='RCHAL'
    RCVY='RCVY'
    REFR='REFR'
    REFV='REFV'
    RELVBY='RELVBY'
    REV='REV'
    RISK='RISK'
    RPLC='RPLC'
    RSON='RSON'
    SAE='SAE'
    SAS='SAS'
    SBS='SBS'
    SCH='SCH'
    SCW='SCW'
    SDU='SDU'
    SEQL='SEQL'
    SPRT='SPRT'
    SPRTBND='SPRTBND'
    SUBJ='SUBJ'
    SUCC='SUCC'
    SUMM='SUMM'
    SYMP='SYMP'
    TRIG='TRIG'
    UPDT='UPDT'
    USE='USE'
    VRXCRPT='VRXCRPT'
    XCRPT='XCRPT'
    XFRM='XFRM'


class ActRelationshipUpdate(str, Enum):
    COMPLY='COMPLY'


class ActRelationshipUpdatesCondition(str, Enum):
    UPDT='UPDT'


class ActRelationshipUses(str, Enum):
    USE='USE'


class ActStatus(str, Enum):
    ABORTED='aborted'
    ACTIVE='active'
    CANCELLED='cancelled'
    COMPLETED='completed'
    HELD='held'
    NEW='new'
    NORMAL='normal'
    NULLIFIED='nullified'
    OBSOLETE='obsolete'
    SUSPENDED='suspended'


class ActStatusAborted(str, Enum):
    ABORTED='aborted'


class ActStatusAbortedCancelledCompleted(str, Enum):
    ABORTED='aborted'
    CANCELLED='cancelled'
    COMPLETED='completed'


class ActStatusActive(str, Enum):
    ACTIVE='active'


class ActStatusCancelled(str, Enum):
    CANCELLED='cancelled'


class ActStatusCompleted(str, Enum):
    COMPLETED='completed'


class ActStatusHeld(str, Enum):
    HELD='held'


class ActStatusNew(str, Enum):
    NEW='new'


class ActStatusNormal(str, Enum):
    NORMAL='normal'
    ABORTED='aborted'
    ACTIVE='active'
    CANCELLED='cancelled'
    COMPLETED='completed'
    HELD='held'
    NEW='new'
    SUSPENDED='suspended'


class ActStatusNullified(str, Enum):
    NULLIFIED='nullified'


class ActStatusObsolete(str, Enum):
    OBSOLETE='obsolete'


class ActStatusSuspended(str, Enum):
    SUSPENDED='suspended'


class AdditionalLocator(str, Enum):
    ADL='ADL'


class AddressLine(str, Enum):
    AL='AL'
    DAL='DAL'
    SAL='SAL'


class AddressPartType(str, Enum):
    ADL='ADL'
    AL='AL'
    BNN='BNN'
    BNR='BNR'
    BNS='BNS'
    CAR='CAR'
    CEN='CEN'
    CNT='CNT'
    CPA='CPA'
    CTY='CTY'
    DAL='DAL'
    DEL='DEL'
    DINST='DINST'
    DINSTA='DINSTA'
    DINSTQ='DINSTQ'
    DIR='DIR'
    DMOD='DMOD'
    DMODID='DMODID'
    INT='INT'
    POB='POB'
    PRE='PRE'
    SAL='SAL'
    STA='STA'
    STB='STB'
    STR='STR'
    STTYP='STTYP'
    UNID='UNID'
    UNIT='UNIT'
    ZIP='ZIP'


class AddressRepresentationUse(str, Enum):
    ABC='ABC'
    IDE='IDE'
    SYL='SYL'


class AddressUse(str, Enum):
    AS='AS'
    BAD='BAD'
    CONF='CONF'
    DIR='DIR'
    EC='EC'
    H='H'
    HP='HP'
    HV='HV'
    MC='MC'
    PG='PG'
    PHYS='PHYS'
    PST='PST'
    PUB='PUB'
    TMP='TMP'
    WP='WP'


class ApplicationMediaType(str, Enum):
    APPLICATIONDICOM='application/dicom'
    APPLICATIONMSWORD='application/msword'
    APPLICATIONPDF='application/pdf'


class AskedButUnknown(str, Enum):
    ASKU='ASKU'
    NAV='NAV'


class AudioMediaType(str, Enum):
    AUDIOBASIC='audio/basic'
    AUDIOK_32_ADPCM='audio/k32adpcm'
    AUDIOMPEG='audio/mpeg'


class BinaryDataEncoding(str, Enum):
    B_64='B64'
    TXT='TXT'


class BuildingNumber(str, Enum):
    BNR='BNR'


class CalendarCycle(str, Enum):
    CD='CD'
    CH='CH'
    CM='CM'
    CN='CN'
    CS='CS'
    CW='CW'
    CY='CY'
    D='D'
    DM='DM'
    DW='DW'
    DY='DY'
    H='H'
    HD='HD'
    J='J'
    M='M'
    MY='MY'
    N='N'
    NH='NH'
    S='S'
    SN='SN'
    W='W'
    WY='WY'
    Y='Y'


class CalendarCycleOneLetter(str, Enum):
    CW='CW'
    W='W'
    CY='CY'
    Y='Y'
    D='D'
    DM='DM'
    DW='DW'
    J='J'
    H='H'
    HD='HD'
    M='M'
    MY='MY'
    N='N'
    NH='NH'
    S='S'
    SN='SN'
    D_1='D'
    H_1='H'
    J_1='J'
    M_1='M'
    N_1='N'
    S_1='S'
    W_1='W'
    Y_1='Y'


class CalendarCycleTwoLetter(str, Enum):
    CW='CW'
    W='W'
    CY='CY'
    Y='Y'
    D='D'
    DM='DM'
    DW='DW'
    J='J'
    H='H'
    HD='HD'
    M='M'
    MY='MY'
    N='N'
    NH='NH'
    S='S'
    SN='SN'
    CD='CD'
    CH='CH'
    CM='CM'
    CN='CN'
    CS='CS'
    DY='DY'
    WY='WY'
    CD_1='CD'
    CH_1='CH'
    CM_1='CM'
    CN_1='CN'
    CS_1='CS'
    CW_1='CW'
    CY_1='CY'
    DM_1='DM'
    DW_1='DW'
    DY_1='DY'
    HD_1='HD'
    MY_1='MY'
    NH_1='NH'
    SN_1='SN'
    WY_1='WY'


class ClassNullFlavor(str, Enum):
    ASKU='ASKU'
    MSK='MSK'
    NA='NA'
    NASK='NASK'
    NAV='NAV'
    NI='NI'
    UNK='UNK'


class CodingRationale(str, Enum):
    O='O'
    P='P'
    R='R'


class CommunicationFunctionType(str, Enum):
    RCV='RCV'
    RSP='RSP'
    SND='SND'


class CompressionAlgorithm(str, Enum):
    DF='DF'
    GZ='GZ'
    Z='Z'
    ZL='ZL'


class ContactRoleType(str, Enum):
    ECON='ECON'
    NOK='NOK'
    BILL='BILL'
    ORG='ORG'
    PAYOR='PAYOR'


class ContextControl(str, Enum):
    AN='AN'
    AP='AP'
    ON='ON'
    OP='OP'


class ContextControlAdditive(str, Enum):
    AN='AN'
    AP='AP'


class ContextControlAdditiveNon_propagating(str, Enum):
    AN='AN'


class ContextControlAdditivePropagating(str, Enum):
    AP='AP'


class ContextControlNonPropagating(str, Enum):
    AN='AN'
    ON='ON'


class ContextControlOverriding(str, Enum):
    ON='ON'
    OP='OP'


class ContextControlOverridingNon_propagating(str, Enum):
    ON='ON'


class ContextControlOverridingPropagating(str, Enum):
    OP='OP'


class ContextControlPropagating(str, Enum):
    AP='AP'
    OP='OP'


class DeliveryAddressLine(str, Enum):
    DAL='DAL'


class EntityClass(str, Enum):
    ANM='ANM'
    CER='CER'
    CHEM='CHEM'
    CITY='CITY'
    CONT='CONT'
    COUNTRY='COUNTRY'
    COUNTY='COUNTY'
    DEV='DEV'
    ENT='ENT'
    FOOD='FOOD'
    HCE='HCE'
    HOLD='HOLD'
    LIV='LIV'
    MAT='MAT'
    MIC='MIC'
    MMAT='MMAT'
    MODDV='MODDV'
    NAT='NAT'
    NLIV='NLIV'
    ORG='ORG'
    PLC='PLC'
    PLNT='PLNT'
    PROVINCE='PROVINCE'
    PSN='PSN'
    PUB='PUB'
    RGRP='RGRP'
    STATE='STATE'


class EntityClassAnimal(str, Enum):
    ANM='ANM'


class EntityClassCertificateRepresentation(str, Enum):
    CER='CER'


class EntityClassChemicalSubstance(str, Enum):
    CHEM='CHEM'


class EntityClassCityOrTown(str, Enum):
    CITY='CITY'


class EntityClassContainer(str, Enum):
    CONT='CONT'
    HOLD='HOLD'


class EntityClassCountry(str, Enum):
    COUNTRY='COUNTRY'


class EntityClassCountyOrParish(str, Enum):
    COUNTY='COUNTY'


class EntityClassDevice(str, Enum):
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'


class EntityClassFood(str, Enum):
    FOOD='FOOD'


class EntityClassGroup(str, Enum):
    RGRP='RGRP'


class EntityClassHealthChartEntity(str, Enum):
    HCE='HCE'


class EntityClassHolder(str, Enum):
    HOLD='HOLD'


class EntityClassImagingModality(str, Enum):
    MODDV='MODDV'


class EntityClassLivingSubject(str, Enum):
    LIV='LIV'
    NLIV='NLIV'
    ANM='ANM'
    MIC='MIC'
    PLNT='PLNT'
    PSN='PSN'


class EntityClassManufacturedMaterial(str, Enum):
    MMAT='MMAT'
    CONT='CONT'
    HOLD='HOLD'
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'


class EntityClassMaterial(str, Enum):
    MAT='MAT'
    CHEM='CHEM'
    FOOD='FOOD'
    MMAT='MMAT'
    CONT='CONT'
    HOLD='HOLD'
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'


class EntityClassMicroorganism(str, Enum):
    MIC='MIC'


class EntityClassNation(str, Enum):
    NAT='NAT'


class EntityClassNonPersonLivingSubject(str, Enum):
    NLIV='NLIV'
    ANM='ANM'
    MIC='MIC'
    PLNT='PLNT'


class EntityClassOrganization(str, Enum):
    ORG='ORG'
    PUB='PUB'
    STATE='STATE'
    NAT='NAT'


class EntityClassPerson(str, Enum):
    PSN='PSN'


class EntityClassPlace(str, Enum):
    PLC='PLC'
    CITY='CITY'
    COUNTRY='COUNTRY'
    COUNTY='COUNTY'
    PROVINCE='PROVINCE'


class EntityClassPlant(str, Enum):
    PLNT='PLNT'


class EntityClassPublicInstitution(str, Enum):
    PUB='PUB'


class EntityClassRoot(str, Enum):
    ENT='ENT'
    HCE='HCE'
    LIV='LIV'
    NLIV='NLIV'
    ANM='ANM'
    MIC='MIC'
    PLNT='PLNT'
    PSN='PSN'
    MAT='MAT'
    CHEM='CHEM'
    FOOD='FOOD'
    MMAT='MMAT'
    CONT='CONT'
    HOLD='HOLD'
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'
    ORG='ORG'
    PUB='PUB'
    STATE='STATE'
    NAT='NAT'
    PLC='PLC'
    CITY='CITY'
    COUNTRY='COUNTRY'
    COUNTY='COUNTY'
    PROVINCE='PROVINCE'
    RGRP='RGRP'


class EntityClassState(str, Enum):
    STATE='STATE'
    NAT='NAT'


class EntityClassStateOrProvince(str, Enum):
    PROVINCE='PROVINCE'


class EntityDeterminer(str, Enum):
    INSTANCE='INSTANCE'
    KIND='KIND'
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class EntityDeterminerDescribedQuantified(str, Enum):
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class EntityDeterminerDetermined(str, Enum):
    KIND='KIND'
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class EntityDeterminerSpecific(str, Enum):
    INSTANCE='INSTANCE'


class EntityNamePartQualifier(str, Enum):
    AC='AC'
    AD='AD'
    BR='BR'
    CL='CL'
    CON='CON'
    DEV='DEV'
    FRM='FRM'
    IN='IN'
    INV='INV'
    LS='LS'
    NB='NB'
    PR='PR'
    SCI='SCI'
    SP='SP'
    STR='STR'
    TITLE='TITLE'
    TMK='TMK'
    USE='USE'
    VV='VV'


class EntityNamePartQualifierR2(str, Enum):
    AC='AC'
    AD='AD'
    BR='BR'
    CL='CL'
    CON='CON'
    DEV='DEV'
    FRM='FRM'
    HOM='HOM'
    IN='IN'
    INV='INV'
    LS='LS'
    MID='MID'
    NB='NB'
    PFX='PFX'
    PR='PR'
    SCI='SCI'
    SFX='SFX'
    SP='SP'
    STR='STR'
    TMK='TMK'
    USE='USE'


class EntityNamePartType(str, Enum):
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class EntityNamePartTypeR2(str, Enum):
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    TITLE='TITLE'


class EntityNameUse(str, Enum):
    A='A'
    ABC='ABC'
    ASGN='ASGN'
    C='C'
    I='I'
    IDE='IDE'
    L='L'
    OR='OR'
    P='P'
    PHON='PHON'
    R='R'
    SNDX='SNDX'
    SRCH='SRCH'
    SYL='SYL'


class EntityNameUseR2(str, Enum):
    A='A'
    ABC='ABC'
    ANON='ANON'
    ASSUMED='Assumed'
    DN='DN'
    I='I'
    IDE='IDE'
    M='M'
    N='N'
    NAME_REPRESENTATION_USE='NameRepresentationUse'
    OLD='OLD'
    OR='OR'
    P='P'
    PHON='PHON'
    R='R'
    SRCH='SRCH'
    SYL='SYL'
    T='T'


class EntityStatus(str, Enum):
    ACTIVE='active'
    INACTIVE='inactive'
    NORMAL='normal'
    NULLIFIED='nullified'


class EntityStatusActive(str, Enum):
    ACTIVE='active'


class EntityStatusInactive(str, Enum):
    INACTIVE='inactive'


class EntityStatusNormal(str, Enum):
    NORMAL='normal'
    ACTIVE='active'
    INACTIVE='inactive'


class EntityStatusNullified(str, Enum):
    NULLIFIED='nullified'


class GeneralAddressUse(str, Enum):
    BAD='BAD'
    CONF='CONF'
    H='H'
    HP='HP'
    HV='HV'
    TMP='TMP'
    WP='WP'
    DIR='DIR'
    PUB='PUB'


class HL7CalendarCycle(str, Enum):
    CD='CD'
    CH='CH'
    CM='CM'
    CN='CN'
    CS='CS'
    CW='CW'
    CY='CY'
    DM='DM'
    DW='DW'
    DY='DY'
    HD='HD'
    MY='MY'
    NH='NH'
    SN='SN'
    WY='WY'


class HL7ITSVersionCode(str, Enum):
    XMLV_1_PR_1='XMLV1PR1'


class HL7SearchUse(str, Enum):
    SRCH='SRCH'
    PHON='PHON'
    SNDX='SNDX'


class HL7StandardVersionCode(str, Enum):
    BALLOT_2008_JAN='Ballot2008Jan'
    BALLOT_2008_MAY='Ballot2008May'
    BALLOT_2008_SEP='Ballot2008Sep'
    BALLOT_2009_JAN='Ballot2009Jan'
    BALLOT_2009_MAY='Ballot2009May'
    BALLOT_2009_SEP='Ballot2009Sep'
    V_3_2003_12='V3-2003-12'
    V_3_2005_N='V3-2005N'
    V_3_2006_N='V3-2006N'
    V_3_2007_N='V3-2007N'
    V_3_PR_1='V3PR1'


class HL7UpdateMode(str, Enum):
    A='A'
    AR='AR'
    D='D'
    K='K'
    N='N'
    R='R'
    REF='REF'
    U='U'


class HomeAddress(str, Enum):
    H='H'
    HP='HP'
    HV='HV'


class IdentifierReliability(str, Enum):
    ISS='ISS'
    UNV='UNV'
    VER='VER'


class IdentifierScope(str, Enum):
    BUSN='BUSN'
    OBJ='OBJ'
    VER='VER'
    VW='VW'


class ImageMediaType(str, Enum):
    IMAGEG_3_FAX='image/g3fax'
    IMAGEGIF='image/gif'
    IMAGEJPEG='image/jpeg'
    IMAGEPNG='image/png'
    IMAGETIFF='image/tiff'


class IntegrityCheckAlgorithm(str, Enum):
    SHA_1='SHA-1'
    SHA_256='SHA-256'


class ManagedParticipationStatus(str, Enum):
    ACTIVE='active'
    CANCELLED='cancelled'
    COMPLETED='completed'
    NORMAL='normal'
    NULLIFIED='nullified'
    PENDING='pending'


class ManagedParticipationStatusActive(str, Enum):
    ACTIVE='active'


class ManagedParticipationStatusCancelled(str, Enum):
    CANCELLED='cancelled'


class ManagedParticipationStatusCompleted(str, Enum):
    COMPLETED='completed'


class ManagedParticipationStatusNormal(str, Enum):
    NORMAL='normal'
    ACTIVE='active'
    CANCELLED='cancelled'
    COMPLETED='completed'
    PENDING='pending'


class ManagedParticipationStatusNullified(str, Enum):
    NULLIFIED='nullified'


class ManagedParticipationStatusPending(str, Enum):
    PENDING='pending'


class MediaType(str, Enum):
    APPLICATION='application'
    APPLICATIONDICOM='application/dicom'
    APPLICATIONMSWORD='application/msword'
    APPLICATIONPDF='application/pdf'
    AUDIO='audio'
    AUDIOBASIC='audio/basic'
    AUDIOK_32_ADPCM='audio/k32adpcm'
    AUDIOMPEG='audio/mpeg'
    IMAGE='image'
    IMAGEG_3_FAX='image/g3fax'
    IMAGEGIF='image/gif'
    IMAGEJPEG='image/jpeg'
    IMAGEPNG='image/png'
    IMAGETIFF='image/tiff'
    MODEL='model'
    MODELVRML='model/vrml'
    MULTIPART='multipart'
    MULTIPARTXHL_7CDALEVELONE='multipart/x-hl7-cda-level-one'
    TEXT='text'
    TEXTHTML='text/html'
    TEXTPLAIN='text/plain'
    TEXTRTF='text/rtf'
    TEXTSGML='text/sgml'
    TEXTXHL_7FT='text/x-hl7-ft'
    TEXTXHL_7TEXTXML='text/x-hl7-text+xml'
    TEXTXML='text/xml'
    VIDEO='video'
    VIDEOMPEG='video/mpeg'
    VIDEOXAVI='video/x-avi'


class MessageWaitingPriority(str, Enum):
    H='H'
    L='L'
    M='M'


class ModelMediaType(str, Enum):
    MODELVRML='model/vrml'


class ModifyIndicator(str, Enum):
    M='M'
    N='N'


class MultipartMediaType(str, Enum):
    MULTIPARTXHL_7CDALEVELONE='multipart/x-hl7-cda-level-one'


class NameLegalUse(str, Enum):
    L='L'
    OR='OR'


class NoInformation(str, Enum):
    NI='NI'
    INV='INV'
    DER='DER'
    OTH='OTH'
    NINF='NINF'
    PINF='PINF'
    UNC='UNC'
    MSK='MSK'
    NA='NA'
    UNK='UNK'
    ASKU='ASKU'
    NAV='NAV'
    NASK='NASK'
    QS='QS'
    TRC='TRC'


class NullFlavor(str, Enum):
    ASKU='ASKU'
    DER='DER'
    INV='INV'
    MSK='MSK'
    NA='NA'
    NASK='NASK'
    NAV='NAV'
    NI='NI'
    NINF='NINF'
    OTH='OTH'
    PINF='PINF'
    QS='QS'
    TRC='TRC'
    UNC='UNC'
    UNK='UNK'


class OrganizationNamePartQualifier(str, Enum):
    AC='AC'
    AD='AD'
    BR='BR'
    CL='CL'
    IN='IN'
    LS='LS'
    NB='NB'
    PR='PR'
    SP='SP'
    TITLE='TITLE'
    VV='VV'


class OrganizationNameUse(str, Enum):
    ABC='ABC'
    IDE='IDE'
    SYL='SYL'


class Other(str, Enum):
    OTH='OTH'
    NINF='NINF'
    PINF='PINF'


class ParticipationAdmitter(str, Enum):
    ADM='ADM'


class ParticipationAnalyte(str, Enum):
    ALY='ALY'


class ParticipationAncillary(str, Enum):
    ADM='ADM'
    ATND='ATND'
    CALLBCK='CALLBCK'
    CON='CON'
    DIS='DIS'
    ESC='ESC'
    REF='REF'


class ParticipationAttender(str, Enum):
    ATND='ATND'


class ParticipationAuthenticator(str, Enum):
    AUTHEN='AUTHEN'


class ParticipationAuthorOriginator(str, Enum):
    AUT='AUT'


class ParticipationBaby(str, Enum):
    BBY='BBY'


class ParticipationBeneficiary(str, Enum):
    BEN='BEN'


class ParticipationCallbackContact(str, Enum):
    CALLBCK='CALLBCK'


class ParticipationCatalyst(str, Enum):
    CAT='CAT'


class ParticipationCausativeAgent(str, Enum):
    CAGNT='CAGNT'


class ParticipationConsultant(str, Enum):
    CON='CON'


class ParticipationConsumable(str, Enum):
    CSM='CSM'


class ParticipationCoverageTarget(str, Enum):
    COV='COV'


class ParticipationCustodian(str, Enum):
    CST='CST'


class ParticipationDataEntryPerson(str, Enum):
    ENT='ENT'


class ParticipationDestination(str, Enum):
    DST='DST'


class ParticipationDischarger(str, Enum):
    DIS='DIS'


class ParticipationDistributor(str, Enum):
    DIST='DIST'


class ParticipationDonor(str, Enum):
    DON='DON'


class ParticipationEntryLocation(str, Enum):
    ELOC='ELOC'


class ParticipationEscort(str, Enum):
    ESC='ESC'


class ParticipationExposureagent(str, Enum):
    EXPAGNT='EXPAGNT'


class ParticipationExposureparticipation(str, Enum):
    EXPART='EXPART'
    EXPTRGT='EXPTRGT'
    EXSRC='EXSRC'


class ParticipationExposuresource(str, Enum):
    EXSRC='EXSRC'


class ParticipationExposuretarget(str, Enum):
    EXPTRGT='EXPTRGT'


class ParticipationGuarantorParty(str, Enum):
    GUAR='GUAR'


class ParticipationHolder(str, Enum):
    HLD='HLD'


class ParticipationIndirectTarget(str, Enum):
    IND='IND'
    BEN='BEN'
    CAGNT='CAGNT'
    COV='COV'
    GUAR='GUAR'
    HLD='HLD'
    RCT='RCT'
    RCV='RCV'


class ParticipationInformant(str, Enum):
    INF='INF'


class ParticipationInformationGenerator(str, Enum):
    AUT='AUT'
    INF='INF'
    TRANS='TRANS'
    ENT='ENT'
    WIT='WIT'


class ParticipationInformationRecipient(str, Enum):
    IRCP='IRCP'
    NOT='NOT'
    PRCP='PRCP'
    REFB='REFB'
    REFT='REFT'
    TRC='TRC'


class ParticipationInformationTranscriber(str, Enum):
    TRANS='TRANS'
    ENT='ENT'


class ParticipationLegalAuthenticator(str, Enum):
    LA='LA'


class ParticipationNon_reuseableDevice(str, Enum):
    NRD='NRD'


class ParticipationOrigin(str, Enum):
    ORG='ORG'


class ParticipationParticipation(str, Enum):
    PART='PART'
    ADM='ADM'
    ATND='ATND'
    CALLBCK='CALLBCK'
    CON='CON'
    DIS='DIS'
    ESC='ESC'
    REF='REF'
    AUT='AUT'
    INF='INF'
    TRANS='TRANS'
    ENT='ENT'
    WIT='WIT'
    CST='CST'
    DIR='DIR'
    ALY='ALY'
    BBY='BBY'
    CAT='CAT'
    CSM='CSM'
    DEV='DEV'
    NRD='NRD'
    RDV='RDV'
    DON='DON'
    EXPAGNT='EXPAGNT'
    EXPART='EXPART'
    EXPTRGT='EXPTRGT'
    EXSRC='EXSRC'
    PRD='PRD'
    SBJ='SBJ'
    SPC='SPC'
    IND='IND'
    BEN='BEN'
    CAGNT='CAGNT'
    COV='COV'
    GUAR='GUAR'
    HLD='HLD'
    RCT='RCT'
    RCV='RCV'
    IRCP='IRCP'
    NOT='NOT'
    PRCP='PRCP'
    REFB='REFB'
    REFT='REFT'
    TRC='TRC'
    LOC='LOC'
    DST='DST'
    ELOC='ELOC'
    ORG='ORG'
    RML='RML'
    VIA='VIA'
    PRF='PRF'
    DIST='DIST'
    PPRF='PPRF'
    SPRF='SPRF'
    RESP='RESP'
    VRF='VRF'
    AUTHEN='AUTHEN'
    LA='LA'


class ParticipationPhysicalPerformer(str, Enum):
    PRF='PRF'
    DIST='DIST'
    PPRF='PPRF'
    SPRF='SPRF'


class ParticipationPrimaryInformationRecipient(str, Enum):
    PRCP='PRCP'


class ParticipationPrimaryPerformer(str, Enum):
    PPRF='PPRF'


class ParticipationProduct(str, Enum):
    PRD='PRD'


class ParticipationReceiver(str, Enum):
    RCV='RCV'


class ParticipationRecordTarget(str, Enum):
    RCT='RCT'


class ParticipationReferredBy(str, Enum):
    REFB='REFB'


class ParticipationReferredTo(str, Enum):
    REFT='REFT'


class ParticipationReferrer(str, Enum):
    REF='REF'


class ParticipationRemote(str, Enum):
    RML='RML'


class ParticipationResponsibleParty(str, Enum):
    RESP='RESP'


class ParticipationReusableDevice(str, Enum):
    RDV='RDV'


class ParticipationSecondaryPerformer(str, Enum):
    SPRF='SPRF'


class ParticipationSpecimen(str, Enum):
    SPC='SPC'


class ParticipationTargetDevice(str, Enum):
    DEV='DEV'
    NRD='NRD'
    RDV='RDV'


class ParticipationTargetDirect(str, Enum):
    DIR='DIR'
    ALY='ALY'
    BBY='BBY'
    CAT='CAT'
    CSM='CSM'
    DEV='DEV'
    NRD='NRD'
    RDV='RDV'
    DON='DON'
    EXPAGNT='EXPAGNT'
    EXPART='EXPART'
    EXPTRGT='EXPTRGT'
    EXSRC='EXSRC'
    PRD='PRD'
    SBJ='SBJ'
    SPC='SPC'


class ParticipationTargetLocation(str, Enum):
    LOC='LOC'
    DST='DST'
    ELOC='ELOC'
    ORG='ORG'
    RML='RML'
    VIA='VIA'


class ParticipationTargetSubject(str, Enum):
    SBJ='SBJ'
    SPC='SPC'


class ParticipationTracker(str, Enum):
    TRC='TRC'


class ParticipationType(str, Enum):
    ADM='ADM'
    ALY='ALY'
    ATND='ATND'
    AUT='AUT'
    AUTHEN='AUTHEN'
    BBY='BBY'
    BEN='BEN'
    CAGNT='CAGNT'
    CALLBCK='CALLBCK'
    CAT='CAT'
    CON='CON'
    COV='COV'
    CSM='CSM'
    CST='CST'
    DEV='DEV'
    DIR='DIR'
    DIS='DIS'
    DIST='DIST'
    DON='DON'
    DST='DST'
    ELOC='ELOC'
    ENT='ENT'
    ESC='ESC'
    EXPAGNT='EXPAGNT'
    EXPART='EXPART'
    EXPTRGT='EXPTRGT'
    EXSRC='EXSRC'
    GUAR='GUAR'
    HLD='HLD'
    IND='IND'
    INF='INF'
    IRCP='IRCP'
    LA='LA'
    LOC='LOC'
    NOT='NOT'
    NRD='NRD'
    ORG='ORG'
    PART='PART'
    PPRF='PPRF'
    PRCP='PRCP'
    PRD='PRD'
    PRF='PRF'
    RCT='RCT'
    RCV='RCV'
    RDV='RDV'
    REF='REF'
    REFB='REFB'
    REFT='REFT'
    RESP='RESP'
    RML='RML'
    SBJ='SBJ'
    SPC='SPC'
    SPRF='SPRF'
    TRANS='TRANS'
    TRC='TRC'
    VIA='VIA'
    VRF='VRF'
    WIT='WIT'


class ParticipationUgentNotificationContact(str, Enum):
    NOT='NOT'


class ParticipationVerifier(str, Enum):
    VRF='VRF'
    AUTHEN='AUTHEN'
    LA='LA'


class ParticipationVia(str, Enum):
    VIA='VIA'


class ParticipationWitness(str, Enum):
    WIT='WIT'


class PersonNameUse(str, Enum):
    ABC='ABC'
    IDE='IDE'
    SYL='SYL'


class PostalAddressUse(str, Enum):
    BAD='BAD'
    CONF='CONF'
    DIR='DIR'
    H='H'
    HP='HP'
    HV='HV'
    PHYS='PHYS'
    PST='PST'
    PUB='PUB'
    TMP='TMP'
    WP='WP'


class ProbabilityDistributionType(str, Enum):
    B='B'
    E='E'
    F='F'
    G='G'
    LN='LN'
    N='N'
    T='T'
    U='U'
    X_2='X2'


class ProcessingID(str, Enum):
    D='D'
    P='P'
    T='T'


class ProcessingMode(str, Enum):
    A='A'
    I='I'
    R='R'
    T='T'


class QueryPriority(str, Enum):
    D='D'
    I='I'


class QueryRequestLimit(str, Enum):
    RD='RD'


class QueryResponse(str, Enum):
    AE='AE'
    NF='NF'
    OK='OK'
    QE='QE'


class QueryStatusCode(str, Enum):
    ABORTED='aborted'
    DELIVERED_RESPONSE='deliveredResponse'
    EXECUTING='executing'
    NEW='new'
    WAIT_CONTINUED_QUERY_RESPONSE='waitContinuedQueryResponse'


class ReactionParticipant(str, Enum):
    CAT='CAT'
    CSM='CSM'
    PRD='PRD'


class RelationalOperator(str, Enum):
    CT='CT'
    EQ='EQ'
    GE='GE'
    GN='GN'
    GT='GT'
    LE='LE'
    LT='LT'
    NE='NE'


class RelationshipConjunction(str, Enum):
    AND='AND'
    OR='OR'
    XOR='XOR'


class ResponseLevel(str, Enum):
    C='C'
    D='D'
    E='E'
    F='F'
    N='N'
    R='R'
    X='X'


class ResponseModality(str, Enum):
    B='B'
    R='R'
    T='T'


class RoleClass(str, Enum):
    ACCESS='ACCESS'
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'
    ACTM='ACTM'
    ADJV='ADJV'
    ADJY='ADJY'
    ADMM='ADMM'
    ADTV='ADTV'
    AFFL='AFFL'
    AGNT='AGNT'
    ALQT='ALQT'
    ASSIGNED='ASSIGNED'
    BASE='BASE'
    BIRTHPL='BIRTHPL'
    BOND='BOND'
    CAREGIVER='CAREGIVER'
    CASEBJ='CASEBJ'
    CHILD='CHILD'
    CIT='CIT'
    CLAIM='CLAIM'
    COLR='COLR'
    COMPAR='COMPAR'
    CON='CON'
    CONC='CONC'
    CONT='CONT'
    CONY='CONY'
    COVPTY='COVPTY'
    CRED='CRED'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    DEATHPLC='DEATHPLC'
    DEPEN='DEPEN'
    DSDLOC='DSDLOC'
    DST='DST'
    ECON='ECON'
    EMP='EMP'
    EQUIV='EQUIV'
    EXPAGTCAR='EXPAGTCAR'
    EXPR='EXPR'
    EXPVECTOR='EXPVECTOR'
    FLVR='FLVR'
    FOMITE='FOMITE'
    GEN='GEN'
    GRIC='GRIC'
    GUAR='GUAR'
    GUARD='GUARD'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IACT='IACT'
    IDENT='IDENT'
    INDIV='INDIV'
    INGR='INGR'
    INST='INST'
    INVSBJ='INVSBJ'
    ISDLOC='ISDLOC'
    ISLT='ISLT'
    LIC='LIC'
    LOCE='LOCE'
    MANU='MANU'
    MBR='MBR'
    MECH='MECH'
    MIL='MIL'
    MNT='MNT'
    NAMED='NAMED'
    NOK='NOK'
    NOT='NOT'
    NURPRAC='NURPRAC'
    NURS='NURS'
    OWN='OWN'
    PA='PA'
    PART='PART'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    PHYS='PHYS'
    POLHOLD='POLHOLD'
    PROG='PROG'
    PROV='PROV'
    PRS='PRS'
    PRSV='PRSV'
    QUAL='QUAL'
    RESBJ='RESBJ'
    RET='RET'
    RGPR='RGPR'
    ROL='ROL'
    SAME='SAME'
    SDLOC='SDLOC'
    SGNOFF='SGNOFF'
    SPEC='SPEC'
    SPNSR='SPNSR'
    STBL='STBL'
    STD='STD'
    STOR='STOR'
    SUBS='SUBS'
    SUBSCR='SUBSCR'
    SUBY='SUBY'
    TERR='TERR'
    THER='THER'
    UNDWRT='UNDWRT'
    USED='USED'
    WRTE='WRTE'


class RoleClassAccess(str, Enum):
    ACCESS='ACCESS'


class RoleClassActiveIngredient(str, Enum):
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'


class RoleClassActiveIngredientBasis(str, Enum):
    ACTIB='ACTIB'


class RoleClassActiveIngredientMoietyBasis(str, Enum):
    ACTIM='ACTIM'


class RoleClassActiveIngredientReferenceBasis(str, Enum):
    ACTIR='ACTIR'


class RoleClassActiveMoiety(str, Enum):
    ACTM='ACTM'


class RoleClassAdditive(str, Enum):
    ADTV='ADTV'


class RoleClassAdjacency(str, Enum):
    ADJY='ADJY'
    CONC='CONC'
    BOND='BOND'
    CONY='CONY'


class RoleClassAdjuvant(str, Enum):
    ADJV='ADJV'


class RoleClassAdministerableMaterial(str, Enum):
    ADMM='ADMM'


class RoleClassAffiliate(str, Enum):
    AFFL='AFFL'


class RoleClassAgent(str, Enum):
    AGNT='AGNT'
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    GUARD='GUARD'


class RoleClassAliquot(str, Enum):
    ALQT='ALQT'


class RoleClassAssignedEntity(str, Enum):
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    SGNOFF='SGNOFF'


class RoleClassAssociative(str, Enum):
    AFFL='AFFL'
    AGNT='AGNT'
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    GUARD='GUARD'
    CIT='CIT'
    COVPTY='COVPTY'
    CLAIM='CLAIM'
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'
    PROG='PROG'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    EMP='EMP'
    MIL='MIL'
    GUAR='GUAR'
    INVSBJ='INVSBJ'
    CASEBJ='CASEBJ'
    RESBJ='RESBJ'
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'
    CAREGIVER='CAREGIVER'
    PRS='PRS'
    ACCESS='ACCESS'
    ADJY='ADJY'
    CONC='CONC'
    BOND='BOND'
    CONY='CONY'
    ADMM='ADMM'
    BIRTHPL='BIRTHPL'
    DEATHPLC='DEATHPLC'
    DST='DST'
    RET='RET'
    EXPR='EXPR'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IDENT='IDENT'
    MANU='MANU'
    THER='THER'
    MNT='MNT'
    OWN='OWN'
    RGPR='RGPR'
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'
    TERR='TERR'
    USED='USED'
    WRTE='WRTE'


class RoleClassBase(str, Enum):
    BASE='BASE'


class RoleClassBirthplace(str, Enum):
    BIRTHPL='BIRTHPL'


class RoleClassCaregiver(str, Enum):
    CAREGIVER='CAREGIVER'


class RoleClassCaseSubject(str, Enum):
    CASEBJ='CASEBJ'


class RoleClassChild(str, Enum):
    CHILD='CHILD'


class RoleClassCitizen(str, Enum):
    CIT='CIT'


class RoleClassClaimant(str, Enum):
    CLAIM='CLAIM'


class RoleClassClinicalResearchInvestigator(str, Enum):
    CRINV='CRINV'


class RoleClassClinicalResearchSponsor(str, Enum):
    CRSPNSR='CRSPNSR'


class RoleClassColorAdditive(str, Enum):
    COLR='COLR'


class RoleClassCommissioningParty(str, Enum):
    COMPAR='COMPAR'


class RoleClassConnection(str, Enum):
    CONC='CONC'
    BOND='BOND'
    CONY='CONY'


class RoleClassContact(str, Enum):
    CON='CON'
    ECON='ECON'
    NOK='NOK'


class RoleClassContactCode(str, Enum):
    ECON='ECON'
    NOK='NOK'


class RoleClassContent(str, Enum):
    CONT='CONT'


class RoleClassContinuity(str, Enum):
    CONY='CONY'


class RoleClassCoverageSponsor(str, Enum):
    SPNSR='SPNSR'


class RoleClassCoveredParty(str, Enum):
    COVPTY='COVPTY'
    CLAIM='CLAIM'
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'
    PROG='PROG'


class RoleClassCredentialedEntity(str, Enum):
    CRED='CRED'


class RoleClassDedicatedServiceDeliveryLocation(str, Enum):
    DSDLOC='DSDLOC'


class RoleClassDependent(str, Enum):
    DEPEN='DEPEN'


class RoleClassDistributedMaterial(str, Enum):
    DST='DST'
    RET='RET'


class RoleClassEmergencyContact(str, Enum):
    ECON='ECON'


class RoleClassEmployee(str, Enum):
    EMP='EMP'
    MIL='MIL'


class RoleClassEquivalentEntity(str, Enum):
    EQUIV='EQUIV'
    SAME='SAME'
    SUBY='SUBY'


class RoleClassExposedEntity(str, Enum):
    EXPR='EXPR'


class RoleClassExposureAgentCarrier(str, Enum):
    EXPAGTCAR='EXPAGTCAR'
    EXPVECTOR='EXPVECTOR'
    FOMITE='FOMITE'


class RoleClassExposureVector(str, Enum):
    EXPVECTOR='EXPVECTOR'


class RoleClassFlavorAdditive(str, Enum):
    FLVR='FLVR'


class RoleClassFomite(str, Enum):
    FOMITE='FOMITE'


class RoleClassGuarantor(str, Enum):
    GUAR='GUAR'


class RoleClassGuardian(str, Enum):
    GUARD='GUARD'


class RoleClassHasGeneric(str, Enum):
    GRIC='GRIC'


class RoleClassHealthChart(str, Enum):
    HLTHCHRT='HLTHCHRT'


class RoleClassHealthcareProvider(str, Enum):
    PROV='PROV'


class RoleClassHeldEntity(str, Enum):
    HLD='HLD'


class RoleClassICSRInvestigationSubject(str, Enum):
    CASEBJ='CASEBJ'
    INVSBJ='INVSBJ'
    PAT='PAT'
    RESBJ='RESBJ'


class RoleClassIdentifiedEntity(str, Enum):
    IDENT='IDENT'


class RoleClassInactiveIngredient(str, Enum):
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'


class RoleClassIncidentalServiceDeliveryLocation(str, Enum):
    ISDLOC='ISDLOC'


class RoleClassIndividual(str, Enum):
    INDIV='INDIV'


class RoleClassIngredientEntity(str, Enum):
    INGR='INGR'
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'
    ADJV='ADJV'
    ADTV='ADTV'
    BASE='BASE'
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'
    MECH='MECH'


class RoleClassInstance(str, Enum):
    INST='INST'


class RoleClassInvestigationSubject(str, Enum):
    INVSBJ='INVSBJ'
    CASEBJ='CASEBJ'
    RESBJ='RESBJ'


class RoleClassInvoicePayor(str, Enum):
    PAYOR='PAYOR'


class RoleClassIsSpeciesEntity(str, Enum):
    GEN='GEN'
    GRIC='GRIC'


class RoleClassIsolate(str, Enum):
    ISLT='ISLT'


class RoleClassLicensedEntity(str, Enum):
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'


class RoleClassLocatedEntity(str, Enum):
    LOCE='LOCE'
    STOR='STOR'


class RoleClassMaintainedEntity(str, Enum):
    MNT='MNT'


class RoleClassManagedEntity(str, Enum):
    ACCESS='ACCESS'
    HLD='HLD'
    MNT='MNT'
    OWN='OWN'


class RoleClassManufacturedProduct(str, Enum):
    MANU='MANU'
    THER='THER'


class RoleClassMechanicalIngredient(str, Enum):
    MECH='MECH'


class RoleClassMember(str, Enum):
    MBR='MBR'


class RoleClassMilitaryPerson(str, Enum):
    MIL='MIL'


class RoleClassMolecularBond(str, Enum):
    BOND='BOND'


class RoleClassMolecularFeatures(str, Enum):
    BOND='BOND'
    PART='PART'


class RoleClassMolecularPart(str, Enum):
    ACTM='ACTM'
    PART='PART'


class RoleClassMutualRelationship(str, Enum):
    AFFL='AFFL'
    AGNT='AGNT'
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    GUARD='GUARD'
    CIT='CIT'
    COVPTY='COVPTY'
    CLAIM='CLAIM'
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'
    PROG='PROG'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    EMP='EMP'
    MIL='MIL'
    GUAR='GUAR'
    INVSBJ='INVSBJ'
    CASEBJ='CASEBJ'
    RESBJ='RESBJ'
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'
    CAREGIVER='CAREGIVER'
    PRS='PRS'


class RoleClassNamedInsured(str, Enum):
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'


class RoleClassNextOfKin(str, Enum):
    NOK='NOK'


class RoleClassNotaryPublic(str, Enum):
    NOT='NOT'


class RoleClassNurse(str, Enum):
    NURS='NURS'


class RoleClassNursePractitioner(str, Enum):
    NURPRAC='NURPRAC'


class RoleClassOntological(str, Enum):
    EQUIV='EQUIV'
    SAME='SAME'
    SUBY='SUBY'
    GEN='GEN'
    GRIC='GRIC'
    INST='INST'
    SUBS='SUBS'


class RoleClassOwnedEntity(str, Enum):
    OWN='OWN'


class RoleClassPart(str, Enum):
    PART='PART'
    ACTM='ACTM'


class RoleClassPartitive(str, Enum):
    CONT='CONT'
    EXPAGTCAR='EXPAGTCAR'
    EXPVECTOR='EXPVECTOR'
    FOMITE='FOMITE'
    INGR='INGR'
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'
    ADJV='ADJV'
    ADTV='ADTV'
    BASE='BASE'
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'
    MECH='MECH'
    LOCE='LOCE'
    STOR='STOR'
    MBR='MBR'
    PART='PART'
    ACTM='ACTM'
    SPEC='SPEC'
    ALQT='ALQT'
    ISLT='ISLT'


class RoleClassPassive(str, Enum):
    ACCESS='ACCESS'
    ADJY='ADJY'
    CONC='CONC'
    BOND='BOND'
    CONY='CONY'
    ADMM='ADMM'
    BIRTHPL='BIRTHPL'
    DEATHPLC='DEATHPLC'
    DST='DST'
    RET='RET'
    EXPR='EXPR'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IDENT='IDENT'
    MANU='MANU'
    THER='THER'
    MNT='MNT'
    OWN='OWN'
    RGPR='RGPR'
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'
    TERR='TERR'
    USED='USED'
    WRTE='WRTE'


class RoleClassPatient(str, Enum):
    PAT='PAT'


class RoleClassPayee(str, Enum):
    PAYEE='PAYEE'


class RoleClassPersonalRelationship(str, Enum):
    PRS='PRS'


class RoleClassPhysician(str, Enum):
    PHYS='PHYS'


class RoleClassPhysicianAssistant(str, Enum):
    PA='PA'


class RoleClassPlaceOfDeath(str, Enum):
    DEATHPLC='DEATHPLC'


class RoleClassPolicyHolder(str, Enum):
    POLHOLD='POLHOLD'


class RoleClassPreservative(str, Enum):
    PRSV='PRSV'


class RoleClassProductRelated(str, Enum):
    DST='DST'
    MANU='MANU'
    RET='RET'
    RGPR='RGPR'
    THER='THER'
    WRTE='WRTE'


class RoleClassProgramEligible(str, Enum):
    PROG='PROG'


class RoleClassQualifiedEntity(str, Enum):
    QUAL='QUAL'


class RoleClassRegulatedProduct(str, Enum):
    RGPR='RGPR'


class RoleClassRelationshipFormal(str, Enum):
    AFFL='AFFL'
    AGNT='AGNT'
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    GUARD='GUARD'
    CIT='CIT'
    COVPTY='COVPTY'
    CLAIM='CLAIM'
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'
    PROG='PROG'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    EMP='EMP'
    MIL='MIL'
    GUAR='GUAR'
    INVSBJ='INVSBJ'
    CASEBJ='CASEBJ'
    RESBJ='RESBJ'
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'


class RoleClassResearchSubject(str, Enum):
    RESBJ='RESBJ'


class RoleClassRetailedMaterial(str, Enum):
    RET='RET'


class RoleClassRoot(str, Enum):
    ROL='ROL'
    AFFL='AFFL'
    AGNT='AGNT'
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'
    CON='CON'
    ECON='ECON'
    NOK='NOK'
    GUARD='GUARD'
    CIT='CIT'
    COVPTY='COVPTY'
    CLAIM='CLAIM'
    NAMED='NAMED'
    DEPEN='DEPEN'
    INDIV='INDIV'
    SUBSCR='SUBSCR'
    PROG='PROG'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    EMP='EMP'
    MIL='MIL'
    GUAR='GUAR'
    INVSBJ='INVSBJ'
    CASEBJ='CASEBJ'
    RESBJ='RESBJ'
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'
    CAREGIVER='CAREGIVER'
    PRS='PRS'
    ACCESS='ACCESS'
    ADJY='ADJY'
    CONC='CONC'
    BOND='BOND'
    CONY='CONY'
    ADMM='ADMM'
    BIRTHPL='BIRTHPL'
    DEATHPLC='DEATHPLC'
    DST='DST'
    RET='RET'
    EXPR='EXPR'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IDENT='IDENT'
    MANU='MANU'
    THER='THER'
    MNT='MNT'
    OWN='OWN'
    RGPR='RGPR'
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'
    TERR='TERR'
    USED='USED'
    WRTE='WRTE'
    EQUIV='EQUIV'
    SAME='SAME'
    SUBY='SUBY'
    GEN='GEN'
    GRIC='GRIC'
    INST='INST'
    SUBS='SUBS'
    CONT='CONT'
    EXPAGTCAR='EXPAGTCAR'
    EXPVECTOR='EXPVECTOR'
    FOMITE='FOMITE'
    INGR='INGR'
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'
    ADJV='ADJV'
    ADTV='ADTV'
    BASE='BASE'
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'
    MECH='MECH'
    LOCE='LOCE'
    STOR='STOR'
    MBR='MBR'
    PART='PART'
    ACTM='ACTM'
    SPEC='SPEC'
    ALQT='ALQT'
    ISLT='ISLT'


class RoleClassSame(str, Enum):
    SAME='SAME'


class RoleClassServiceDeliveryLocation(str, Enum):
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'


class RoleClassSigningAuthorityOrOfficer(str, Enum):
    SGNOFF='SGNOFF'


class RoleClassSpecimen(str, Enum):
    SPEC='SPEC'
    ALQT='ALQT'
    ISLT='ISLT'


class RoleClassStabilizer(str, Enum):
    STBL='STBL'


class RoleClassStoredEntity(str, Enum):
    STOR='STOR'


class RoleClassStudent(str, Enum):
    STD='STD'


class RoleClassSubscriber(str, Enum):
    SUBSCR='SUBSCR'


class RoleClassSubstancePresence(str, Enum):
    CONT='CONT'
    INGR='INGR'
    ACTI='ACTI'
    ACTIB='ACTIB'
    ACTIM='ACTIM'
    ACTIR='ACTIR'
    ADJV='ADJV'
    ADTV='ADTV'
    BASE='BASE'
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'
    MECH='MECH'
    LOCE='LOCE'
    STOR='STOR'
    PART='PART'
    ACTM='ACTM'


class RoleClassSubsumedBy(str, Enum):
    SUBY='SUBY'


class RoleClassSubsumer(str, Enum):
    SUBS='SUBS'


class RoleClassTerritoryOfAuthority(str, Enum):
    TERR='TERR'


class RoleClassTherapeuticAgent(str, Enum):
    THER='THER'


class RoleClassUnderwriter(str, Enum):
    UNDWRT='UNDWRT'


class RoleClassUsedEntity(str, Enum):
    USED='USED'


class RoleClassWarrantedProduct(str, Enum):
    WRTE='WRTE'


class RoleLinkHasContact(str, Enum):
    CONT='CONT'


class RoleLinkHasDirectAuthorityOver(str, Enum):
    DIRAUTH='DIRAUTH'


class RoleLinkHasIndirectAuthorityOver(str, Enum):
    INDAUTH='INDAUTH'


class RoleLinkHasPart(str, Enum):
    PART='PART'


class RoleLinkIdentification(str, Enum):
    IDENT='IDENT'


class RoleLinkIsBackupFor(str, Enum):
    BACKUP='BACKUP'


class RoleLinkRelated(str, Enum):
    REL='REL'
    BACKUP='BACKUP'
    CONT='CONT'
    DIRAUTH='DIRAUTH'
    IDENT='IDENT'
    INDAUTH='INDAUTH'
    PART='PART'
    REPL='REPL'


class RoleLinkReplaces(str, Enum):
    REPL='REPL'


class RoleLinkType(str, Enum):
    BACKUP='BACKUP'
    CONT='CONT'
    DIRAUTH='DIRAUTH'
    IDENT='IDENT'
    INDAUTH='INDAUTH'
    PART='PART'
    REL='REL'
    REPL='REPL'


class RoleStatus(str, Enum):
    ACTIVE='active'
    CANCELLED='cancelled'
    NORMAL='normal'
    NULLIFIED='nullified'
    PENDING='pending'
    SUSPENDED='suspended'
    TERMINATED='terminated'


class RoleStatusActive(str, Enum):
    ACTIVE='active'


class RoleStatusCancelled(str, Enum):
    CANCELLED='cancelled'


class RoleStatusNormal(str, Enum):
    NORMAL='normal'
    ACTIVE='active'
    CANCELLED='cancelled'
    PENDING='pending'
    SUSPENDED='suspended'
    TERMINATED='terminated'


class RoleStatusNullified(str, Enum):
    NULLIFIED='nullified'


class RoleStatusPending(str, Enum):
    PENDING='pending'


class RoleStatusSuspended(str, Enum):
    SUSPENDED='suspended'


class RoleStatusTerminated(str, Enum):
    TERMINATED='terminated'


class Sequencing(str, Enum):
    A='A'
    D='D'
    N='N'


class SetOperator(str, Enum):
    A='A'
    E='E'
    H='H'
    I='I'
    P='P'


class StreetAddressLine(str, Enum):
    SAL='SAL'


class StreetName(str, Enum):
    STR='STR'


class TelecommunicationAddressUse(str, Enum):
    AS='AS'
    BAD='BAD'
    CONF='CONF'
    DIR='DIR'
    EC='EC'
    H='H'
    HP='HP'
    HV='HV'
    MC='MC'
    PG='PG'
    PUB='PUB'
    TMP='TMP'
    WP='WP'


class TelecommunicationCapabilities(str, Enum):
    DATA='DATA'
    FAX='FAX'
    SMS='SMS'
    TTY='TTY'
    VOICE='VOICE'


class TextMediaType(str, Enum):
    TEXTHTML='text/html'
    TEXTPLAIN='text/plain'
    TEXTRTF='text/rtf'
    TEXTSGML='text/sgml'
    TEXTXHL_7FT='text/x-hl7-ft'
    TEXTXHL_7TEXTXML='text/x-hl7-text+xml'
    TEXTXML='text/xml'


class TimingEvent(str, Enum):
    AC='AC'
    ACD='ACD'
    ACM='ACM'
    ACV='ACV'
    C='C'
    CD='CD'
    CM='CM'
    CV='CV'
    HS='HS'
    IC='IC'
    ICD='ICD'
    ICM='ICM'
    ICV='ICV'
    PC='PC'
    PCD='PCD'
    PCM='PCM'
    PCV='PCV'
    WAKE='WAKE'


class TransmissionRelationshipTypeCode(str, Enum):
    SEQL='SEQL'


class URLScheme(str, Enum):
    CID='cid'
    FILE='file'
    FTP='ftp'
    HL_7ATT='hl7-att'
    HTTP='http'
    MAILTO='mailto'
    MLLP='mllp'
    NFS='nfs'
    TEL='tel'
    TELNET='telnet'


class Unknown(str, Enum):
    UNK='UNK'
    ASKU='ASKU'
    NAV='NAV'
    NASK='NASK'
    QS='QS'
    TRC='TRC'


class VideoMediaType(str, Enum):
    VIDEOMPEG='video/mpeg'
    VIDEOXAVI='video/x-avi'


class WorkPlace(str, Enum):
    WP='WP'
    DIR='DIR'
    PUB='PUB'


class alignType(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType1(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType10(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType12(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType14(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType3(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType5(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType7(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class codeType(str, Enum):
    ACTIVE='active'
    COMPLETED='completed'


class frameType(str, Enum):
    VOID='void'
    ABOVE='above'
    BELOW='below'
    HSIDES='hsides'
    LHS='lhs'
    RHS='rhs'
    VSIDES='vsides'
    BOX='box'
    BORDER='border'


class listTypeType(str, Enum):
    ORDERED='ordered'
    UNORDERED='unordered'


class revisedType(str, Enum):
    INSERT='insert'
    DELETE='delete'


class rulesType(str, Enum):
    NONE='none'
    GROUPS='groups'
    ROWS='rows'
    COLS='cols'
    ALL='all'


class scopeType(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class scopeType9(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class valignType(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType11(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType13(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType15(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType2(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType4(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType6(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType8(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class x_AccommodationRequestorRole(str, Enum):
    AGNT='AGNT'
    PAT='PAT'
    PROV='PROV'
    PRS='PRS'


class x_ActClassCareProvisionEncounter(str, Enum):
    ENC='ENC'
    PCPR='PCPR'


class x_ActClassCareProvisionObservation(str, Enum):
    OBS='OBS'
    PCPR='PCPR'


class x_ActClassCareProvisionProcedure(str, Enum):
    PCPR='PCPR'
    PROC='PROC'


class x_ActClassDocumentEntryAct(str, Enum):
    ACCM='ACCM'
    ACSN='ACSN'
    ACT='ACT'
    AEXPOS='AEXPOS'
    CONS='CONS'
    CONTREG='CONTREG'
    CTTEVENT='CTTEVENT'
    DISPACT='DISPACT'
    EXPOS='EXPOS'
    INC='INC'
    INFRM='INFRM'
    LIST='LIST'
    MPROT='MPROT'
    PCPR='PCPR'
    REG='REG'
    REV='REV'
    SPCTRT='SPCTRT'
    STORE='STORE'
    TEXPOS='TEXPOS'
    TRFR='TRFR'
    TRNS='TRNS'


class x_ActClassDocumentEntryOrganizer(str, Enum):
    BATTERY='BATTERY'
    CLUSTER='CLUSTER'


class x_ActMoodCompletionCriterion(str, Enum):
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    INT='INT'
    RQO='RQO'


class x_ActMoodDefEvn(str, Enum):
    DEF='DEF'
    EVN='EVN'


class x_ActMoodDefEvnRqo(str, Enum):
    DEF='DEF'
    EVN='EVN'
    RQO='RQO'


class x_ActMoodDefEvnRqoPrmsPrp(str, Enum):
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodDocumentObservation(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    GOL='GOL'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    RSK='RSK'


class x_ActMoodEvnOrdPrmsPrp(str, Enum):
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodIntentEvent(str, Enum):
    APT='APT'
    ARQ='ARQ'
    EVN='EVN'
    INT='INT'
    PERMRQ='PERMRQ'
    PRMS='PRMS'
    PRP='PRP'
    RMD='RMD'
    RQO='RQO'


class x_ActMoodOrdPrms(str, Enum):
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodOrdPrmsEvn(str, Enum):
    EVN='EVN'
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodPermPermrq(str, Enum):
    PERM='PERM'
    PERMRQ='PERMRQ'


class x_ActMoodRequestEvent(str, Enum):
    EVN='EVN'
    RQO='RQO'


class x_ActMoodRqoPrpAptArq(str, Enum):
    APT='APT'
    ARQ='ARQ'
    PRP='PRP'
    RQO='RQO'


class x_ActOrderableOrBillable(str, Enum):
    ACCM='ACCM'
    ALRT='ALRT'
    BATTERY='BATTERY'
    CASE='CASE'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    CONC='CONC'
    COND='COND'
    DETPOL='DETPOL'
    DGIMG='DGIMG'
    ENC='ENC'
    EXP='EXP'
    GEN='GEN'
    INVSTG='INVSTG'
    LLD='LLD'
    LOC='LOC'
    OBS='OBS'
    OBSCOR='OBSCOR'
    OBSSER='OBSSER'
    OUTB='OUTB'
    PCPR='PCPR'
    PHN='PHN'
    POL='POL'
    POS='POS'
    POSACC='POSACC'
    POSCOORD='POSCOORD'
    PRN='PRN'
    PROC='PROC'
    RLD='RLD'
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'
    RTRD='RTRD'
    SBADM='SBADM'
    SBEXT='SBEXT'
    SEQ='SEQ'
    SEQVAR='SEQVAR'
    SFWL='SFWL'
    SIT='SIT'
    SPCOBS='SPCOBS'
    SPECCOLLECT='SPECCOLLECT'
    STN='STN'
    SUP='SUP'
    TRD='TRD'
    TRNS='TRNS'
    VERIF='VERIF'


class x_ActRelationshipDocument(str, Enum):
    APND='APND'
    RPLC='RPLC'
    XFRM='XFRM'


class x_ActRelationshipDocumentSPL(str, Enum):
    APND='APND'
    DRIV='DRIV'
    RPLC='RPLC'
    XCRPT='XCRPT'
    XFRM='XFRM'


class x_ActRelationshipEntry(str, Enum):
    COMP='COMP'
    DRIV='DRIV'


class x_ActRelationshipEntryRelationship(str, Enum):
    CAUS='CAUS'
    COMP='COMP'
    GEVL='GEVL'
    MFST='MFST'
    REFR='REFR'
    RSON='RSON'
    SAS='SAS'
    SPRT='SPRT'
    SUBJ='SUBJ'
    XCRPT='XCRPT'


class x_ActRelationshipExternalReference(str, Enum):
    ELNK='ELNK'
    REFR='REFR'
    RPLC='RPLC'
    SPRT='SPRT'
    SUBJ='SUBJ'
    XCRPT='XCRPT'


class x_ActRelationshipPatientTransport(str, Enum):
    ARR='ARR'
    DEP='DEP'


class x_ActRelationshipPertinentInfo(str, Enum):
    CAUS='CAUS'
    MFST='MFST'
    REFR='REFR'
    SPRT='SPRT'
    SUBJ='SUBJ'


class x_ActRelationshipRelatedAuthorizations(str, Enum):
    AUTH='AUTH'
    REFR='REFR'


class x_ActReplaceOrRevise(str, Enum):
    MOD='MOD'
    RPLC='RPLC'


class x_ActStatusActiveComplete(str, Enum):
    ACTIVE='active'
    COMPLETED='completed'


class x_ActStatusActiveSuspended(str, Enum):
    ACTIVE='active'
    SUSPENDED='suspended'


class x_ActStatusPrevious(str, Enum):
    CANCELLED='cancelled'
    NULLIFIED='nullified'
    OBSOLETE='obsolete'


class x_ClinicalStatementActMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    RSK='RSK'


class x_ClinicalStatementEncounterMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ClinicalStatementExposureMood(str, Enum):
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    RSK='RSK'


class x_ClinicalStatementObservationMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    GOL='GOL'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    RSK='RSK'


class x_ClinicalStatementProcedureMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ClinicalStatementSubstanceMood(str, Enum):
    CRT='CRT'
    DEF='DEF'
    EVN='EVN'
    EVNCRT='EVN.CRT'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ClinicalStatementSupplyMood(str, Enum):
    DEF='DEF'
    EVN='EVN'
    INT='INT'


class x_DeterminerInstanceKind(str, Enum):
    INSTANCE='INSTANCE'
    KIND='KIND'
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class x_DocumentActMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    RSK='RSK'


class x_DocumentEncounterMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentEntrySubject(str, Enum):
    PAT='PAT'
    PRS='PRS'
    SPEC='SPEC'


class x_DocumentProcedureMood(str, Enum):
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentStatus(str, Enum):
    ACTIVE='active'
    CANCELLED='cancelled'
    NEW='new'
    OBSOLETE='obsolete'


class x_DocumentSubject(str, Enum):
    PAT='PAT'
    PRS='PRS'


class x_DocumentSubstanceMood(str, Enum):
    DEF='DEF'
    EVN='EVN'
    INT='INT'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_EncounterParticipant(str, Enum):
    ADM='ADM'
    ATND='ATND'
    CON='CON'
    DIS='DIS'
    REF='REF'


class x_EncounterPerformerParticipation(str, Enum):
    CON='CON'
    PRF='PRF'
    SPRF='SPRF'


class x_EntityClassDocumentReceiving(str, Enum):
    HCE='HCE'
    NAT='NAT'
    ORG='ORG'
    PSN='PSN'
    PUB='PUB'
    STATE='STATE'


class x_EntityClassPersonOrOrgReceiving(str, Enum):
    NAT='NAT'
    ORG='ORG'
    PSN='PSN'
    PUB='PUB'
    STATE='STATE'


class x_InformationRecipient(str, Enum):
    PRCP='PRCP'
    TRC='TRC'


class x_InformationRecipientRole(str, Enum):
    ASSIGNED='ASSIGNED'
    HLTHCHRT='HLTHCHRT'


class x_LabProcessClassCodes(str, Enum):
    ACSN='ACSN'
    CONTREG='CONTREG'
    OBS='OBS'
    PROC='PROC'
    SPCTRT='SPCTRT'
    SPECCOLLECT='SPECCOLLECT'
    STORE='STORE'
    TRNS='TRNS'


class x_OrganizationNamePartType(str, Enum):
    DEL='DEL'
    PFX='PFX'
    SFX='SFX'


class x_ParticipationAuthorPerformer(str, Enum):
    AUT='AUT'
    PRF='PRF'


class x_ParticipationEntVrf(str, Enum):
    ENT='ENT'
    VRF='VRF'


class x_ParticipationPrfEntVrf(str, Enum):
    ENT='ENT'
    PRF='PRF'
    VRF='VRF'


class x_ParticipationVrfRespSprfWit(str, Enum):
    RESP='RESP'
    SPRF='SPRF'
    VRF='VRF'
    WIT='WIT'


class x_PersonNamePartType(str, Enum):
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class x_PhoneOrEmailURLScheme(str, Enum):
    MAILTO='mailto'
    TEL='tel'


class x_PhoneURLScheme(str, Enum):
    TEL='tel'


class x_RoleClassAccommodationRequestor(str, Enum):
    AGNT='AGNT'
    PAT='PAT'
    PROV='PROV'
    PRS='PRS'


class x_RoleClassCoverage(str, Enum):
    COVPTY='COVPTY'
    POLHOLD='POLHOLD'
    SPNSR='SPNSR'
    UNDWRT='UNDWRT'


class x_RoleClassCoverageInvoice(str, Enum):
    PAYEE='PAYEE'
    PAYOR='PAYOR'


class x_RoleClassCredentialedEntity(str, Enum):
    ASSIGNED='ASSIGNED'
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'
    QUAL='QUAL'


class x_RoleClassPayeePolicyRelationship(str, Enum):
    COVPTY='COVPTY'
    GUAR='GUAR'
    POLHOLD='POLHOLD'
    PROV='PROV'
    PRS='PRS'


class x_SUCC_REPL_PREV(str, Enum):
    PREV='PREV'
    RPLC='RPLC'
    SUCC='SUCC'


class x_ServiceEventPerformer(str, Enum):
    PRF='PRF'
    SPRF='SPRF'


#
# Start data representation classes
#
class POCD_MT000040UV02_Act(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_ActClassDocumentEntryAct' = None, moodCode: 'x_DocumentActMood' = None, actionNegationInd: 'bl' = None, negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: 'CE' = None, confidentialityCode: 'CE' = None, uncertaintyCode: 'CE' = None, reasonCode: List_['CE'] = None, languageCode: 'CS' = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.uncertaintyCode = uncertaintyCode
        self.uncertaintyCode_nsprefix_ = None
        if reasonCode is None:
            self.reasonCode = []
        else:
            self.reasonCode = reasonCode
        self.reasonCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Act)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Act.subclass:
            return POCD_MT000040UV02_Act.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Act(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_uncertaintyCode(self):
        return self.uncertaintyCode
    def set_uncertaintyCode(self, uncertaintyCode):
        self.uncertaintyCode = uncertaintyCode
    def get_reasonCode(self):
        return self.reasonCode
    def set_reasonCode(self, reasonCode):
        self.reasonCode = reasonCode
    def add_reasonCode(self, value):
        self.reasonCode.append(value)
    def insert_reasonCode_at(self, index, value):
        self.reasonCode.insert(index, value)
    def replace_reasonCode_at(self, index, value):
        self.reasonCode[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActClassDocumentEntryAct(self, value):
        # Validate type x_ActClassDocumentEntryAct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACSN', 'ACT', 'AEXPOS', 'CONS', 'CONTREG', 'CTTEVENT', 'DISPACT', 'EXPOS', 'INC', 'INFRM', 'LIST', 'MPROT', 'PCPR', 'REG', 'REV', 'SPCTRT', 'STORE', 'TEXPOS', 'TRFR', 'TRNS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryAct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryAct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryAct_patterns_, ))
    validate_x_ActClassDocumentEntryAct_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentActMood(self, value):
        # Validate type x_DocumentActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'DEF', 'EVN', 'INT', 'PRMS', 'PRP', 'RQO', 'RSK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentActMood_patterns_, ))
    validate_x_DocumentActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode is not None or
            self.confidentialityCode is not None or
            self.uncertaintyCode is not None or
            self.reasonCode or
            self.languageCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Act', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Act')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Act':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Act')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Act', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Act'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Act', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.uncertaintyCode is not None:
            namespaceprefix_ = self.uncertaintyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.uncertaintyCode_nsprefix_) else ''
            self.uncertaintyCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='uncertaintyCode', pretty_print=pretty_print)
        for reasonCode_ in self.reasonCode:
            namespaceprefix_ = self.reasonCode_nsprefix_ + ':' if (UseCapturedNS_ and self.reasonCode_nsprefix_) else ''
            reasonCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reasonCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryAct(self.classCode)    # validate type x_ActClassDocumentEntryAct
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentActMood(self.moodCode)    # validate type x_DocumentActMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'uncertaintyCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uncertaintyCode = obj_
            obj_.original_tagname_ = 'uncertaintyCode'
        elif nodeName_ == 'reasonCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reasonCode.append(obj_)
            obj_.original_tagname_ = 'reasonCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_Act


class POCD_MT000040UV02_AssignedAuthor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, assignedPerson: 'POCD_MT000040UV02.Person' = None, assignedAuthoringDevice: 'POCD_MT000040UV02.AuthoringDevice' = None, representedOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.assignedAuthoringDevice = assignedAuthoringDevice
        self.assignedAuthoringDevice_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_AssignedAuthor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_AssignedAuthor.subclass:
            return POCD_MT000040UV02_AssignedAuthor.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_AssignedAuthor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_assignedAuthoringDevice(self):
        return self.assignedAuthoringDevice
    def set_assignedAuthoringDevice(self, assignedAuthoringDevice):
        self.assignedAuthoringDevice = assignedAuthoringDevice
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.assignedAuthoringDevice is not None or
            self.representedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedAuthor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.AssignedAuthor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.AssignedAuthor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.AssignedAuthor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.AssignedAuthor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.AssignedAuthor'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedAuthor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.assignedAuthoringDevice is not None:
            namespaceprefix_ = self.assignedAuthoringDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthoringDevice_nsprefix_) else ''
            self.assignedAuthoringDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthoringDevice', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'assignedAuthoringDevice':
            obj_ = POCD_MT000040UV02_AuthoringDevice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthoringDevice = obj_
            obj_.original_tagname_ = 'assignedAuthoringDevice'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
# end class POCD_MT000040UV02_AssignedAuthor


class POCD_MT000040UV02_AssignedCustodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, representedCustodianOrganization: 'POCD_MT000040UV02.CustodianOrganization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.representedCustodianOrganization = representedCustodianOrganization
        self.representedCustodianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_AssignedCustodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_AssignedCustodian.subclass:
            return POCD_MT000040UV02_AssignedCustodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_AssignedCustodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_representedCustodianOrganization(self):
        return self.representedCustodianOrganization
    def set_representedCustodianOrganization(self, representedCustodianOrganization):
        self.representedCustodianOrganization = representedCustodianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.representedCustodianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedCustodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.AssignedCustodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.AssignedCustodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.AssignedCustodian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.AssignedCustodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.AssignedCustodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedCustodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.representedCustodianOrganization is not None:
            namespaceprefix_ = self.representedCustodianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedCustodianOrganization_nsprefix_) else ''
            self.representedCustodianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedCustodianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'representedCustodianOrganization':
            obj_ = POCD_MT000040UV02_CustodianOrganization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedCustodianOrganization = obj_
            obj_.original_tagname_ = 'representedCustodianOrganization'
# end class POCD_MT000040UV02_AssignedCustodian


class POCD_MT000040UV02_AssignedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, assignedPerson: 'POCD_MT000040UV02.Person' = None, representedOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_AssignedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_AssignedEntity.subclass:
            return POCD_MT000040UV02_AssignedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_AssignedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.representedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.AssignedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.AssignedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.AssignedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.AssignedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.AssignedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssignedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
# end class POCD_MT000040UV02_AssignedEntity


class POCD_MT000040UV02_AssociatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassAssociative' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, associatedPerson: 'POCD_MT000040UV02.Person' = None, scopingOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.associatedPerson = associatedPerson
        self.associatedPerson_nsprefix_ = None
        self.scopingOrganization = scopingOrganization
        self.scopingOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_AssociatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_AssociatedEntity.subclass:
            return POCD_MT000040UV02_AssociatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_AssociatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_associatedPerson(self):
        return self.associatedPerson
    def set_associatedPerson(self, associatedPerson):
        self.associatedPerson = associatedPerson
    def get_scopingOrganization(self):
        return self.scopingOrganization
    def set_scopingOrganization(self, scopingOrganization):
        self.scopingOrganization = scopingOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClassAssociative(self, value):
        # Validate type RoleClassAssociative, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AFFL', 'AGNT', 'ASSIGNED', 'COMPAR', 'SGNOFF', 'CON', 'ECON', 'NOK', 'GUARD', 'CIT', 'COVPTY', 'CLAIM', 'NAMED', 'DEPEN', 'INDIV', 'SUBSCR', 'PROG', 'CRINV', 'CRSPNSR', 'EMP', 'MIL', 'GUAR', 'INVSBJ', 'CASEBJ', 'RESBJ', 'LIC', 'NOT', 'PROV', 'PAT', 'PAYEE', 'PAYOR', 'POLHOLD', 'QUAL', 'SPNSR', 'STD', 'UNDWRT', 'CAREGIVER', 'PRS', 'ACCESS', 'ADJY', 'CONC', 'BOND', 'CONY', 'ADMM', 'BIRTHPL', 'DEATHPLC', 'DST', 'RET', 'EXPR', 'HLD', 'HLTHCHRT', 'IDENT', 'MANU', 'THER', 'MNT', 'OWN', 'RGPR', 'SDLOC', 'DSDLOC', 'ISDLOC', 'TERR', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassAssociative' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassAssociative_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassAssociative_patterns_, ))
    validate_RoleClassAssociative_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.associatedPerson is not None or
            self.scopingOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssociatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.AssociatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.AssociatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.AssociatedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.AssociatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.AssociatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AssociatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.associatedPerson is not None:
            namespaceprefix_ = self.associatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedPerson_nsprefix_) else ''
            self.associatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedPerson', pretty_print=pretty_print)
        if self.scopingOrganization is not None:
            namespaceprefix_ = self.scopingOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingOrganization_nsprefix_) else ''
            self.scopingOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssociative(self.classCode)    # validate type RoleClassAssociative
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'associatedPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedPerson = obj_
            obj_.original_tagname_ = 'associatedPerson'
        elif nodeName_ == 'scopingOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingOrganization = obj_
            obj_.original_tagname_ = 'scopingOrganization'
# end class POCD_MT000040UV02_AssociatedEntity


class POCD_MT000040UV02_Authenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'AUTHEN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, signatureCode: 'CV' = None, signatureText: 'ED' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.signatureText = signatureText
        self.signatureText_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Authenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Authenticator.subclass:
            return POCD_MT000040UV02_Authenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Authenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_signatureText(self):
        return self.signatureText
    def set_signatureText(self, signatureText):
        self.signatureText = signatureText
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.signatureText is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Authenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Authenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Authenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Authenticator')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Authenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Authenticator'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUTHEN" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Authenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.signatureText is not None:
            namespaceprefix_ = self.signatureText_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureText_nsprefix_) else ''
            self.signatureText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureText', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'signatureText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureText = obj_
            obj_.original_tagname_ = 'signatureText'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_Authenticator


class POCD_MT000040UV02_Author(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'AUT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'TS' = None, assignedAuthor: 'POCD_MT000040UV02.AssignedAuthor' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedAuthor = assignedAuthor
        self.assignedAuthor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Author)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Author.subclass:
            return POCD_MT000040UV02_Author.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Author(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedAuthor(self):
        return self.assignedAuthor
    def set_assignedAuthor(self, assignedAuthor):
        self.assignedAuthor = assignedAuthor
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedAuthor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Author', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Author')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Author':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Author')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Author', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Author'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Author', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedAuthor is not None:
            namespaceprefix_ = self.assignedAuthor_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthor_nsprefix_) else ''
            self.assignedAuthor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedAuthor':
            obj_ = POCD_MT000040UV02_AssignedAuthor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthor = obj_
            obj_.original_tagname_ = 'assignedAuthor'
# end class POCD_MT000040UV02_Author


class POCD_MT000040UV02_AuthoringDevice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'DEV', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, manufacturerModelName: 'SC' = None, softwareName: 'SC' = None, asMaintainedEntity: List_['POCD_MT000040UV02.MaintainedEntity'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
        if asMaintainedEntity is None:
            self.asMaintainedEntity = []
        else:
            self.asMaintainedEntity = asMaintainedEntity
        self.asMaintainedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_AuthoringDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_AuthoringDevice.subclass:
            return POCD_MT000040UV02_AuthoringDevice.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_AuthoringDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_asMaintainedEntity(self):
        return self.asMaintainedEntity
    def set_asMaintainedEntity(self, asMaintainedEntity):
        self.asMaintainedEntity = asMaintainedEntity
    def add_asMaintainedEntity(self, value):
        self.asMaintainedEntity.append(value)
    def insert_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity.insert(index, value)
    def replace_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None or
            self.asMaintainedEntity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AuthoringDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.AuthoringDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.AuthoringDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.AuthoringDevice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.AuthoringDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.AuthoringDevice'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DEV" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.AuthoringDevice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
        for asMaintainedEntity_ in self.asMaintainedEntity:
            namespaceprefix_ = self.asMaintainedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.asMaintainedEntity_nsprefix_) else ''
            asMaintainedEntity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asMaintainedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
        elif nodeName_ == 'asMaintainedEntity':
            obj_ = POCD_MT000040UV02_MaintainedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asMaintainedEntity.append(obj_)
            obj_.original_tagname_ = 'asMaintainedEntity'
# end class POCD_MT000040UV02_AuthoringDevice


class POCD_MT000040UV02_Authorization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'AUTH', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, consent: 'POCD_MT000040UV02.Consent' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.consent = consent
        self.consent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Authorization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Authorization.subclass:
            return POCD_MT000040UV02_Authorization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Authorization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_consent(self):
        return self.consent
    def set_consent(self, consent):
        self.consent = consent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.consent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Authorization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Authorization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Authorization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Authorization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Authorization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Authorization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUTH" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Authorization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.consent is not None:
            namespaceprefix_ = self.consent_nsprefix_ + ':' if (UseCapturedNS_ and self.consent_nsprefix_) else ''
            self.consent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'consent':
            obj_ = POCD_MT000040UV02_Consent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consent = obj_
            obj_.original_tagname_ = 'consent'
# end class POCD_MT000040UV02_Authorization


class POCD_MT000040UV02_Birthplace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'BIRTHPL', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, place: 'POCD_MT000040UV02.Place' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.place = place
        self.place_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Birthplace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Birthplace.subclass:
            return POCD_MT000040UV02_Birthplace.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Birthplace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.place is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Birthplace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Birthplace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Birthplace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Birthplace')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Birthplace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Birthplace'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "BIRTHPL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Birthplace', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.place is not None:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            self.place.export(outfile, level, namespaceprefix_, namespacedef_='', name_='place', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'place':
            obj_ = POCD_MT000040UV02_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
# end class POCD_MT000040UV02_Birthplace


class POCD_MT000040UV02_ClinicalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCCLIN', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, code: 'CE' = None, title: 'ST' = None, statusCode: 'statusCode' = None, effectiveTime: 'TS' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, setId: 'II' = None, versionNumber: 'ST.r2b' = None, copyTime: 'TS' = None, recordTarget: List_['POCD_MT000040UV02.RecordTarget'] = None, author: List_['POCD_MT000040UV02.Author'] = None, dataEnterer: 'POCD_MT000040UV02.DataEnterer' = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, custodian: 'POCD_MT000040UV02.Custodian' = None, informationRecipient: List_['POCD_MT000040UV02.Participant'] = None, legalAuthenticator: List_['POCD_MT000040UV02.LegalAuthenticator'] = None, authenticator: List_['POCD_MT000040UV02.Authenticator'] = None, participant: List_['POCD_MT000040UV02.Participant2'] = None, inFulfillmentOf: List_['POCD_MT000040UV02.InFulfillmentOf'] = None, documentationOf: List_['POCD_MT000040UV02.DocumentationOf'] = None, relatedDocument: List_['POCD_MT000040UV02.RelatedDocument'] = None, authorization: List_['POCD_MT000040UV02.Authorization'] = None, componentOf: 'POCD_MT000040UV02.Component1' = None, component: 'POCD_MT000040UV02.Component2' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "sdtc"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "sdtc"
        self.typeId = typeId
        self.typeId_nsprefix_ = "sdtc"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "sdtc"
        self.id = id
        self.id_nsprefix_ = "sdtc"
        self.code = code
        self.code_nsprefix_ = "sdtc"
        self.title = title
        self.title_nsprefix_ = "sdtc"
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = "sdtc"
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = "sdtc"
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = "sdtc"
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = "sdtc"
        self.setId = setId
        self.setId_nsprefix_ = "sdtc"
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = "sdtc"
        self.copyTime = copyTime
        self.copyTime_nsprefix_ = "sdtc"
        if recordTarget is None:
            self.recordTarget = []
        else:
            self.recordTarget = recordTarget
        self.recordTarget_nsprefix_ = "sdtc"
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = "sdtc"
        self.dataEnterer = dataEnterer
        self.dataEnterer_nsprefix_ = "sdtc"
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = "sdtc"
        self.custodian = custodian
        self.custodian_nsprefix_ = "sdtc"
        if informationRecipient is None:
            self.informationRecipient = []
        else:
            self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = "sdtc"
        if legalAuthenticator is None:
            self.legalAuthenticator = []
        else:
            self.legalAuthenticator = legalAuthenticator
        self.legalAuthenticator_nsprefix_ = "sdtc"
        if authenticator is None:
            self.authenticator = []
        else:
            self.authenticator = authenticator
        self.authenticator_nsprefix_ = "sdtc"
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = "sdtc"
        if inFulfillmentOf is None:
            self.inFulfillmentOf = []
        else:
            self.inFulfillmentOf = inFulfillmentOf
        self.inFulfillmentOf_nsprefix_ = "sdtc"
        if documentationOf is None:
            self.documentationOf = []
        else:
            self.documentationOf = documentationOf
        self.documentationOf_nsprefix_ = "sdtc"
        if relatedDocument is None:
            self.relatedDocument = []
        else:
            self.relatedDocument = relatedDocument
        self.relatedDocument_nsprefix_ = "sdtc"
        if authorization is None:
            self.authorization = []
        else:
            self.authorization = authorization
        self.authorization_nsprefix_ = "sdtc"
        self.componentOf = componentOf
        self.componentOf_nsprefix_ = "sdtc"
        self.component = component
        self.component_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ClinicalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ClinicalDocument.subclass:
            return POCD_MT000040UV02_ClinicalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ClinicalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_copyTime(self):
        return self.copyTime
    def set_copyTime(self, copyTime):
        self.copyTime = copyTime
    def get_recordTarget(self):
        return self.recordTarget
    def set_recordTarget(self, recordTarget):
        self.recordTarget = recordTarget
    def add_recordTarget(self, value):
        self.recordTarget.append(value)
    def insert_recordTarget_at(self, index, value):
        self.recordTarget.insert(index, value)
    def replace_recordTarget_at(self, index, value):
        self.recordTarget[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_dataEnterer(self):
        return self.dataEnterer
    def set_dataEnterer(self, dataEnterer):
        self.dataEnterer = dataEnterer
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_custodian(self):
        return self.custodian
    def set_custodian(self, custodian):
        self.custodian = custodian
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def add_informationRecipient(self, value):
        self.informationRecipient.append(value)
    def insert_informationRecipient_at(self, index, value):
        self.informationRecipient.insert(index, value)
    def replace_informationRecipient_at(self, index, value):
        self.informationRecipient[index] = value
    def get_legalAuthenticator(self):
        return self.legalAuthenticator
    def set_legalAuthenticator(self, legalAuthenticator):
        self.legalAuthenticator = legalAuthenticator
    def add_legalAuthenticator(self, value):
        self.legalAuthenticator.append(value)
    def insert_legalAuthenticator_at(self, index, value):
        self.legalAuthenticator.insert(index, value)
    def replace_legalAuthenticator_at(self, index, value):
        self.legalAuthenticator[index] = value
    def get_authenticator(self):
        return self.authenticator
    def set_authenticator(self, authenticator):
        self.authenticator = authenticator
    def add_authenticator(self, value):
        self.authenticator.append(value)
    def insert_authenticator_at(self, index, value):
        self.authenticator.insert(index, value)
    def replace_authenticator_at(self, index, value):
        self.authenticator[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_inFulfillmentOf(self):
        return self.inFulfillmentOf
    def set_inFulfillmentOf(self, inFulfillmentOf):
        self.inFulfillmentOf = inFulfillmentOf
    def add_inFulfillmentOf(self, value):
        self.inFulfillmentOf.append(value)
    def insert_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf.insert(index, value)
    def replace_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf[index] = value
    def get_documentationOf(self):
        return self.documentationOf
    def set_documentationOf(self, documentationOf):
        self.documentationOf = documentationOf
    def add_documentationOf(self, value):
        self.documentationOf.append(value)
    def insert_documentationOf_at(self, index, value):
        self.documentationOf.insert(index, value)
    def replace_documentationOf_at(self, index, value):
        self.documentationOf[index] = value
    def get_relatedDocument(self):
        return self.relatedDocument
    def set_relatedDocument(self, relatedDocument):
        self.relatedDocument = relatedDocument
    def add_relatedDocument(self, value):
        self.relatedDocument.append(value)
    def insert_relatedDocument_at(self, index, value):
        self.relatedDocument.insert(index, value)
    def replace_relatedDocument_at(self, index, value):
        self.relatedDocument[index] = value
    def get_authorization(self):
        return self.authorization
    def set_authorization(self, authorization):
        self.authorization = authorization
    def add_authorization(self, value):
        self.authorization.append(value)
    def insert_authorization_at(self, index, value):
        self.authorization.insert(index, value)
    def replace_authorization_at(self, index, value):
        self.authorization[index] = value
    def get_componentOf(self):
        return self.componentOf
    def set_componentOf(self, componentOf):
        self.componentOf = componentOf
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.setId is not None or
            self.versionNumber is not None or
            self.copyTime is not None or
            self.recordTarget or
            self.author or
            self.dataEnterer is not None or
            self.informant or
            self.custodian is not None or
            self.informationRecipient or
            self.legalAuthenticator or
            self.authenticator or
            self.participant or
            self.inFulfillmentOf or
            self.documentationOf or
            self.relatedDocument or
            self.authorization or
            self.componentOf is not None or
            self.component is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ClinicalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ClinicalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ClinicalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ClinicalDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ClinicalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ClinicalDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCCLIN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ClinicalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
        if self.copyTime is not None:
            namespaceprefix_ = self.copyTime_nsprefix_ + ':' if (UseCapturedNS_ and self.copyTime_nsprefix_) else ''
            self.copyTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copyTime', pretty_print=pretty_print)
        for recordTarget_ in self.recordTarget:
            namespaceprefix_ = self.recordTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.recordTarget_nsprefix_) else ''
            recordTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordTarget', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        if self.dataEnterer is not None:
            namespaceprefix_ = self.dataEnterer_nsprefix_ + ':' if (UseCapturedNS_ and self.dataEnterer_nsprefix_) else ''
            self.dataEnterer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataEnterer', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        if self.custodian is not None:
            namespaceprefix_ = self.custodian_nsprefix_ + ':' if (UseCapturedNS_ and self.custodian_nsprefix_) else ''
            self.custodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='custodian', pretty_print=pretty_print)
        for informationRecipient_ in self.informationRecipient:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            informationRecipient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        for legalAuthenticator_ in self.legalAuthenticator:
            namespaceprefix_ = self.legalAuthenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.legalAuthenticator_nsprefix_) else ''
            legalAuthenticator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='legalAuthenticator', pretty_print=pretty_print)
        for authenticator_ in self.authenticator:
            namespaceprefix_ = self.authenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.authenticator_nsprefix_) else ''
            authenticator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authenticator', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for inFulfillmentOf_ in self.inFulfillmentOf:
            namespaceprefix_ = self.inFulfillmentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf_nsprefix_) else ''
            inFulfillmentOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inFulfillmentOf', pretty_print=pretty_print)
        for documentationOf_ in self.documentationOf:
            namespaceprefix_ = self.documentationOf_nsprefix_ + ':' if (UseCapturedNS_ and self.documentationOf_nsprefix_) else ''
            documentationOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentationOf', pretty_print=pretty_print)
        for relatedDocument_ in self.relatedDocument:
            namespaceprefix_ = self.relatedDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedDocument_nsprefix_) else ''
            relatedDocument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedDocument', pretty_print=pretty_print)
        for authorization_ in self.authorization:
            namespaceprefix_ = self.authorization_nsprefix_ + ':' if (UseCapturedNS_ and self.authorization_nsprefix_) else ''
            authorization_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authorization', pretty_print=pretty_print)
        if self.componentOf is not None:
            namespaceprefix_ = self.componentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.componentOf_nsprefix_) else ''
            self.componentOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentOf', pretty_print=pretty_print)
        if self.component is not None:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            self.component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'statusCode':
            obj_ = statusCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'setId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            obj_ = ST_r2b.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
        elif nodeName_ == 'copyTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyTime = obj_
            obj_.original_tagname_ = 'copyTime'
        elif nodeName_ == 'recordTarget':
            obj_ = POCD_MT000040UV02_RecordTarget.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordTarget.append(obj_)
            obj_.original_tagname_ = 'recordTarget'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'dataEnterer':
            obj_ = POCD_MT000040UV02_DataEnterer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataEnterer = obj_
            obj_.original_tagname_ = 'dataEnterer'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'custodian':
            obj_ = POCD_MT000040UV02_Custodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.custodian = obj_
            obj_.original_tagname_ = 'custodian'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040UV02_Participant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient.append(obj_)
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'legalAuthenticator':
            obj_ = POCD_MT000040UV02_LegalAuthenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalAuthenticator.append(obj_)
            obj_.original_tagname_ = 'legalAuthenticator'
        elif nodeName_ == 'authenticator':
            obj_ = POCD_MT000040UV02_Authenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authenticator.append(obj_)
            obj_.original_tagname_ = 'authenticator'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'inFulfillmentOf':
            obj_ = POCD_MT000040UV02_InFulfillmentOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf'
        elif nodeName_ == 'documentationOf':
            obj_ = POCD_MT000040UV02_DocumentationOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documentationOf.append(obj_)
            obj_.original_tagname_ = 'documentationOf'
        elif nodeName_ == 'relatedDocument':
            obj_ = POCD_MT000040UV02_RelatedDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedDocument.append(obj_)
            obj_.original_tagname_ = 'relatedDocument'
        elif nodeName_ == 'authorization':
            obj_ = POCD_MT000040UV02_Authorization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authorization.append(obj_)
            obj_.original_tagname_ = 'authorization'
        elif nodeName_ == 'componentOf':
            obj_ = POCD_MT000040UV02_Component1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentOf = obj_
            obj_.original_tagname_ = 'componentOf'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040UV02_Component2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component = obj_
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040UV02_ClinicalDocument


class POCD_MT000040UV02_Component1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'COMP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, encompassingEncounter: 'POCD_MT000040UV02.EncompassingEncounter' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.encompassingEncounter = encompassingEncounter
        self.encompassingEncounter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Component1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Component1.subclass:
            return POCD_MT000040UV02_Component1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Component1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_encompassingEncounter(self):
        return self.encompassingEncounter
    def set_encompassingEncounter(self, encompassingEncounter):
        self.encompassingEncounter = encompassingEncounter
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.encompassingEncounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Component1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Component1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Component1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Component1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Component1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.encompassingEncounter is not None:
            namespaceprefix_ = self.encompassingEncounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encompassingEncounter_nsprefix_) else ''
            self.encompassingEncounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encompassingEncounter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'encompassingEncounter':
            obj_ = POCD_MT000040UV02_EncompassingEncounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encompassingEncounter = obj_
            obj_.original_tagname_ = 'encompassingEncounter'
# end class POCD_MT000040UV02_Component1


class POCD_MT000040UV02_Component2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, nonXMLBody: 'POCD_MT000040UV02.NonXMLBody' = None, structuredBody: 'POCD_MT000040UV02.StructuredBody' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.nonXMLBody = nonXMLBody
        self.nonXMLBody_nsprefix_ = None
        self.structuredBody = structuredBody
        self.structuredBody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Component2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Component2.subclass:
            return POCD_MT000040UV02_Component2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Component2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_nonXMLBody(self):
        return self.nonXMLBody
    def set_nonXMLBody(self, nonXMLBody):
        self.nonXMLBody = nonXMLBody
    def get_structuredBody(self):
        return self.structuredBody
    def set_structuredBody(self, structuredBody):
        self.structuredBody = structuredBody
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.nonXMLBody is not None or
            self.structuredBody is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Component2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Component2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Component2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Component2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Component2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.nonXMLBody is not None:
            namespaceprefix_ = self.nonXMLBody_nsprefix_ + ':' if (UseCapturedNS_ and self.nonXMLBody_nsprefix_) else ''
            self.nonXMLBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonXMLBody', pretty_print=pretty_print)
        if self.structuredBody is not None:
            namespaceprefix_ = self.structuredBody_nsprefix_ + ':' if (UseCapturedNS_ and self.structuredBody_nsprefix_) else ''
            self.structuredBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structuredBody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'nonXMLBody':
            obj_ = POCD_MT000040UV02_NonXMLBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonXMLBody = obj_
            obj_.original_tagname_ = 'nonXMLBody'
        elif nodeName_ == 'structuredBody':
            obj_ = POCD_MT000040UV02_StructuredBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structuredBody = obj_
            obj_.original_tagname_ = 'structuredBody'
# end class POCD_MT000040UV02_Component2


class POCD_MT000040UV02_Component3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, section: 'POCD_MT000040UV02.Section' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Component3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Component3.subclass:
            return POCD_MT000040UV02_Component3.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Component3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Component3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Component3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Component3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Component3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Component3'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040UV02_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040UV02_Component3


class POCD_MT000040UV02_Component4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, sequenceNumber: 'INT' = None, seperatableInd: 'BL' = None, act: 'POCD_MT000040UV02.Act' = None, encounter: 'POCD_MT000040UV02.Encounter' = None, observation: 'POCD_MT000040UV02.Observation' = None, observationMedia: 'POCD_MT000040UV02.ObservationMedia' = None, organizer: 'POCD_MT000040UV02.Organizer' = None, procedure: 'POCD_MT000040UV02.Procedure' = None, regionOfInterest: 'POCD_MT000040UV02.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040UV02.SubstanceAdministration' = None, supply: 'POCD_MT000040UV02.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Component4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Component4.subclass:
            return POCD_MT000040UV02_Component4.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Component4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Component4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Component4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Component4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Component4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Component4'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040UV02_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040UV02_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040UV02_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040UV02_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040UV02_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040UV02_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040UV02_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040UV02_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040UV02_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040UV02_Component4


class POCD_MT000040UV02_Component5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, section: 'POCD_MT000040UV02.Section' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Component5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Component5.subclass:
            return POCD_MT000040UV02_Component5.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Component5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Component5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Component5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Component5')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Component5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Component5'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Component5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040UV02_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040UV02_Component5


class POCD_MT000040UV02_Consent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'CONS', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, statusCode: 'CS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Consent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Consent.subclass:
            return POCD_MT000040UV02_Consent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Consent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Consent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Consent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Consent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Consent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Consent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Consent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "CONS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Consent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
# end class POCD_MT000040UV02_Consent


class POCD_MT000040UV02_Consumable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'CSM', contextControlCode: 'ContextControl' = 'ON', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, manufacturedProduct: 'POCD_MT000040UV02.ManufacturedProduct' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Consumable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Consumable.subclass:
            return POCD_MT000040UV02_Consumable.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Consumable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Consumable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Consumable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Consumable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Consumable')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Consumable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Consumable'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "CSM" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "ON" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Consumable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040UV02_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040UV02_Consumable


class POCD_MT000040UV02_Criterion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN.CRT', actionNegationInd: 'bl' = None, isCriterionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, value: 'ANY' = None, valueNegationInd: 'BL' = None, interpretationCode: 'CE' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.valueNegationInd = valueNegationInd
        self.valueNegationInd_nsprefix_ = None
        self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Criterion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Criterion.subclass:
            return POCD_MT000040UV02_Criterion.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Criterion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_valueNegationInd(self):
        return self.valueNegationInd
    def set_valueNegationInd(self, valueNegationInd):
        self.valueNegationInd = valueNegationInd
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None or
            self.valueNegationInd is not None or
            self.interpretationCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Criterion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Criterion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Criterion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Criterion')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Criterion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Criterion'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN.CRT" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.isCriterionInd is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Criterion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
        if self.valueNegationInd is not None:
            namespaceprefix_ = self.valueNegationInd_nsprefix_ + ':' if (UseCapturedNS_ and self.valueNegationInd_nsprefix_) else ''
            self.valueNegationInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='valueNegationInd', pretty_print=pretty_print)
        if self.interpretationCode is not None:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            self.interpretationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'valueNegationInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.valueNegationInd = obj_
            obj_.original_tagname_ = 'valueNegationInd'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode = obj_
            obj_.original_tagname_ = 'interpretationCode'
# end class POCD_MT000040UV02_Criterion


class POCD_MT000040UV02_Custodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'CST', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedCustodian: 'POCD_MT000040UV02.AssignedCustodian' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedCustodian = assignedCustodian
        self.assignedCustodian_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Custodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Custodian.subclass:
            return POCD_MT000040UV02_Custodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Custodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedCustodian(self):
        return self.assignedCustodian
    def set_assignedCustodian(self, assignedCustodian):
        self.assignedCustodian = assignedCustodian
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedCustodian is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Custodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Custodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Custodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Custodian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Custodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Custodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "CST" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Custodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedCustodian is not None:
            namespaceprefix_ = self.assignedCustodian_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedCustodian_nsprefix_) else ''
            self.assignedCustodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedCustodian', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedCustodian':
            obj_ = POCD_MT000040UV02_AssignedCustodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedCustodian = obj_
            obj_.original_tagname_ = 'assignedCustodian'
# end class POCD_MT000040UV02_Custodian


class POCD_MT000040UV02_CustodianOrganization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'ORG', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: 'ON' = None, telecom: 'TEL' = None, addr: 'AD' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_CustodianOrganization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_CustodianOrganization.subclass:
            return POCD_MT000040UV02_CustodianOrganization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_CustodianOrganization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name is not None or
            self.telecom is not None or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.CustodianOrganization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.CustodianOrganization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.CustodianOrganization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.CustodianOrganization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.CustodianOrganization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.CustodianOrganization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ORG" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.CustodianOrganization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.telecom is not None:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            self.telecom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom = obj_
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040UV02_CustodianOrganization


class POCD_MT000040UV02_DataEnterer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'ENT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_DataEnterer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_DataEnterer.subclass:
            return POCD_MT000040UV02_DataEnterer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_DataEnterer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.DataEnterer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.DataEnterer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.DataEnterer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.DataEnterer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.DataEnterer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.DataEnterer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "ENT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.DataEnterer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_DataEnterer


class POCD_MT000040UV02_Device(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassDevice' = 'DEV', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, manufacturerModelName: 'SC' = None, softwareName: 'SC' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Device)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Device.subclass:
            return POCD_MT000040UV02_Device.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClassDevice(self, value):
        # Validate type EntityClassDevice, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEV', 'CER', 'MODDV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassDevice' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassDevice_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassDevice_patterns_, ))
    validate_EntityClassDevice_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Device', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Device':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Device')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Device'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DEV" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Device', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassDevice(self.classCode)    # validate type EntityClassDevice
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
# end class POCD_MT000040UV02_Device


class POCD_MT000040UV02_DocumentationOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'DOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, serviceEvent: 'POCD_MT000040UV02.ServiceEvent' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.serviceEvent = serviceEvent
        self.serviceEvent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_DocumentationOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_DocumentationOf.subclass:
            return POCD_MT000040UV02_DocumentationOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_DocumentationOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_serviceEvent(self):
        return self.serviceEvent
    def set_serviceEvent(self, serviceEvent):
        self.serviceEvent = serviceEvent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.serviceEvent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.DocumentationOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.DocumentationOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.DocumentationOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.DocumentationOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.DocumentationOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.DocumentationOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "DOC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.DocumentationOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.serviceEvent is not None:
            namespaceprefix_ = self.serviceEvent_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceEvent_nsprefix_) else ''
            self.serviceEvent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceEvent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'serviceEvent':
            obj_ = POCD_MT000040UV02_ServiceEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceEvent = obj_
            obj_.original_tagname_ = 'serviceEvent'
# end class POCD_MT000040UV02_DocumentationOf


class POCD_MT000040UV02_EncompassingEncounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'ENC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, effectiveTime: 'IVL_TS' = None, admissionReferralSourceCode: 'CE' = None, dischargeDispositionCode: 'CE' = None, responsibleParty: 'POCD_MT000040UV02.ResponsibleParty' = None, encounterParticipant: List_['POCD_MT000040UV02.EncounterParticipant'] = None, location: 'POCD_MT000040UV02.Location' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.admissionReferralSourceCode = admissionReferralSourceCode
        self.admissionReferralSourceCode_nsprefix_ = None
        self.dischargeDispositionCode = dischargeDispositionCode
        self.dischargeDispositionCode_nsprefix_ = None
        self.responsibleParty = responsibleParty
        self.responsibleParty_nsprefix_ = None
        if encounterParticipant is None:
            self.encounterParticipant = []
        else:
            self.encounterParticipant = encounterParticipant
        self.encounterParticipant_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_EncompassingEncounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_EncompassingEncounter.subclass:
            return POCD_MT000040UV02_EncompassingEncounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_EncompassingEncounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_admissionReferralSourceCode(self):
        return self.admissionReferralSourceCode
    def set_admissionReferralSourceCode(self, admissionReferralSourceCode):
        self.admissionReferralSourceCode = admissionReferralSourceCode
    def get_dischargeDispositionCode(self):
        return self.dischargeDispositionCode
    def set_dischargeDispositionCode(self, dischargeDispositionCode):
        self.dischargeDispositionCode = dischargeDispositionCode
    def get_responsibleParty(self):
        return self.responsibleParty
    def set_responsibleParty(self, responsibleParty):
        self.responsibleParty = responsibleParty
    def get_encounterParticipant(self):
        return self.encounterParticipant
    def set_encounterParticipant(self, encounterParticipant):
        self.encounterParticipant = encounterParticipant
    def add_encounterParticipant(self, value):
        self.encounterParticipant.append(value)
    def insert_encounterParticipant_at(self, index, value):
        self.encounterParticipant.insert(index, value)
    def replace_encounterParticipant_at(self, index, value):
        self.encounterParticipant[index] = value
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.admissionReferralSourceCode is not None or
            self.dischargeDispositionCode is not None or
            self.responsibleParty is not None or
            self.encounterParticipant or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EncompassingEncounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.EncompassingEncounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.EncompassingEncounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.EncompassingEncounter')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.EncompassingEncounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.EncompassingEncounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EncompassingEncounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.admissionReferralSourceCode is not None:
            namespaceprefix_ = self.admissionReferralSourceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.admissionReferralSourceCode_nsprefix_) else ''
            self.admissionReferralSourceCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='admissionReferralSourceCode', pretty_print=pretty_print)
        if self.dischargeDispositionCode is not None:
            namespaceprefix_ = self.dischargeDispositionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dischargeDispositionCode_nsprefix_) else ''
            self.dischargeDispositionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dischargeDispositionCode', pretty_print=pretty_print)
        if self.responsibleParty is not None:
            namespaceprefix_ = self.responsibleParty_nsprefix_ + ':' if (UseCapturedNS_ and self.responsibleParty_nsprefix_) else ''
            self.responsibleParty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='responsibleParty', pretty_print=pretty_print)
        for encounterParticipant_ in self.encounterParticipant:
            namespaceprefix_ = self.encounterParticipant_nsprefix_ + ':' if (UseCapturedNS_ and self.encounterParticipant_nsprefix_) else ''
            encounterParticipant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounterParticipant', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'admissionReferralSourceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.admissionReferralSourceCode = obj_
            obj_.original_tagname_ = 'admissionReferralSourceCode'
        elif nodeName_ == 'dischargeDispositionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dischargeDispositionCode = obj_
            obj_.original_tagname_ = 'dischargeDispositionCode'
        elif nodeName_ == 'responsibleParty':
            obj_ = POCD_MT000040UV02_ResponsibleParty.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.responsibleParty = obj_
            obj_.original_tagname_ = 'responsibleParty'
        elif nodeName_ == 'encounterParticipant':
            obj_ = POCD_MT000040UV02_EncounterParticipant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounterParticipant.append(obj_)
            obj_.original_tagname_ = 'encounterParticipant'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040UV02_Location.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class POCD_MT000040UV02_EncompassingEncounter


class POCD_MT000040UV02_Encounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'ENC', moodCode: 'x_DocumentEncounterMood' = None, actionNegationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: 'CE' = None, confidentialityCode: 'CE' = None, reasonCode: List_['CE'] = None, languageCode: 'CS' = None, admissionReferralSourceCode: 'CE' = None, lengthOfStayQuantity: 'PQ' = None, dischargeDispositionCode: 'CE' = None, preAdmitTestInd: 'BL' = None, specialCourtesiesCode: List_['CE'] = None, specialArrangementCode: List_['CE'] = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        if reasonCode is None:
            self.reasonCode = []
        else:
            self.reasonCode = reasonCode
        self.reasonCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.admissionReferralSourceCode = admissionReferralSourceCode
        self.admissionReferralSourceCode_nsprefix_ = None
        self.lengthOfStayQuantity = lengthOfStayQuantity
        self.lengthOfStayQuantity_nsprefix_ = None
        self.dischargeDispositionCode = dischargeDispositionCode
        self.dischargeDispositionCode_nsprefix_ = None
        self.preAdmitTestInd = preAdmitTestInd
        self.preAdmitTestInd_nsprefix_ = None
        if specialCourtesiesCode is None:
            self.specialCourtesiesCode = []
        else:
            self.specialCourtesiesCode = specialCourtesiesCode
        self.specialCourtesiesCode_nsprefix_ = None
        if specialArrangementCode is None:
            self.specialArrangementCode = []
        else:
            self.specialArrangementCode = specialArrangementCode
        self.specialArrangementCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Encounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Encounter.subclass:
            return POCD_MT000040UV02_Encounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Encounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_reasonCode(self):
        return self.reasonCode
    def set_reasonCode(self, reasonCode):
        self.reasonCode = reasonCode
    def add_reasonCode(self, value):
        self.reasonCode.append(value)
    def insert_reasonCode_at(self, index, value):
        self.reasonCode.insert(index, value)
    def replace_reasonCode_at(self, index, value):
        self.reasonCode[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_admissionReferralSourceCode(self):
        return self.admissionReferralSourceCode
    def set_admissionReferralSourceCode(self, admissionReferralSourceCode):
        self.admissionReferralSourceCode = admissionReferralSourceCode
    def get_lengthOfStayQuantity(self):
        return self.lengthOfStayQuantity
    def set_lengthOfStayQuantity(self, lengthOfStayQuantity):
        self.lengthOfStayQuantity = lengthOfStayQuantity
    def get_dischargeDispositionCode(self):
        return self.dischargeDispositionCode
    def set_dischargeDispositionCode(self, dischargeDispositionCode):
        self.dischargeDispositionCode = dischargeDispositionCode
    def get_preAdmitTestInd(self):
        return self.preAdmitTestInd
    def set_preAdmitTestInd(self, preAdmitTestInd):
        self.preAdmitTestInd = preAdmitTestInd
    def get_specialCourtesiesCode(self):
        return self.specialCourtesiesCode
    def set_specialCourtesiesCode(self, specialCourtesiesCode):
        self.specialCourtesiesCode = specialCourtesiesCode
    def add_specialCourtesiesCode(self, value):
        self.specialCourtesiesCode.append(value)
    def insert_specialCourtesiesCode_at(self, index, value):
        self.specialCourtesiesCode.insert(index, value)
    def replace_specialCourtesiesCode_at(self, index, value):
        self.specialCourtesiesCode[index] = value
    def get_specialArrangementCode(self):
        return self.specialArrangementCode
    def set_specialArrangementCode(self, specialArrangementCode):
        self.specialArrangementCode = specialArrangementCode
    def add_specialArrangementCode(self, value):
        self.specialArrangementCode.append(value)
    def insert_specialArrangementCode_at(self, index, value):
        self.specialArrangementCode.insert(index, value)
    def replace_specialArrangementCode_at(self, index, value):
        self.specialArrangementCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentEncounterMood(self, value):
        # Validate type x_DocumentEncounterMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'DEF', 'EVN', 'INT', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentEncounterMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentEncounterMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentEncounterMood_patterns_, ))
    validate_x_DocumentEncounterMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode is not None or
            self.confidentialityCode is not None or
            self.reasonCode or
            self.languageCode is not None or
            self.admissionReferralSourceCode is not None or
            self.lengthOfStayQuantity is not None or
            self.dischargeDispositionCode is not None or
            self.preAdmitTestInd is not None or
            self.specialCourtesiesCode or
            self.specialArrangementCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Encounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Encounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Encounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Encounter')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Encounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Encounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Encounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        for reasonCode_ in self.reasonCode:
            namespaceprefix_ = self.reasonCode_nsprefix_ + ':' if (UseCapturedNS_ and self.reasonCode_nsprefix_) else ''
            reasonCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reasonCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.admissionReferralSourceCode is not None:
            namespaceprefix_ = self.admissionReferralSourceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.admissionReferralSourceCode_nsprefix_) else ''
            self.admissionReferralSourceCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='admissionReferralSourceCode', pretty_print=pretty_print)
        if self.lengthOfStayQuantity is not None:
            namespaceprefix_ = self.lengthOfStayQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.lengthOfStayQuantity_nsprefix_) else ''
            self.lengthOfStayQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lengthOfStayQuantity', pretty_print=pretty_print)
        if self.dischargeDispositionCode is not None:
            namespaceprefix_ = self.dischargeDispositionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dischargeDispositionCode_nsprefix_) else ''
            self.dischargeDispositionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dischargeDispositionCode', pretty_print=pretty_print)
        if self.preAdmitTestInd is not None:
            namespaceprefix_ = self.preAdmitTestInd_nsprefix_ + ':' if (UseCapturedNS_ and self.preAdmitTestInd_nsprefix_) else ''
            self.preAdmitTestInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preAdmitTestInd', pretty_print=pretty_print)
        for specialCourtesiesCode_ in self.specialCourtesiesCode:
            namespaceprefix_ = self.specialCourtesiesCode_nsprefix_ + ':' if (UseCapturedNS_ and self.specialCourtesiesCode_nsprefix_) else ''
            specialCourtesiesCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specialCourtesiesCode', pretty_print=pretty_print)
        for specialArrangementCode_ in self.specialArrangementCode:
            namespaceprefix_ = self.specialArrangementCode_nsprefix_ + ':' if (UseCapturedNS_ and self.specialArrangementCode_nsprefix_) else ''
            specialArrangementCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specialArrangementCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentEncounterMood(self.moodCode)    # validate type x_DocumentEncounterMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'reasonCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reasonCode.append(obj_)
            obj_.original_tagname_ = 'reasonCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'admissionReferralSourceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.admissionReferralSourceCode = obj_
            obj_.original_tagname_ = 'admissionReferralSourceCode'
        elif nodeName_ == 'lengthOfStayQuantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lengthOfStayQuantity = obj_
            obj_.original_tagname_ = 'lengthOfStayQuantity'
        elif nodeName_ == 'dischargeDispositionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dischargeDispositionCode = obj_
            obj_.original_tagname_ = 'dischargeDispositionCode'
        elif nodeName_ == 'preAdmitTestInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preAdmitTestInd = obj_
            obj_.original_tagname_ = 'preAdmitTestInd'
        elif nodeName_ == 'specialCourtesiesCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specialCourtesiesCode.append(obj_)
            obj_.original_tagname_ = 'specialCourtesiesCode'
        elif nodeName_ == 'specialArrangementCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specialArrangementCode.append(obj_)
            obj_.original_tagname_ = 'specialArrangementCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_Encounter


class POCD_MT000040UV02_EncounterParticipant(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_EncounterParticipant' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'IVL_TS' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_EncounterParticipant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_EncounterParticipant.subclass:
            return POCD_MT000040UV02_EncounterParticipant.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_EncounterParticipant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_EncounterParticipant(self, value):
        # Validate type x_EncounterParticipant, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ATND', 'CON', 'DIS', 'REF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_EncounterParticipant' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_EncounterParticipant_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_EncounterParticipant_patterns_, ))
    validate_x_EncounterParticipant_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EncounterParticipant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.EncounterParticipant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.EncounterParticipant':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.EncounterParticipant')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.EncounterParticipant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.EncounterParticipant'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EncounterParticipant', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_EncounterParticipant(self.typeCode)    # validate type x_EncounterParticipant
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_EncounterParticipant


class POCD_MT000040UV02_Entity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassRoot' = 'ENT', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, desc: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Entity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Entity.subclass:
            return POCD_MT000040UV02_Entity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ENT', 'HCE', 'LIV', 'NLIV', 'ANM', 'MIC', 'PLNT', 'PSN', 'MAT', 'CHEM', 'FOOD', 'MMAT', 'CONT', 'HOLD', 'DEV', 'CER', 'MODDV', 'ORG', 'PUB', 'STATE', 'NAT', 'PLC', 'CITY', 'COUNTRY', 'COUNTY', 'PROVINCE', 'RGRP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassRoot_patterns_, ))
    validate_EntityClassRoot_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Entity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Entity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Entity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Entity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Entity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Entity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Entity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040UV02_Entity


class POCD_MT000040UV02_Entry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipEntry' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, act: 'POCD_MT000040UV02.Act' = None, encounter: 'POCD_MT000040UV02.Encounter' = None, observation: 'POCD_MT000040UV02.Observation' = None, observationMedia: 'POCD_MT000040UV02.ObservationMedia' = None, organizer: 'POCD_MT000040UV02.Organizer' = None, procedure: 'POCD_MT000040UV02.Procedure' = None, regionOfInterest: 'POCD_MT000040UV02.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040UV02.SubstanceAdministration' = None, supply: 'POCD_MT000040UV02.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Entry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Entry.subclass:
            return POCD_MT000040UV02_Entry.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActRelationshipEntry(self, value):
        # Validate type x_ActRelationshipEntry, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'DRIV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipEntry' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipEntry_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipEntry_patterns_, ))
    validate_x_ActRelationshipEntry_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Entry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Entry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Entry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Entry')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Entry'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipEntry(self.typeCode)    # validate type x_ActRelationshipEntry
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040UV02_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040UV02_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040UV02_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040UV02_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040UV02_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040UV02_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040UV02_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040UV02_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040UV02_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040UV02_Entry


class POCD_MT000040UV02_EntryRelationship(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = None, inversionInd: 'bl' = None, contextConductionInd: 'bl' = 'true', negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, sequenceNumber: 'INT' = None, seperatableInd: 'BL' = None, act: 'POCD_MT000040UV02.Act' = None, encounter: 'POCD_MT000040UV02.Encounter' = None, observation: 'POCD_MT000040UV02.Observation' = None, observationMedia: 'POCD_MT000040UV02.ObservationMedia' = None, organizer: 'POCD_MT000040UV02.Organizer' = None, procedure: 'POCD_MT000040UV02.Procedure' = None, regionOfInterest: 'POCD_MT000040UV02.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040UV02.SubstanceAdministration' = None, supply: 'POCD_MT000040UV02.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.inversionInd = _cast(bool, inversionInd)
        self.inversionInd_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_EntryRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_EntryRelationship.subclass:
            return POCD_MT000040UV02_EntryRelationship.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_EntryRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_inversionInd(self):
        return self.inversionInd
    def set_inversionInd(self, inversionInd):
        self.inversionInd = inversionInd
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EntryRelationship', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.EntryRelationship')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.EntryRelationship':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.EntryRelationship')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.EntryRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.EntryRelationship'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.inversionInd is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            outfile.write(' inversionInd="%s"' % self.gds_format_boolean(self.inversionInd, input_name='inversionInd'))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.EntryRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
        value = find_attr_value_('inversionInd', node)
        if value is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            if value in ('true', '1'):
                self.inversionInd = True
            elif value in ('false', '0'):
                self.inversionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inversionInd)    # validate type bl
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040UV02_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040UV02_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040UV02_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040UV02_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040UV02_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040UV02_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040UV02_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040UV02_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040UV02_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040UV02_EntryRelationship


class POCD_MT000040UV02_ExternalAct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ExternalAct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ExternalAct.subclass:
            return POCD_MT000040UV02_ExternalAct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ExternalAct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACT', 'COMPOSITION', 'DOC', 'DOCCLIN', 'CDALVLONE', 'CONTAINER', 'CATEGORY', 'DOCBODY', 'DOCSECT', 'TOPIC', 'EXTRACT', 'EHR', 'FOLDER', 'GROUPER', 'CLUSTER', 'ACCM', 'ACCT', 'ACSN', 'ADJUD', 'CACT', 'ACTN', 'INFO', 'STC', 'CNTRCT', 'FCNTRCT', 'COV', 'CONS', 'CONTREG', 'CTTEVENT', 'DISPACT', 'EXPOS', 'AEXPOS', 'TEXPOS', 'INC', 'INFRM', 'INVE', 'LIST', 'MPROT', 'OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF', 'PCPR', 'ENC', 'POLICY', 'JURISPOL', 'ORGPOL', 'SCOPOL', 'STDPOL', 'PROC', 'SBADM', 'SBEXT', 'SPECCOLLECT', 'REG', 'REV', 'SPCTRT', 'SPLY', 'DIET', 'STORE', 'SUBST', 'TRFR', 'TRNS', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassRoot_patterns_, ))
    validate_ActClassRoot_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalAct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ExternalAct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ExternalAct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ExternalAct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ExternalAct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ExternalAct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalAct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040UV02_ExternalAct


class POCD_MT000040UV02_ExternalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassDocument' = 'DOC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, setId: 'II' = None, versionNumber: 'ST.r2b' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ExternalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ExternalDocument.subclass:
            return POCD_MT000040UV02_ExternalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ExternalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassDocument(self, value):
        # Validate type ActClassDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOC', 'DOCCLIN', 'CDALVLONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassDocument_patterns_, ))
    validate_ActClassDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ExternalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ExternalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ExternalDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ExternalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ExternalDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassDocument(self.classCode)    # validate type ActClassDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            obj_ = ST_r2b.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040UV02_ExternalDocument


class POCD_MT000040UV02_ExternalObservation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ExternalObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ExternalObservation.subclass:
            return POCD_MT000040UV02_ExternalObservation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ExternalObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalObservation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ExternalObservation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ExternalObservation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ExternalObservation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ExternalObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ExternalObservation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040UV02_ExternalObservation


class POCD_MT000040UV02_ExternalProcedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'PROC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ExternalProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ExternalProcedure.subclass:
            return POCD_MT000040UV02_ExternalProcedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ExternalProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalProcedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ExternalProcedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ExternalProcedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ExternalProcedure')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ExternalProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ExternalProcedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PROC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ExternalProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040UV02_ExternalProcedure


class POCD_MT000040UV02_Guardian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'GUARD', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, guardianPerson: 'POCD_MT000040UV02.Person' = None, guardianOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.guardianPerson = guardianPerson
        self.guardianPerson_nsprefix_ = None
        self.guardianOrganization = guardianOrganization
        self.guardianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Guardian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Guardian.subclass:
            return POCD_MT000040UV02_Guardian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Guardian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_guardianPerson(self):
        return self.guardianPerson
    def set_guardianPerson(self, guardianPerson):
        self.guardianPerson = guardianPerson
    def get_guardianOrganization(self):
        return self.guardianOrganization
    def set_guardianOrganization(self, guardianOrganization):
        self.guardianOrganization = guardianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.guardianPerson is not None or
            self.guardianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Guardian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Guardian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Guardian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Guardian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Guardian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Guardian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "GUARD" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Guardian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.guardianPerson is not None:
            namespaceprefix_ = self.guardianPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianPerson_nsprefix_) else ''
            self.guardianPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianPerson', pretty_print=pretty_print)
        if self.guardianOrganization is not None:
            namespaceprefix_ = self.guardianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianOrganization_nsprefix_) else ''
            self.guardianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'guardianPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianPerson = obj_
            obj_.original_tagname_ = 'guardianPerson'
        elif nodeName_ == 'guardianOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianOrganization = obj_
            obj_.original_tagname_ = 'guardianOrganization'
# end class POCD_MT000040UV02_Guardian


class POCD_MT000040UV02_HealthCareFacility(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassServiceDeliveryLocation' = 'SDLOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, location: 'POCD_MT000040UV02.Place' = None, serviceProviderOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        self.serviceProviderOrganization = serviceProviderOrganization
        self.serviceProviderOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_HealthCareFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_HealthCareFacility.subclass:
            return POCD_MT000040UV02_HealthCareFacility.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_HealthCareFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_serviceProviderOrganization(self):
        return self.serviceProviderOrganization
    def set_serviceProviderOrganization(self, serviceProviderOrganization):
        self.serviceProviderOrganization = serviceProviderOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClassServiceDeliveryLocation(self, value):
        # Validate type RoleClassServiceDeliveryLocation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SDLOC', 'DSDLOC', 'ISDLOC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassServiceDeliveryLocation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassServiceDeliveryLocation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassServiceDeliveryLocation_patterns_, ))
    validate_RoleClassServiceDeliveryLocation_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.location is not None or
            self.serviceProviderOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.HealthCareFacility', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.HealthCareFacility')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.HealthCareFacility':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.HealthCareFacility')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.HealthCareFacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.HealthCareFacility'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SDLOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.HealthCareFacility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        if self.serviceProviderOrganization is not None:
            namespaceprefix_ = self.serviceProviderOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceProviderOrganization_nsprefix_) else ''
            self.serviceProviderOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceProviderOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassServiceDeliveryLocation(self.classCode)    # validate type RoleClassServiceDeliveryLocation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040UV02_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'serviceProviderOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceProviderOrganization = obj_
            obj_.original_tagname_ = 'serviceProviderOrganization'
# end class POCD_MT000040UV02_HealthCareFacility


class POCD_MT000040UV02_Informant12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'INF', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, relatedEntity: 'POCD_MT000040UV02.RelatedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
        self.relatedEntity = relatedEntity
        self.relatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Informant12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Informant12.subclass:
            return POCD_MT000040UV02_Informant12.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Informant12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_relatedEntity(self):
        return self.relatedEntity
    def set_relatedEntity(self, relatedEntity):
        self.relatedEntity = relatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None or
            self.relatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Informant12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Informant12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Informant12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Informant12')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Informant12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Informant12'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "INF" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Informant12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
        if self.relatedEntity is not None:
            namespaceprefix_ = self.relatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedEntity_nsprefix_) else ''
            self.relatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
        elif nodeName_ == 'relatedEntity':
            obj_ = POCD_MT000040UV02_RelatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedEntity = obj_
            obj_.original_tagname_ = 'relatedEntity'
# end class POCD_MT000040UV02_Informant12


class POCD_MT000040UV02_InFulfillmentOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'FLFS', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, order: 'POCD_MT000040UV02.Order' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.order = order
        self.order_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_InFulfillmentOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_InFulfillmentOf.subclass:
            return POCD_MT000040UV02_InFulfillmentOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_InFulfillmentOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.order is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.InFulfillmentOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.InFulfillmentOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.InFulfillmentOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.InFulfillmentOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.InFulfillmentOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.InFulfillmentOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "FLFS" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.InFulfillmentOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.order is not None:
            namespaceprefix_ = self.order_nsprefix_ + ':' if (UseCapturedNS_ and self.order_nsprefix_) else ''
            self.order.export(outfile, level, namespaceprefix_, namespacedef_='', name_='order', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'order':
            obj_ = POCD_MT000040UV02_Order.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.order = obj_
            obj_.original_tagname_ = 'order'
# end class POCD_MT000040UV02_InFulfillmentOf


class POCD_MT000040UV02_IntendedRecipient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_InformationRecipientRole' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, informationRecipient: 'POCD_MT000040UV02.Person' = None, receivedOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = None
        self.receivedOrganization = receivedOrganization
        self.receivedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_IntendedRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_IntendedRecipient.subclass:
            return POCD_MT000040UV02_IntendedRecipient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_IntendedRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def get_receivedOrganization(self):
        return self.receivedOrganization
    def set_receivedOrganization(self, receivedOrganization):
        self.receivedOrganization = receivedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_InformationRecipientRole(self, value):
        # Validate type x_InformationRecipientRole, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASSIGNED', 'HLTHCHRT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipientRole' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipientRole_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipientRole_patterns_, ))
    validate_x_InformationRecipientRole_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.informationRecipient is not None or
            self.receivedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.IntendedRecipient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.IntendedRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.IntendedRecipient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.IntendedRecipient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.IntendedRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.IntendedRecipient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.IntendedRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.informationRecipient is not None:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            self.informationRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        if self.receivedOrganization is not None:
            namespaceprefix_ = self.receivedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.receivedOrganization_nsprefix_) else ''
            self.receivedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receivedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_InformationRecipientRole(self.classCode)    # validate type x_InformationRecipientRole
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient = obj_
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'receivedOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receivedOrganization = obj_
            obj_.original_tagname_ = 'receivedOrganization'
# end class POCD_MT000040UV02_IntendedRecipient


class POCD_MT000040UV02_LabeledDrug(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'MMAT', determinerCode: 'EntityDeterminer' = 'KIND', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, name: 'EN' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_LabeledDrug)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_LabeledDrug.subclass:
            return POCD_MT000040UV02_LabeledDrug.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_LabeledDrug(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LabeledDrug', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.LabeledDrug')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.LabeledDrug':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.LabeledDrug')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.LabeledDrug', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.LabeledDrug'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MMAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "KIND" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LabeledDrug', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class POCD_MT000040UV02_LabeledDrug


class POCD_MT000040UV02_LanguageCommunication(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, languageCode: 'CS' = None, modeCode: 'CE' = None, proficiencyLevelCode: 'CE' = None, preferenceInd: 'BL' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.proficiencyLevelCode = proficiencyLevelCode
        self.proficiencyLevelCode_nsprefix_ = None
        self.preferenceInd = preferenceInd
        self.preferenceInd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_LanguageCommunication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_LanguageCommunication.subclass:
            return POCD_MT000040UV02_LanguageCommunication.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_LanguageCommunication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_proficiencyLevelCode(self):
        return self.proficiencyLevelCode
    def set_proficiencyLevelCode(self, proficiencyLevelCode):
        self.proficiencyLevelCode = proficiencyLevelCode
    def get_preferenceInd(self):
        return self.preferenceInd
    def set_preferenceInd(self, preferenceInd):
        self.preferenceInd = preferenceInd
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.languageCode is not None or
            self.modeCode is not None or
            self.proficiencyLevelCode is not None or
            self.preferenceInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LanguageCommunication', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.LanguageCommunication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.LanguageCommunication':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.LanguageCommunication')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.LanguageCommunication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.LanguageCommunication'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LanguageCommunication', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.proficiencyLevelCode is not None:
            namespaceprefix_ = self.proficiencyLevelCode_nsprefix_ + ':' if (UseCapturedNS_ and self.proficiencyLevelCode_nsprefix_) else ''
            self.proficiencyLevelCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proficiencyLevelCode', pretty_print=pretty_print)
        if self.preferenceInd is not None:
            namespaceprefix_ = self.preferenceInd_nsprefix_ + ':' if (UseCapturedNS_ and self.preferenceInd_nsprefix_) else ''
            self.preferenceInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preferenceInd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'proficiencyLevelCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proficiencyLevelCode = obj_
            obj_.original_tagname_ = 'proficiencyLevelCode'
        elif nodeName_ == 'preferenceInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preferenceInd = obj_
            obj_.original_tagname_ = 'preferenceInd'
# end class POCD_MT000040UV02_LanguageCommunication


class POCD_MT000040UV02_LegalAuthenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'LA', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, signatureCode: 'CV' = None, signatureText: 'ED' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.signatureText = signatureText
        self.signatureText_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_LegalAuthenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_LegalAuthenticator.subclass:
            return POCD_MT000040UV02_LegalAuthenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_LegalAuthenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_signatureText(self):
        return self.signatureText
    def set_signatureText(self, signatureText):
        self.signatureText = signatureText
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.signatureText is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LegalAuthenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.LegalAuthenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.LegalAuthenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.LegalAuthenticator')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.LegalAuthenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.LegalAuthenticator'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "LA" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.LegalAuthenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.signatureText is not None:
            namespaceprefix_ = self.signatureText_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureText_nsprefix_) else ''
            self.signatureText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureText', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'signatureText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureText = obj_
            obj_.original_tagname_ = 'signatureText'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_LegalAuthenticator


class POCD_MT000040UV02_Location(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'LOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, healthCareFacility: 'POCD_MT000040UV02.HealthCareFacility' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.healthCareFacility = healthCareFacility
        self.healthCareFacility_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Location.subclass:
            return POCD_MT000040UV02_Location.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_healthCareFacility(self):
        return self.healthCareFacility
    def set_healthCareFacility(self, healthCareFacility):
        self.healthCareFacility = healthCareFacility
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.healthCareFacility is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Location', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Location':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Location')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Location'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "LOC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.healthCareFacility is not None:
            namespaceprefix_ = self.healthCareFacility_nsprefix_ + ':' if (UseCapturedNS_ and self.healthCareFacility_nsprefix_) else ''
            self.healthCareFacility.export(outfile, level, namespaceprefix_, namespacedef_='', name_='healthCareFacility', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'healthCareFacility':
            obj_ = POCD_MT000040UV02_HealthCareFacility.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.healthCareFacility = obj_
            obj_.original_tagname_ = 'healthCareFacility'
# end class POCD_MT000040UV02_Location


class POCD_MT000040UV02_MaintainedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'MNT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, effectiveTime: 'IVL_TS' = None, maintainingPerson: 'POCD_MT000040UV02.Person' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.maintainingPerson = maintainingPerson
        self.maintainingPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_MaintainedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_MaintainedEntity.subclass:
            return POCD_MT000040UV02_MaintainedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_MaintainedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_maintainingPerson(self):
        return self.maintainingPerson
    def set_maintainingPerson(self, maintainingPerson):
        self.maintainingPerson = maintainingPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.effectiveTime is not None or
            self.maintainingPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.MaintainedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.MaintainedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.MaintainedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.MaintainedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.MaintainedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.MaintainedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MNT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.MaintainedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.maintainingPerson is not None:
            namespaceprefix_ = self.maintainingPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.maintainingPerson_nsprefix_) else ''
            self.maintainingPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maintainingPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'maintainingPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maintainingPerson = obj_
            obj_.original_tagname_ = 'maintainingPerson'
# end class POCD_MT000040UV02_MaintainedEntity


class POCD_MT000040UV02_ManufacturedProduct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'MANU', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, manufacturedLabeledDrug: 'POCD_MT000040UV02.LabeledDrug' = None, manufacturedMaterial: 'POCD_MT000040UV02.Material' = None, manufacturerOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
        self.manufacturedLabeledDrug_nsprefix_ = None
        self.manufacturedMaterial = manufacturedMaterial
        self.manufacturedMaterial_nsprefix_ = None
        self.manufacturerOrganization = manufacturerOrganization
        self.manufacturerOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ManufacturedProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ManufacturedProduct.subclass:
            return POCD_MT000040UV02_ManufacturedProduct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ManufacturedProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_manufacturedLabeledDrug(self):
        return self.manufacturedLabeledDrug
    def set_manufacturedLabeledDrug(self, manufacturedLabeledDrug):
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
    def get_manufacturedMaterial(self):
        return self.manufacturedMaterial
    def set_manufacturedMaterial(self, manufacturedMaterial):
        self.manufacturedMaterial = manufacturedMaterial
    def get_manufacturerOrganization(self):
        return self.manufacturerOrganization
    def set_manufacturerOrganization(self, manufacturerOrganization):
        self.manufacturerOrganization = manufacturerOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.manufacturedLabeledDrug is not None or
            self.manufacturedMaterial is not None or
            self.manufacturerOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ManufacturedProduct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ManufacturedProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ManufacturedProduct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ManufacturedProduct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ManufacturedProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ManufacturedProduct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MANU" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ManufacturedProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.manufacturedLabeledDrug is not None:
            namespaceprefix_ = self.manufacturedLabeledDrug_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedLabeledDrug_nsprefix_) else ''
            self.manufacturedLabeledDrug.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedLabeledDrug', pretty_print=pretty_print)
        if self.manufacturedMaterial is not None:
            namespaceprefix_ = self.manufacturedMaterial_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedMaterial_nsprefix_) else ''
            self.manufacturedMaterial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedMaterial', pretty_print=pretty_print)
        if self.manufacturerOrganization is not None:
            namespaceprefix_ = self.manufacturerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerOrganization_nsprefix_) else ''
            self.manufacturerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'manufacturedLabeledDrug':
            obj_ = POCD_MT000040UV02_LabeledDrug.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedLabeledDrug = obj_
            obj_.original_tagname_ = 'manufacturedLabeledDrug'
        elif nodeName_ == 'manufacturedMaterial':
            obj_ = POCD_MT000040UV02_Material.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedMaterial = obj_
            obj_.original_tagname_ = 'manufacturedMaterial'
        elif nodeName_ == 'manufacturerOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerOrganization = obj_
            obj_.original_tagname_ = 'manufacturerOrganization'
# end class POCD_MT000040UV02_ManufacturedProduct


class POCD_MT000040UV02_Material(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'MMAT', determinerCode: 'EntityDeterminer' = 'KIND', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, name: 'EN' = None, desc: 'ED' = None, formCode: 'CE' = None, lotNumberText: 'ST' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
        self.formCode = formCode
        self.formCode_nsprefix_ = None
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Material.subclass:
            return POCD_MT000040UV02_Material.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_formCode(self):
        return self.formCode
    def set_formCode(self, formCode):
        self.formCode = formCode
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None or
            self.desc is not None or
            self.formCode is not None or
            self.lotNumberText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Material':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Material')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Material'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MMAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "KIND" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.formCode is not None:
            namespaceprefix_ = self.formCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formCode_nsprefix_) else ''
            self.formCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formCode', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'formCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formCode = obj_
            obj_.original_tagname_ = 'formCode'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
# end class POCD_MT000040UV02_Material


class POCD_MT000040UV02_NonXMLBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCBODY', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, text: 'ED' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_NonXMLBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_NonXMLBody.subclass:
            return POCD_MT000040UV02_NonXMLBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_NonXMLBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.NonXMLBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.NonXMLBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.NonXMLBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.NonXMLBody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.NonXMLBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.NonXMLBody'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCBODY" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.NonXMLBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
# end class POCD_MT000040UV02_NonXMLBody


class POCD_MT000040UV02_Observation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'x_ActMoodDocumentObservation' = None, actionNegationInd: 'bl' = None, negationInd: 'bl' = None, isCriterionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, derivationExpr: 'ST' = None, title: 'ED' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: 'CE' = None, confidentialityCode: List_['CE'] = None, repeatNumber: 'IVL_INT' = None, uncertaintyCode: 'CE' = None, languageCode: 'CS' = None, value: List_['ANY'] = None, valueNegationInd: 'BL' = None, interpretationCode: List_['CE'] = None, methodCode: List_['CE'] = None, targetSiteCode: List_['CD'] = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, referenceRange: List_['POCD_MT000040UV02.ReferenceRange'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.derivationExpr = derivationExpr
        self.derivationExpr_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        if confidentialityCode is None:
            self.confidentialityCode = []
        else:
            self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.uncertaintyCode = uncertaintyCode
        self.uncertaintyCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.valueNegationInd = valueNegationInd
        self.valueNegationInd_nsprefix_ = None
        if interpretationCode is None:
            self.interpretationCode = []
        else:
            self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if referenceRange is None:
            self.referenceRange = []
        else:
            self.referenceRange = referenceRange
        self.referenceRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Observation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Observation.subclass:
            return POCD_MT000040UV02_Observation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Observation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_derivationExpr(self):
        return self.derivationExpr
    def set_derivationExpr(self, derivationExpr):
        self.derivationExpr = derivationExpr
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def add_confidentialityCode(self, value):
        self.confidentialityCode.append(value)
    def insert_confidentialityCode_at(self, index, value):
        self.confidentialityCode.insert(index, value)
    def replace_confidentialityCode_at(self, index, value):
        self.confidentialityCode[index] = value
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_uncertaintyCode(self):
        return self.uncertaintyCode
    def set_uncertaintyCode(self, uncertaintyCode):
        self.uncertaintyCode = uncertaintyCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def add_value(self, value):
        self.value.append(value)
    def add_value_with_type(self, value):
        self.value.append(value)
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_valueNegationInd(self):
        return self.valueNegationInd
    def set_valueNegationInd(self, valueNegationInd):
        self.valueNegationInd = valueNegationInd
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def add_interpretationCode(self, value):
        self.interpretationCode.append(value)
    def insert_interpretationCode_at(self, index, value):
        self.interpretationCode.insert(index, value)
    def replace_interpretationCode_at(self, index, value):
        self.interpretationCode[index] = value
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_referenceRange(self):
        return self.referenceRange
    def set_referenceRange(self, referenceRange):
        self.referenceRange = referenceRange
    def add_referenceRange(self, value):
        self.referenceRange.append(value)
    def insert_referenceRange_at(self, index, value):
        self.referenceRange.insert(index, value)
    def replace_referenceRange_at(self, index, value):
        self.referenceRange[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActMoodDocumentObservation(self, value):
        # Validate type x_ActMoodDocumentObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'DEF', 'EVN', 'GOL', 'INT', 'PRMS', 'PRP', 'RQO', 'RSK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActMoodDocumentObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActMoodDocumentObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActMoodDocumentObservation_patterns_, ))
    validate_x_ActMoodDocumentObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.derivationExpr is not None or
            self.title is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode is not None or
            self.confidentialityCode or
            self.repeatNumber is not None or
            self.uncertaintyCode is not None or
            self.languageCode is not None or
            self.value or
            self.valueNegationInd is not None or
            self.interpretationCode or
            self.methodCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.referenceRange
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Observation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Observation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Observation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Observation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Observation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Observation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
        if self.isCriterionInd is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Observation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.derivationExpr is not None:
            namespaceprefix_ = self.derivationExpr_nsprefix_ + ':' if (UseCapturedNS_ and self.derivationExpr_nsprefix_) else ''
            self.derivationExpr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='derivationExpr', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        for confidentialityCode_ in self.confidentialityCode:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            confidentialityCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.uncertaintyCode is not None:
            namespaceprefix_ = self.uncertaintyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.uncertaintyCode_nsprefix_) else ''
            self.uncertaintyCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='uncertaintyCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
        if self.valueNegationInd is not None:
            namespaceprefix_ = self.valueNegationInd_nsprefix_ + ':' if (UseCapturedNS_ and self.valueNegationInd_nsprefix_) else ''
            self.valueNegationInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='valueNegationInd', pretty_print=pretty_print)
        for interpretationCode_ in self.interpretationCode:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            interpretationCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for referenceRange_ in self.referenceRange:
            namespaceprefix_ = self.referenceRange_nsprefix_ + ':' if (UseCapturedNS_ and self.referenceRange_nsprefix_) else ''
            referenceRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referenceRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_ActMoodDocumentObservation(self.moodCode)    # validate type x_ActMoodDocumentObservation
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'derivationExpr':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.derivationExpr = obj_
            obj_.original_tagname_ = 'derivationExpr'
        elif nodeName_ == 'title':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode.append(obj_)
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'uncertaintyCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uncertaintyCode = obj_
            obj_.original_tagname_ = 'uncertaintyCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'valueNegationInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.valueNegationInd = obj_
            obj_.original_tagname_ = 'valueNegationInd'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode.append(obj_)
            obj_.original_tagname_ = 'interpretationCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'referenceRange':
            obj_ = POCD_MT000040UV02_ReferenceRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referenceRange.append(obj_)
            obj_.original_tagname_ = 'referenceRange'
# end class POCD_MT000040UV02_Observation


class POCD_MT000040UV02_ObservationMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, languageCode: 'CS' = None, value: 'ED' = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ObservationMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ObservationMedia.subclass:
            return POCD_MT000040UV02_ObservationMedia.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ObservationMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.languageCode is not None or
            self.value is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ObservationMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ObservationMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ObservationMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ObservationMedia')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ObservationMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ObservationMedia'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ObservationMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_ObservationMedia


class POCD_MT000040UV02_ObservationRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN.CRT', isCriterionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, value: 'ANY' = None, valueNegationInd: 'BL' = None, interpretationCode: 'CE' = None, precondition: 'precondition' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.valueNegationInd = valueNegationInd
        self.valueNegationInd_nsprefix_ = None
        self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
        self.precondition = precondition
        self.precondition_nsprefix_ = "lab"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ObservationRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ObservationRange.subclass:
            return POCD_MT000040UV02_ObservationRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ObservationRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_valueNegationInd(self):
        return self.valueNegationInd
    def set_valueNegationInd(self, valueNegationInd):
        self.valueNegationInd = valueNegationInd
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None or
            self.valueNegationInd is not None or
            self.interpretationCode is not None or
            self.precondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:lab="urn:oid:1.3.6.1.4.1.19376.1.3.2" ', name_='POCD_MT000040UV02.ObservationRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ObservationRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ObservationRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ObservationRange')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ObservationRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ObservationRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN.CRT" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if not self.isCriterionInd and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:lab="urn:oid:1.3.6.1.4.1.19376.1.3.2" ', name_='POCD_MT000040UV02.ObservationRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
        if self.valueNegationInd is not None:
            namespaceprefix_ = self.valueNegationInd_nsprefix_ + ':' if (UseCapturedNS_ and self.valueNegationInd_nsprefix_) else ''
            self.valueNegationInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='valueNegationInd', pretty_print=pretty_print)
        if self.interpretationCode is not None:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            self.interpretationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
        if self.precondition is not None:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            self.precondition.export(outfile, level, namespaceprefix_='lab:', namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'valueNegationInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.valueNegationInd = obj_
            obj_.original_tagname_ = 'valueNegationInd'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode = obj_
            obj_.original_tagname_ = 'interpretationCode'
        elif nodeName_ == 'precondition':
            obj_ = precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition = obj_
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_ObservationRange


class POCD_MT000040UV02_Order(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'RQO', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, priorityCode: 'CE' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Order)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Order.subclass:
            return POCD_MT000040UV02_Order.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Order(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACT', 'COMPOSITION', 'DOC', 'DOCCLIN', 'CDALVLONE', 'CONTAINER', 'CATEGORY', 'DOCBODY', 'DOCSECT', 'TOPIC', 'EXTRACT', 'EHR', 'FOLDER', 'GROUPER', 'CLUSTER', 'ACCM', 'ACCT', 'ACSN', 'ADJUD', 'CACT', 'ACTN', 'INFO', 'STC', 'CNTRCT', 'FCNTRCT', 'COV', 'CONS', 'CONTREG', 'CTTEVENT', 'DISPACT', 'EXPOS', 'AEXPOS', 'TEXPOS', 'INC', 'INFRM', 'INVE', 'LIST', 'MPROT', 'OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF', 'PCPR', 'ENC', 'POLICY', 'JURISPOL', 'ORGPOL', 'SCOPOL', 'STDPOL', 'PROC', 'SBADM', 'SBEXT', 'SPECCOLLECT', 'REG', 'REV', 'SPCTRT', 'SPLY', 'DIET', 'STORE', 'SUBST', 'TRFR', 'TRNS', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassRoot_patterns_, ))
    validate_ActClassRoot_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.priorityCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Order', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Order')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Order':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Order')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Order', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Order'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "RQO" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Order', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
# end class POCD_MT000040UV02_Order


class POCD_MT000040UV02_Organization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'ORG', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: List_['ON'] = None, telecom: List_['TEL'] = None, addr: List_['AD'] = None, standardIndustryClassCode: 'CE' = None, asOrganizationPartOf: 'POCD_MT000040UV02.OrganizationPartOf' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        self.standardIndustryClassCode = standardIndustryClassCode
        self.standardIndustryClassCode_nsprefix_ = None
        self.asOrganizationPartOf = asOrganizationPartOf
        self.asOrganizationPartOf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Organization.subclass:
            return POCD_MT000040UV02_Organization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_standardIndustryClassCode(self):
        return self.standardIndustryClassCode
    def set_standardIndustryClassCode(self, standardIndustryClassCode):
        self.standardIndustryClassCode = standardIndustryClassCode
    def get_asOrganizationPartOf(self):
        return self.asOrganizationPartOf
    def set_asOrganizationPartOf(self, asOrganizationPartOf):
        self.asOrganizationPartOf = asOrganizationPartOf
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name or
            self.telecom or
            self.addr or
            self.standardIndustryClassCode is not None or
            self.asOrganizationPartOf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Organization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Organization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Organization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Organization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Organization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Organization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ORG" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Organization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        if self.standardIndustryClassCode is not None:
            namespaceprefix_ = self.standardIndustryClassCode_nsprefix_ + ':' if (UseCapturedNS_ and self.standardIndustryClassCode_nsprefix_) else ''
            self.standardIndustryClassCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardIndustryClassCode', pretty_print=pretty_print)
        if self.asOrganizationPartOf is not None:
            namespaceprefix_ = self.asOrganizationPartOf_nsprefix_ + ':' if (UseCapturedNS_ and self.asOrganizationPartOf_nsprefix_) else ''
            self.asOrganizationPartOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asOrganizationPartOf', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'standardIndustryClassCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardIndustryClassCode = obj_
            obj_.original_tagname_ = 'standardIndustryClassCode'
        elif nodeName_ == 'asOrganizationPartOf':
            obj_ = POCD_MT000040UV02_OrganizationPartOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asOrganizationPartOf = obj_
            obj_.original_tagname_ = 'asOrganizationPartOf'
# end class POCD_MT000040UV02_Organization


class POCD_MT000040UV02_OrganizationPartOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'PART', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, wholeOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.wholeOrganization = wholeOrganization
        self.wholeOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_OrganizationPartOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_OrganizationPartOf.subclass:
            return POCD_MT000040UV02_OrganizationPartOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_OrganizationPartOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_wholeOrganization(self):
        return self.wholeOrganization
    def set_wholeOrganization(self, wholeOrganization):
        self.wholeOrganization = wholeOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.wholeOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.OrganizationPartOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.OrganizationPartOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.OrganizationPartOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.OrganizationPartOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.OrganizationPartOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.OrganizationPartOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PART" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.OrganizationPartOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.wholeOrganization is not None:
            namespaceprefix_ = self.wholeOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.wholeOrganization_nsprefix_) else ''
            self.wholeOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wholeOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'wholeOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wholeOrganization = obj_
            obj_.original_tagname_ = 'wholeOrganization'
# end class POCD_MT000040UV02_OrganizationPartOf


class POCD_MT000040UV02_Organizer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_ActClassDocumentEntryOrganizer' = None, moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: List_['CE'] = None, confidentialityCode: 'CE' = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, component: List_['POCD_MT000040UV02.Component4'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        if priorityCode is None:
            self.priorityCode = []
        else:
            self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Organizer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Organizer.subclass:
            return POCD_MT000040UV02_Organizer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Organizer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def add_priorityCode(self, value):
        self.priorityCode.append(value)
    def insert_priorityCode_at(self, index, value):
        self.priorityCode.insert(index, value)
    def replace_priorityCode_at(self, index, value):
        self.priorityCode[index] = value
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActClassDocumentEntryOrganizer(self, value):
        # Validate type x_ActClassDocumentEntryOrganizer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BATTERY', 'CLUSTER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryOrganizer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryOrganizer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryOrganizer_patterns_, ))
    validate_x_ActClassDocumentEntryOrganizer_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode or
            self.confidentialityCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.reference or
            self.precondition or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Organizer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Organizer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Organizer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Organizer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Organizer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Organizer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Organizer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        for priorityCode_ in self.priorityCode:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            priorityCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryOrganizer(self.classCode)    # validate type x_ActClassDocumentEntryOrganizer
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode.append(obj_)
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040UV02_Component4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040UV02_Organizer


class POCD_MT000040UV02_ParentDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCCLIN', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, setId: 'II' = None, versionNumber: 'ST.r2b' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ParentDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ParentDocument.subclass:
            return POCD_MT000040UV02_ParentDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ParentDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ParentDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ParentDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ParentDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ParentDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ParentDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ParentDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCCLIN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ParentDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            obj_ = ST_r2b.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040UV02_ParentDocument


class POCD_MT000040UV02_Participant(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_InformationRecipient' = 'PRCP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, intendedRecipient: 'POCD_MT000040UV02.IntendedRecipient' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.intendedRecipient = intendedRecipient
        self.intendedRecipient_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Participant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Participant.subclass:
            return POCD_MT000040UV02_Participant.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Participant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_intendedRecipient(self):
        return self.intendedRecipient
    def set_intendedRecipient(self, intendedRecipient):
        self.intendedRecipient = intendedRecipient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_InformationRecipient(self, value):
        # Validate type x_InformationRecipient, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRCP', 'TRC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipient' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipient_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipient_patterns_, ))
    validate_x_InformationRecipient_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.intendedRecipient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Participant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Participant':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Participant')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Participant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Participant'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.intendedRecipient is not None:
            namespaceprefix_ = self.intendedRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.intendedRecipient_nsprefix_) else ''
            self.intendedRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intendedRecipient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_InformationRecipient(self.typeCode)    # validate type x_InformationRecipient
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'intendedRecipient':
            obj_ = POCD_MT000040UV02_IntendedRecipient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intendedRecipient = obj_
            obj_.original_tagname_ = 'intendedRecipient'
# end class POCD_MT000040UV02_Participant


class POCD_MT000040UV02_Participant2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = None, contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CD' = None, time: 'IVL_TS' = None, associatedEntity: 'POCD_MT000040UV02.AssociatedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.associatedEntity = associatedEntity
        self.associatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Participant2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Participant2.subclass:
            return POCD_MT000040UV02_Participant2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Participant2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_associatedEntity(self):
        return self.associatedEntity
    def set_associatedEntity(self, associatedEntity):
        self.associatedEntity = associatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.associatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Participant2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Participant2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Participant2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Participant2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Participant2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.associatedEntity is not None:
            namespaceprefix_ = self.associatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedEntity_nsprefix_) else ''
            self.associatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'associatedEntity':
            obj_ = POCD_MT000040UV02_AssociatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedEntity = obj_
            obj_.original_tagname_ = 'associatedEntity'
# end class POCD_MT000040UV02_Participant2


class POCD_MT000040UV02_Participant3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = None, contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, awarenessCode: 'CE' = None, participantRole: 'POCD_MT000040UV02.ParticipantRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.participantRole = participantRole
        self.participantRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Participant3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Participant3.subclass:
            return POCD_MT000040UV02_Participant3.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Participant3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_participantRole(self):
        return self.participantRole
    def set_participantRole(self, participantRole):
        self.participantRole = participantRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.awarenessCode is not None or
            self.participantRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Participant3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Participant3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Participant3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Participant3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Participant3'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Participant3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.participantRole is not None:
            namespaceprefix_ = self.participantRole_nsprefix_ + ':' if (UseCapturedNS_ and self.participantRole_nsprefix_) else ''
            self.participantRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participantRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'participantRole':
            obj_ = POCD_MT000040UV02_ParticipantRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participantRole = obj_
            obj_.original_tagname_ = 'participantRole'
# end class POCD_MT000040UV02_Participant3


class POCD_MT000040UV02_ParticipantRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassRoot' = 'ROL', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, playingDevice: 'POCD_MT000040UV02.Device' = None, playingEntity: 'POCD_MT000040UV02.PlayingEntity' = None, scopingEntity: 'POCD_MT000040UV02.Entity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.playingDevice = playingDevice
        self.playingDevice_nsprefix_ = None
        self.playingEntity = playingEntity
        self.playingEntity_nsprefix_ = None
        self.scopingEntity = scopingEntity
        self.scopingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ParticipantRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ParticipantRole.subclass:
            return POCD_MT000040UV02_ParticipantRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ParticipantRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_playingDevice(self):
        return self.playingDevice
    def set_playingDevice(self, playingDevice):
        self.playingDevice = playingDevice
    def get_playingEntity(self):
        return self.playingEntity
    def set_playingEntity(self, playingEntity):
        self.playingEntity = playingEntity
    def get_scopingEntity(self):
        return self.scopingEntity
    def set_scopingEntity(self, scopingEntity):
        self.scopingEntity = scopingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClassRoot(self, value):
        # Validate type RoleClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ROL', 'AFFL', 'AGNT', 'ASSIGNED', 'COMPAR', 'SGNOFF', 'CON', 'ECON', 'NOK', 'GUARD', 'CIT', 'COVPTY', 'CLAIM', 'NAMED', 'DEPEN', 'INDIV', 'SUBSCR', 'PROG', 'CRINV', 'CRSPNSR', 'EMP', 'MIL', 'GUAR', 'INVSBJ', 'CASEBJ', 'RESBJ', 'LIC', 'NOT', 'PROV', 'PAT', 'PAYEE', 'PAYOR', 'POLHOLD', 'QUAL', 'SPNSR', 'STD', 'UNDWRT', 'CAREGIVER', 'PRS', 'ACCESS', 'ADJY', 'CONC', 'BOND', 'CONY', 'ADMM', 'BIRTHPL', 'DEATHPLC', 'DST', 'RET', 'EXPR', 'HLD', 'HLTHCHRT', 'IDENT', 'MANU', 'THER', 'MNT', 'OWN', 'RGPR', 'SDLOC', 'DSDLOC', 'ISDLOC', 'TERR', 'USED', 'WRTE', 'EQUIV', 'SAME', 'SUBY', 'GEN', 'GRIC', 'INST', 'SUBS', 'CONT', 'EXPAGTCAR', 'EXPVECTOR', 'FOMITE', 'INGR', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ADJV', 'ADTV', 'BASE', 'IACT', 'COLR', 'FLVR', 'PRSV', 'STBL', 'MECH', 'LOCE', 'STOR', 'MBR', 'PART', 'ACTM', 'SPEC', 'ALQT', 'ISLT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassRoot_patterns_, ))
    validate_RoleClassRoot_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.playingDevice is not None or
            self.playingEntity is not None or
            self.scopingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ParticipantRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ParticipantRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ParticipantRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ParticipantRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ParticipantRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ParticipantRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ROL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ParticipantRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.playingDevice is not None:
            namespaceprefix_ = self.playingDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.playingDevice_nsprefix_) else ''
            self.playingDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingDevice', pretty_print=pretty_print)
        if self.playingEntity is not None:
            namespaceprefix_ = self.playingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.playingEntity_nsprefix_) else ''
            self.playingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingEntity', pretty_print=pretty_print)
        if self.scopingEntity is not None:
            namespaceprefix_ = self.scopingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingEntity_nsprefix_) else ''
            self.scopingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassRoot(self.classCode)    # validate type RoleClassRoot
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'playingDevice':
            obj_ = POCD_MT000040UV02_Device.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingDevice = obj_
            obj_.original_tagname_ = 'playingDevice'
        elif nodeName_ == 'playingEntity':
            obj_ = POCD_MT000040UV02_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingEntity = obj_
            obj_.original_tagname_ = 'playingEntity'
        elif nodeName_ == 'scopingEntity':
            obj_ = POCD_MT000040UV02_Entity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingEntity = obj_
            obj_.original_tagname_ = 'scopingEntity'
# end class POCD_MT000040UV02_ParticipantRole


class POCD_MT000040UV02_Patient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, name: List_['PN'] = None, desc: 'ED' = None, administrativeGenderCode: 'CE' = None, birthTime: 'TS' = None, deceasedInd: 'BL' = None, deceasedTime: 'TS' = None, multipleBirthInd: 'BL' = None, multipleBirthOrderNumber: 'INT' = None, maritalStatusCode: 'CE' = None, religiousAffiliationCode: 'CE' = None, raceCode: List_['CE'] = None, ethnicGroupCode: List_['CE'] = None, guardian: List_['POCD_MT000040UV02.Guardian'] = None, birthplace: 'POCD_MT000040UV02.Birthplace' = None, languageCommunication: List_['POCD_MT000040UV02.LanguageCommunication'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
        self.deceasedInd = deceasedInd
        self.deceasedInd_nsprefix_ = None
        self.deceasedTime = deceasedTime
        self.deceasedTime_nsprefix_ = None
        self.multipleBirthInd = multipleBirthInd
        self.multipleBirthInd_nsprefix_ = None
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
        self.multipleBirthOrderNumber_nsprefix_ = None
        self.maritalStatusCode = maritalStatusCode
        self.maritalStatusCode_nsprefix_ = None
        self.religiousAffiliationCode = religiousAffiliationCode
        self.religiousAffiliationCode_nsprefix_ = None
        if raceCode is None:
            self.raceCode = []
        else:
            self.raceCode = raceCode
        self.raceCode_nsprefix_ = None
        if ethnicGroupCode is None:
            self.ethnicGroupCode = []
        else:
            self.ethnicGroupCode = ethnicGroupCode
        self.ethnicGroupCode_nsprefix_ = None
        if guardian is None:
            self.guardian = []
        else:
            self.guardian = guardian
        self.guardian_nsprefix_ = None
        self.birthplace = birthplace
        self.birthplace_nsprefix_ = None
        if languageCommunication is None:
            self.languageCommunication = []
        else:
            self.languageCommunication = languageCommunication
        self.languageCommunication_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Patient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Patient.subclass:
            return POCD_MT000040UV02_Patient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Patient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_deceasedInd(self):
        return self.deceasedInd
    def set_deceasedInd(self, deceasedInd):
        self.deceasedInd = deceasedInd
    def get_deceasedTime(self):
        return self.deceasedTime
    def set_deceasedTime(self, deceasedTime):
        self.deceasedTime = deceasedTime
    def get_multipleBirthInd(self):
        return self.multipleBirthInd
    def set_multipleBirthInd(self, multipleBirthInd):
        self.multipleBirthInd = multipleBirthInd
    def get_multipleBirthOrderNumber(self):
        return self.multipleBirthOrderNumber
    def set_multipleBirthOrderNumber(self, multipleBirthOrderNumber):
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
    def get_maritalStatusCode(self):
        return self.maritalStatusCode
    def set_maritalStatusCode(self, maritalStatusCode):
        self.maritalStatusCode = maritalStatusCode
    def get_religiousAffiliationCode(self):
        return self.religiousAffiliationCode
    def set_religiousAffiliationCode(self, religiousAffiliationCode):
        self.religiousAffiliationCode = religiousAffiliationCode
    def get_raceCode(self):
        return self.raceCode
    def set_raceCode(self, raceCode):
        self.raceCode = raceCode
    def add_raceCode(self, value):
        self.raceCode.append(value)
    def insert_raceCode_at(self, index, value):
        self.raceCode.insert(index, value)
    def replace_raceCode_at(self, index, value):
        self.raceCode[index] = value
    def get_ethnicGroupCode(self):
        return self.ethnicGroupCode
    def set_ethnicGroupCode(self, ethnicGroupCode):
        self.ethnicGroupCode = ethnicGroupCode
    def add_ethnicGroupCode(self, value):
        self.ethnicGroupCode.append(value)
    def insert_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode.insert(index, value)
    def replace_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode[index] = value
    def get_guardian(self):
        return self.guardian
    def set_guardian(self, guardian):
        self.guardian = guardian
    def add_guardian(self, value):
        self.guardian.append(value)
    def insert_guardian_at(self, index, value):
        self.guardian.insert(index, value)
    def replace_guardian_at(self, index, value):
        self.guardian[index] = value
    def get_birthplace(self):
        return self.birthplace
    def set_birthplace(self, birthplace):
        self.birthplace = birthplace
    def get_languageCommunication(self):
        return self.languageCommunication
    def set_languageCommunication(self, languageCommunication):
        self.languageCommunication = languageCommunication
    def add_languageCommunication(self, value):
        self.languageCommunication.append(value)
    def insert_languageCommunication_at(self, index, value):
        self.languageCommunication.insert(index, value)
    def replace_languageCommunication_at(self, index, value):
        self.languageCommunication[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name or
            self.desc is not None or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.deceasedInd is not None or
            self.deceasedTime is not None or
            self.multipleBirthInd is not None or
            self.multipleBirthOrderNumber is not None or
            self.maritalStatusCode is not None or
            self.religiousAffiliationCode is not None or
            self.raceCode or
            self.ethnicGroupCode or
            self.guardian or
            self.birthplace is not None or
            self.languageCommunication
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Patient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Patient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Patient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Patient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Patient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Patient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Patient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.deceasedInd is not None:
            namespaceprefix_ = self.deceasedInd_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedInd_nsprefix_) else ''
            self.deceasedInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deceasedInd', pretty_print=pretty_print)
        if self.deceasedTime is not None:
            namespaceprefix_ = self.deceasedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedTime_nsprefix_) else ''
            self.deceasedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deceasedTime', pretty_print=pretty_print)
        if self.multipleBirthInd is not None:
            namespaceprefix_ = self.multipleBirthInd_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthInd_nsprefix_) else ''
            self.multipleBirthInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multipleBirthInd', pretty_print=pretty_print)
        if self.multipleBirthOrderNumber is not None:
            namespaceprefix_ = self.multipleBirthOrderNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthOrderNumber_nsprefix_) else ''
            self.multipleBirthOrderNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multipleBirthOrderNumber', pretty_print=pretty_print)
        if self.maritalStatusCode is not None:
            namespaceprefix_ = self.maritalStatusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.maritalStatusCode_nsprefix_) else ''
            self.maritalStatusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maritalStatusCode', pretty_print=pretty_print)
        if self.religiousAffiliationCode is not None:
            namespaceprefix_ = self.religiousAffiliationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.religiousAffiliationCode_nsprefix_) else ''
            self.religiousAffiliationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='religiousAffiliationCode', pretty_print=pretty_print)
        for raceCode_ in self.raceCode:
            namespaceprefix_ = self.raceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.raceCode_nsprefix_) else ''
            raceCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='raceCode', pretty_print=pretty_print)
        for ethnicGroupCode_ in self.ethnicGroupCode:
            namespaceprefix_ = self.ethnicGroupCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ethnicGroupCode_nsprefix_) else ''
            ethnicGroupCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ethnicGroupCode', pretty_print=pretty_print)
        for guardian_ in self.guardian:
            namespaceprefix_ = self.guardian_nsprefix_ + ':' if (UseCapturedNS_ and self.guardian_nsprefix_) else ''
            guardian_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardian', pretty_print=pretty_print)
        if self.birthplace is not None:
            namespaceprefix_ = self.birthplace_nsprefix_ + ':' if (UseCapturedNS_ and self.birthplace_nsprefix_) else ''
            self.birthplace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthplace', pretty_print=pretty_print)
        for languageCommunication_ in self.languageCommunication:
            namespaceprefix_ = self.languageCommunication_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCommunication_nsprefix_) else ''
            languageCommunication_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCommunication', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'deceasedInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedInd = obj_
            obj_.original_tagname_ = 'deceasedInd'
        elif nodeName_ == 'deceasedTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedTime = obj_
            obj_.original_tagname_ = 'deceasedTime'
        elif nodeName_ == 'multipleBirthInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthInd = obj_
            obj_.original_tagname_ = 'multipleBirthInd'
        elif nodeName_ == 'multipleBirthOrderNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthOrderNumber = obj_
            obj_.original_tagname_ = 'multipleBirthOrderNumber'
        elif nodeName_ == 'maritalStatusCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maritalStatusCode = obj_
            obj_.original_tagname_ = 'maritalStatusCode'
        elif nodeName_ == 'religiousAffiliationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.religiousAffiliationCode = obj_
            obj_.original_tagname_ = 'religiousAffiliationCode'
        elif nodeName_ == 'raceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.raceCode.append(obj_)
            obj_.original_tagname_ = 'raceCode'
        elif nodeName_ == 'ethnicGroupCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ethnicGroupCode.append(obj_)
            obj_.original_tagname_ = 'ethnicGroupCode'
        elif nodeName_ == 'guardian':
            obj_ = POCD_MT000040UV02_Guardian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardian.append(obj_)
            obj_.original_tagname_ = 'guardian'
        elif nodeName_ == 'birthplace':
            obj_ = POCD_MT000040UV02_Birthplace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthplace = obj_
            obj_.original_tagname_ = 'birthplace'
        elif nodeName_ == 'languageCommunication':
            obj_ = POCD_MT000040UV02_LanguageCommunication.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCommunication.append(obj_)
            obj_.original_tagname_ = 'languageCommunication'
# end class POCD_MT000040UV02_Patient


class POCD_MT000040UV02_PatientRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'PAT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, patient: 'POCD_MT000040UV02.Patient' = None, providerOrganization: 'POCD_MT000040UV02.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.patient = patient
        self.patient_nsprefix_ = None
        self.providerOrganization = providerOrganization
        self.providerOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_PatientRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_PatientRole.subclass:
            return POCD_MT000040UV02_PatientRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_PatientRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_patient(self):
        return self.patient
    def set_patient(self, patient):
        self.patient = patient
    def get_providerOrganization(self):
        return self.providerOrganization
    def set_providerOrganization(self, providerOrganization):
        self.providerOrganization = providerOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.patient is not None or
            self.providerOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.PatientRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.PatientRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.PatientRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.PatientRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.PatientRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.PatientRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.PatientRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.patient is not None:
            namespaceprefix_ = self.patient_nsprefix_ + ':' if (UseCapturedNS_ and self.patient_nsprefix_) else ''
            self.patient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patient', pretty_print=pretty_print)
        if self.providerOrganization is not None:
            namespaceprefix_ = self.providerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.providerOrganization_nsprefix_) else ''
            self.providerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='providerOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'patient':
            obj_ = POCD_MT000040UV02_Patient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patient = obj_
            obj_.original_tagname_ = 'patient'
        elif nodeName_ == 'providerOrganization':
            obj_ = POCD_MT000040UV02_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.providerOrganization = obj_
            obj_.original_tagname_ = 'providerOrganization'
# end class POCD_MT000040UV02_PatientRole


class POCD_MT000040UV02_Performer1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ServiceEventPerformer' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Performer1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Performer1.subclass:
            return POCD_MT000040UV02_Performer1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Performer1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ServiceEventPerformer(self, value):
        # Validate type x_ServiceEventPerformer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRF', 'SPRF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ServiceEventPerformer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ServiceEventPerformer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ServiceEventPerformer_patterns_, ))
    validate_x_ServiceEventPerformer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Performer1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Performer1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Performer1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Performer1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Performer1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Performer1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Performer1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ServiceEventPerformer(self.typeCode)    # validate type x_ServiceEventPerformer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_Performer1


class POCD_MT000040UV02_Performer2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'PRF', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, modeCode: 'CE' = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Performer2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Performer2.subclass:
            return POCD_MT000040UV02_Performer2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Performer2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.modeCode is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Performer2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Performer2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Performer2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Performer2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Performer2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Performer2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRF" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Performer2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_Performer2


class POCD_MT000040UV02_Person(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, name: List_['PN'] = None, desc: 'ED' = None, birthTime: 'TS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Person.subclass:
            return POCD_MT000040UV02_Person.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name or
            self.desc is not None or
            self.birthTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Person', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Person':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Person')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Person'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
# end class POCD_MT000040UV02_Person


class POCD_MT000040UV02_Place(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PLC', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, name: 'EN' = None, addr: 'AD' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Place.subclass:
            return POCD_MT000040UV02_Place.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name is not None or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Place', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Place')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Place':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Place')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Place'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PLC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040UV02_Place


class POCD_MT000040UV02_PlayingEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassRoot' = 'ENT', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, quantity: List_['PQ'] = None, name: List_['PN'] = None, desc: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.quantity_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_PlayingEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_PlayingEntity.subclass:
            return POCD_MT000040UV02_PlayingEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_PlayingEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def add_quantity(self, value):
        self.quantity.append(value)
    def insert_quantity_at(self, index, value):
        self.quantity.insert(index, value)
    def replace_quantity_at(self, index, value):
        self.quantity[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ENT', 'HCE', 'LIV', 'NLIV', 'ANM', 'MIC', 'PLNT', 'PSN', 'MAT', 'CHEM', 'FOOD', 'MMAT', 'CONT', 'HOLD', 'DEV', 'CER', 'MODDV', 'ORG', 'PUB', 'STATE', 'NAT', 'PLC', 'CITY', 'COUNTRY', 'COUNTY', 'PROVINCE', 'RGRP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassRoot_patterns_, ))
    validate_EntityClassRoot_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.quantity or
            self.name or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.PlayingEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.PlayingEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.PlayingEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.PlayingEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.PlayingEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.PlayingEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.PlayingEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for quantity_ in self.quantity:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            quantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity.append(obj_)
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040UV02_PlayingEntity


class POCD_MT000040UV02_Precondition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'PRCN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, criterion: 'POCD_MT000040UV02.Criterion' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.criterion = criterion
        self.criterion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Precondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Precondition.subclass:
            return POCD_MT000040UV02_Precondition.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Precondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.criterion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Precondition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Precondition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Precondition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Precondition')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Precondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Precondition'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCN" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Precondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.criterion is not None:
            namespaceprefix_ = self.criterion_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion_nsprefix_) else ''
            self.criterion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'criterion':
            obj_ = POCD_MT000040UV02_Criterion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion = obj_
            obj_.original_tagname_ = 'criterion'
# end class POCD_MT000040UV02_Precondition


class POCD_MT000040UV02_Procedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassProcedure' = 'PROC', moodCode: 'x_DocumentProcedureMood' = None, actionNegationInd: 'bl' = None, negationInd: 'bl' = None, isCriterionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: 'CE' = None, confidentialityCode: 'CE' = None, uncertaintyCode: 'CE' = None, languageCode: 'CS' = None, methodCode: List_['CE'] = None, approachSiteCode: List_['CD'] = None, targetSiteCode: List_['CD'] = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.uncertaintyCode = uncertaintyCode
        self.uncertaintyCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Procedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Procedure.subclass:
            return POCD_MT000040UV02_Procedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Procedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_uncertaintyCode(self):
        return self.uncertaintyCode
    def set_uncertaintyCode(self, uncertaintyCode):
        self.uncertaintyCode = uncertaintyCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassProcedure(self, value):
        # Validate type ActClassProcedure, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROC', 'SBADM', 'SBEXT', 'SPECCOLLECT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassProcedure' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassProcedure_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassProcedure_patterns_, ))
    validate_ActClassProcedure_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentProcedureMood(self, value):
        # Validate type x_DocumentProcedureMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'DEF', 'EVN', 'INT', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentProcedureMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentProcedureMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentProcedureMood_patterns_, ))
    validate_x_DocumentProcedureMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode is not None or
            self.confidentialityCode is not None or
            self.uncertaintyCode is not None or
            self.languageCode is not None or
            self.methodCode or
            self.approachSiteCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Procedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Procedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Procedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Procedure')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Procedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Procedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PROC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
        if self.isCriterionInd is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Procedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.uncertaintyCode is not None:
            namespaceprefix_ = self.uncertaintyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.uncertaintyCode_nsprefix_) else ''
            self.uncertaintyCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='uncertaintyCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassProcedure(self.classCode)    # validate type ActClassProcedure
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentProcedureMood(self.moodCode)    # validate type x_DocumentProcedureMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'uncertaintyCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uncertaintyCode = obj_
            obj_.original_tagname_ = 'uncertaintyCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_Procedure


class POCD_MT000040UV02_Product(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'PRD', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, manufacturedProduct: 'POCD_MT000040UV02.ManufacturedProduct' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Product.subclass:
            return POCD_MT000040UV02_Product.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Product', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Product')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Product':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Product')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Product'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRD" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040UV02_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040UV02_Product


class POCD_MT000040UV02_RecordTarget(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'RCT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, patientRole: 'POCD_MT000040UV02.PatientRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.patientRole = patientRole
        self.patientRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RecordTarget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RecordTarget.subclass:
            return POCD_MT000040UV02_RecordTarget.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RecordTarget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_patientRole(self):
        return self.patientRole
    def set_patientRole(self, patientRole):
        self.patientRole = patientRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.patientRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RecordTarget', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RecordTarget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RecordTarget':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RecordTarget')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RecordTarget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RecordTarget'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "RCT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RecordTarget', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.patientRole is not None:
            namespaceprefix_ = self.patientRole_nsprefix_ + ':' if (UseCapturedNS_ and self.patientRole_nsprefix_) else ''
            self.patientRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'patientRole':
            obj_ = POCD_MT000040UV02_PatientRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientRole = obj_
            obj_.original_tagname_ = 'patientRole'
# end class POCD_MT000040UV02_RecordTarget


class POCD_MT000040UV02_Reference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipExternalReference' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, seperatableInd: 'BL' = None, externalAct: 'POCD_MT000040UV02.ExternalAct' = None, externalObservation: 'POCD_MT000040UV02.ExternalObservation' = None, externalProcedure: 'POCD_MT000040UV02.ExternalProcedure' = None, externalDocument: 'POCD_MT000040UV02.ExternalDocument' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.externalAct = externalAct
        self.externalAct_nsprefix_ = None
        self.externalObservation = externalObservation
        self.externalObservation_nsprefix_ = None
        self.externalProcedure = externalProcedure
        self.externalProcedure_nsprefix_ = None
        self.externalDocument = externalDocument
        self.externalDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Reference.subclass:
            return POCD_MT000040UV02_Reference.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_externalAct(self):
        return self.externalAct
    def set_externalAct(self, externalAct):
        self.externalAct = externalAct
    def get_externalObservation(self):
        return self.externalObservation
    def set_externalObservation(self, externalObservation):
        self.externalObservation = externalObservation
    def get_externalProcedure(self):
        return self.externalProcedure
    def set_externalProcedure(self, externalProcedure):
        self.externalProcedure = externalProcedure
    def get_externalDocument(self):
        return self.externalDocument
    def set_externalDocument(self, externalDocument):
        self.externalDocument = externalDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActRelationshipExternalReference(self, value):
        # Validate type x_ActRelationshipExternalReference, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ELNK', 'REFR', 'RPLC', 'SPRT', 'SUBJ', 'XCRPT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipExternalReference' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipExternalReference_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipExternalReference_patterns_, ))
    validate_x_ActRelationshipExternalReference_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.seperatableInd is not None or
            self.externalAct is not None or
            self.externalObservation is not None or
            self.externalProcedure is not None or
            self.externalDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Reference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Reference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Reference'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.externalAct is not None:
            namespaceprefix_ = self.externalAct_nsprefix_ + ':' if (UseCapturedNS_ and self.externalAct_nsprefix_) else ''
            self.externalAct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalAct', pretty_print=pretty_print)
        if self.externalObservation is not None:
            namespaceprefix_ = self.externalObservation_nsprefix_ + ':' if (UseCapturedNS_ and self.externalObservation_nsprefix_) else ''
            self.externalObservation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalObservation', pretty_print=pretty_print)
        if self.externalProcedure is not None:
            namespaceprefix_ = self.externalProcedure_nsprefix_ + ':' if (UseCapturedNS_ and self.externalProcedure_nsprefix_) else ''
            self.externalProcedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalProcedure', pretty_print=pretty_print)
        if self.externalDocument is not None:
            namespaceprefix_ = self.externalDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.externalDocument_nsprefix_) else ''
            self.externalDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipExternalReference(self.typeCode)    # validate type x_ActRelationshipExternalReference
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'externalAct':
            obj_ = POCD_MT000040UV02_ExternalAct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalAct = obj_
            obj_.original_tagname_ = 'externalAct'
        elif nodeName_ == 'externalObservation':
            obj_ = POCD_MT000040UV02_ExternalObservation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalObservation = obj_
            obj_.original_tagname_ = 'externalObservation'
        elif nodeName_ == 'externalProcedure':
            obj_ = POCD_MT000040UV02_ExternalProcedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalProcedure = obj_
            obj_.original_tagname_ = 'externalProcedure'
        elif nodeName_ == 'externalDocument':
            obj_ = POCD_MT000040UV02_ExternalDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalDocument = obj_
            obj_.original_tagname_ = 'externalDocument'
# end class POCD_MT000040UV02_Reference


class POCD_MT000040UV02_ReferenceRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'REFV', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, observationRange: 'POCD_MT000040UV02.ObservationRange' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.observationRange = observationRange
        self.observationRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ReferenceRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ReferenceRange.subclass:
            return POCD_MT000040UV02_ReferenceRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ReferenceRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_observationRange(self):
        return self.observationRange
    def set_observationRange(self, observationRange):
        self.observationRange = observationRange
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.observationRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ReferenceRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ReferenceRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ReferenceRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ReferenceRange')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ReferenceRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ReferenceRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "REFV" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ReferenceRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.observationRange is not None:
            namespaceprefix_ = self.observationRange_nsprefix_ + ':' if (UseCapturedNS_ and self.observationRange_nsprefix_) else ''
            self.observationRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'observationRange':
            obj_ = POCD_MT000040UV02_ObservationRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationRange = obj_
            obj_.original_tagname_ = 'observationRange'
# end class POCD_MT000040UV02_ReferenceRange


class POCD_MT000040UV02_RegionOfInterest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'ROIOVL', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, value: List_['POCD_MT000040UV02.RegionOfInterest.value'] = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RegionOfInterest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RegionOfInterest.subclass:
            return POCD_MT000040UV02_RegionOfInterest.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RegionOfInterest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.value or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RegionOfInterest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RegionOfInterest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RegionOfInterest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RegionOfInterest')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RegionOfInterest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RegionOfInterest'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ROIOVL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RegionOfInterest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'value':
            obj_ = POCD_MT000040UV02_RegionOfInterest_value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_RegionOfInterest


class POCD_MT000040UV02_RelatedDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipDocument' = None, inversionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, parentDocument: 'POCD_MT000040UV02.ParentDocument' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.inversionInd = _cast(bool, inversionInd)
        self.inversionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.parentDocument = parentDocument
        self.parentDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RelatedDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RelatedDocument.subclass:
            return POCD_MT000040UV02_RelatedDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RelatedDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_parentDocument(self):
        return self.parentDocument
    def set_parentDocument(self, parentDocument):
        self.parentDocument = parentDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_inversionInd(self):
        return self.inversionInd
    def set_inversionInd(self, inversionInd):
        self.inversionInd = inversionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActRelationshipDocument(self, value):
        # Validate type x_ActRelationshipDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'RPLC', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipDocument_patterns_, ))
    validate_x_ActRelationshipDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.parentDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RelatedDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RelatedDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RelatedDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RelatedDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RelatedDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.inversionInd is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            outfile.write(' inversionInd="%s"' % self.gds_format_boolean(self.inversionInd, input_name='inversionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.parentDocument is not None:
            namespaceprefix_ = self.parentDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.parentDocument_nsprefix_) else ''
            self.parentDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parentDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipDocument(self.typeCode)    # validate type x_ActRelationshipDocument
        value = find_attr_value_('inversionInd', node)
        if value is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            if value in ('true', '1'):
                self.inversionInd = True
            elif value in ('false', '0'):
                self.inversionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inversionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'parentDocument':
            obj_ = POCD_MT000040UV02_ParentDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parentDocument = obj_
            obj_.original_tagname_ = 'parentDocument'
# end class POCD_MT000040UV02_RelatedDocument


class POCD_MT000040UV02_RelatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassMutualRelationship' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, effectiveTime: 'IVL_TS' = None, relatedPerson: 'POCD_MT000040UV02.Person' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.relatedPerson = relatedPerson
        self.relatedPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RelatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RelatedEntity.subclass:
            return POCD_MT000040UV02_RelatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RelatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_relatedPerson(self):
        return self.relatedPerson
    def set_relatedPerson(self, relatedPerson):
        self.relatedPerson = relatedPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClassMutualRelationship(self, value):
        # Validate type RoleClassMutualRelationship, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AFFL', 'AGNT', 'ASSIGNED', 'COMPAR', 'SGNOFF', 'CON', 'ECON', 'NOK', 'GUARD', 'CIT', 'COVPTY', 'CLAIM', 'NAMED', 'DEPEN', 'INDIV', 'SUBSCR', 'PROG', 'CRINV', 'CRSPNSR', 'EMP', 'MIL', 'GUAR', 'INVSBJ', 'CASEBJ', 'RESBJ', 'LIC', 'NOT', 'PROV', 'PAT', 'PAYEE', 'PAYOR', 'POLHOLD', 'QUAL', 'SPNSR', 'STD', 'UNDWRT', 'CAREGIVER', 'PRS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassMutualRelationship' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassMutualRelationship_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassMutualRelationship_patterns_, ))
    validate_RoleClassMutualRelationship_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.addr or
            self.telecom or
            self.effectiveTime is not None or
            self.relatedPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RelatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RelatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RelatedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RelatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RelatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.relatedPerson is not None:
            namespaceprefix_ = self.relatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedPerson_nsprefix_) else ''
            self.relatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassMutualRelationship(self.classCode)    # validate type RoleClassMutualRelationship
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'relatedPerson':
            obj_ = POCD_MT000040UV02_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedPerson = obj_
            obj_.original_tagname_ = 'relatedPerson'
# end class POCD_MT000040UV02_RelatedEntity


class POCD_MT000040UV02_RelatedSubject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_DocumentSubject' = 'PRS', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, subject: 'POCD_MT000040UV02.SubjectPerson' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RelatedSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RelatedSubject.subclass:
            return POCD_MT000040UV02_RelatedSubject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RelatedSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentSubject(self, value):
        # Validate type x_DocumentSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PAT', 'PRS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubject_patterns_, ))
    validate_x_DocumentSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.addr or
            self.telecom or
            self.subject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedSubject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RelatedSubject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RelatedSubject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RelatedSubject')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RelatedSubject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RelatedSubject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PRS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.RelatedSubject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_DocumentSubject(self.classCode)    # validate type x_DocumentSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_SubjectPerson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
# end class POCD_MT000040UV02_RelatedSubject


class POCD_MT000040UV02_ResponsibleParty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'RESP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedEntity: 'POCD_MT000040UV02.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ResponsibleParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ResponsibleParty.subclass:
            return POCD_MT000040UV02_ResponsibleParty.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ResponsibleParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ResponsibleParty', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ResponsibleParty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ResponsibleParty':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ResponsibleParty')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ResponsibleParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ResponsibleParty'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "RESP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ResponsibleParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040UV02_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040UV02_ResponsibleParty


class POCD_MT000040UV02_Section(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCSECT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, code: 'CE' = None, title: 'ST' = None, text: 'StrucDoc.Text' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, subject: 'POCD_MT000040UV02.Subject' = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, entry: List_['POCD_MT000040UV02.Entry'] = None, component: List_['POCD_MT000040UV02.Component5'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        self.entry_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Section)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Section.subclass:
            return POCD_MT000040UV02_Section.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Section(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_entry(self):
        return self.entry
    def set_entry(self, entry):
        self.entry = entry
    def add_entry(self, value):
        self.entry.append(value)
    def insert_entry_at(self, index, value):
        self.entry.insert(index, value)
    def replace_entry_at(self, index, value):
        self.entry[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.subject is not None or
            self.author or
            self.informant or
            self.entry or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Section', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Section')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Section':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Section')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Section', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Section'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCSECT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Section', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for entry_ in self.entry:
            namespaceprefix_ = self.entry_nsprefix_ + ':' if (UseCapturedNS_ and self.entry_nsprefix_) else ''
            entry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entry', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'text':
            obj_ = StrucDoc_Text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'entry':
            obj_ = POCD_MT000040UV02_Entry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entry.append(obj_)
            obj_.original_tagname_ = 'entry'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040UV02_Component5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040UV02_Section


class POCD_MT000040UV02_ServiceEvent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, performer: List_['POCD_MT000040UV02.Performer1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_ServiceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_ServiceEvent.subclass:
            return POCD_MT000040UV02_ServiceEvent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_ServiceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACT', 'COMPOSITION', 'DOC', 'DOCCLIN', 'CDALVLONE', 'CONTAINER', 'CATEGORY', 'DOCBODY', 'DOCSECT', 'TOPIC', 'EXTRACT', 'EHR', 'FOLDER', 'GROUPER', 'CLUSTER', 'ACCM', 'ACCT', 'ACSN', 'ADJUD', 'CACT', 'ACTN', 'INFO', 'STC', 'CNTRCT', 'FCNTRCT', 'COV', 'CONS', 'CONTREG', 'CTTEVENT', 'DISPACT', 'EXPOS', 'AEXPOS', 'TEXPOS', 'INC', 'INFRM', 'INVE', 'LIST', 'MPROT', 'OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF', 'PCPR', 'ENC', 'POLICY', 'JURISPOL', 'ORGPOL', 'SCOPOL', 'STDPOL', 'PROC', 'SBADM', 'SBEXT', 'SPECCOLLECT', 'REG', 'REV', 'SPCTRT', 'SPLY', 'DIET', 'STORE', 'SUBST', 'TRFR', 'TRNS', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassRoot' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassRoot_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassRoot_patterns_, ))
    validate_ActClassRoot_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.performer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ServiceEvent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.ServiceEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.ServiceEvent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.ServiceEvent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.ServiceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.ServiceEvent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.ServiceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
# end class POCD_MT000040UV02_ServiceEvent


class POCD_MT000040UV02_Specimen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'SPC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, specimenRole: 'POCD_MT000040UV02.SpecimenRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.specimenRole = specimenRole
        self.specimenRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Specimen)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Specimen.subclass:
            return POCD_MT000040UV02_Specimen.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Specimen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_specimenRole(self):
        return self.specimenRole
    def set_specimenRole(self, specimenRole):
        self.specimenRole = specimenRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.specimenRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Specimen', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Specimen')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Specimen':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Specimen')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Specimen', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Specimen'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "SPC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Specimen', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.specimenRole is not None:
            namespaceprefix_ = self.specimenRole_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenRole_nsprefix_) else ''
            self.specimenRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'specimenRole':
            obj_ = POCD_MT000040UV02_SpecimenRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenRole = obj_
            obj_.original_tagname_ = 'specimenRole'
# end class POCD_MT000040UV02_Specimen


class POCD_MT000040UV02_SpecimenRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'SPEC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, specimenPlayingEntity: 'POCD_MT000040UV02.PlayingEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.specimenPlayingEntity = specimenPlayingEntity
        self.specimenPlayingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_SpecimenRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_SpecimenRole.subclass:
            return POCD_MT000040UV02_SpecimenRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_SpecimenRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_specimenPlayingEntity(self):
        return self.specimenPlayingEntity
    def set_specimenPlayingEntity(self, specimenPlayingEntity):
        self.specimenPlayingEntity = specimenPlayingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCESS', 'ACTI', 'ACTIB', 'ACTIM', 'ACTIR', 'ACTM', 'ADJV', 'ADJY', 'ADMM', 'ADTV', 'AFFL', 'AGNT', 'ALQT', 'ASSIGNED', 'BASE', 'BIRTHPL', 'BOND', 'CAREGIVER', 'CASEBJ', 'CHILD', 'CIT', 'CLAIM', 'COLR', 'COMPAR', 'CON', 'CONC', 'CONT', 'CONY', 'COVPTY', 'CRED', 'CRINV', 'CRSPNSR', 'DEATHPLC', 'DEPEN', 'DSDLOC', 'DST', 'ECON', 'EMP', 'EQUIV', 'EXPAGTCAR', 'EXPR', 'EXPVECTOR', 'FLVR', 'FOMITE', 'GEN', 'GRIC', 'GUAR', 'GUARD', 'HLD', 'HLTHCHRT', 'IACT', 'IDENT', 'INDIV', 'INGR', 'INST', 'INVSBJ', 'ISDLOC', 'ISLT', 'LIC', 'LOCE', 'MANU', 'MBR', 'MECH', 'MIL', 'MNT', 'NAMED', 'NOK', 'NOT', 'NURPRAC', 'NURS', 'OWN', 'PA', 'PART', 'PAT', 'PAYEE', 'PAYOR', 'PHYS', 'POLHOLD', 'PROG', 'PROV', 'PRS', 'PRSV', 'QUAL', 'RESBJ', 'RET', 'RGPR', 'ROL', 'SAME', 'SDLOC', 'SGNOFF', 'SPEC', 'SPNSR', 'STBL', 'STD', 'STOR', 'SUBS', 'SUBSCR', 'SUBY', 'TERR', 'THER', 'UNDWRT', 'USED', 'WRTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClass_patterns_, ))
    validate_RoleClass_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.specimenPlayingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SpecimenRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.SpecimenRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.SpecimenRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.SpecimenRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.SpecimenRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.SpecimenRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SPEC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SpecimenRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.specimenPlayingEntity is not None:
            namespaceprefix_ = self.specimenPlayingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenPlayingEntity_nsprefix_) else ''
            self.specimenPlayingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenPlayingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'specimenPlayingEntity':
            obj_ = POCD_MT000040UV02_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenPlayingEntity = obj_
            obj_.original_tagname_ = 'specimenPlayingEntity'
# end class POCD_MT000040UV02_SpecimenRole


class POCD_MT000040UV02_StructuredBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCBODY', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, component: List_['POCD_MT000040UV02.Component3'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_StructuredBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_StructuredBody.subclass:
            return POCD_MT000040UV02_StructuredBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_StructuredBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.StructuredBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.StructuredBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.StructuredBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.StructuredBody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.StructuredBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.StructuredBody'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCBODY" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.StructuredBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040UV02_Component3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040UV02_StructuredBody


class POCD_MT000040UV02_Subject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'SBJ', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, awarenessCode: 'CE' = None, relatedSubject: 'POCD_MT000040UV02.RelatedSubject' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.relatedSubject = relatedSubject
        self.relatedSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Subject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Subject.subclass:
            return POCD_MT000040UV02_Subject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_relatedSubject(self):
        return self.relatedSubject
    def set_relatedSubject(self, relatedSubject):
        self.relatedSubject = relatedSubject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ALY', 'ATND', 'AUT', 'AUTHEN', 'BBY', 'BEN', 'CAGNT', 'CALLBCK', 'CAT', 'CON', 'COV', 'CSM', 'CST', 'DEV', 'DIR', 'DIS', 'DIST', 'DON', 'DST', 'ELOC', 'ENT', 'ESC', 'EXPAGNT', 'EXPART', 'EXPTRGT', 'EXSRC', 'GUAR', 'HLD', 'IND', 'INF', 'IRCP', 'LA', 'LOC', 'NOT', 'NRD', 'ORG', 'PART', 'PPRF', 'PRCP', 'PRD', 'PRF', 'RCT', 'RCV', 'RDV', 'REF', 'REFB', 'REFT', 'RESP', 'RML', 'SBJ', 'SPC', 'SPRF', 'TRANS', 'TRC', 'VIA', 'VRF', 'WIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationType_patterns_, ))
    validate_ParticipationType_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AN', 'AP', 'ON', 'OP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ContextControl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ContextControl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ContextControl_patterns_, ))
    validate_ContextControl_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.awarenessCode is not None or
            self.relatedSubject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Subject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Subject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Subject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Subject')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Subject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Subject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "SBJ" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Subject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.relatedSubject is not None:
            namespaceprefix_ = self.relatedSubject_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedSubject_nsprefix_) else ''
            self.relatedSubject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedSubject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.contextControlCode = ' '.join(self.contextControlCode.split())
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'relatedSubject':
            obj_ = POCD_MT000040UV02_RelatedSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedSubject = obj_
            obj_.original_tagname_ = 'relatedSubject'
# end class POCD_MT000040UV02_Subject


class POCD_MT000040UV02_SubjectPerson(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: List_['PN'] = None, desc: 'ED' = None, administrativeGenderCode: 'CE' = None, birthTime: 'TS' = None, deceasedInd: 'BL' = None, deceasedTime: 'TS' = None, multipleBirthInd: 'BL' = None, multipleBirthOrderNumber: 'INT' = None, raceCode: List_['CE'] = None, ethnicGroupCode: List_['CE'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
        self.deceasedInd = deceasedInd
        self.deceasedInd_nsprefix_ = None
        self.deceasedTime = deceasedTime
        self.deceasedTime_nsprefix_ = None
        self.multipleBirthInd = multipleBirthInd
        self.multipleBirthInd_nsprefix_ = None
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
        self.multipleBirthOrderNumber_nsprefix_ = None
        if raceCode is None:
            self.raceCode = []
        else:
            self.raceCode = raceCode
        self.raceCode_nsprefix_ = None
        if ethnicGroupCode is None:
            self.ethnicGroupCode = []
        else:
            self.ethnicGroupCode = ethnicGroupCode
        self.ethnicGroupCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_SubjectPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_SubjectPerson.subclass:
            return POCD_MT000040UV02_SubjectPerson.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_SubjectPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_deceasedInd(self):
        return self.deceasedInd
    def set_deceasedInd(self, deceasedInd):
        self.deceasedInd = deceasedInd
    def get_deceasedTime(self):
        return self.deceasedTime
    def set_deceasedTime(self, deceasedTime):
        self.deceasedTime = deceasedTime
    def get_multipleBirthInd(self):
        return self.multipleBirthInd
    def set_multipleBirthInd(self, multipleBirthInd):
        self.multipleBirthInd = multipleBirthInd
    def get_multipleBirthOrderNumber(self):
        return self.multipleBirthOrderNumber
    def set_multipleBirthOrderNumber(self, multipleBirthOrderNumber):
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
    def get_raceCode(self):
        return self.raceCode
    def set_raceCode(self, raceCode):
        self.raceCode = raceCode
    def add_raceCode(self, value):
        self.raceCode.append(value)
    def insert_raceCode_at(self, index, value):
        self.raceCode.insert(index, value)
    def replace_raceCode_at(self, index, value):
        self.raceCode[index] = value
    def get_ethnicGroupCode(self):
        return self.ethnicGroupCode
    def set_ethnicGroupCode(self, ethnicGroupCode):
        self.ethnicGroupCode = ethnicGroupCode
    def add_ethnicGroupCode(self, value):
        self.ethnicGroupCode.append(value)
    def insert_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode.insert(index, value)
    def replace_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ANM', 'CER', 'CHEM', 'CITY', 'CONT', 'COUNTRY', 'COUNTY', 'DEV', 'ENT', 'FOOD', 'HCE', 'HOLD', 'LIV', 'MAT', 'MIC', 'MMAT', 'MODDV', 'NAT', 'NLIV', 'ORG', 'PLC', 'PLNT', 'PROVINCE', 'PSN', 'PUB', 'RGRP', 'STATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClass_patterns_, ))
    validate_EntityClass_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE', 'KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminer_patterns_, ))
    validate_EntityDeterminer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name or
            self.desc is not None or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.deceasedInd is not None or
            self.deceasedTime is not None or
            self.multipleBirthInd is not None or
            self.multipleBirthOrderNumber is not None or
            self.raceCode or
            self.ethnicGroupCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SubjectPerson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.SubjectPerson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.SubjectPerson':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.SubjectPerson')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.SubjectPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.SubjectPerson'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SubjectPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.deceasedInd is not None:
            namespaceprefix_ = self.deceasedInd_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedInd_nsprefix_) else ''
            self.deceasedInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deceasedInd', pretty_print=pretty_print)
        if self.deceasedTime is not None:
            namespaceprefix_ = self.deceasedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedTime_nsprefix_) else ''
            self.deceasedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deceasedTime', pretty_print=pretty_print)
        if self.multipleBirthInd is not None:
            namespaceprefix_ = self.multipleBirthInd_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthInd_nsprefix_) else ''
            self.multipleBirthInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multipleBirthInd', pretty_print=pretty_print)
        if self.multipleBirthOrderNumber is not None:
            namespaceprefix_ = self.multipleBirthOrderNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthOrderNumber_nsprefix_) else ''
            self.multipleBirthOrderNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multipleBirthOrderNumber', pretty_print=pretty_print)
        for raceCode_ in self.raceCode:
            namespaceprefix_ = self.raceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.raceCode_nsprefix_) else ''
            raceCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='raceCode', pretty_print=pretty_print)
        for ethnicGroupCode_ in self.ethnicGroupCode:
            namespaceprefix_ = self.ethnicGroupCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ethnicGroupCode_nsprefix_) else ''
            ethnicGroupCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ethnicGroupCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'deceasedInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedInd = obj_
            obj_.original_tagname_ = 'deceasedInd'
        elif nodeName_ == 'deceasedTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedTime = obj_
            obj_.original_tagname_ = 'deceasedTime'
        elif nodeName_ == 'multipleBirthInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthInd = obj_
            obj_.original_tagname_ = 'multipleBirthInd'
        elif nodeName_ == 'multipleBirthOrderNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthOrderNumber = obj_
            obj_.original_tagname_ = 'multipleBirthOrderNumber'
        elif nodeName_ == 'raceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.raceCode.append(obj_)
            obj_.original_tagname_ = 'raceCode'
        elif nodeName_ == 'ethnicGroupCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ethnicGroupCode.append(obj_)
            obj_.original_tagname_ = 'ethnicGroupCode'
# end class POCD_MT000040UV02_SubjectPerson


class POCD_MT000040UV02_SubstanceAdministration(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'SBADM', moodCode: 'x_DocumentSubstanceMood' = None, actionNegationInd: 'bl' = None, negationInd: 'bl' = None, isCriterionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: List_['SXCM_TS'] = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: 'CE' = None, confidentialityCode: 'CE' = None, repeatNumber: 'IVL_INT' = None, languageCode: 'CS' = None, routeCode: 'CE' = None, approachSiteCode: List_['CD'] = None, doseQuantity: 'IVL_PQ' = None, rateQuantity: 'IVL_PQ' = None, doseCheckQuantity: List_['RTO_PQ_PQ'] = None, maxDoseQuantity: List_['RTO_PQ_PQ'] = None, administrationUnitCode: 'CE' = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, consumable: 'POCD_MT000040UV02.Consumable' = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.routeCode = routeCode
        self.routeCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        self.doseQuantity = doseQuantity
        self.doseQuantity_nsprefix_ = None
        self.rateQuantity = rateQuantity
        self.rateQuantity_nsprefix_ = None
        if doseCheckQuantity is None:
            self.doseCheckQuantity = []
        else:
            self.doseCheckQuantity = doseCheckQuantity
        self.doseCheckQuantity_nsprefix_ = None
        if maxDoseQuantity is None:
            self.maxDoseQuantity = []
        else:
            self.maxDoseQuantity = maxDoseQuantity
        self.maxDoseQuantity_nsprefix_ = None
        self.administrationUnitCode = administrationUnitCode
        self.administrationUnitCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.consumable = consumable
        self.consumable_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_SubstanceAdministration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_SubstanceAdministration.subclass:
            return POCD_MT000040UV02_SubstanceAdministration.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_SubstanceAdministration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_routeCode(self):
        return self.routeCode
    def set_routeCode(self, routeCode):
        self.routeCode = routeCode
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_doseQuantity(self):
        return self.doseQuantity
    def set_doseQuantity(self, doseQuantity):
        self.doseQuantity = doseQuantity
    def get_rateQuantity(self):
        return self.rateQuantity
    def set_rateQuantity(self, rateQuantity):
        self.rateQuantity = rateQuantity
    def get_doseCheckQuantity(self):
        return self.doseCheckQuantity
    def set_doseCheckQuantity(self, doseCheckQuantity):
        self.doseCheckQuantity = doseCheckQuantity
    def add_doseCheckQuantity(self, value):
        self.doseCheckQuantity.append(value)
    def insert_doseCheckQuantity_at(self, index, value):
        self.doseCheckQuantity.insert(index, value)
    def replace_doseCheckQuantity_at(self, index, value):
        self.doseCheckQuantity[index] = value
    def get_maxDoseQuantity(self):
        return self.maxDoseQuantity
    def set_maxDoseQuantity(self, maxDoseQuantity):
        self.maxDoseQuantity = maxDoseQuantity
    def add_maxDoseQuantity(self, value):
        self.maxDoseQuantity.append(value)
    def insert_maxDoseQuantity_at(self, index, value):
        self.maxDoseQuantity.insert(index, value)
    def replace_maxDoseQuantity_at(self, index, value):
        self.maxDoseQuantity[index] = value
    def get_administrationUnitCode(self):
        return self.administrationUnitCode
    def set_administrationUnitCode(self, administrationUnitCode):
        self.administrationUnitCode = administrationUnitCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_consumable(self):
        return self.consumable
    def set_consumable(self, consumable):
        self.consumable = consumable
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEF', 'EVN', 'INT', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode is not None or
            self.confidentialityCode is not None or
            self.repeatNumber is not None or
            self.languageCode is not None or
            self.routeCode is not None or
            self.approachSiteCode or
            self.doseQuantity is not None or
            self.rateQuantity is not None or
            self.doseCheckQuantity or
            self.maxDoseQuantity or
            self.administrationUnitCode is not None or
            self.subject is not None or
            self.specimen or
            self.consumable is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SubstanceAdministration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.SubstanceAdministration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.SubstanceAdministration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.SubstanceAdministration')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.SubstanceAdministration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.SubstanceAdministration'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SBADM" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
        if self.isCriterionInd is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.SubstanceAdministration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.routeCode is not None:
            namespaceprefix_ = self.routeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.routeCode_nsprefix_) else ''
            self.routeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        if self.doseQuantity is not None:
            namespaceprefix_ = self.doseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.doseQuantity_nsprefix_) else ''
            self.doseQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doseQuantity', pretty_print=pretty_print)
        if self.rateQuantity is not None:
            namespaceprefix_ = self.rateQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.rateQuantity_nsprefix_) else ''
            self.rateQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rateQuantity', pretty_print=pretty_print)
        for doseCheckQuantity_ in self.doseCheckQuantity:
            namespaceprefix_ = self.doseCheckQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.doseCheckQuantity_nsprefix_) else ''
            doseCheckQuantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doseCheckQuantity', pretty_print=pretty_print)
        for maxDoseQuantity_ in self.maxDoseQuantity:
            namespaceprefix_ = self.maxDoseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.maxDoseQuantity_nsprefix_) else ''
            maxDoseQuantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxDoseQuantity', pretty_print=pretty_print)
        if self.administrationUnitCode is not None:
            namespaceprefix_ = self.administrationUnitCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrationUnitCode_nsprefix_) else ''
            self.administrationUnitCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrationUnitCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.consumable is not None:
            namespaceprefix_ = self.consumable_nsprefix_ + ':' if (UseCapturedNS_ and self.consumable_nsprefix_) else ''
            self.consumable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consumable', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'routeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeCode = obj_
            obj_.original_tagname_ = 'routeCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'doseQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doseQuantity = obj_
            obj_.original_tagname_ = 'doseQuantity'
        elif nodeName_ == 'rateQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rateQuantity = obj_
            obj_.original_tagname_ = 'rateQuantity'
        elif nodeName_ == 'doseCheckQuantity':
            obj_ = RTO_PQ_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doseCheckQuantity.append(obj_)
            obj_.original_tagname_ = 'doseCheckQuantity'
        elif nodeName_ == 'maxDoseQuantity':
            obj_ = RTO_PQ_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxDoseQuantity.append(obj_)
            obj_.original_tagname_ = 'maxDoseQuantity'
        elif nodeName_ == 'administrationUnitCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrationUnitCode = obj_
            obj_.original_tagname_ = 'administrationUnitCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'consumable':
            obj_ = POCD_MT000040UV02_Consumable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consumable = obj_
            obj_.original_tagname_ = 'consumable'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_SubstanceAdministration


class POCD_MT000040UV02_Supply(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'SPLY', moodCode: 'x_DocumentSubstanceMood' = None, actionNegationInd: 'bl' = None, isCriterionInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: List_['SXCM_TS'] = None, activityTime: List_['SXCM_TS'] = None, availabilityTime: 'TS' = None, priorityCode: List_['CE'] = None, confidentialityCode: 'CE' = None, repeatNumber: 'IVL_INT' = None, independentInd: 'BL' = None, languageCode: 'CS' = None, quantity: 'PQ' = None, expectedUseTime: 'IVL_TS' = None, subject: 'POCD_MT000040UV02.Subject' = None, specimen: List_['POCD_MT000040UV02.Specimen'] = None, product: 'POCD_MT000040UV02.Product' = None, performer: List_['POCD_MT000040UV02.Performer2'] = None, author: List_['POCD_MT000040UV02.Author'] = None, informant: List_['POCD_MT000040UV02.Informant12'] = None, participant: List_['POCD_MT000040UV02.Participant3'] = None, entryRelationship: List_['POCD_MT000040UV02.EntryRelationship'] = None, reference: List_['POCD_MT000040UV02.Reference'] = None, precondition: List_['POCD_MT000040UV02.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.actionNegationInd = _cast(bool, actionNegationInd)
        self.actionNegationInd_nsprefix_ = None
        self.isCriterionInd = _cast(bool, isCriterionInd)
        self.isCriterionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if activityTime is None:
            self.activityTime = []
        else:
            self.activityTime = activityTime
        self.activityTime_nsprefix_ = None
        self.availabilityTime = availabilityTime
        self.availabilityTime_nsprefix_ = None
        if priorityCode is None:
            self.priorityCode = []
        else:
            self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.independentInd = independentInd
        self.independentInd_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.quantity = quantity
        self.quantity_nsprefix_ = None
        self.expectedUseTime = expectedUseTime
        self.expectedUseTime_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_Supply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_Supply.subclass:
            return POCD_MT000040UV02_Supply.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_Supply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_activityTime(self):
        return self.activityTime
    def set_activityTime(self, activityTime):
        self.activityTime = activityTime
    def add_activityTime(self, value):
        self.activityTime.append(value)
    def insert_activityTime_at(self, index, value):
        self.activityTime.insert(index, value)
    def replace_activityTime_at(self, index, value):
        self.activityTime[index] = value
    def get_availabilityTime(self):
        return self.availabilityTime
    def set_availabilityTime(self, availabilityTime):
        self.availabilityTime = availabilityTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def add_priorityCode(self, value):
        self.priorityCode.append(value)
    def insert_priorityCode_at(self, index, value):
        self.priorityCode.insert(index, value)
    def replace_priorityCode_at(self, index, value):
        self.priorityCode[index] = value
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_independentInd(self):
        return self.independentInd
    def set_independentInd(self, independentInd):
        self.independentInd = independentInd
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_expectedUseTime(self):
        return self.expectedUseTime
    def set_expectedUseTime(self, expectedUseTime):
        self.expectedUseTime = expectedUseTime
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_actionNegationInd(self):
        return self.actionNegationInd
    def set_actionNegationInd(self, actionNegationInd):
        self.actionNegationInd = actionNegationInd
    def get_isCriterionInd(self):
        return self.isCriterionInd
    def set_isCriterionInd(self, isCriterionInd):
        self.isCriterionInd = isCriterionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCM', 'ACCT', 'ACSN', 'ACT', 'ACTN', 'ADJUD', 'AEXPOS', 'ALRT', 'BATTERY', 'CACT', 'CASE', 'CATEGORY', 'CDALVLONE', 'CLNTRL', 'CLUSTER', 'CNOD', 'CNTRCT', 'COMPOSITION', 'CONC', 'COND', 'CONS', 'CONTAINER', 'CONTREG', 'COV', 'CTTEVENT', 'DETPOL', 'DGIMG', 'DIET', 'DISPACT', 'DOC', 'DOCBODY', 'DOCCLIN', 'DOCSECT', 'EHR', 'ENC', 'EXP', 'EXPOS', 'EXTRACT', 'FCNTRCT', 'FOLDER', 'GEN', 'GROUPER', 'INC', 'INFO', 'INFRM', 'INVE', 'INVSTG', 'JURISPOL', 'LIST', 'LLD', 'LOC', 'MPROT', 'OBS', 'OBSCOR', 'OBSSER', 'ORGPOL', 'OUTB', 'PCPR', 'PHN', 'POL', 'POLICY', 'POS', 'POSACC', 'POSCOORD', 'PRN', 'PROC', 'REG', 'REV', 'RLD', 'ROIBND', 'ROIOVL', 'RTRD', 'SBADM', 'SBEXT', 'SCOPOL', 'SEQ', 'SEQVAR', 'SFWL', 'SIT', 'SPCOBS', 'SPCTRT', 'SPECCOLLECT', 'SPLY', 'STC', 'STDPOL', 'STN', 'STORE', 'SUBST', 'SUP', 'TEXPOS', 'TOPIC', 'TRD', 'TRFR', 'TRNS', 'VERIF', 'XACT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClass_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClass_patterns_, ))
    validate_ActClass_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEF', 'EVN', 'INT', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.activityTime or
            self.availabilityTime is not None or
            self.priorityCode or
            self.confidentialityCode is not None or
            self.repeatNumber is not None or
            self.independentInd is not None or
            self.languageCode is not None or
            self.quantity is not None or
            self.expectedUseTime is not None or
            self.subject is not None or
            self.specimen or
            self.product is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Supply', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.Supply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.Supply':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.Supply')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.Supply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.Supply'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SPLY" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.actionNegationInd is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            outfile.write(' actionNegationInd="%s"' % self.gds_format_boolean(self.actionNegationInd, input_name='actionNegationInd'))
        if self.isCriterionInd is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            outfile.write(' isCriterionInd="%s"' % self.gds_format_boolean(self.isCriterionInd, input_name='isCriterionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='POCD_MT000040UV02.Supply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for activityTime_ in self.activityTime:
            namespaceprefix_ = self.activityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activityTime_nsprefix_) else ''
            activityTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activityTime', pretty_print=pretty_print)
        if self.availabilityTime is not None:
            namespaceprefix_ = self.availabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityTime_nsprefix_) else ''
            self.availabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityTime', pretty_print=pretty_print)
        for priorityCode_ in self.priorityCode:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            priorityCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.independentInd is not None:
            namespaceprefix_ = self.independentInd_nsprefix_ + ':' if (UseCapturedNS_ and self.independentInd_nsprefix_) else ''
            self.independentInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='independentInd', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.expectedUseTime is not None:
            namespaceprefix_ = self.expectedUseTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expectedUseTime_nsprefix_) else ''
            self.expectedUseTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expectedUseTime', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.product is not None:
            namespaceprefix_ = self.product_nsprefix_ + ':' if (UseCapturedNS_ and self.product_nsprefix_) else ''
            self.product.export(outfile, level, namespaceprefix_, namespacedef_='', name_='product', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
        value = find_attr_value_('actionNegationInd', node)
        if value is not None and 'actionNegationInd' not in already_processed:
            already_processed.add('actionNegationInd')
            if value in ('true', '1'):
                self.actionNegationInd = True
            elif value in ('false', '0'):
                self.actionNegationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.actionNegationInd)    # validate type bl
        value = find_attr_value_('isCriterionInd', node)
        if value is not None and 'isCriterionInd' not in already_processed:
            already_processed.add('isCriterionInd')
            if value in ('true', '1'):
                self.isCriterionInd = True
            elif value in ('false', '0'):
                self.isCriterionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isCriterionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'activityTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activityTime.append(obj_)
            obj_.original_tagname_ = 'activityTime'
        elif nodeName_ == 'availabilityTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityTime = obj_
            obj_.original_tagname_ = 'availabilityTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode.append(obj_)
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'independentInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.independentInd = obj_
            obj_.original_tagname_ = 'independentInd'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'expectedUseTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expectedUseTime = obj_
            obj_.original_tagname_ = 'expectedUseTime'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040UV02_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040UV02_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'product':
            obj_ = POCD_MT000040UV02_Product.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040UV02_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040UV02_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040UV02_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040UV02_Participant3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040UV02_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040UV02_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040UV02_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040UV02_Supply


class StrucDoc_Text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, mediaType: 'string' = 'text/x-hl7-text+xml', content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Text.subclass:
            return StrucDoc_Text.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Text')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Text'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType != "text/x-hl7-text+xml" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Text', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Text


class StrucDoc_Title(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, mediaType: 'string' = 'text/x-hl7-title+xml', content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.TitleFootnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Title)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Title.subclass:
            return StrucDoc_Title.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Title', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Title')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Title':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Title')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Title'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType != "text/x-hl7-title+xml" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Title', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Title


class StrucDoc_Br(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Br)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Br.subclass:
            return StrucDoc_Br.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Br(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Br')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Br':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Br')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Br', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Br'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Br


class StrucDoc_Caption(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Caption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Caption.subclass:
            return StrucDoc_Caption.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.linkHtml or
            self.sub or
            self.sup or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Caption', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Caption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Caption':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Caption')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Caption'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Caption', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Caption


class StrucDoc_Col(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, span: 'string' = '1', width: 'string' = None, align: 'alignType' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Col)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Col.subclass:
            return StrucDoc_Col.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Col(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType(self, value):
        # Validate type alignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType(self, value):
        # Validate type valignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Col')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Col':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Col')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Col', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Col'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType(self.align)    # validate type alignType
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType(self.valign)    # validate type valignType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Col


class StrucDoc_Colgroup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, span: 'string' = '1', width: 'string' = None, align: 'alignType1' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType2' = None, col: List_['StrucDoc.Col'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Colgroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Colgroup.subclass:
            return StrucDoc_Colgroup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Colgroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType1(self, value):
        # Validate type alignType1, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType2(self, value):
        # Validate type valignType2, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.col
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Colgroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Colgroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Colgroup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Colgroup')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Colgroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Colgroup'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Colgroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType1(self.align)    # validate type alignType1
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType2(self.valign)    # validate type valignType2
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
# end class StrucDoc_Colgroup


class StrucDoc_Content(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, revised: 'revisedType' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.revised = _cast(None, revised)
        self.revised_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Content.subclass:
            return StrucDoc_Content.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_revised(self):
        return self.revised
    def set_revised(self, revised):
        self.revised = revised
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_revisedType(self, value):
        # Validate type revisedType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['insert', 'delete']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on revisedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Content', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Content')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Content':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Content')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Content'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.revised is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            outfile.write(' revised=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revised), input_name='revised')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Content', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('revised', node)
        if value is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            self.revised = value
            self.validate_revisedType(self.revised)    # validate type revisedType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Content


class StrucDoc_TitleContent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.TitleFootnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleContent.subclass:
            return StrucDoc_TitleContent.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.TitleContent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleContent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleContent')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleContent'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.TitleContent', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleContent


class StrucDoc_Footnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Footnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Footnote.subclass:
            return StrucDoc_Footnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Footnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Footnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Footnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Footnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Footnote')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Footnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Footnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Footnote


class StrucDoc_TitleFootnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleFootnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleFootnote.subclass:
            return StrucDoc_TitleFootnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleFootnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.TitleFootnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleFootnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleFootnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleFootnote')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleFootnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.TitleFootnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleFootnote


class StrucDoc_FootnoteRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, IDREF: 'string' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.IDREF = _cast(None, IDREF)
        self.IDREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_FootnoteRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_FootnoteRef.subclass:
            return StrucDoc_FootnoteRef.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_FootnoteRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_IDREF(self):
        return self.IDREF
    def set_IDREF(self, IDREF):
        self.IDREF = IDREF
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.FootnoteRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.FootnoteRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.FootnoteRef')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.FootnoteRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.FootnoteRef'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.IDREF is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            outfile.write(' IDREF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDREF), input_name='IDREF')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('IDREF', node)
        if value is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            self.IDREF = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_FootnoteRef


class StrucDoc_Item(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Item.subclass:
            return StrucDoc_Item.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Item', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Item':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Item')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Item'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Item', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Item


class StrucDoc_LinkHtml(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name: 'string' = None, href: 'string' = None, rel: 'string' = None, rev: 'string' = None, title: 'string' = None, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.rel = _cast(None, rel)
        self.rel_nsprefix_ = None
        self.rev = _cast(None, rev)
        self.rev_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_LinkHtml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_LinkHtml.subclass:
            return StrucDoc_LinkHtml.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_LinkHtml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_rel(self):
        return self.rel
    def set_rel(self, rel):
        self.rel = rel
    def get_rev(self):
        return self.rev
    def set_rev(self, rev):
        self.rev = rev
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.LinkHtml', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.LinkHtml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.LinkHtml':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.LinkHtml')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.LinkHtml'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            outfile.write(' rev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rev), input_name='rev')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.LinkHtml', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('rev', node)
        if value is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            self.rev = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_LinkHtml


class StrucDoc_List(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, listType: 'listTypeType' = 'unordered', caption: 'StrucDoc.Caption' = None, item: List_['StrucDoc.Item'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.listType = _cast(None, listType)
        self.listType_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_List)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_List.subclass:
            return StrucDoc_List.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_listType(self):
        return self.listType
    def set_listType(self, listType):
        self.listType = listType
    def validate_listTypeType(self, value):
        # Validate type listTypeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ordered', 'unordered']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on listTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.caption is not None or
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.List', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.List')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.List':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.List')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.List', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.List'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.listType != "unordered" and 'listType' not in already_processed:
            already_processed.add('listType')
            outfile.write(' listType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.listType), input_name='listType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.List', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('listType', node)
        if value is not None and 'listType' not in already_processed:
            already_processed.add('listType')
            self.listType = value
            self.validate_listTypeType(self.listType)    # validate type listTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'item':
            obj_ = StrucDoc_Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class StrucDoc_List


class StrucDoc_Paragraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Paragraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Paragraph.subclass:
            return StrucDoc_Paragraph.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Paragraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Paragraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Paragraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Paragraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Paragraph')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Paragraph'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Paragraph', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Paragraph


class StrucDoc_RenderMultiMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, referencedObject: 'string' = None, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.referencedObject = _cast(None, referencedObject)
        self.referencedObject_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_RenderMultiMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_RenderMultiMedia.subclass:
            return StrucDoc_RenderMultiMedia.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_RenderMultiMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_referencedObject(self):
        return self.referencedObject
    def set_referencedObject(self, referencedObject):
        self.referencedObject = referencedObject
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def has__content(self):
        if (
            self.caption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.RenderMultiMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.RenderMultiMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.RenderMultiMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.RenderMultiMedia')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.RenderMultiMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.RenderMultiMedia'):
        if self.referencedObject is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            outfile.write(' referencedObject=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referencedObject), input_name='referencedObject')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.RenderMultiMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referencedObject', node)
        if value is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            self.referencedObject = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
# end class StrucDoc_RenderMultiMedia


class StrucDoc_Sub(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sub.subclass:
            return StrucDoc_Sub.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sub':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sub')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sub'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sub


class StrucDoc_Sup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sup.subclass:
            return StrucDoc_Sup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sup')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sup'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sup


class StrucDoc_Table(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, summary: 'string' = None, width: 'string' = None, border: 'string' = None, frame: 'frameType' = None, rules: 'rulesType' = None, cellspacing: 'string' = None, cellpadding: 'string' = None, caption: 'StrucDoc.Caption' = None, col: List_['StrucDoc.Col'] = None, colgroup: List_['StrucDoc.Colgroup'] = None, thead: 'StrucDoc.Thead' = None, tfoot: 'StrucDoc.Tfoot' = None, tbody: List_['StrucDoc.Tbody'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.summary = _cast(None, summary)
        self.summary_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.border = _cast(None, border)
        self.border_nsprefix_ = None
        self.frame = _cast(None, frame)
        self.frame_nsprefix_ = None
        self.rules = _cast(None, rules)
        self.rules_nsprefix_ = None
        self.cellspacing = _cast(None, cellspacing)
        self.cellspacing_nsprefix_ = None
        self.cellpadding = _cast(None, cellpadding)
        self.cellpadding_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
        if colgroup is None:
            self.colgroup = []
        else:
            self.colgroup = colgroup
        self.colgroup_nsprefix_ = None
        self.thead = thead
        self.thead_nsprefix_ = None
        self.tfoot = tfoot
        self.tfoot_nsprefix_ = None
        if tbody is None:
            self.tbody = []
        else:
            self.tbody = tbody
        self.tbody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Table)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Table.subclass:
            return StrucDoc_Table.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_colgroup(self):
        return self.colgroup
    def set_colgroup(self, colgroup):
        self.colgroup = colgroup
    def add_colgroup(self, value):
        self.colgroup.append(value)
    def insert_colgroup_at(self, index, value):
        self.colgroup.insert(index, value)
    def replace_colgroup_at(self, index, value):
        self.colgroup[index] = value
    def get_thead(self):
        return self.thead
    def set_thead(self, thead):
        self.thead = thead
    def get_tfoot(self):
        return self.tfoot
    def set_tfoot(self, tfoot):
        self.tfoot = tfoot
    def get_tbody(self):
        return self.tbody
    def set_tbody(self, tbody):
        self.tbody = tbody
    def add_tbody(self, value):
        self.tbody.append(value)
    def insert_tbody_at(self, index, value):
        self.tbody.insert(index, value)
    def replace_tbody_at(self, index, value):
        self.tbody[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def get_rules(self):
        return self.rules
    def set_rules(self, rules):
        self.rules = rules
    def get_cellspacing(self):
        return self.cellspacing
    def set_cellspacing(self, cellspacing):
        self.cellspacing = cellspacing
    def get_cellpadding(self):
        return self.cellpadding
    def set_cellpadding(self, cellpadding):
        self.cellpadding = cellpadding
    def validate_frameType(self, value):
        # Validate type frameType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on frameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_rulesType(self, value):
        # Validate type rulesType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'groups', 'rows', 'cols', 'all']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.caption is not None or
            self.col or
            self.colgroup or
            self.thead is not None or
            self.tfoot is not None or
            self.tbody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Table', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Table')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Table':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Table')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Table'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.summary), input_name='summary')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.border is not None and 'border' not in already_processed:
            already_processed.add('border')
            outfile.write(' border=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.border), input_name='border')), ))
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            outfile.write(' frame=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.frame), input_name='frame')), ))
        if self.rules is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            outfile.write(' rules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rules), input_name='rules')), ))
        if self.cellspacing is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            outfile.write(' cellspacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellspacing), input_name='cellspacing')), ))
        if self.cellpadding is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            outfile.write(' cellpadding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellpadding), input_name='cellpadding')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
        for colgroup_ in self.colgroup:
            namespaceprefix_ = self.colgroup_nsprefix_ + ':' if (UseCapturedNS_ and self.colgroup_nsprefix_) else ''
            colgroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='colgroup', pretty_print=pretty_print)
        if self.thead is not None:
            namespaceprefix_ = self.thead_nsprefix_ + ':' if (UseCapturedNS_ and self.thead_nsprefix_) else ''
            self.thead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thead', pretty_print=pretty_print)
        if self.tfoot is not None:
            namespaceprefix_ = self.tfoot_nsprefix_ + ':' if (UseCapturedNS_ and self.tfoot_nsprefix_) else ''
            self.tfoot.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfoot', pretty_print=pretty_print)
        for tbody_ in self.tbody:
            namespaceprefix_ = self.tbody_nsprefix_ + ':' if (UseCapturedNS_ and self.tbody_nsprefix_) else ''
            tbody_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tbody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('border', node)
        if value is not None and 'border' not in already_processed:
            already_processed.add('border')
            self.border = value
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            self.frame = value
            self.validate_frameType(self.frame)    # validate type frameType
        value = find_attr_value_('rules', node)
        if value is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            self.rules = value
            self.validate_rulesType(self.rules)    # validate type rulesType
        value = find_attr_value_('cellspacing', node)
        if value is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            self.cellspacing = value
        value = find_attr_value_('cellpadding', node)
        if value is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            self.cellpadding = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
        elif nodeName_ == 'colgroup':
            obj_ = StrucDoc_Colgroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.colgroup.append(obj_)
            obj_.original_tagname_ = 'colgroup'
        elif nodeName_ == 'thead':
            obj_ = StrucDoc_Thead.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.thead = obj_
            obj_.original_tagname_ = 'thead'
        elif nodeName_ == 'tfoot':
            obj_ = StrucDoc_Tfoot.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfoot = obj_
            obj_.original_tagname_ = 'tfoot'
        elif nodeName_ == 'tbody':
            obj_ = StrucDoc_Tbody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tbody.append(obj_)
            obj_.original_tagname_ = 'tbody'
# end class StrucDoc_Table


class StrucDoc_Tbody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, align: 'alignType3' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType4' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tbody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tbody.subclass:
            return StrucDoc_Tbody.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tbody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType3(self, value):
        # Validate type alignType3, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType4(self, value):
        # Validate type valignType4, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tbody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tbody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tbody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tbody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tbody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tbody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tbody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType3(self.align)    # validate type alignType3
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType4(self.valign)    # validate type valignType4
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tbody


class StrucDoc_Td(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, abbr: 'string' = None, axis: 'string' = None, headers: 'string' = None, scope: 'scopeType' = None, rowspan: 'string' = '1', colspan: 'string' = '1', align: 'alignType5' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType6' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Td)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Td.subclass:
            return StrucDoc_Td.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Td(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType(self, value):
        # Validate type scopeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType5(self, value):
        # Validate type alignType5, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType6(self, value):
        # Validate type valignType6, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Td', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Td')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Td':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Td')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Td'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Td', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType(self.scope)    # validate type scopeType
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType5(self.align)    # validate type alignType5
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType6(self.valign)    # validate type valignType6
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Td


class StrucDoc_Tfoot(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, align: 'alignType7' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType8' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tfoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tfoot.subclass:
            return StrucDoc_Tfoot.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tfoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType7(self, value):
        # Validate type alignType7, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType8(self, value):
        # Validate type valignType8, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tfoot', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tfoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tfoot':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tfoot')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tfoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tfoot'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tfoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType7(self.align)    # validate type alignType7
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType8(self.valign)    # validate type valignType8
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tfoot


class StrucDoc_Th(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, abbr: 'string' = None, axis: 'string' = None, headers: 'string' = None, scope: 'scopeType9' = None, rowspan: 'string' = '1', colspan: 'string' = '1', align: 'alignType10' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType11' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Th)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Th.subclass:
            return StrucDoc_Th.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Th(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType9(self, value):
        # Validate type scopeType9, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType10(self, value):
        # Validate type alignType10, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType10' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType11(self, value):
        # Validate type valignType11, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType11' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Th', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Th')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Th':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Th')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Th'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Th', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType9(self.scope)    # validate type scopeType9
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType10(self.align)    # validate type alignType10
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType11(self.valign)    # validate type valignType11
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Th


class StrucDoc_Thead(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, align: 'alignType12' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType13' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Thead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Thead.subclass:
            return StrucDoc_Thead.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Thead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType12(self, value):
        # Validate type alignType12, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType12' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType13(self, value):
        # Validate type valignType13, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType13' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Thead', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Thead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Thead':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Thead')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Thead', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Thead'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Thead', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType12(self.align)    # validate type alignType12
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType13(self.valign)    # validate type valignType13
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Thead


class StrucDoc_Tr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'string' = None, language: 'NMTOKEN' = None, styleCode: 'NMTOKENS' = None, align: 'alignType14' = None, char: 'string' = None, charoff: 'string' = None, valign: 'valignType15' = None, th: List_['StrucDoc.Th'] = None, td: List_['StrucDoc.Td'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if th is None:
            self.th = []
        else:
            self.th = th
        self.th_nsprefix_ = None
        if td is None:
            self.td = []
        else:
            self.td = td
        self.td_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tr.subclass:
            return StrucDoc_Tr.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_th(self):
        return self.th
    def set_th(self, th):
        self.th = th
    def add_th(self, value):
        self.th.append(value)
    def insert_th_at(self, index, value):
        self.th.insert(index, value)
    def replace_th_at(self, index, value):
        self.th[index] = value
    def get_td(self):
        return self.td
    def set_td(self, td):
        self.td = td
    def add_td(self, value):
        self.td.append(value)
    def insert_td_at(self, index, value):
        self.td.insert(index, value)
    def replace_td_at(self, index, value):
        self.td[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType14(self, value):
        # Validate type alignType14, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType14' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType15(self, value):
        # Validate type valignType15, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.th or
            self.td
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tr':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tr')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tr'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='StrucDoc.Tr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for th_ in self.th:
            namespaceprefix_ = self.th_nsprefix_ + ':' if (UseCapturedNS_ and self.th_nsprefix_) else ''
            th_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='th', pretty_print=pretty_print)
        for td_ in self.td:
            namespaceprefix_ = self.td_nsprefix_ + ':' if (UseCapturedNS_ and self.td_nsprefix_) else ''
            td_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='td', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType14(self.align)    # validate type alignType14
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType15(self.valign)    # validate type valignType15
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'th':
            obj_ = StrucDoc_Th.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.th.append(obj_)
            obj_.original_tagname_ = 'th'
        elif nodeName_ == 'td':
            obj_ = StrucDoc_Td.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.td.append(obj_)
            obj_.original_tagname_ = 'td'
# end class StrucDoc_Tr


class ANY(GeneratedsSuper):
    """ANY --
    Defines the basic properties of every data value. This
    is an abstract type, meaning that no value can be just
    a data value without belonging to any concrete type.
    Every concrete type is a specialization of this
    general abstract DataValue type.
      
    * nullFlavor --
      An exceptional value expressing missing information
      and possibly the reason why the information is missing.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANY.subclass:
            return ANY.subclass(*args_, **kwargs_)
        else:
            return ANY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANY'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ANY


class BL(ANY):
    """BL --
    The Boolean type stands for the values of two-valued logic.
    A Boolean value can be either true or
    false, or, as any other value may be NULL.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'bl' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BL"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BL.subclass:
            return BL.subclass(*args_, **kwargs_)
        else:
            return BL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BL'):
        super(BL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_boolean(self.value, input_name='value'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', fromsubclass_=False, pretty_print=True):
        super(BL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.value)    # validate type bl
        super(BL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BL


class ANYNonNull(ANY):
    """ANYNonNull --
    The BooleanNonNull type is used where a Boolean cannot
    have a null value. A Boolean value can be either
    true or false.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANYNonNull"), self).__init__(nullFlavor, extensiontype_,  **kwargs_)
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANYNonNull)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANYNonNull.subclass:
            return ANYNonNull.subclass(*args_, **kwargs_)
        else:
            return ANYNonNull(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(ANYNonNull, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANYNonNull')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANYNonNull':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANYNonNull', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANYNonNull'):
        super(ANYNonNull, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ANYNonNull, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ANYNonNull


class BN(ANYNonNull):
    """BN --
    The BooleanNonNull type is used where a Boolean cannot
    have a null value. A Boolean value can be either
    true or false.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANYNonNull
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'bn' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BN"), self).__init__(nullFlavor,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BN.subclass:
            return BN.subclass(*args_, **kwargs_)
        else:
            return BN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(BN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BN'):
        super(BN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', fromsubclass_=False, pretty_print=True):
        super(BN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.value)    # validate type bn
        super(BN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BN


class BIN(ANY):
    """BIN --
    Binary data is a raw block of bits. Binary data is a
    protected type that MUST not be used outside the data
    type specification.
      
    * representation --
      Specifies the representation of the binary data that
      is the content of the binary data value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BIN"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BIN.subclass:
            return BIN.subclass(*args_, **kwargs_)
        else:
            return BIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BIN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BIN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BIN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BIN'):
        super(BIN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', fromsubclass_=False, pretty_print=True):
        super(BIN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BIN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BIN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BIN


class ED(BIN):
    """ED --
    Data that is primarily intended for human interpretation
    or for further machine processing is outside the scope of
    HL7. This includes unformatted or formatted written language,
    multimedia data, or structured information as defined by a
    different standard (e.g., XML-signatures.)  Instead of the
    data itself, an ED may contain
    only a reference (see TEL.) Note
    that the ST data type is a
    specialization of
    when the  is text/plain.
      
    * mediaType --
      Identifies the type of the encapsulated data and
      identifies a method to interpret or render the data.
      
    * language --
      For character based information the language property
      specifies the human language of the text.
      
    * compression --
      Indicates whether the raw byte data is compressed,
      and what compression algorithm was used.
      
    * integrityCheck --
      The integrity check is a short binary value representing
      a cryptographically strong checksum that is calculated
      over the binary data. The purpose of this property, when
      communicated with a reference is for anyone to validate
      later whether the reference still resolved to the same
      data that the reference resolved to when the encapsulated
      data value with reference was created.
      
    * integrityCheckAlgorithm --
      Specifies the algorithm used to compute the
      integrityCheck value.
      
    * reference --
      A telecommunication address (TEL), such as a URL
      for HTTP or FTP, which will resolve to precisely
      the sam
      e binary data that could as well have been
      provided as inline data.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ED"), self).__init__(nullFlavor, representation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED.subclass:
            return ED.subclass(*args_, **kwargs_)
        else:
            return ED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ED, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ED', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ED':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ED'):
        super(ED, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ED', fromsubclass_=False, pretty_print=True):
        super(ED, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        super(ED, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ED, self)._buildChildren(child_, node, nodeName_, True)
# end class ED


class thumbnail(ED):
    """thumbnail --
    A thumbnail is an abbreviated rendition of the full
    data. A thumbnail requires significantly fewer
    resources than the full data, while still maintaining
    some distinctive similarity with the full data. A
    thumbnail is typically used with by-reference
    encapsulated data. It allows a user to select data
    more efficiently before actually downloading through
    the reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, thumbnail_member: 'thumbnail' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("thumbnail"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail_member
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thumbnail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thumbnail.subclass:
            return thumbnail.subclass(*args_, **kwargs_)
        else:
            return thumbnail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(thumbnail, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='thumbnail', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('thumbnail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'thumbnail':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='thumbnail'):
        super(thumbnail, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='thumbnail', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(thumbnail, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class thumbnail


class ST(ED):
    """ST --
    The character string data type stands for text data,
    primarily intended for machine processing (e.g.,
    sorting, querying, indexing, etc.) Used for names,
    symbols, and formal expressions.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ST"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ST.subclass:
            return ST.subclass(*args_, **kwargs_)
        else:
            return ST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ST, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ST', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ST':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ST'):
        super(ST, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ST', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ST, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ST


class CD(ANY):
    """CD --
    A concept descriptor represents any kind of concept usually
    by giving a code defined in a code system.  A concept
    descriptor can contain the original text or phrase that
    served as the basis of the coding and one or more
    translations into different coding systems. A concept
    descriptor can also contain qualifiers to describe, e.g.,
    the concept of a "left foot" as a postcoordinated term built
    from the primary code "FOOT" and the qualifier "LEFT".
    In exceptional cases, the concept descriptor need not
    contain a code but only the original text describing
    that concept.
      
    * code --
      The plain code symbol defined by the code system.
      For example, "784.0" is the code symbol of the ICD-9
      code "784.0" for headache.
      
    * codeSystem --
      Specifies the code system that defines the code.
      
    * codeSystemName --
      A common name of the coding system.
      
    * codeSystemVersion --
      If applicable, a version descriptor defined
      specifically for the given code system.
      
    * displayName --
      A name or title for the code, under which the sending
      system shows the code value to its users.
      
    * originalText --
      The text or phrase used as the basis for the coding.
      
    * qualifier --
      Specifies additional codes that increase the
      specificity of the primary code.
      
    * translation --
      A set of other concept descriptors that translate
      this concept descriptor into other code systems.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CD"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CD.subclass:
            return CD.subclass(*args_, **kwargs_)
        else:
            return CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def add_qualifier(self, value):
        self.qualifier.append(value)
    def insert_qualifier_at(self, index, value):
        self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value):
        self.qualifier[index] = value
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.originalText is not None or
            self.qualifier or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CD'):
        super(CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CD', fromsubclass_=False, pretty_print=True):
        super(CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            qualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'originalText', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_originalText'):
              self.add_originalText(obj_.value)
            elif hasattr(self, 'set_originalText'):
              self.set_originalText(obj_.value)
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'qualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_qualifier'):
              self.add_qualifier(obj_.value)
            elif hasattr(self, 'set_qualifier'):
              self.set_qualifier(obj_.value)
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = CD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CD, self)._buildChildren(child_, node, nodeName_, True)
# end class CD


class CE(CD):
    """CE --
    Coded data, consists of a coded value (CV)
    and, optionally, coded value(s) from other coding systems
    that identify the same concept. Used when alternative
    codes may exist.
      
    * code --
      The plain code symbol defined by the code system.
      For example, "784.0" is the code symbol of the ICD-9
      code "784.0" for headache.
      
    * codeSystem --
      Specifies the code system that defines the code.
      
    * codeSystemName --
      A common name of the coding system.
      
    * codeSystemVersion --
      If applicable, a version descriptor defined
      specifically for the given code system.
      
    * displayName --
      A name or title for the code, under which the sending
      system shows the code value to its users.
      
    * originalText --
      The text or phrase used as the basis for the coding.
      
    * translation --
      A set of other concept descriptors that translate
      this concept descriptor into other code systems.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CE"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CE.subclass:
            return CE.subclass(*args_, **kwargs_)
        else:
            return CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.originalText is not None or
            self.qualifier is not None or
            self.translation or
            super(CE, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CE'):
        super(CE, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.qualifier is not None:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            self.qualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CE, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'
# end class CE


class CV(CE):
    """CV --
    Coded data, consists of a code, display name, code system,
    and original text. Used when a single code value must be sent.
      
    * code --
      The plain code symbol defined by the code system.
      For example, "784.0" is the code symbol of the ICD-9
      code "784.0" for headache.
      
    * codeSystem --
      Specifies the code system that defines the code.
      
    * codeSystemName --
      A common name of the coding system.
      
    * codeSystemVersion --
      If applicable, a version descriptor defined
      specifically for the given code system.
      
    * displayName --
      A name or title for the code, under which the sending
      system shows the code value to its users.
      
    * originalText --
      The text or phrase used as the basis for the coding.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CV"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.translation = translation
        self.translation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV.subclass:
            return CV.subclass(*args_, **kwargs_)
        else:
            return CV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.originalText is not None or
            self.translation is not None or
            super(CV, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CV', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CV':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CV'):
        super(CV, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.translation is not None:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            self.translation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CV, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation = obj_
            obj_.original_tagname_ = 'translation'
# end class CV


class CS(CV):
    """CS --
    Coded data, consists of a code, display name, code system,
    and original text. Used when a single code value must be sent.
      
    * code --
      The plain code symbol defined by the code system.
      For example, "784.0" is the code symbol of the ICD-9
      code "784.0" for headache.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CS"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CS.subclass:
            return CS.subclass(*args_, **kwargs_)
        else:
            return CS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(CS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CS'):
        super(CS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CS


class CO(CV):
    """CO --
    Coded data, where the domain from which the codeset comes
    is ordered. The Coded Ordinal data type adds semantics
    related to ordering so that models that make use of such
    domains may introduce model elements that involve statements
    about the order of the terms in a domain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CO"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CO.subclass:
            return CO.subclass(*args_, **kwargs_)
        else:
            return CO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(CO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CO'):
        super(CO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', fromsubclass_=False, pretty_print=True):
        super(CO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CO


class CR(ANY):
    """CR --
    A concept qualifier code with optionally named role.
    Both qualifier role and value codes must be defined by
    the coding system.  For example, if SNOMED RT defines a
    concept "leg", a role relation "has-laterality", and
    another concept "left", the concept role relation allows
    to add the qualifier "has-laterality: left" to a primary
    code "leg" to construct the meaning "left leg".
      
    * inverted --
      Indicates if the sense of the role name is inverted.
      This can be used in cases where the underlying code
      system defines inversion but does not provide reciprocal
      pairs of role names. By default, inverted is false.
      
    * name --
      Specifies the manner in which the concept role value
      contributes to the meaning of a code phrase.  For
      example, if SNOMED RT defines a concept "leg", a role
      relation "has-laterality", and another concept "left",
      the concept role relation allows to add the qualifier
      "has-laterality: left" to a primary code "leg" to
      construct the meaning "left leg".  In this example
      "has-laterality" is .
      
    * value --
      The concept that modifies the primary code of a code
      phrase through the role relation.  For example, if
      SNOMED RT defines a concept "leg", a role relation
      "has-laterality", and another concept "left", the
      concept role relation allows adding the qualifier
      "has-laterality: left" to a primary code "leg" to
      construct the meaning "left leg".  In this example
      "left" is .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, inverted: 'bn' = 'false', name: 'CV' = None, value: 'CD' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CR"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inverted = _cast(bool, inverted)
        self.inverted_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CR.subclass:
            return CR.subclass(*args_, **kwargs_)
        else:
            return CR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_inverted(self):
        return self.inverted
    def set_inverted(self, inverted):
        self.inverted = inverted
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.name is not None or
            self.value is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CR, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CR'):
        super(CR, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        if self.inverted != "false" and 'inverted' not in already_processed:
            already_processed.add('inverted')
            outfile.write(' inverted=%s' % (quote_attrib(self.inverted), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='CR', fromsubclass_=False, pretty_print=True):
        super(CR, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inverted', node)
        if value is not None and 'inverted' not in already_processed:
            already_processed.add('inverted')
            if value in ('true', '1'):
                self.inverted = True
            elif value in ('false', '0'):
                self.inverted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.inverted)    # validate type bn
        super(CR, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CV)
            class_obj_ = CV.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'name', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_name'):
              self.add_name(obj_.value)
            elif hasattr(self, 'set_name'):
              self.set_name(obj_.value)
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CR, self)._buildChildren(child_, node, nodeName_, True)
# end class CR


class SC(ST):
    """SC --
    An ST that optionally may have a code attached.
    The text must always be present if a code is present. The
    code is often a local code.
      
    * code --
      The plain code symbol defined by the code system.
      For example, "784.0" is the code symbol of the ICD-9
      code "784.0" for headache.
      
    * codeSystem --
      Specifies the code system that defines the code.
      
    * codeSystemName --
      A common name of the coding system.
      
    * codeSystemVersion --
      If applicable, a version descriptor defined
      specifically for the given code system.
      
    * displayName --
      A name or title for the code, under which the sending
      system shows the code value to its users.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SC"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SC.subclass:
            return SC.subclass(*args_, **kwargs_)
        else:
            return SC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SC, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SC':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SC'):
        super(SC, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', fromsubclass_=False, pretty_print=True):
        super(SC, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(SC, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SC, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SC


class II(ANY):
    """II --
    An identifier that uniquely identifies a thing or object.
    Examples are object identifier for HL7 RIM objects,
    medical record number, order id, service catalog item id,
    Vehicle Identification Number (VIN), etc. Instance
    identifiers are defined based on ISO object identifiers.
      
    * root --
      A unique identifier that guarantees the global uniqueness
      of the instance identifier. The root alone may be the
      entire instance identifier.
      
    * extension --
      A character string as a unique identifier within the
      scope of the identifier root.
      
    * assigningAuthorityName --
      A human readable name or mnemonic for the assigning
      authority. This name may be provided solely for the
      convenience of unaided humans interpreting an  value
      and can have no computational meaning. Note: no
      automated processing must depend on the assigning
      authority name to be present in any form.
      
    * displayable --
      Specifies if the identifier is intended for human
      display and data entry (displayable = true) as
      opposed to pure machine interoperation (displayable
      = false).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, root: 'uid' = None, extension: 'st' = None, assigningAuthorityName: 'st' = None, displayable: 'bl' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("II"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.assigningAuthorityName_nsprefix_ = None
        self.displayable = _cast(bool, displayable)
        self.displayable_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II.subclass:
            return II.subclass(*args_, **kwargs_)
        else:
            return II(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def get_assigningAuthorityName(self):
        return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName):
        self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self):
        return self.displayable
    def set_displayable(self, displayable):
        self.displayable = displayable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(II, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'II':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='II'):
        super(II, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.assigningAuthorityName), input_name='assigningAuthorityName')), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable="%s"' % self.gds_format_boolean(self.displayable, input_name='displayable'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', fromsubclass_=False, pretty_print=True):
        super(II, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            if value in ('true', '1'):
                self.displayable = True
            elif value in ('false', '0'):
                self.displayable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.displayable)    # validate type bl
        super(II, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(II, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class II


class URL(ANY):
    """URL --
    A telecommunications address  specified according to
    Internet standard RFC 1738
    [http://www.ietf.org/rfc/rfc1738.txt]. The
    URL specifies the protocol and the contact point defined
    by that protocol for the resource.  Notable uses of the
    telecommunication address data type are for telephone and
    telefax numbers, e-mail addresses, Hypertext references,
    FTP references, etc.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'url' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("URL"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL.subclass:
            return URL.subclass(*args_, **kwargs_)
        else:
            return URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_url(self, value):
        # Validate type url, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(URL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URL'):
        super(URL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', fromsubclass_=False, pretty_print=True):
        super(URL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_url(self.value)    # validate type url
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(URL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(URL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class URL


class TEL(URL):
    """TEL --
    A telephone number (voice or fax), e-mail address, or
    other locator for a resource (information or service)
    mediated by telecommunication equipment. The address
    is specified as a URL
    qualified by time specification and use codes that help
    in deciding which address to use for a given time and
    purpose.
      
    * use --
      One or more codes advising a system or user which
      telecommunication address in a set of like addresses
      to select for a given telecommunication need.
      
    * useablePeriod --
      Specifies the periods of time during which the
      telecommunication address can be used.  For a
      telephone number, this can indicate the time of day
      in which the party can be reached on that telephone.
      For a web address, it may specify a time range in
      which the web content is promised to be available
      under the given address.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = URL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'url' = None, use: 'set_TelecommunicationAddressUse' = None, useablePeriod: List_['SXCM_TS'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TEL"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEL.subclass:
            return TEL.subclass(*args_, **kwargs_)
        else:
            return TEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_TelecommunicationAddressUse(self, value):
        # Validate type set_TelecommunicationAddressUse, a restriction on TelecommunicationAddressUse.
        pass
    def has__content(self):
        if (
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TEL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='TEL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEL'):
        super(TEL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='TEL', fromsubclass_=False, pretty_print=True):
        super(TEL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_TelecommunicationAddressUse(self.use.split())    # validate type set_TelecommunicationAddressUse
        super(TEL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            class_obj_ = SXCM_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TEL, self)._buildChildren(child_, node, nodeName_, True)
# end class TEL


class ADXP(ST):
    """ADXP --
    A character string that may have a type-tag signifying its
    role in the address. Typical parts that exist in about
    every address are street, house number, or post box,
    postal code, city, country but other roles may be defined
    regionally, nationally, or on an enterprise level (e.g. in
    military addresses). Addresses are usually broken up into
    lines, which are indicated by special line-breaking
    delimiter elements (e.g., DEL).
      
    * partType --
      Specifies whether an address part names the street,
      city, country, postal code, post box, etc. If the type
      is NULL the address part is unclassified and would
      simply appear on an address label as is.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ADXP"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP.subclass:
            return ADXP.subclass(*args_, **kwargs_)
        else:
            return ADXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ADXP, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADXP'):
        super(ADXP, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', fromsubclass_=False, pretty_print=True):
        super(ADXP, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(ADXP, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ADXP, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ADXP


class adxp_delimiter(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_delimiter"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_delimiter.subclass:
            return adxp_delimiter.subclass(*args_, **kwargs_)
        else:
            return adxp_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_delimiter, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.delimiter'):
        super(adxp_delimiter, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        if self.partType != "DEL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_delimiter, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_delimiter


class adxp_country(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_country"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_country.subclass:
            return adxp_country.subclass(*args_, **kwargs_)
        else:
            return adxp_country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_country, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.country':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.country'):
        super(adxp_country, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        if self.partType != "CNT" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_country, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_country


class adxp_state(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_state"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_state)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_state.subclass:
            return adxp_state.subclass(*args_, **kwargs_)
        else:
            return adxp_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_state, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.state')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.state':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.state'):
        super(adxp_state, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        if self.partType != "STA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_state, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_state


class adxp_county(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_county"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_county)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_county.subclass:
            return adxp_county.subclass(*args_, **kwargs_)
        else:
            return adxp_county(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_county, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.county')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.county':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.county'):
        super(adxp_county, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        if self.partType != "CPA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_county, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_county


class adxp_city(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_city"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_city)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_city.subclass:
            return adxp_city.subclass(*args_, **kwargs_)
        else:
            return adxp_city(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_city, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.city')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.city':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.city'):
        super(adxp_city, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        if self.partType != "CTY" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_city, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_city


class adxp_postalCode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_postalCode"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postalCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postalCode.subclass:
            return adxp_postalCode.subclass(*args_, **kwargs_)
        else:
            return adxp_postalCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postalCode, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postalCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postalCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postalCode'):
        super(adxp_postalCode, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        if self.partType != "ZIP" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postalCode, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postalCode


class adxp_streetAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetAddressLine"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetAddressLine.subclass:
            return adxp_streetAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_streetAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetAddressLine, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetAddressLine'):
        super(adxp_streetAddressLine, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        if self.partType != "SAL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetAddressLine, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetAddressLine


class adxp_houseNumber(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_houseNumber"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumber.subclass:
            return adxp_houseNumber.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumber, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumber')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumber':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumber'):
        super(adxp_houseNumber, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        if self.partType != "BNR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumber, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumber


class adxp_houseNumberNumeric(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_houseNumberNumeric"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumberNumeric)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumberNumeric.subclass:
            return adxp_houseNumberNumeric.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumberNumeric(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumberNumeric, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumberNumeric')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumberNumeric':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumberNumeric'):
        super(adxp_houseNumberNumeric, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        if self.partType != "BNN" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumberNumeric, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumberNumeric


class adxp_direction(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_direction"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_direction.subclass:
            return adxp_direction.subclass(*args_, **kwargs_)
        else:
            return adxp_direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_direction, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.direction'):
        super(adxp_direction, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        if self.partType != "DIR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_direction, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_direction


class adxp_streetName(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetName"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetName.subclass:
            return adxp_streetName.subclass(*args_, **kwargs_)
        else:
            return adxp_streetName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetName, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetName'):
        super(adxp_streetName, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        if self.partType != "STR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetName, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetName


class adxp_streetNameBase(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetNameBase"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameBase.subclass:
            return adxp_streetNameBase.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameBase, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameBase'):
        super(adxp_streetNameBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        if self.partType != "STB" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameBase


class adxp_streetNameType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetNameType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameType.subclass:
            return adxp_streetNameType.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameType'):
        super(adxp_streetNameType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        if self.partType != "STTYP" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameType


class adxp_additionalLocator(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_additionalLocator"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_additionalLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_additionalLocator.subclass:
            return adxp_additionalLocator.subclass(*args_, **kwargs_)
        else:
            return adxp_additionalLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_additionalLocator, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.additionalLocator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.additionalLocator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.additionalLocator'):
        super(adxp_additionalLocator, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        if self.partType != "ADL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_additionalLocator, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_additionalLocator


class adxp_unitID(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_unitID"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitID.subclass:
            return adxp_unitID.subclass(*args_, **kwargs_)
        else:
            return adxp_unitID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitID, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitID':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitID'):
        super(adxp_unitID, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        if self.partType != "UNID" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitID, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitID


class adxp_unitType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_unitType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitType.subclass:
            return adxp_unitType.subclass(*args_, **kwargs_)
        else:
            return adxp_unitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitType'):
        super(adxp_unitType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        if self.partType != "UNIT" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitType


class adxp_careOf(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_careOf"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_careOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_careOf.subclass:
            return adxp_careOf.subclass(*args_, **kwargs_)
        else:
            return adxp_careOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_careOf, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.careOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.careOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.careOf'):
        super(adxp_careOf, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        if self.partType != "CAR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_careOf, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_careOf


class adxp_censusTract(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_censusTract"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_censusTract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_censusTract.subclass:
            return adxp_censusTract.subclass(*args_, **kwargs_)
        else:
            return adxp_censusTract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_censusTract, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.censusTract')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.censusTract':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.censusTract'):
        super(adxp_censusTract, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        if self.partType != "CEN" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_censusTract, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_censusTract


class adxp_deliveryAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryAddressLine"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryAddressLine.subclass:
            return adxp_deliveryAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryAddressLine, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryAddressLine'):
        super(adxp_deliveryAddressLine, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        if self.partType != "DAL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryAddressLine, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryAddressLine


class adxp_deliveryInstallationType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationType.subclass:
            return adxp_deliveryInstallationType.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationType'):
        super(adxp_deliveryInstallationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        if self.partType != "DINST" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationType


class adxp_deliveryInstallationArea(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationArea"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationArea.subclass:
            return adxp_deliveryInstallationArea.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationArea, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationArea':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationArea'):
        super(adxp_deliveryInstallationArea, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        if self.partType != "DINSTA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationArea, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationArea


class adxp_deliveryInstallationQualifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationQualifier"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationQualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationQualifier.subclass:
            return adxp_deliveryInstallationQualifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationQualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationQualifier, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationQualifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationQualifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationQualifier'):
        super(adxp_deliveryInstallationQualifier, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        if self.partType != "DINSTQ" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationQualifier, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationQualifier


class adxp_deliveryMode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryMode"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryMode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryMode.subclass:
            return adxp_deliveryMode.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryMode, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryMode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryMode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryMode'):
        super(adxp_deliveryMode, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        if self.partType != "DMOD" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryMode, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryMode


class adxp_deliveryModeIdentifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryModeIdentifier"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryModeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryModeIdentifier.subclass:
            return adxp_deliveryModeIdentifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryModeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryModeIdentifier, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryModeIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryModeIdentifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryModeIdentifier'):
        super(adxp_deliveryModeIdentifier, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        if self.partType != "DMODID" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryModeIdentifier, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryModeIdentifier


class adxp_buildingNumberSuffix(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_buildingNumberSuffix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_buildingNumberSuffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_buildingNumberSuffix.subclass:
            return adxp_buildingNumberSuffix.subclass(*args_, **kwargs_)
        else:
            return adxp_buildingNumberSuffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_buildingNumberSuffix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.buildingNumberSuffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.buildingNumberSuffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.buildingNumberSuffix'):
        super(adxp_buildingNumberSuffix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        if self.partType != "BNS" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_buildingNumberSuffix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_buildingNumberSuffix


class adxp_postBox(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_postBox"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postBox.subclass:
            return adxp_postBox.subclass(*args_, **kwargs_)
        else:
            return adxp_postBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postBox, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postBox':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postBox'):
        super(adxp_postBox, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        if self.partType != "POB" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postBox, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postBox


class adxp_precinct(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_precinct"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_precinct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_precinct.subclass:
            return adxp_precinct.subclass(*args_, **kwargs_)
        else:
            return adxp_precinct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADL', 'AL', 'BNN', 'BNR', 'BNS', 'CAR', 'CEN', 'CNT', 'CPA', 'CTY', 'DAL', 'DEL', 'DINST', 'DINSTA', 'DINSTQ', 'DIR', 'DMOD', 'DMODID', 'INT', 'POB', 'PRE', 'SAL', 'STA', 'STB', 'STR', 'STTYP', 'UNID', 'UNIT', 'ZIP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AddressPartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressPartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AddressPartType_patterns_, ))
    validate_AddressPartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_precinct, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.precinct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.precinct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.precinct'):
        super(adxp_precinct, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        if self.partType != "PRE" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_precinct, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_precinct


class AD(ANY):
    """AD --
    Mailing and home or office addresses. A sequence of
    address parts, such as street or post office Box, city,
    postal code, country, etc.
      
    * use --
      A set of codes advising a system or user which address
      in a set of like addresses to select for a given purpose.
      
    * isNotOrdered --
      A boolean value specifying whether the order of the
      address parts is known or not. While the address parts
      are always a Sequence, the order in which they are
      presented may or may not be known. Where this matters,
      can be used to convey this
      information.
      
    * useablePeriod --
      A GTS specifying the
      periods of time during which the address can be used.
      This is used to specify different addresses for
      different times of the year or to refer to historical
      addresses.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_PostalAddressUse' = None, isNotOrdered: 'bl' = None, delimiter: List_['adxp.delimiter'] = None, country: List_['adxp.country'] = None, state: List_['adxp.state'] = None, county: List_['adxp.county'] = None, city: List_['adxp.city'] = None, postalCode: List_['adxp.postalCode'] = None, streetAddressLine: List_['adxp.streetAddressLine'] = None, houseNumber: List_['adxp.houseNumber'] = None, houseNumberNumeric: List_['adxp.houseNumberNumeric'] = None, direction: List_['adxp.direction'] = None, streetName: List_['adxp.streetName'] = None, streetNameBase: List_['adxp.streetNameBase'] = None, streetNameType: List_['adxp.streetNameType'] = None, additionalLocator: List_['adxp.additionalLocator'] = None, unitID: List_['adxp.unitID'] = None, unitType: List_['adxp.unitType'] = None, careOf: List_['adxp.careOf'] = None, censusTract: List_['adxp.censusTract'] = None, deliveryAddressLine: List_['adxp.deliveryAddressLine'] = None, deliveryInstallationType: List_['adxp.deliveryInstallationType'] = None, deliveryInstallationArea: List_['adxp.deliveryInstallationArea'] = None, deliveryInstallationQualifier: List_['adxp.deliveryInstallationQualifier'] = None, deliveryMode: List_['adxp.deliveryMode'] = None, deliveryModeIdentifier: List_['adxp.deliveryModeIdentifier'] = None, buildingNumberSuffix: List_['adxp.buildingNumberSuffix'] = None, postBox: List_['adxp.postBox'] = None, precinct: List_['adxp.precinct'] = None, useablePeriod: List_['SXCM_TS'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AD"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        self.isNotOrdered = _cast(bool, isNotOrdered)
        self.isNotOrdered_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if country is None:
            self.country = []
        else:
            self.country = country
        self.country_nsprefix_ = None
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = None
        if county is None:
            self.county = []
        else:
            self.county = county
        self.county_nsprefix_ = None
        if city is None:
            self.city = []
        else:
            self.city = city
        self.city_nsprefix_ = None
        if postalCode is None:
            self.postalCode = []
        else:
            self.postalCode = postalCode
        self.postalCode_nsprefix_ = None
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        self.streetAddressLine_nsprefix_ = None
        if houseNumber is None:
            self.houseNumber = []
        else:
            self.houseNumber = houseNumber
        self.houseNumber_nsprefix_ = None
        if houseNumberNumeric is None:
            self.houseNumberNumeric = []
        else:
            self.houseNumberNumeric = houseNumberNumeric
        self.houseNumberNumeric_nsprefix_ = None
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        self.direction_nsprefix_ = None
        if streetName is None:
            self.streetName = []
        else:
            self.streetName = streetName
        self.streetName_nsprefix_ = None
        if streetNameBase is None:
            self.streetNameBase = []
        else:
            self.streetNameBase = streetNameBase
        self.streetNameBase_nsprefix_ = None
        if streetNameType is None:
            self.streetNameType = []
        else:
            self.streetNameType = streetNameType
        self.streetNameType_nsprefix_ = None
        if additionalLocator is None:
            self.additionalLocator = []
        else:
            self.additionalLocator = additionalLocator
        self.additionalLocator_nsprefix_ = None
        if unitID is None:
            self.unitID = []
        else:
            self.unitID = unitID
        self.unitID_nsprefix_ = None
        if unitType is None:
            self.unitType = []
        else:
            self.unitType = unitType
        self.unitType_nsprefix_ = None
        if careOf is None:
            self.careOf = []
        else:
            self.careOf = careOf
        self.careOf_nsprefix_ = None
        if censusTract is None:
            self.censusTract = []
        else:
            self.censusTract = censusTract
        self.censusTract_nsprefix_ = None
        if deliveryAddressLine is None:
            self.deliveryAddressLine = []
        else:
            self.deliveryAddressLine = deliveryAddressLine
        self.deliveryAddressLine_nsprefix_ = None
        if deliveryInstallationType is None:
            self.deliveryInstallationType = []
        else:
            self.deliveryInstallationType = deliveryInstallationType
        self.deliveryInstallationType_nsprefix_ = None
        if deliveryInstallationArea is None:
            self.deliveryInstallationArea = []
        else:
            self.deliveryInstallationArea = deliveryInstallationArea
        self.deliveryInstallationArea_nsprefix_ = None
        if deliveryInstallationQualifier is None:
            self.deliveryInstallationQualifier = []
        else:
            self.deliveryInstallationQualifier = deliveryInstallationQualifier
        self.deliveryInstallationQualifier_nsprefix_ = None
        if deliveryMode is None:
            self.deliveryMode = []
        else:
            self.deliveryMode = deliveryMode
        self.deliveryMode_nsprefix_ = None
        if deliveryModeIdentifier is None:
            self.deliveryModeIdentifier = []
        else:
            self.deliveryModeIdentifier = deliveryModeIdentifier
        self.deliveryModeIdentifier_nsprefix_ = None
        if buildingNumberSuffix is None:
            self.buildingNumberSuffix = []
        else:
            self.buildingNumberSuffix = buildingNumberSuffix
        self.buildingNumberSuffix_nsprefix_ = None
        if postBox is None:
            self.postBox = []
        else:
            self.postBox = postBox
        self.postBox_nsprefix_ = None
        if precinct is None:
            self.precinct = []
        else:
            self.precinct = precinct
        self.precinct_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD.subclass:
            return AD.subclass(*args_, **kwargs_)
        else:
            return AD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def add_country(self, value):
        self.country.append(value)
    def insert_country_at(self, index, value):
        self.country.insert(index, value)
    def replace_country_at(self, index, value):
        self.country[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def get_county(self):
        return self.county
    def set_county(self, county):
        self.county = county
    def add_county(self, value):
        self.county.append(value)
    def insert_county_at(self, index, value):
        self.county.insert(index, value)
    def replace_county_at(self, index, value):
        self.county[index] = value
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def add_city(self, value):
        self.city.append(value)
    def insert_city_at(self, index, value):
        self.city.insert(index, value)
    def replace_city_at(self, index, value):
        self.city[index] = value
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def add_postalCode(self, value):
        self.postalCode.append(value)
    def insert_postalCode_at(self, index, value):
        self.postalCode.insert(index, value)
    def replace_postalCode_at(self, index, value):
        self.postalCode[index] = value
    def get_streetAddressLine(self):
        return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine):
        self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value):
        self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value):
        self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value):
        self.streetAddressLine[index] = value
    def get_houseNumber(self):
        return self.houseNumber
    def set_houseNumber(self, houseNumber):
        self.houseNumber = houseNumber
    def add_houseNumber(self, value):
        self.houseNumber.append(value)
    def insert_houseNumber_at(self, index, value):
        self.houseNumber.insert(index, value)
    def replace_houseNumber_at(self, index, value):
        self.houseNumber[index] = value
    def get_houseNumberNumeric(self):
        return self.houseNumberNumeric
    def set_houseNumberNumeric(self, houseNumberNumeric):
        self.houseNumberNumeric = houseNumberNumeric
    def add_houseNumberNumeric(self, value):
        self.houseNumberNumeric.append(value)
    def insert_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric.insert(index, value)
    def replace_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric[index] = value
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def add_direction(self, value):
        self.direction.append(value)
    def insert_direction_at(self, index, value):
        self.direction.insert(index, value)
    def replace_direction_at(self, index, value):
        self.direction[index] = value
    def get_streetName(self):
        return self.streetName
    def set_streetName(self, streetName):
        self.streetName = streetName
    def add_streetName(self, value):
        self.streetName.append(value)
    def insert_streetName_at(self, index, value):
        self.streetName.insert(index, value)
    def replace_streetName_at(self, index, value):
        self.streetName[index] = value
    def get_streetNameBase(self):
        return self.streetNameBase
    def set_streetNameBase(self, streetNameBase):
        self.streetNameBase = streetNameBase
    def add_streetNameBase(self, value):
        self.streetNameBase.append(value)
    def insert_streetNameBase_at(self, index, value):
        self.streetNameBase.insert(index, value)
    def replace_streetNameBase_at(self, index, value):
        self.streetNameBase[index] = value
    def get_streetNameType(self):
        return self.streetNameType
    def set_streetNameType(self, streetNameType):
        self.streetNameType = streetNameType
    def add_streetNameType(self, value):
        self.streetNameType.append(value)
    def insert_streetNameType_at(self, index, value):
        self.streetNameType.insert(index, value)
    def replace_streetNameType_at(self, index, value):
        self.streetNameType[index] = value
    def get_additionalLocator(self):
        return self.additionalLocator
    def set_additionalLocator(self, additionalLocator):
        self.additionalLocator = additionalLocator
    def add_additionalLocator(self, value):
        self.additionalLocator.append(value)
    def insert_additionalLocator_at(self, index, value):
        self.additionalLocator.insert(index, value)
    def replace_additionalLocator_at(self, index, value):
        self.additionalLocator[index] = value
    def get_unitID(self):
        return self.unitID
    def set_unitID(self, unitID):
        self.unitID = unitID
    def add_unitID(self, value):
        self.unitID.append(value)
    def insert_unitID_at(self, index, value):
        self.unitID.insert(index, value)
    def replace_unitID_at(self, index, value):
        self.unitID[index] = value
    def get_unitType(self):
        return self.unitType
    def set_unitType(self, unitType):
        self.unitType = unitType
    def add_unitType(self, value):
        self.unitType.append(value)
    def insert_unitType_at(self, index, value):
        self.unitType.insert(index, value)
    def replace_unitType_at(self, index, value):
        self.unitType[index] = value
    def get_careOf(self):
        return self.careOf
    def set_careOf(self, careOf):
        self.careOf = careOf
    def add_careOf(self, value):
        self.careOf.append(value)
    def insert_careOf_at(self, index, value):
        self.careOf.insert(index, value)
    def replace_careOf_at(self, index, value):
        self.careOf[index] = value
    def get_censusTract(self):
        return self.censusTract
    def set_censusTract(self, censusTract):
        self.censusTract = censusTract
    def add_censusTract(self, value):
        self.censusTract.append(value)
    def insert_censusTract_at(self, index, value):
        self.censusTract.insert(index, value)
    def replace_censusTract_at(self, index, value):
        self.censusTract[index] = value
    def get_deliveryAddressLine(self):
        return self.deliveryAddressLine
    def set_deliveryAddressLine(self, deliveryAddressLine):
        self.deliveryAddressLine = deliveryAddressLine
    def add_deliveryAddressLine(self, value):
        self.deliveryAddressLine.append(value)
    def insert_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine.insert(index, value)
    def replace_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine[index] = value
    def get_deliveryInstallationType(self):
        return self.deliveryInstallationType
    def set_deliveryInstallationType(self, deliveryInstallationType):
        self.deliveryInstallationType = deliveryInstallationType
    def add_deliveryInstallationType(self, value):
        self.deliveryInstallationType.append(value)
    def insert_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType.insert(index, value)
    def replace_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType[index] = value
    def get_deliveryInstallationArea(self):
        return self.deliveryInstallationArea
    def set_deliveryInstallationArea(self, deliveryInstallationArea):
        self.deliveryInstallationArea = deliveryInstallationArea
    def add_deliveryInstallationArea(self, value):
        self.deliveryInstallationArea.append(value)
    def insert_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea.insert(index, value)
    def replace_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea[index] = value
    def get_deliveryInstallationQualifier(self):
        return self.deliveryInstallationQualifier
    def set_deliveryInstallationQualifier(self, deliveryInstallationQualifier):
        self.deliveryInstallationQualifier = deliveryInstallationQualifier
    def add_deliveryInstallationQualifier(self, value):
        self.deliveryInstallationQualifier.append(value)
    def insert_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier.insert(index, value)
    def replace_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier[index] = value
    def get_deliveryMode(self):
        return self.deliveryMode
    def set_deliveryMode(self, deliveryMode):
        self.deliveryMode = deliveryMode
    def add_deliveryMode(self, value):
        self.deliveryMode.append(value)
    def insert_deliveryMode_at(self, index, value):
        self.deliveryMode.insert(index, value)
    def replace_deliveryMode_at(self, index, value):
        self.deliveryMode[index] = value
    def get_deliveryModeIdentifier(self):
        return self.deliveryModeIdentifier
    def set_deliveryModeIdentifier(self, deliveryModeIdentifier):
        self.deliveryModeIdentifier = deliveryModeIdentifier
    def add_deliveryModeIdentifier(self, value):
        self.deliveryModeIdentifier.append(value)
    def insert_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier.insert(index, value)
    def replace_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier[index] = value
    def get_buildingNumberSuffix(self):
        return self.buildingNumberSuffix
    def set_buildingNumberSuffix(self, buildingNumberSuffix):
        self.buildingNumberSuffix = buildingNumberSuffix
    def add_buildingNumberSuffix(self, value):
        self.buildingNumberSuffix.append(value)
    def insert_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix.insert(index, value)
    def replace_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix[index] = value
    def get_postBox(self):
        return self.postBox
    def set_postBox(self, postBox):
        self.postBox = postBox
    def add_postBox(self, value):
        self.postBox.append(value)
    def insert_postBox_at(self, index, value):
        self.postBox.insert(index, value)
    def replace_postBox_at(self, index, value):
        self.postBox[index] = value
    def get_precinct(self):
        return self.precinct
    def set_precinct(self, precinct):
        self.precinct = precinct
    def add_precinct(self, value):
        self.precinct.append(value)
    def insert_precinct_at(self, index, value):
        self.precinct.insert(index, value)
    def replace_precinct_at(self, index, value):
        self.precinct[index] = value
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_isNotOrdered(self):
        return self.isNotOrdered
    def set_isNotOrdered(self, isNotOrdered):
        self.isNotOrdered = isNotOrdered
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_PostalAddressUse(self, value):
        # Validate type set_PostalAddressUse, a restriction on PostalAddressUse.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.delimiter or
            self.country or
            self.state or
            self.county or
            self.city or
            self.postalCode or
            self.streetAddressLine or
            self.houseNumber or
            self.houseNumberNumeric or
            self.direction or
            self.streetName or
            self.streetNameBase or
            self.streetNameType or
            self.additionalLocator or
            self.unitID or
            self.unitType or
            self.careOf or
            self.censusTract or
            self.deliveryAddressLine or
            self.deliveryInstallationType or
            self.deliveryInstallationArea or
            self.deliveryInstallationQualifier or
            self.deliveryMode or
            self.deliveryModeIdentifier or
            self.buildingNumberSuffix or
            self.postBox or
            self.precinct or
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(AD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='AD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AD'):
        super(AD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.isNotOrdered is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            outfile.write(' isNotOrdered="%s"' % self.gds_format_boolean(self.isNotOrdered, input_name='isNotOrdered'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='AD', fromsubclass_=False, pretty_print=True):
        super(AD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for country_ in self.country:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            country_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='country', pretty_print=pretty_print)
        for state_ in self.state:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        for county_ in self.county:
            namespaceprefix_ = self.county_nsprefix_ + ':' if (UseCapturedNS_ and self.county_nsprefix_) else ''
            county_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            city_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='city', pretty_print=pretty_print)
        for postalCode_ in self.postalCode:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            postalCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            namespaceprefix_ = self.streetAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.streetAddressLine_nsprefix_) else ''
            streetAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetAddressLine', pretty_print=pretty_print)
        for houseNumber_ in self.houseNumber:
            namespaceprefix_ = self.houseNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumber_nsprefix_) else ''
            houseNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumber', pretty_print=pretty_print)
        for houseNumberNumeric_ in self.houseNumberNumeric:
            namespaceprefix_ = self.houseNumberNumeric_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumberNumeric_nsprefix_) else ''
            houseNumberNumeric_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumberNumeric', pretty_print=pretty_print)
        for direction_ in self.direction:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            direction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        for streetName_ in self.streetName:
            namespaceprefix_ = self.streetName_nsprefix_ + ':' if (UseCapturedNS_ and self.streetName_nsprefix_) else ''
            streetName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetName', pretty_print=pretty_print)
        for streetNameBase_ in self.streetNameBase:
            namespaceprefix_ = self.streetNameBase_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameBase_nsprefix_) else ''
            streetNameBase_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameBase', pretty_print=pretty_print)
        for streetNameType_ in self.streetNameType:
            namespaceprefix_ = self.streetNameType_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameType_nsprefix_) else ''
            streetNameType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameType', pretty_print=pretty_print)
        for additionalLocator_ in self.additionalLocator:
            namespaceprefix_ = self.additionalLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalLocator_nsprefix_) else ''
            additionalLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalLocator', pretty_print=pretty_print)
        for unitID_ in self.unitID:
            namespaceprefix_ = self.unitID_nsprefix_ + ':' if (UseCapturedNS_ and self.unitID_nsprefix_) else ''
            unitID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitID', pretty_print=pretty_print)
        for unitType_ in self.unitType:
            namespaceprefix_ = self.unitType_nsprefix_ + ':' if (UseCapturedNS_ and self.unitType_nsprefix_) else ''
            unitType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitType', pretty_print=pretty_print)
        for careOf_ in self.careOf:
            namespaceprefix_ = self.careOf_nsprefix_ + ':' if (UseCapturedNS_ and self.careOf_nsprefix_) else ''
            careOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='careOf', pretty_print=pretty_print)
        for censusTract_ in self.censusTract:
            namespaceprefix_ = self.censusTract_nsprefix_ + ':' if (UseCapturedNS_ and self.censusTract_nsprefix_) else ''
            censusTract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='censusTract', pretty_print=pretty_print)
        for deliveryAddressLine_ in self.deliveryAddressLine:
            namespaceprefix_ = self.deliveryAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryAddressLine_nsprefix_) else ''
            deliveryAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryAddressLine', pretty_print=pretty_print)
        for deliveryInstallationType_ in self.deliveryInstallationType:
            namespaceprefix_ = self.deliveryInstallationType_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationType_nsprefix_) else ''
            deliveryInstallationType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationType', pretty_print=pretty_print)
        for deliveryInstallationArea_ in self.deliveryInstallationArea:
            namespaceprefix_ = self.deliveryInstallationArea_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationArea_nsprefix_) else ''
            deliveryInstallationArea_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationArea', pretty_print=pretty_print)
        for deliveryInstallationQualifier_ in self.deliveryInstallationQualifier:
            namespaceprefix_ = self.deliveryInstallationQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationQualifier_nsprefix_) else ''
            deliveryInstallationQualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationQualifier', pretty_print=pretty_print)
        for deliveryMode_ in self.deliveryMode:
            namespaceprefix_ = self.deliveryMode_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryMode_nsprefix_) else ''
            deliveryMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryMode', pretty_print=pretty_print)
        for deliveryModeIdentifier_ in self.deliveryModeIdentifier:
            namespaceprefix_ = self.deliveryModeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryModeIdentifier_nsprefix_) else ''
            deliveryModeIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryModeIdentifier', pretty_print=pretty_print)
        for buildingNumberSuffix_ in self.buildingNumberSuffix:
            namespaceprefix_ = self.buildingNumberSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.buildingNumberSuffix_nsprefix_) else ''
            buildingNumberSuffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buildingNumberSuffix', pretty_print=pretty_print)
        for postBox_ in self.postBox:
            namespaceprefix_ = self.postBox_nsprefix_ + ':' if (UseCapturedNS_ and self.postBox_nsprefix_) else ''
            postBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postBox', pretty_print=pretty_print)
        for precinct_ in self.precinct:
            namespaceprefix_ = self.precinct_nsprefix_ + ':' if (UseCapturedNS_ and self.precinct_nsprefix_) else ''
            precinct_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precinct', pretty_print=pretty_print)
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_PostalAddressUse(self.use.split())    # validate type set_PostalAddressUse
        value = find_attr_value_('isNotOrdered', node)
        if value is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            if value in ('true', '1'):
                self.isNotOrdered = True
            elif value in ('false', '0'):
                self.isNotOrdered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isNotOrdered)    # validate type bl
        super(AD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = adxp_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'country':
            obj_ = adxp_country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'country', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_country'):
              self.add_country(obj_.value)
            elif hasattr(self, 'set_country'):
              self.set_country(obj_.value)
        elif nodeName_ == 'state':
            obj_ = adxp_state.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'county':
            obj_ = adxp_county.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'county', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_county'):
              self.add_county(obj_.value)
            elif hasattr(self, 'set_county'):
              self.set_county(obj_.value)
        elif nodeName_ == 'city':
            obj_ = adxp_city.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'city', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_city'):
              self.add_city(obj_.value)
            elif hasattr(self, 'set_city'):
              self.set_city(obj_.value)
        elif nodeName_ == 'postalCode':
            obj_ = adxp_postalCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = adxp_streetAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        elif nodeName_ == 'houseNumber':
            obj_ = adxp_houseNumber.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumber', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumber'):
              self.add_houseNumber(obj_.value)
            elif hasattr(self, 'set_houseNumber'):
              self.set_houseNumber(obj_.value)
        elif nodeName_ == 'houseNumberNumeric':
            obj_ = adxp_houseNumberNumeric.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumberNumeric', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumberNumeric'):
              self.add_houseNumberNumeric(obj_.value)
            elif hasattr(self, 'set_houseNumberNumeric'):
              self.set_houseNumberNumeric(obj_.value)
        elif nodeName_ == 'direction':
            obj_ = adxp_direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'direction', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_direction'):
              self.add_direction(obj_.value)
            elif hasattr(self, 'set_direction'):
              self.set_direction(obj_.value)
        elif nodeName_ == 'streetName':
            obj_ = adxp_streetName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetName', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetName'):
              self.add_streetName(obj_.value)
            elif hasattr(self, 'set_streetName'):
              self.set_streetName(obj_.value)
        elif nodeName_ == 'streetNameBase':
            obj_ = adxp_streetNameBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameBase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameBase'):
              self.add_streetNameBase(obj_.value)
            elif hasattr(self, 'set_streetNameBase'):
              self.set_streetNameBase(obj_.value)
        elif nodeName_ == 'streetNameType':
            obj_ = adxp_streetNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameType'):
              self.add_streetNameType(obj_.value)
            elif hasattr(self, 'set_streetNameType'):
              self.set_streetNameType(obj_.value)
        elif nodeName_ == 'additionalLocator':
            obj_ = adxp_additionalLocator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'additionalLocator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_additionalLocator'):
              self.add_additionalLocator(obj_.value)
            elif hasattr(self, 'set_additionalLocator'):
              self.set_additionalLocator(obj_.value)
        elif nodeName_ == 'unitID':
            obj_ = adxp_unitID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitID', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitID'):
              self.add_unitID(obj_.value)
            elif hasattr(self, 'set_unitID'):
              self.set_unitID(obj_.value)
        elif nodeName_ == 'unitType':
            obj_ = adxp_unitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitType'):
              self.add_unitType(obj_.value)
            elif hasattr(self, 'set_unitType'):
              self.set_unitType(obj_.value)
        elif nodeName_ == 'careOf':
            obj_ = adxp_careOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'careOf', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_careOf'):
              self.add_careOf(obj_.value)
            elif hasattr(self, 'set_careOf'):
              self.set_careOf(obj_.value)
        elif nodeName_ == 'censusTract':
            obj_ = adxp_censusTract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'censusTract', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_censusTract'):
              self.add_censusTract(obj_.value)
            elif hasattr(self, 'set_censusTract'):
              self.set_censusTract(obj_.value)
        elif nodeName_ == 'deliveryAddressLine':
            obj_ = adxp_deliveryAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryAddressLine'):
              self.add_deliveryAddressLine(obj_.value)
            elif hasattr(self, 'set_deliveryAddressLine'):
              self.set_deliveryAddressLine(obj_.value)
        elif nodeName_ == 'deliveryInstallationType':
            obj_ = adxp_deliveryInstallationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationType'):
              self.add_deliveryInstallationType(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationType'):
              self.set_deliveryInstallationType(obj_.value)
        elif nodeName_ == 'deliveryInstallationArea':
            obj_ = adxp_deliveryInstallationArea.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationArea', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationArea'):
              self.add_deliveryInstallationArea(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationArea'):
              self.set_deliveryInstallationArea(obj_.value)
        elif nodeName_ == 'deliveryInstallationQualifier':
            obj_ = adxp_deliveryInstallationQualifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationQualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationQualifier'):
              self.add_deliveryInstallationQualifier(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationQualifier'):
              self.set_deliveryInstallationQualifier(obj_.value)
        elif nodeName_ == 'deliveryMode':
            obj_ = adxp_deliveryMode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryMode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryMode'):
              self.add_deliveryMode(obj_.value)
            elif hasattr(self, 'set_deliveryMode'):
              self.set_deliveryMode(obj_.value)
        elif nodeName_ == 'deliveryModeIdentifier':
            obj_ = adxp_deliveryModeIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryModeIdentifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryModeIdentifier'):
              self.add_deliveryModeIdentifier(obj_.value)
            elif hasattr(self, 'set_deliveryModeIdentifier'):
              self.set_deliveryModeIdentifier(obj_.value)
        elif nodeName_ == 'buildingNumberSuffix':
            obj_ = adxp_buildingNumberSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'buildingNumberSuffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_buildingNumberSuffix'):
              self.add_buildingNumberSuffix(obj_.value)
            elif hasattr(self, 'set_buildingNumberSuffix'):
              self.set_buildingNumberSuffix(obj_.value)
        elif nodeName_ == 'postBox':
            obj_ = adxp_postBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postBox', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postBox'):
              self.add_postBox(obj_.value)
            elif hasattr(self, 'set_postBox'):
              self.set_postBox(obj_.value)
        elif nodeName_ == 'precinct':
            obj_ = adxp_precinct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'precinct', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_precinct'):
              self.add_precinct(obj_.value)
            elif hasattr(self, 'set_precinct'):
              self.set_precinct(obj_.value)
        elif nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            class_obj_ = SXCM_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD, self)._buildChildren(child_, node, nodeName_, True)
# end class AD


class ENXP(ST):
    """ENXP --
    A character string token representing a part of a name.
    May have a type code signifying the role of the part in
    the whole entity name, and a qualifier code for more detail
    about the name part type. Typical name parts for person
    names are given names, and family names, titles, etc.
      
    * partType --
      Indicates whether the name part is a given name, family
      name, prefix, suffix, etc.
      
    * qualifier --  is a set of codes each of which specifies
      a certain subcategory of the name part in addition to
      the main name part type. For example, a given name may
      be flagged as a nickname, a family name may be a
      pseudonym or a name of public records.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ENXP"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENXP.subclass:
            return ENXP.subclass(*args_, **kwargs_)
        else:
            return ENXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def validate_set_EntityNamePartQualifier(self, value):
        # Validate type set_EntityNamePartQualifier, a restriction on EntityNamePartQualifier.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ENXP, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ENXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ENXP'):
        super(ENXP, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', fromsubclass_=False, pretty_print=True):
        super(ENXP, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
            self.qualifier = ' '.join(self.qualifier.split())
            self.validate_set_EntityNamePartQualifier(self.qualifier.split())    # validate type set_EntityNamePartQualifier
        super(ENXP, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ENXP, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ENXP


class en_delimiter(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_delimiter"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_delimiter.subclass:
            return en_delimiter.subclass(*args_, **kwargs_)
        else:
            return en_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_delimiter, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.delimiter'):
        super(en_delimiter, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        if self.partType != "DEL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_delimiter, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_delimiter


class en_family(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_family"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_family)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_family.subclass:
            return en_family.subclass(*args_, **kwargs_)
        else:
            return en_family(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_family, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.family')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.family':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.family'):
        super(en_family, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        if self.partType != "FAM" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_family, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_family


class en_given(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_given"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_given)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_given.subclass:
            return en_given.subclass(*args_, **kwargs_)
        else:
            return en_given(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_given, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.given')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.given':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.given'):
        super(en_given, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        if self.partType != "GIV" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_given, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_given


class en_prefix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_prefix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_prefix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_prefix.subclass:
            return en_prefix.subclass(*args_, **kwargs_)
        else:
            return en_prefix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_prefix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.prefix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.prefix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.prefix'):
        super(en_prefix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        if self.partType != "PFX" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_prefix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_prefix


class en_suffix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_suffix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_suffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_suffix.subclass:
            return en_suffix.subclass(*args_, **kwargs_)
        else:
            return en_suffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEL', 'FAM', 'GIV', 'PFX', 'SFX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityNamePartType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityNamePartType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityNamePartType_patterns_, ))
    validate_EntityNamePartType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_suffix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.suffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.suffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.suffix'):
        super(en_suffix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        if self.partType != "SFX" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_suffix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_suffix


class EN(ANY):
    """EN --
    A name for a person, organization, place or thing. A
    sequence of name parts, such as given name or family
    name, prefix, suffix, etc. Examples for entity name
    values are "Jim Bob Walton, Jr.", "Health Level Seven,
    Inc.", "Lake Tahoe", etc. An entity name may be as simple
    as a character string or may consist of several entity name
    parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health
    Level Seven" and "Inc.", "Lake" and "Tahoe".
      
    * use --
      A set of codes advising a system or user which name
      in a set of like names to select for a given purpose.
      A name without specific use code might be a default
      name useful for any purpose, but a name with a specific
      use code would be preferred for that respective purpose.
      
    * validTime --
      An interval of time specifying the time during which
      the name is or was used for the entity. This
      accomodates the fact that people change names for
      people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EN"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if family is None:
            self.family = []
        else:
            self.family = family
        self.family_nsprefix_ = None
        if given is None:
            self.given = []
        else:
            self.given = given
        self.given_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EN.subclass:
            return EN.subclass(*args_, **kwargs_)
        else:
            return EN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    def add_family(self, value):
        self.family.append(value)
    def insert_family_at(self, index, value):
        self.family.insert(index, value)
    def replace_family_at(self, index, value):
        self.family[index] = value
    def get_given(self):
        return self.given
    def set_given(self, given):
        self.given = given
    def add_given(self, value):
        self.given.append(value)
    def insert_given_at(self, index, value):
        self.given.insert(index, value)
    def replace_given_at(self, index, value):
        self.given[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def has__content(self):
        if (
            self.delimiter or
            self.family or
            self.given or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EN'):
        super(EN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EN', fromsubclass_=False, pretty_print=True):
        super(EN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for family_ in self.family:
            namespaceprefix_ = self.family_nsprefix_ + ':' if (UseCapturedNS_ and self.family_nsprefix_) else ''
            family_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='family', pretty_print=pretty_print)
        for given_ in self.given:
            namespaceprefix_ = self.given_nsprefix_ + ':' if (UseCapturedNS_ and self.given_nsprefix_) else ''
            given_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='given', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use.split())    # validate type set_EntityNameUse
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EN, self)._buildChildren(child_, node, nodeName_, True)
# end class EN


class PN(EN):
    """PN --
    A name for a person. A sequence of name parts, such as
    given name or family name, prefix, suffix, etc. PN differs
    from EN because the qualifier type cannot include LS
    (Legal Status).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PN"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN.subclass:
            return PN.subclass(*args_, **kwargs_)
        else:
            return PN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PN'):
        super(PN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', fromsubclass_=False, pretty_print=True):
        super(PN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PN


class ON(EN):
    """ON --
    A name for an organization. A sequence of name parts.
      
    * use --
      A set of codes advising a system or user which name
      in a set of like names to select for a given purpose.
      A name without specific use code might be a default
      name useful for any purpose, but a name with a specific
      use code would be preferred for that respective purpose.
      
    * validTime --
      An interval of time specifying the time during which
      the name is or was used for the entity. This
      accomodates the fact that people change names for
      people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ON"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ON)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ON.subclass:
            return ON.subclass(*args_, **kwargs_)
        else:
            return ON(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def has__content(self):
        if (
            self.delimiter or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ON, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ON', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ON')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ON':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ON'):
        super(ON, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ON', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use.split())    # validate type set_EntityNameUse
        super(ON, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ON


class TN(EN):
    """TN --
    A restriction of entity name that is effectively a simple string used
    for a simple name for things and places.
      
    * validTime --
      An interval of time specifying the time during which
      the name is or was used for the entity. This
      accomodates the fact that people change names for
      people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TN"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TN.subclass:
            return TN.subclass(*args_, **kwargs_)
        else:
            return TN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='TN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TN'):
        super(TN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='TN', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TN


class QTY(ANY):
    """QTY --  is an abstract generalization
    for all data types (1) whose value set has an order
    relation (less-or-equal) and (2) where difference is
    defined in all of the data type's totally ordered value
    subsets.  The quantity type abstraction is needed in
    defining certain other types, such as the interval and
    the probability distribution.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QTY"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QTY.subclass:
            return QTY.subclass(*args_, **kwargs_)
        else:
            return QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(QTY, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QTY'):
        super(QTY, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', fromsubclass_=False, pretty_print=True):
        super(QTY, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QTY, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(QTY, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QTY


class INT(QTY):
    """INT --
    Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
    numbers that are results of counting and enumerating.
    Integer numbers are discrete, the set of integers is
    infinite but countable.  No arbitrary limit is imposed on
    the range of integer numbers. Two NULL flavors are
    defined for the positive and negative infinity.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("INT"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT.subclass:
            return INT.subclass(*args_, **kwargs_)
        else:
            return INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT'):
        super(INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', fromsubclass_=False, pretty_print=True):
        super(INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
            self.validate_int(self.value)    # validate type int
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class INT


class REAL(QTY):
    """REAL --
    Fractional numbers. Typically used whenever quantities
    are measured, estimated, or computed from other real
    numbers.  The typical representation is decimal, where
    the number of significant decimal digits is known as the
    precision. Real numbers are needed beyond integers
    whenever quantities of the real world are measured,
    estimated, or computed from other real numbers. The term
    "Real number" in this specification is used to mean
    that fractional values are covered without necessarily
    implying the full set of the mathematical real numbers.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("REAL"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL.subclass:
            return REAL.subclass(*args_, **kwargs_)
        else:
            return REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REAL'):
        super(REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', fromsubclass_=False, pretty_print=True):
        super(REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class REAL


class PQR(CV):
    """PQR --
    A representation of a physical quantity in a unit from
    any code system. Used to show alternative representation
    for a physical quantity.
      
    * value --
      The magnitude of the measurement value in terms of
      the unit specified in the code.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, value: 'real' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PQR"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQR.subclass:
            return PQR.subclass(*args_, **kwargs_)
        else:
            return PQR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def has__content(self):
        if (
            super(PQR, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PQR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQR'):
        super(PQR, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', fromsubclass_=False, pretty_print=True):
        super(PQR, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        super(PQR, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PQR, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PQR


class PQ(QTY):
    """PQ --
    A dimensioned quantity expressing the result of a
    measurement act.
      
    * value --
      The magnitude of the quantity measured in terms of
      the unit.
      
    * unit --
      The unit of measure specified in the Unified Code for
      Units of Measure (UCUM)
      [http://aurora.rg.iupui.edu/UCUM].
      
    * translation --
      An alternative representation of the same physical
      quantity expressed in a different unit, of a different
      unit code system and possibly with a different value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQ.subclass:
            return PQ.subclass(*args_, **kwargs_)
        else:
            return PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQ'):
        super(PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit != "1" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PQ', fromsubclass_=False, pretty_print=True):
        super(PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_cs(self.unit)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'translation':
            obj_ = PQR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class PQ


class MO(QTY):
    """MO --
    A monetary amount is a quantity expressing the amount of
    money in some currency. Currencies are the units in which
    monetary amounts are denominated in different economic
    regions. While the monetary amount is a single kind of
    quantity (money) the exchange rates between the different
    units are variable.  This is the principle difference
    between physical quantity and monetary amounts, and the
    reason why currency units are not physical units.
      
    * value --
      The magnitude of the monetary amount in terms of the
      currency unit.
      
    * currency --
      The currency unit as defined in ISO 4217.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MO"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.currency = _cast(None, currency)
        self.currency_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MO.subclass:
            return MO.subclass(*args_, **kwargs_)
        else:
            return MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MO'):
        super(MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', fromsubclass_=False, pretty_print=True):
        super(MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
            self.currency = ' '.join(self.currency.split())
            self.validate_cs(self.currency)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MO


class EIVL_event(CE):
    """EIVL.event --
    A code for a common (periodical) activity of daily
    living based on which the event related periodic
    interval is specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_event"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_event.subclass:
            return EIVL_event.subclass(*args_, **kwargs_)
        else:
            return EIVL_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def validate_TimingEvent(self, value):
        # Validate type TimingEvent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'ACD', 'ACM', 'ACV', 'C', 'CD', 'CM', 'CV', 'HS', 'IC', 'ICD', 'ICM', 'ICV', 'PC', 'PCD', 'PCM', 'PCV', 'WAKE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimingEvent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TimingEvent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TimingEvent_patterns_, ))
    validate_TimingEvent_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(EIVL_event, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL.event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL.event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL.event', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL.event'):
        super(EIVL_event, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem != "2.16.840.1.113883.5.139" and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName != "TimingEvent" and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_TimingEvent(self.code)    # validate type TimingEvent
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        super(EIVL_event, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EIVL_event


class RTO_QTY_QTY(QTY):
    """numerator --
    The quantity that is being divided in the ratio.  The
    default is the integer number 1 (one).
      
    * denominator --
      The quantity that devides the numerator in the ratio.
      The default is the integer number 1 (one).
      The denominator must not be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_QTY_QTY"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_QTY_QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_QTY_QTY.subclass:
            return RTO_QTY_QTY.subclass(*args_, **kwargs_)
        else:
            return RTO_QTY_QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def set_numerator_with_type(self, value):
        self.numerator = value
        value.original_tagname_ = 'numerator'
        value.extensiontype_ = value.__class__.__name__
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def set_denominator_with_type(self, value):
        self.denominator = value
        value.original_tagname_ = 'denominator'
        value.extensiontype_ = value.__class__.__name__
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO_QTY_QTY, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_QTY_QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_QTY_QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_QTY_QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_QTY_QTY'):
        super(RTO_QTY_QTY, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_QTY_QTY', fromsubclass_=False, pretty_print=True):
        super(RTO_QTY_QTY, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            self.numerator.export(outfile, level, namespaceprefix_, name_='numerator', namespacedef_='', pretty_print=pretty_print)
        if self.denominator is not None:
            self.denominator.export(outfile, level, namespaceprefix_, name_='denominator', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RTO_QTY_QTY, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <numerator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <denominator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_QTY_QTY, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_QTY_QTY


class precondition(GeneratedsSuper):
    """precondition -- L
    ’
    elemento entry/act/entryRelationShip/observation/referenceRange/observationRange/precondition se presente DEVE contenere l
    ’
    elemento precondition/criterion che DEVE contenere:
    active, nel caso in cui lo stato di produzione dei risultati sia parziale;
    completed, nel caso in cui lo stato di produzione dei risultati sia completo.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'PRCN', typeId: 'POCD_MT000040UV02.InfrastructureRoot.typeId' = None, criterion: 'labCriterion' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = "cdaGen"
        self.criterion = criterion
        self.criterion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, precondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if precondition.subclass:
            return precondition.subclass(*args_, **kwargs_)
        else:
            return precondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type cdaGen:NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActRelationshipType(self, value):
        # Validate type cdaGen:ActRelationshipType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APND', 'ARR', 'AUTH', 'BLOCK', 'BSLN', 'CAUS', 'CHRG', 'CIND', 'COMP', 'COMPLY', 'CONCURRENT', 'COST', 'COVBY', 'CREDIT', 'CTRLV', 'CURE', 'CURE.ADJ', 'DEBIT', 'DEP', 'DIAG', 'DOC', 'DRIV', 'DURING', 'EAE', 'EAS', 'EBS', 'ECW', 'EDU', 'ELNK', 'EVID', 'EXACBY', 'EXPL', 'FLFS', 'GEN', 'GEVL', 'GOAL', 'INST', 'ITEMSLOC', 'LIMIT', 'META', 'MFST', 'MITGT', 'MOD', 'MTCH', 'MTGT.ADJ', 'NAME', 'OBJC', 'OBJF', 'OCCR', 'OPTN', 'OREF', 'OUTC', 'OVERLAP', 'PERT', 'PRCN', 'PREV', 'RCHAL', 'RCVY', 'REFR', 'REFV', 'RELVBY', 'REV', 'RISK', 'RPLC', 'RSON', 'SAE', 'SAS', 'SBS', 'SCH', 'SCW', 'SDU', 'SEQL', 'SPRT', 'SPRTBND', 'SUBJ', 'SUCC', 'SUMM', 'SYMP', 'TRIG', 'UPDT', 'USE', 'VRXCRPT', 'XCRPT', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipType_patterns_, ))
    validate_ActRelationshipType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.typeId is not None or
            self.criterion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:cdaGen="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:sdtc" ', name_='precondition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('precondition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'precondition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='precondition')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='precondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='precondition'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCN" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:cdaGen="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:sdtc" ', name_='precondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        if self.criterion is not None:
            namespaceprefix_ = self.criterion_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion_nsprefix_) else ''
            self.criterion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeId':
            obj_ = POCD_MT000040UV02_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'criterion':
            obj_ = labCriterion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion = obj_
            obj_.original_tagname_ = 'criterion'
# end class precondition


class labCriterion(GeneratedsSuper):
    """labCriterion -- L
    ’
    elemento entry/act/entryRelationShip/observation/referenceRange/observationRange/precondition se presente DEVE contenere l
    ’
    elemento precondition/criterion che DEVE contenere:
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'COND', moodCode: 'ActMood' = 'EVN', code: 'CE' = None, value: 'ANY' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = "cdaGen"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, labCriterion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if labCriterion.subclass:
            return labCriterion.subclass(*args_, **kwargs_)
        else:
            return labCriterion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type cdaGen:NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASKU', 'DER', 'INV', 'MSK', 'NA', 'NASK', 'NAV', 'NI', 'NINF', 'OTH', 'PINF', 'QS', 'TRC', 'UNC', 'UNK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NullFlavor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_NullFlavor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NullFlavor_patterns_, ))
    validate_NullFlavor_patterns_ = [['^([^\\s]+)$']]
    def validate_ActClassObservation(self, value):
        # Validate type cdaGen:ActClassObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OBS', 'ROIBND', 'ROIOVL', 'LLD', 'PRN', 'RLD', 'SFWL', 'SIT', 'STN', 'SUP', 'RTRD', 'TRD', 'ALRT', 'BATTERY', 'CLNTRL', 'CNOD', 'CONC', 'COND', 'CASE', 'OUTB', 'DGIMG', 'GEN', 'DETPOL', 'EXP', 'LOC', 'PHN', 'POL', 'SEQ', 'SEQVAR', 'INVSTG', 'OBSSER', 'OBSCOR', 'POS', 'POSACC', 'POSCOORD', 'SPCOBS', 'VERIF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassObservation_patterns_, ))
    validate_ActClassObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type cdaGen:ActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['APT', 'ARQ', 'CRT', 'DEF', 'EVN', 'EVN.CRT', 'EXPEC', 'GOL', 'INT', 'OPT', 'PERM', 'PERMRQ', 'PRMS', 'PRP', 'RMD', 'RQO', 'RSK', 'SLOT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMood_patterns_, ))
    validate_ActMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.code is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:cdaGen="urn:hl7-org:v3" ', name_='labCriterion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('labCriterion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'labCriterion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='labCriterion')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='labCriterion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='labCriterion'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "COND" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc"  xmlns:cdaGen="urn:hl7-org:v3" ', name_='labCriterion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class labCriterion


class statusCode(GeneratedsSuper):
    """statusCode --  Il componente code di statusCode PU
    Ò
    assumere uno dei valori seguenti:
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code: 'codeType' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, statusCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if statusCode.subclass:
            return statusCode.subclass(*args_, **kwargs_)
        else:
            return statusCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def validate_codeType(self, value):
        # Validate type codeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['active', 'completed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on codeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='statusCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('statusCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'statusCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='statusCode')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='statusCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='statusCode'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='statusCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_codeType(self.code)    # validate type codeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class statusCode


class RTO(RTO_QTY_QTY):
    """RTO --
    A quantity constructed as the quotient of a numerator
    quantity divided by a denominator quantity. Common
    factors in the numerator and denominator are not
    automatically cancelled out.   supports titers
    (e.g., "1:128") and other quantities produced by
    laboratories that truly represent ratios. Ratios are
    not simply "structured numerics", particularly blood
    pressure measurements (e.g. "120/60") are not ratios.
    In many cases REAL should be used instead
    of .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RTO_QTY_QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO"), self).__init__(nullFlavor, numerator, denominator, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO.subclass:
            return RTO.subclass(*args_, **kwargs_)
        else:
            return RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO'):
        super(RTO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', fromsubclass_=False, pretty_print=True):
        super(RTO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RTO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RTO


class TS(QTY):
    """TS --
    A quantity specifying a point on the axis of natural time.
    A point in time is most often represented as a calendar
    expression.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TS"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS.subclass:
            return TS.subclass(*args_, **kwargs_)
        else:
            return TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ts(self, value):
        # Validate type ts, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^([0-9]{1,8}|([0-9]{9,14}|[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TS'):
        super(TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', fromsubclass_=False, pretty_print=True):
        super(TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TS


class UVP_TS(TS):
    """probability --
    The probability assigned to the value, a decimal number
    between 0 (very uncertain) and 1 (certain).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, probability: 'probability' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UVP_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.probability = _cast(float, probability)
        self.probability_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UVP_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UVP_TS.subclass:
            return UVP_TS.subclass(*args_, **kwargs_)
        else:
            return UVP_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_probability(self):
        return self.probability
    def set_probability(self, probability):
        self.probability = probability
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_probability(self, value):
        # Validate type probability, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(UVP_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UVP_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UVP_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UVP_TS'):
        super(UVP_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            outfile.write(' probability="%s"' % self.gds_format_double(self.probability, input_name='probability'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', fromsubclass_=False, pretty_print=True):
        super(UVP_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('probability', node)
        if value is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            value = self.gds_parse_double(value, node, 'probability')
            self.probability = value
            self.validate_probability(self.probability)    # validate type probability
        super(UVP_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(UVP_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class UVP_TS


class RTO_MO_PQ(QTY):
    """numerator --
    The quantity that is being divided in the ratio.  The
    default is the integer number 1 (one).
      
    * denominator --
      The quantity that devides the numerator in the ratio.
      The default is the integer number 1 (one).
      The denominator must not be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'MO' = None, denominator: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_MO_PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_MO_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_MO_PQ.subclass:
            return RTO_MO_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_MO_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO_MO_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_MO_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_MO_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_MO_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_MO_PQ'):
        super(RTO_MO_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_MO_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_MO_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RTO_MO_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, MO)
            class_obj_ = MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_MO_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_MO_PQ


class RTO_PQ_PQ(QTY):
    """numerator --
    The quantity that is being divided in the ratio.  The
    default is the integer number 1 (one).
      
    * denominator --
      The quantity that devides the numerator in the ratio.
      The default is the integer number 1 (one).
      The denominator must not be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'PQ' = None, denominator: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_PQ_PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_PQ_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_PQ_PQ.subclass:
            return RTO_PQ_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_PQ_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO_PQ_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_PQ_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_PQ_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_PQ_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_PQ_PQ'):
        super(RTO_PQ_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='RTO_PQ_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_PQ_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RTO_PQ_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_PQ_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_PQ_PQ


class GLIST_PQ(ANY):
    """period --
    If non-NULL, specifies that the sequence alternates,
    i.e., after this many increments, the sequence item
    values roll over to start from the initial sequence
    item value. For example, the sequence (1; 2; 3; 1; 2;
    3; 1; 2; 3; ...) has period 3; also the sequence
    (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
    3 too.
      
    * denominator --
      The integer by which the index for the sequence is
      divided, effectively the number of times the sequence
      generates the same sequence item value before
      incrementing to the next sequence item value. For
      example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
      3; ...)  the denominator is 3.
      
    * head --
      This is the start-value of the generated list.
      
    * increment --
      The difference between one value and its previous
      different value. For example, to generate the sequence
      (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
      generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
      13; ...) the increment is also 3.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, period: 'int' = None, denominator: 'int' = None, head: 'PQ' = None, increment: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GLIST_PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_PQ.subclass:
            return GLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return GLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.head is not None or
            self.increment is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(GLIST_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='GLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_PQ'):
        super(GLIST_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='GLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(GLIST_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'head', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_head'):
              self.add_head(obj_.value)
            elif hasattr(self, 'set_head'):
              self.set_head(obj_.value)
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'increment', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_increment'):
              self.add_increment(obj_.value)
            elif hasattr(self, 'set_increment'):
              self.set_increment(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(GLIST_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class GLIST_PQ


class GLIST_TS(ANY):
    """period --
    If non-NULL, specifies that the sequence alternates,
    i.e., after this many increments, the sequence item
    values roll over to start from the initial sequence
    item value. For example, the sequence (1; 2; 3; 1; 2;
    3; 1; 2; 3; ...) has period 3; also the sequence
    (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
    3 too.
      
    * denominator --
      The integer by which the index for the sequence is
      divided, effectively the number of times the sequence
      generates the same sequence item value before
      incrementing to the next sequence item value. For
      example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
      3; ...)  the denominator is 3.
      
    * head --
      This is the start-value of the generated list.
      
    * increment --
      The difference between one value and its previous
      different value. For example, to generate the sequence
      (1; 4; 7; 10; 13; ...) the increment is 3; likewise to
      generate the sequence (1; 1; 4; 4; 7; 7; 10; 10; 13;
      13; ...) the increment is also 3.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, period: 'int' = None, denominator: 'int' = None, head: 'TS' = None, increment: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GLIST_TS"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_TS.subclass:
            return GLIST_TS.subclass(*args_, **kwargs_)
        else:
            return GLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.head is not None or
            self.increment is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(GLIST_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='GLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_TS'):
        super(GLIST_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='GLIST_TS', fromsubclass_=False, pretty_print=True):
        super(GLIST_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'head', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_head'):
              self.add_head(obj_.value)
            elif hasattr(self, 'set_head'):
              self.set_head(obj_.value)
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'increment', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_increment'):
              self.add_increment(obj_.value)
            elif hasattr(self, 'set_increment'):
              self.set_increment(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(GLIST_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class GLIST_TS


class SLIST_TS(ANY):
    """origin --
    The origin of the list item value scale, i.e., the
    physical quantity that a zero-digit in the sequence
    would represent.
      
    * scale --
      A ratio-scale quantity that is factored out of the
      digit sequence.
      
    * digits --
      A sequence of raw digits for the sample values. This is
      typically the raw output of an A/D converter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, origin: 'TS' = None, scale: 'PQ' = None, digits: 'integer' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SLIST_TS"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_TS.subclass:
            return SLIST_TS.subclass(*args_, **kwargs_)
        else:
            return SLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def has__content(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SLIST_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_TS'):
        super(SLIST_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SLIST_TS', fromsubclass_=False, pretty_print=True):
        super(SLIST_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SLIST_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'origin', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_origin'):
              self.add_origin(obj_.value)
            elif hasattr(self, 'set_origin'):
              self.set_origin(obj_.value)
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'scale', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_scale'):
              self.add_scale(obj_.value)
            elif hasattr(self, 'set_scale'):
              self.set_scale(obj_.value)
        elif nodeName_ == 'digits' and child_.text is not None:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'digits')
            ival_ = self.gds_validate_integer(ival_, node, 'digits')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'digits', ival_)
            self.content_.append(obj_)
            self.digits_nsprefix_ = child_.prefix
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SLIST_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class SLIST_TS


class SLIST_PQ(ANY):
    """origin --
    The origin of the list item value scale, i.e., the
    physical quantity that a zero-digit in the sequence
    would represent.
      
    * scale --
      A ratio-scale quantity that is factored out of the
      digit sequence.
      
    * digits --
      A sequence of raw digits for the sample values. This is
      typically the raw output of an A/D converter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, origin: 'PQ' = None, scale: 'PQ' = None, digits: 'integer' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SLIST_PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_PQ.subclass:
            return SLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return SLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def has__content(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SLIST_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_PQ'):
        super(SLIST_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(SLIST_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SLIST_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'origin', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_origin'):
              self.add_origin(obj_.value)
            elif hasattr(self, 'set_origin'):
              self.set_origin(obj_.value)
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'scale', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_scale'):
              self.add_scale(obj_.value)
            elif hasattr(self, 'set_scale'):
              self.set_scale(obj_.value)
        elif nodeName_ == 'digits' and child_.text is not None:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'digits')
            ival_ = self.gds_validate_integer(ival_, node, 'digits')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'digits', ival_)
            self.content_.append(obj_)
            self.digits_nsprefix_ = child_.prefix
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SLIST_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class SLIST_PQ


class BXIT_CD(CD):
    """qty --
    The quantity in which the bag item occurs in its containing bag.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, qty: 'int' = '1', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BXIT_CD"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_CD.subclass:
            return BXIT_CD.subclass(*args_, **kwargs_)
        else:
            return BXIT_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BXIT_CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_CD'):
        super(BXIT_CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', fromsubclass_=False, pretty_print=True):
        super(BXIT_CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BXIT_CD, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_CD


class HXIT_CE(CE):
    """validTime --
    The time interval during which the given information
    was, is, or is expected to be valid. The interval can
    be open or closed, as well as infinite or undefined on
    either side.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, validTime: 'IVL_TS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HXIT_CE"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_CE.subclass:
            return HXIT_CE.subclass(*args_, **kwargs_)
        else:
            return HXIT_CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def has__content(self):
        if (
            self.validTime is not None or
            super(HXIT_CE, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='HXIT_CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HXIT_CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_CE'):
        super(HXIT_CE, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='HXIT_CE', fromsubclass_=False, pretty_print=True):
        super(HXIT_CE, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HXIT_CE, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTime = obj_
            obj_.original_tagname_ = 'validTime'
        super(HXIT_CE, self)._buildChildren(child_, node, nodeName_, True)
# end class HXIT_CE


class HXIT_PQ(PQ):
    """validTime --
    The time interval during which the given information
    was, is, or is expected to be valid. The interval can
    be open or closed, as well as infinite or undefined on
    either side.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HXIT_PQ"), self).__init__(nullFlavor, value, unit, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_PQ.subclass:
            return HXIT_PQ.subclass(*args_, **kwargs_)
        else:
            return HXIT_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(HXIT_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='HXIT_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_PQ'):
        super(HXIT_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='HXIT_PQ', fromsubclass_=False, pretty_print=True):
        super(HXIT_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HXIT_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(HXIT_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class HXIT_PQ


class IVXB_MO(MO):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_MO"), self).__init__(nullFlavor, value, currency, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_MO.subclass:
            return IVXB_MO.subclass(*args_, **kwargs_)
        else:
            return IVXB_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_MO'):
        super(IVXB_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', fromsubclass_=False, pretty_print=True):
        super(IVXB_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_MO


class IVXB_REAL(REAL):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_REAL"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_REAL.subclass:
            return IVXB_REAL.subclass(*args_, **kwargs_)
        else:
            return IVXB_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_REAL'):
        super(IVXB_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', fromsubclass_=False, pretty_print=True):
        super(IVXB_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_REAL


class IVXB_INT(INT):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_INT"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_INT.subclass:
            return IVXB_INT.subclass(*args_, **kwargs_)
        else:
            return IVXB_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_INT'):
        super(IVXB_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', fromsubclass_=False, pretty_print=True):
        super(IVXB_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_INT


class SXCM_REAL(REAL):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_REAL"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_REAL.subclass:
            return SXCM_REAL.subclass(*args_, **kwargs_)
        else:
            return SXCM_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_REAL'):
        super(SXCM_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', fromsubclass_=False, pretty_print=True):
        super(SXCM_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_REAL


class SXCM_INT(INT):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_INT"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_INT.subclass:
            return SXCM_INT.subclass(*args_, **kwargs_)
        else:
            return SXCM_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_INT'):
        super(SXCM_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', fromsubclass_=False, pretty_print=True):
        super(SXCM_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_INT


class SXCM_MO(MO):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_MO"), self).__init__(nullFlavor, value, currency, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_MO.subclass:
            return SXCM_MO.subclass(*args_, **kwargs_)
        else:
            return SXCM_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_MO'):
        super(SXCM_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', fromsubclass_=False, pretty_print=True):
        super(SXCM_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_MO


class SXCM_CD(CD):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_CD"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_CD.subclass:
            return SXCM_CD.subclass(*args_, **kwargs_)
        else:
            return SXCM_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_CD'):
        super(SXCM_CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', fromsubclass_=False, pretty_print=True):
        super(SXCM_CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        super(SXCM_CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_CD, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_CD


class PPD_PQ(PQ):
    """distributionType --
    A code specifying the type of probability distribution.
    Possible values are as shown in the attached table.
    The NULL value (unknown) for the type code indicates
    that the probability distribution type is unknown. In
    that case, the standard deviation has the meaning of an
    informal guess.
      
    * standardDeviation --
      The primary measure of variance/uncertainty of the
      value (the square root of the sum of the squares of
      the differences between all data points and the mean).
      The standard deviation is used to normalize the data
      for computing the distribution function. Applications
      that cannot deal with probability distributions can
      still get an idea about the confidence level by looking
      at the standard deviation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_PQ.subclass:
            return PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.standardDeviation is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_PQ'):
        super(PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'standardDeviation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_standardDeviation'):
              self.add_standardDeviation(obj_.value)
            elif hasattr(self, 'set_standardDeviation'):
              self.set_standardDeviation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class PPD_PQ


class PPD_TS(TS):
    """distributionType --
    A code specifying the type of probability distribution.
    Possible values are as shown in the attached table.
    The NULL value (unknown) for the type code indicates
    that the probability distribution type is unknown. In
    that case, the standard deviation has the meaning of an
    informal guess.
      
    * standardDeviation --
      The primary measure of variance/uncertainty of the
      value (the square root of the sum of the squares of
      the differences between all data points and the mean).
      The standard deviation is used to normalize the data
      for computing the distribution function. Applications
      that cannot deal with probability distributions can
      still get an idea about the confidence level by looking
      at the standard deviation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PPD_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_TS.subclass:
            return PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.standardDeviation is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_TS'):
        super(PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'standardDeviation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_standardDeviation'):
              self.add_standardDeviation(obj_.value)
            elif hasattr(self, 'set_standardDeviation'):
              self.set_standardDeviation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PPD_TS


class IVXB_PQ(PQ):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PQ"), self).__init__(nullFlavor, value, unit, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PQ.subclass:
            return IVXB_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PQ'):
        super(IVXB_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PQ


class SXCM_PQ(PQ):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PQ"), self).__init__(nullFlavor, value, unit, translation, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PQ.subclass:
            return SXCM_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PQ'):
        super(SXCM_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PQ


class IVXB_RTO(RTO):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RTO
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_RTO"), self).__init__(nullFlavor, numerator, denominator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_RTO.subclass:
            return IVXB_RTO.subclass(*args_, **kwargs_)
        else:
            return IVXB_RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_RTO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_RTO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_RTO'):
        super(IVXB_RTO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_RTO')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_RTO', fromsubclass_=False, pretty_print=True):
        super(IVXB_RTO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_RTO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_RTO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_RTO


class SXCM_RTO(RTO):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RTO
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_RTO"), self).__init__(nullFlavor, numerator, denominator, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_RTO.subclass:
            return SXCM_RTO.subclass(*args_, **kwargs_)
        else:
            return SXCM_RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_RTO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_RTO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_RTO'):
        super(SXCM_RTO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_RTO')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_RTO', fromsubclass_=False, pretty_print=True):
        super(SXCM_RTO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_RTO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_RTO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_RTO


class IVL_RTO(SXCM_RTO):
    """low --
    The low limit of the interval.
      
    * high --
      The high limit of the interval
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_RTO
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, operator: 'SetOperator' = 'I', low: 'IVXB_RTO' = None, high: 'IVXB_RTO' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_RTO"), self).__init__(nullFlavor, numerator, denominator, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_RTO.subclass:
            return IVL_RTO.subclass(*args_, **kwargs_)
        else:
            return IVL_RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_RTO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_RTO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_RTO'):
        super(IVL_RTO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_RTO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_RTO', fromsubclass_=False, pretty_print=True):
        super(IVL_RTO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_RTO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_RTO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_RTO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_RTO, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_RTO


class IVL_PQ(SXCM_PQ):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', low: 'IVXB_PQ' = None, high: 'IVXB_PQ' = None, width: 'PQ' = None, center: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PQ"), self).__init__(nullFlavor, value, unit, translation, operator, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PQ.subclass:
            return IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PQ'):
        super(IVL_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IVL_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PQ


class ED_r2b(BIN):
    """ED.r2b --
    Data t
    hat is primarily intended for human interpretation
    or for further machine processing is outside the scope of
    HL7. This includes unformatted or formatted written language,
    multimedia data, or structured information as defined by a
    different standard (e.g., XML-signatures.)  Instead of the
    data itself, an ED may contain
    only a reference (see TEL.) Note
    that the ST data type is a
    specialization of ED
    when the  is text/plain. When the content is text/plain, the
    content may appear either as the text content of the element,
    or in the value attribute, but not both.
      
    * value --
      The plain text content of the ED. Note that plain text content may
      appear in either the value attribute or the text content of the element,
      but not both.
      
    * mediaType --
      Identifies the type of the encapsulated data and
      identifies a method to interpret or render the data.
      
    * language --
      For character based information the language property
      specifies the human language of the text.
      
    * compression --
      Indicates whether the raw byte data is compressed,
      and what compression algorithm was used.
      
    * integrityCheck --
      The integrity check is a short binary value representing
      a cryptographically strong checksum that is calculated
      over the binary data. The purpose of this property, when
      communicated with a reference is for anyone to validate
      later whether the reference still resolved to the same
      data that the reference resolved to when the encapsulated
      data value with reference was created.
      
    * integrityCheckAlgorithm --
      Specifies the algorithm used to compute the
      integrityCheck value.
      
    * description --
      A stand-in for the full media for use as an alternative description of the media where the media is not accessible for display.
      
    * reference --
      A telecommunication address (TEL), such as a URL
      for HTTP or FTP, which will resolve to precisely
      the same binary data that could as well have been
      provided as inline data.
      
    * thumbnail --
      A thumbnail is an abbreviated rendition of the full data. A thumbnail requires
      significantly fewer resources than the full data, while still maintaining some
      distinctive similarity with the full data. A thumbnail is typically used with
      by-reference encapsulated data. It allows a user to select data more efficiently
      before actually downloading through the reference.
      
    * translation --
      Alternate renditions of the same content translated into a
      different language or a different mediaType. The translation
      property is a set of  that each translate the first rendition
      into different a language or use a different mediaType. Each
      element of the translation set must be a translation of the
      value. Translations may not contain translations.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', value: 'st' = None, mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', description: 'st' = None, reference: 'TEL' = None, thumbnail: 'thumbnail' = None, translation: List_['EDTranslation'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ED_r2b"), self).__init__(nullFlavor, representation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED_r2b)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED_r2b.subclass:
            return ED_r2b.subclass(*args_, **kwargs_)
        else:
            return ED_r2b(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ED_r2b, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ED.r2b', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED.r2b')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ED.r2b':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED.r2b')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ED.r2b'):
        super(ED_r2b, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED.r2b')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ED.r2b', fromsubclass_=False, pretty_print=True):
        super(ED_r2b, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_st(self.value)    # validate type st
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_st(self.description)    # validate type st
        super(ED_r2b, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == 'translation':
            obj_ = EDTranslation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ED_r2b, self)._buildChildren(child_, node, nodeName_, True)
# end class ED_r2b


class EDTranslation(ED_r2b):
    """EDTranslation --
    Alternate renditions of the same content translated into a different
    language or a different mediaType. The translation property is a set
    of  that each translate the first rendition into different a language or use
    a different mediaType. Each element of the translation set must be a
    translation of the  value. Translations may not contain translations. .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED_r2b
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', value: 'st' = None, mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', description: 'st' = None, reference: 'TEL' = None, thumbnail: 'thumbnail' = None, translation: List_['EDTranslation'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EDTranslation"), self).__init__(nullFlavor, representation, value, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, description, reference, thumbnail, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EDTranslation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EDTranslation.subclass:
            return EDTranslation.subclass(*args_, **kwargs_)
        else:
            return EDTranslation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.translation is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EDTranslation, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EDTranslation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EDTranslation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EDTranslation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EDTranslation')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EDTranslation'):
        super(EDTranslation, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EDTranslation')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EDTranslation', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
        if self.translation is not None:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            self.translation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EDTranslation, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == 'translation':
            obj_ = EDTranslation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class EDTranslation


class STTranslation(EDTranslation):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EDTranslation
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', value: 'st' = None, mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', description: 'st' = None, reference: 'TEL' = None, thumbnail: 'thumbnail' = None, translation: List_['EDTranslation'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("STTranslation"), self).__init__(nullFlavor, representation, value, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, description, reference, thumbnail, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STTranslation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STTranslation.subclass:
            return STTranslation.subclass(*args_, **kwargs_)
        else:
            return STTranslation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.translation is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(STTranslation, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='STTranslation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STTranslation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STTranslation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STTranslation')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STTranslation'):
        super(STTranslation, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STTranslation')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='STTranslation', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.translation is not None:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            self.translation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(STTranslation, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'translation':
            obj_ = STTranslation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class STTranslation


class ST_r2b(ED_r2b):
    """ST.r2b --
    The character string data type stands for text data,
    primarily intended for machine processing (e.g.,
    sorting, querying, indexing, etc.) Used for names,
    symbols, and formal expressions. The ST data type
    may have it's data as either the text content of the
    element, or in a value attribute, but not both.
      
    * translation --
      Alternate renditions of the same content translated into a
      different language. Each
      element of the translation set must be a translation of the
      value. Translations may not contain translations.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED_r2b
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', value: 'st' = None, mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', description: 'st' = None, reference: 'TEL' = None, thumbnail: 'thumbnail' = None, translation: List_['EDTranslation'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ST_r2b"), self).__init__(nullFlavor, representation, value, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, description, reference, thumbnail, translation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ST_r2b)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ST_r2b.subclass:
            return ST_r2b.subclass(*args_, **kwargs_)
        else:
            return ST_r2b(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ST_r2b, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ST.r2b', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ST.r2b')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ST.r2b':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST.r2b')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ST.r2b'):
        super(ST_r2b, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST.r2b')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='ST.r2b', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_st(self.value)    # validate type st
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        super(ST_r2b, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = ED_r2b.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == 'translation':
            obj_ = STTranslation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ST_r2b


class POCD_MT000040UV02_RegionOfInterest_value(INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, unsorted: 'boolean' = False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("POCD_MT000040UV02_RegionOfInterest_value"), self).__init__(nullFlavor, value,  **kwargs_)
        self.unsorted = _cast(bool, unsorted)
        self.unsorted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_RegionOfInterest_value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_RegionOfInterest_value.subclass:
            return POCD_MT000040UV02_RegionOfInterest_value.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_RegionOfInterest_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unsorted(self):
        return self.unsorted
    def set_unsorted(self, unsorted):
        self.unsorted = unsorted
    def has__content(self):
        if (
            super(POCD_MT000040UV02_RegionOfInterest_value, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040UV02.RegionOfInterest.value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.RegionOfInterest.value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.RegionOfInterest.value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RegionOfInterest.value')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.RegionOfInterest.value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.RegionOfInterest.value'):
        super(POCD_MT000040UV02_RegionOfInterest_value, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.RegionOfInterest.value')
        if self.unsorted and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            outfile.write(' unsorted="%s"' % self.gds_format_boolean(self.unsorted, input_name='unsorted'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040UV02.RegionOfInterest.value', fromsubclass_=False, pretty_print=True):
        super(POCD_MT000040UV02_RegionOfInterest_value, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unsorted', node)
        if value is not None and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            if value in ('true', '1'):
                self.unsorted = True
            elif value in ('false', '0'):
                self.unsorted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(POCD_MT000040UV02_RegionOfInterest_value, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(POCD_MT000040UV02_RegionOfInterest_value, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class POCD_MT000040UV02_RegionOfInterest_value


class POCD_MT000040UV02_InfrastructureRoot_typeId(II):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = II
    def __init__(self, nullFlavor: 'NullFlavor' = None, root: 'uid' = None, extension: 'st' = None, assigningAuthorityName: 'st' = None, displayable: 'bl' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("POCD_MT000040UV02_InfrastructureRoot_typeId"), self).__init__(nullFlavor, root, extension, assigningAuthorityName, displayable,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040UV02_InfrastructureRoot_typeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040UV02_InfrastructureRoot_typeId.subclass:
            return POCD_MT000040UV02_InfrastructureRoot_typeId.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040UV02_InfrastructureRoot_typeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(POCD_MT000040UV02_InfrastructureRoot_typeId, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040UV02.InfrastructureRoot.typeId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040UV02.InfrastructureRoot.typeId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040UV02.InfrastructureRoot.typeId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.InfrastructureRoot.typeId')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040UV02.InfrastructureRoot.typeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040UV02.InfrastructureRoot.typeId'):
        super(POCD_MT000040UV02_InfrastructureRoot_typeId, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040UV02.InfrastructureRoot.typeId')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040UV02.InfrastructureRoot.typeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        super(POCD_MT000040UV02_InfrastructureRoot_typeId, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class POCD_MT000040UV02_InfrastructureRoot_typeId


class IVXB_TS(TS):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_TS.subclass:
            return IVXB_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_TS'):
        super(IVXB_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_TS


class SXCM_TS(TS):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_TS.subclass:
            return SXCM_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_TS'):
        super(SXCM_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_TS


class BXIT_IVL_PQ(IVL_PQ):
    """qty --
    The quantity in which the bag item occurs in its containing bag.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IVL_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', low: 'IVXB_PQ' = None, high: 'IVXB_PQ' = None, width: 'PQ' = None, center: 'PQ' = None, qty: 'int' = '1', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BXIT_IVL_PQ"), self).__init__(nullFlavor, value, unit, translation, operator, low, high, width, center, valueOf_, mixedclass_, content_,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_IVL_PQ.subclass:
            return BXIT_IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return BXIT_IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BXIT_IVL_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_IVL_PQ'):
        super(BXIT_IVL_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(BXIT_IVL_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_IVL_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BXIT_IVL_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_IVL_PQ


class IVL_MO(SXCM_MO):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, operator: 'SetOperator' = 'I', low: 'IVXB_MO' = None, high: 'IVXB_MO' = None, width: 'MO' = None, center: 'MO' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_MO"), self).__init__(nullFlavor, value, currency, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_MO.subclass:
            return IVL_MO.subclass(*args_, **kwargs_)
        else:
            return IVL_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_MO'):
        super(IVL_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_MO', fromsubclass_=False, pretty_print=True):
        super(IVL_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            class_obj_ = MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, MO)
            class_obj_ = MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            class_obj_ = MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_MO, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_MO


class IVL_REAL(SXCM_REAL):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, operator: 'SetOperator' = 'I', low: 'IVXB_REAL' = None, high: 'IVXB_REAL' = None, width: 'REAL' = None, center: 'REAL' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_REAL"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_REAL.subclass:
            return IVL_REAL.subclass(*args_, **kwargs_)
        else:
            return IVL_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_REAL'):
        super(IVL_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_REAL', fromsubclass_=False, pretty_print=True):
        super(IVL_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            class_obj_ = REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, REAL)
            class_obj_ = REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            class_obj_ = REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_REAL, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_REAL


class IVL_INT(SXCM_INT):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, operator: 'SetOperator' = 'I', low: 'IVXB_INT' = None, high: 'IVXB_INT' = None, width: 'INT' = None, center: 'INT' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_INT"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_INT.subclass:
            return IVL_INT.subclass(*args_, **kwargs_)
        else:
            return IVL_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_INT'):
        super(IVL_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_INT', fromsubclass_=False, pretty_print=True):
        super(IVL_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            class_obj_ = INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, INT)
            class_obj_ = INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            class_obj_ = INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_INT, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_INT


class SXPR_TS(SXCM_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', comp: List_['SXCM_TS'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXPR_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        if comp is None:
            self.comp = []
        else:
            self.comp = comp
        self.comp_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXPR_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXPR_TS.subclass:
            return SXPR_TS.subclass(*args_, **kwargs_)
        else:
            return SXPR_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_comp(self):
        return self.comp
    def set_comp(self, comp):
        self.comp = comp
    def add_comp(self, value):
        self.comp.append(value)
    def insert_comp_at(self, index, value):
        self.comp.insert(index, value)
    def replace_comp_at(self, index, value):
        self.comp[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.comp or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXPR_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SXPR_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXPR_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXPR_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXPR_TS'):
        super(SXPR_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='SXPR_TS', fromsubclass_=False, pretty_print=True):
        super(SXPR_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comp_ in self.comp:
            namespaceprefix_ = self.comp_nsprefix_ + ':' if (UseCapturedNS_ and self.comp_nsprefix_) else ''
            comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SXPR_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'comp':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            class_obj_ = SXCM_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'comp', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_comp'):
              self.add_comp(obj_.value)
            elif hasattr(self, 'set_comp'):
              self.set_comp(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXPR_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class SXPR_TS


class IVXB_PPD_PQ(PPD_PQ):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_PQ.subclass:
            return IVXB_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_PQ'):
        super(IVXB_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_PQ


class SXCM_PPD_PQ(PPD_PQ):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_PQ.subclass:
            return SXCM_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_PQ'):
        super(SXCM_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_PQ


class IVL_PPD_PQ(SXCM_PPD_PQ):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', low: 'IVXB_PPD_PQ' = None, high: 'IVXB_PPD_PQ' = None, width: 'PPD_PQ' = None, center: 'PPD_PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_PQ.subclass:
            return IVL_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_PQ'):
        super(IVL_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_PQ


class IVXB_PPD_TS(PPD_TS):
    """inclusive --
    Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_TS.subclass:
            return IVXB_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_TS'):
        super(IVXB_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_TS


class SXCM_PPD_TS(PPD_TS):
    """operator --
    A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_TS.subclass:
            return SXCM_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_TS'):
        super(SXCM_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_TS


class PIVL_PPD_TS(SXCM_PPD_TS):
    """PIVL_PPD_TS --
    Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition.  However, they are NOT allowed
    by the normative description of this type.  Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
      
    * alignment --
      Specifies if and how the repetitions are aligned to
      the cycles of the underlying calendar (e.g., to
      distinguish every 30 days from "the 5th of every
      month".) A non-aligned periodic interval recurs
      independently from the calendar. An aligned periodic
      interval is synchronized with the calendar.
      
    * institutionSpecified --
      Indicates whether the exact timing is up to the party
      executing the schedule (e.g., to distinguish "every 8
      hours" from "3 times a day".)
      
    * phase --
      A prototype of the repeating interval specifying the
      duration of each occurrence and anchors the periodic
      interval sequence at a certain point in time.
      
    * period --
      A time duration specifying a reciprocal measure of
      the frequency at which the periodic interval repeats.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', alignment: 'CalendarCycle' = None, institutionSpecified: 'bl' = 'false', phase: 'IVL_PPD_TS' = None, period: 'PPD_PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PIVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_PPD_TS.subclass:
            return PIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CD', 'CH', 'CM', 'CN', 'CS', 'CW', 'CY', 'D', 'DM', 'DW', 'DY', 'H', 'HD', 'J', 'M', 'MY', 'N', 'NH', 'S', 'SN', 'W', 'WY', 'Y']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CalendarCycle' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CalendarCycle_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CalendarCycle_patterns_, ))
    validate_CalendarCycle_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.phase is not None or
            self.period is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PIVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_PPD_TS'):
        super(PIVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.alignment = ' '.join(self.alignment.split())
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'phase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_phase'):
              self.add_phase(obj_.value)
            elif hasattr(self, 'set_phase'):
              self.set_phase(obj_.value)
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'period', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_period'):
              self.add_period(obj_.value)
            elif hasattr(self, 'set_period'):
              self.set_period(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PIVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PIVL_PPD_TS


class EIVL_TS(SXCM_TS):
    """EIVL_TS --
    Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition.  However, they are NOT allowed
    by the normative description of this type.  Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
      
    * event --
      A code for a common (periodical) activity of daily
      living based on which the event related periodic
      interval is specified.
      
    * offset --
      An interval of elapsed time (duration, not absolute
      point in time) that marks the offsets for the
      beginning, width and end of the event-related periodic
      interval measured from the time each such event
      actually occurred.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', event: 'EIVL.event' = None, offset: 'IVL_PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_TS.subclass:
            return EIVL_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.event is not None or
            self.offset is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EIVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_TS'):
        super(EIVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EIVL_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EIVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'event', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_event'):
              self.add_event(obj_.value)
            elif hasattr(self, 'set_event'):
              self.set_event(obj_.value)
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            class_obj_ = IVL_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'offset', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_offset'):
              self.add_offset(obj_.value)
            elif hasattr(self, 'set_offset'):
              self.set_offset(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EIVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class EIVL_TS


class PIVL_TS(SXCM_TS):
    """PIVL_TS --
    Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition.  However, they are NOT allowed
    by the normative description of this type.  Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
      
    * alignment --
      Specifies if and how the repetitions are aligned to
      the cycles of the underlying calendar (e.g., to
      distinguish every 30 days from "the 5th of every
      month".) A non-aligned periodic interval recurs
      independently from the calendar. An aligned periodic
      interval is synchronized with the calendar.
      
    * institutionSpecified --
      Indicates whether the exact timing is up to the party
      executing the schedule (e.g., to distinguish "every 8
      hours" from "3 times a day".)
      
    * phase --
      A prototype of the repeating interval specifying the
      duration of each occurrence and anchors the periodic
      interval sequence at a certain point in time.
      
    * period --
      A time duration specifying a reciprocal measure of
      the frequency at which the periodic interval repeats.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', alignment: 'CalendarCycle' = None, institutionSpecified: 'bl' = 'false', phase: 'IVL_TS' = None, period: 'PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PIVL_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_TS.subclass:
            return PIVL_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CD', 'CH', 'CM', 'CN', 'CS', 'CW', 'CY', 'D', 'DM', 'DW', 'DY', 'H', 'HD', 'J', 'M', 'MY', 'N', 'NH', 'S', 'SN', 'W', 'WY', 'Y']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CalendarCycle' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CalendarCycle_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CalendarCycle_patterns_, ))
    validate_CalendarCycle_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.phase is not None or
            self.period is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PIVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_TS'):
        super(PIVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='PIVL_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.alignment = ' '.join(self.alignment.split())
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'phase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_phase'):
              self.add_phase(obj_.value)
            elif hasattr(self, 'set_phase'):
              self.set_phase(obj_.value)
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'period', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_period'):
              self.add_period(obj_.value)
            elif hasattr(self, 'set_period'):
              self.set_period(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PIVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PIVL_TS


class IVL_TS(SXCM_TS):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', low: 'IVXB_TS' = None, high: 'IVXB_TS' = None, width: 'PQ' = None, center: 'TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_TS.subclass:
            return IVL_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_TS'):
        super(IVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_TS


class EIVL_PPD_TS(SXCM_PPD_TS):
    """EIVL_PPD_TS --
    Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition.  However, they are NOT allowed
    by the normative description of this type.  Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
      
    * event --
      A code for a common (periodical) activity of daily
      living based on which the event related periodic
      interval is specified.
      
    * offset --
      An interval of elapsed time (duration, not absolute
      point in time) that marks the offsets for the
      beginning, width and end of the event-related periodic
      interval measured from the time each such event
      actually occurred.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', event: 'EIVL.event' = None, offset: 'IVL_PPD_PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_PPD_TS.subclass:
            return EIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.event is not None or
            self.offset is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EIVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_PPD_TS'):
        super(EIVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='EIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EIVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'event', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_event'):
              self.add_event(obj_.value)
            elif hasattr(self, 'set_event'):
              self.set_event(obj_.value)
        elif nodeName_ == 'offset':
            obj_ = IVL_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'offset', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_offset'):
              self.add_offset(obj_.value)
            elif hasattr(self, 'set_offset'):
              self.set_offset(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EIVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class EIVL_PPD_TS


class IVL_PPD_TS(SXCM_PPD_TS):
    """low --
    The low limit of the interval.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
      
    * high --
      The high limit of the interval.
      
    * center --
      The arithmetic mean of the interval (low plus high
      divided by 2). The purpose of distinguishing the center
      as a semantic property is for conversions of intervals
      from and to point values.
      
    * width --
      The difference between high and low boundary. The
      purpose of distinguishing a width property is to
      handle all cases of incomplete information
      symmetrically. In any interval representation only
      two of the three properties high, low, and width need
      to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', low: 'IVXB_PPD_TS' = None, high: 'IVXB_PPD_TS' = None, width: 'PPD_PQ' = None, center: 'PPD_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_TS.subclass:
            return IVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_TS'):
        super(IVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:sdtc" ', name_='IVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_TS)
            class_obj_ = PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            class_obj_ = PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_TS


#
# End data representation classes.
#


GDSClassesMapping = {
    'ClinicalDocument': POCD_MT000040UV02_ClinicalDocument,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040UV02_ClinicalDocument'
        rootClass = POCD_MT000040UV02_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040UV02_ClinicalDocument'
        rootClass = POCD_MT000040UV02_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040UV02_ClinicalDocument'
        rootClass = POCD_MT000040UV02_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040UV02_ClinicalDocument'
        rootClass = POCD_MT000040UV02_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from it_ext import *\n\n')
        sys.stdout.write('import it_ext as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:hl7-org:sdtc': [],
 'urn:hl7-org:v3': [('StrucDoc_Text',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Title',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Br', 'schema/it_ext/./NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Caption',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Col',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Colgroup',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Content',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_TitleContent',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Footnote',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_TitleFootnote',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_FootnoteRef',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Item',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_LinkHtml',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_List',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Paragraph',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_RenderMultiMedia',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Sub',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Sup',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Table',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Tbody',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Td', 'schema/it_ext/./NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Tfoot',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Th', 'schema/it_ext/./NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Thead',
                     'schema/it_ext/./NarrativeBlock.xsd',
                     'CT'),
                    ('StrucDoc_Tr', 'schema/it_ext/./NarrativeBlock.xsd', 'CT'),
                    ('POCD_MT000040UV02_InfrastructureRoot_typeId',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Act',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_AssignedAuthor',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_AssignedCustodian',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_AssignedEntity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_AssociatedEntity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Authenticator',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Author',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_AuthoringDevice',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Authorization',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Birthplace',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ClinicalDocument',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Component1',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Component2',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Component3',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Component4',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Component5',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Consent',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Consumable',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Criterion',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Custodian',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_CustodianOrganization',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_DataEnterer',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Device',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_DocumentationOf',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_EncompassingEncounter',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Encounter',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_EncounterParticipant',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Entity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Entry',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_EntryRelationship',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ExternalAct',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ExternalDocument',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ExternalObservation',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ExternalProcedure',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Guardian',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_HealthCareFacility',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Informant12',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_InFulfillmentOf',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_IntendedRecipient',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_LabeledDrug',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_LanguageCommunication',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_LegalAuthenticator',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Location',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_MaintainedEntity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ManufacturedProduct',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Material',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_NonXMLBody',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Observation',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ObservationMedia',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ObservationRange',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Order',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Organization',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_OrganizationPartOf',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Organizer',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ParentDocument',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Participant',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Participant2',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Participant3',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ParticipantRole',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Patient',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_PatientRole',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Performer1',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Performer2',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Person',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Place',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_PlayingEntity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Precondition',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Procedure',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Product',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RecordTarget',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Reference',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ReferenceRange',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RegionOfInterest_value',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RegionOfInterest',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RelatedDocument',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RelatedEntity',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_RelatedSubject',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ResponsibleParty',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Section',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_ServiceEvent',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Specimen',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_SpecimenRole',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_StructuredBody',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Subject',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_SubjectPerson',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_SubstanceAdministration',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('POCD_MT000040UV02_Supply',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('ST_r2b', 'schema/it_ext/./POCD_MT000040UV02.xsd', 'CT'),
                    ('STTranslation',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('EDTranslation',
                     'schema/it_ext/./POCD_MT000040UV02.xsd',
                     'CT'),
                    ('ED_r2b', 'schema/it_ext/./POCD_MT000040UV02.xsd', 'CT')],
 'urn:oid:1.3.6.1.4.1.19376.1.3.2': [('labCriterion',
                                      'schema/it_ext/./labExtension_1.2_gen.xsd',
                                      'CT')]}

__all__ = [
    "AD",
    "ADXP",
    "ANY",
    "ANYNonNull",
    "BIN",
    "BL",
    "BN",
    "BXIT_CD",
    "BXIT_IVL_PQ",
    "CD",
    "CE",
    "CO",
    "CR",
    "CS",
    "CV",
    "ED",
    "EDTranslation",
    "ED_r2b",
    "EIVL_PPD_TS",
    "EIVL_TS",
    "EIVL_event",
    "EN",
    "ENXP",
    "GLIST_PQ",
    "GLIST_TS",
    "HXIT_CE",
    "HXIT_PQ",
    "II",
    "INT",
    "IVL_INT",
    "IVL_MO",
    "IVL_PPD_PQ",
    "IVL_PPD_TS",
    "IVL_PQ",
    "IVL_REAL",
    "IVL_RTO",
    "IVL_TS",
    "IVXB_INT",
    "IVXB_MO",
    "IVXB_PPD_PQ",
    "IVXB_PPD_TS",
    "IVXB_PQ",
    "IVXB_REAL",
    "IVXB_RTO",
    "IVXB_TS",
    "MO",
    "ON",
    "PIVL_PPD_TS",
    "PIVL_TS",
    "PN",
    "POCD_MT000040UV02_Act",
    "POCD_MT000040UV02_AssignedAuthor",
    "POCD_MT000040UV02_AssignedCustodian",
    "POCD_MT000040UV02_AssignedEntity",
    "POCD_MT000040UV02_AssociatedEntity",
    "POCD_MT000040UV02_Authenticator",
    "POCD_MT000040UV02_Author",
    "POCD_MT000040UV02_AuthoringDevice",
    "POCD_MT000040UV02_Authorization",
    "POCD_MT000040UV02_Birthplace",
    "POCD_MT000040UV02_ClinicalDocument",
    "POCD_MT000040UV02_Component1",
    "POCD_MT000040UV02_Component2",
    "POCD_MT000040UV02_Component3",
    "POCD_MT000040UV02_Component4",
    "POCD_MT000040UV02_Component5",
    "POCD_MT000040UV02_Consent",
    "POCD_MT000040UV02_Consumable",
    "POCD_MT000040UV02_Criterion",
    "POCD_MT000040UV02_Custodian",
    "POCD_MT000040UV02_CustodianOrganization",
    "POCD_MT000040UV02_DataEnterer",
    "POCD_MT000040UV02_Device",
    "POCD_MT000040UV02_DocumentationOf",
    "POCD_MT000040UV02_EncompassingEncounter",
    "POCD_MT000040UV02_Encounter",
    "POCD_MT000040UV02_EncounterParticipant",
    "POCD_MT000040UV02_Entity",
    "POCD_MT000040UV02_Entry",
    "POCD_MT000040UV02_EntryRelationship",
    "POCD_MT000040UV02_ExternalAct",
    "POCD_MT000040UV02_ExternalDocument",
    "POCD_MT000040UV02_ExternalObservation",
    "POCD_MT000040UV02_ExternalProcedure",
    "POCD_MT000040UV02_Guardian",
    "POCD_MT000040UV02_HealthCareFacility",
    "POCD_MT000040UV02_InFulfillmentOf",
    "POCD_MT000040UV02_Informant12",
    "POCD_MT000040UV02_InfrastructureRoot_typeId",
    "POCD_MT000040UV02_IntendedRecipient",
    "POCD_MT000040UV02_LabeledDrug",
    "POCD_MT000040UV02_LanguageCommunication",
    "POCD_MT000040UV02_LegalAuthenticator",
    "POCD_MT000040UV02_Location",
    "POCD_MT000040UV02_MaintainedEntity",
    "POCD_MT000040UV02_ManufacturedProduct",
    "POCD_MT000040UV02_Material",
    "POCD_MT000040UV02_NonXMLBody",
    "POCD_MT000040UV02_Observation",
    "POCD_MT000040UV02_ObservationMedia",
    "POCD_MT000040UV02_ObservationRange",
    "POCD_MT000040UV02_Order",
    "POCD_MT000040UV02_Organization",
    "POCD_MT000040UV02_OrganizationPartOf",
    "POCD_MT000040UV02_Organizer",
    "POCD_MT000040UV02_ParentDocument",
    "POCD_MT000040UV02_Participant",
    "POCD_MT000040UV02_Participant2",
    "POCD_MT000040UV02_Participant3",
    "POCD_MT000040UV02_ParticipantRole",
    "POCD_MT000040UV02_Patient",
    "POCD_MT000040UV02_PatientRole",
    "POCD_MT000040UV02_Performer1",
    "POCD_MT000040UV02_Performer2",
    "POCD_MT000040UV02_Person",
    "POCD_MT000040UV02_Place",
    "POCD_MT000040UV02_PlayingEntity",
    "POCD_MT000040UV02_Precondition",
    "POCD_MT000040UV02_Procedure",
    "POCD_MT000040UV02_Product",
    "POCD_MT000040UV02_RecordTarget",
    "POCD_MT000040UV02_Reference",
    "POCD_MT000040UV02_ReferenceRange",
    "POCD_MT000040UV02_RegionOfInterest",
    "POCD_MT000040UV02_RegionOfInterest_value",
    "POCD_MT000040UV02_RelatedDocument",
    "POCD_MT000040UV02_RelatedEntity",
    "POCD_MT000040UV02_RelatedSubject",
    "POCD_MT000040UV02_ResponsibleParty",
    "POCD_MT000040UV02_Section",
    "POCD_MT000040UV02_ServiceEvent",
    "POCD_MT000040UV02_Specimen",
    "POCD_MT000040UV02_SpecimenRole",
    "POCD_MT000040UV02_StructuredBody",
    "POCD_MT000040UV02_Subject",
    "POCD_MT000040UV02_SubjectPerson",
    "POCD_MT000040UV02_SubstanceAdministration",
    "POCD_MT000040UV02_Supply",
    "PPD_PQ",
    "PPD_TS",
    "PQ",
    "PQR",
    "QTY",
    "REAL",
    "RTO",
    "RTO_MO_PQ",
    "RTO_PQ_PQ",
    "RTO_QTY_QTY",
    "SC",
    "SLIST_PQ",
    "SLIST_TS",
    "ST",
    "STTranslation",
    "ST_r2b",
    "SXCM_CD",
    "SXCM_INT",
    "SXCM_MO",
    "SXCM_PPD_PQ",
    "SXCM_PPD_TS",
    "SXCM_PQ",
    "SXCM_REAL",
    "SXCM_RTO",
    "SXCM_TS",
    "SXPR_TS",
    "StrucDoc_Br",
    "StrucDoc_Caption",
    "StrucDoc_Col",
    "StrucDoc_Colgroup",
    "StrucDoc_Content",
    "StrucDoc_Footnote",
    "StrucDoc_FootnoteRef",
    "StrucDoc_Item",
    "StrucDoc_LinkHtml",
    "StrucDoc_List",
    "StrucDoc_Paragraph",
    "StrucDoc_RenderMultiMedia",
    "StrucDoc_Sub",
    "StrucDoc_Sup",
    "StrucDoc_Table",
    "StrucDoc_Tbody",
    "StrucDoc_Td",
    "StrucDoc_Text",
    "StrucDoc_Tfoot",
    "StrucDoc_Th",
    "StrucDoc_Thead",
    "StrucDoc_Title",
    "StrucDoc_TitleContent",
    "StrucDoc_TitleFootnote",
    "StrucDoc_Tr",
    "TEL",
    "TN",
    "TS",
    "URL",
    "UVP_TS",
    "adxp_additionalLocator",
    "adxp_buildingNumberSuffix",
    "adxp_careOf",
    "adxp_censusTract",
    "adxp_city",
    "adxp_country",
    "adxp_county",
    "adxp_delimiter",
    "adxp_deliveryAddressLine",
    "adxp_deliveryInstallationArea",
    "adxp_deliveryInstallationQualifier",
    "adxp_deliveryInstallationType",
    "adxp_deliveryMode",
    "adxp_deliveryModeIdentifier",
    "adxp_direction",
    "adxp_houseNumber",
    "adxp_houseNumberNumeric",
    "adxp_postBox",
    "adxp_postalCode",
    "adxp_precinct",
    "adxp_state",
    "adxp_streetAddressLine",
    "adxp_streetName",
    "adxp_streetNameBase",
    "adxp_streetNameType",
    "adxp_unitID",
    "adxp_unitType",
    "en_delimiter",
    "en_family",
    "en_given",
    "en_prefix",
    "en_suffix",
    "labCriterion",
    "precondition",
    "statusCode",
    "thumbnail"
]
