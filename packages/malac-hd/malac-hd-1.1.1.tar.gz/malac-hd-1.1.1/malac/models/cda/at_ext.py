#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jan 30 15:00:16 2025 by generateDS.py version 2.43.3.
# Python 3.12.6 (tags/v3.12.6:a4a2d2b, Sep  6 2024, 20:11:23) [MSC v.1940 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'at_ext.py')
#   ('--no-questions', '')
#   ('-f', '')
#
# Command line arguments:
#   ../cda-schema/CDA_extELGA.xsd
#
# Command line:
#   generateDS.py -o "at_ext.py" --no-questions -f ../cda-schema/CDA_extELGA.xsd
#
# Current working directory (os.getcwd()):
#   generateds
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_
from typing import List as List_


Validate_simpletypes_ = True
SaveElementTreeNode = True
SaveNodeDict = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str
node_dict = {}


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if instring is None:
                result = ""
            elif isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class ActClassComposition(str, Enum):
    """ActClassComposition -- specDomain: V19442
    (C-0-D11527-V13856-V19445-V19442-cpt)
    
    """
    COMPOSITION='COMPOSITION'


class ActClassCondition(str, Enum):
    """ActClassCondition -- specDomain: V19580
    (C-0-D11527-V13856-V11529-V19580-cpt)
    
    """
    COND='COND'


class ActClassContract(str, Enum):
    """ActClassContract -- specDomain: V14002 (C-0-D11527-V13856-V14002-cpt)
    
    """
    CNTRCT='CNTRCT'


class ActClassControlAct(str, Enum):
    """ActClassControlAct -- specDomain: V11534 (C-0-D11527-V13856-V11534-cpt)
    
    """
    CACT='CACT'
    ACTN='ACTN'
    INFO='INFO'
    STC='STC'


class ActClassDocument(str, Enum):
    """ActClassDocument -- specDomain: V18938
    (C-0-D11527-V13856-V19445-V19442-V18938-cpt)
    
    """
    DOC='DOC'


class ActClassEntry(str, Enum):
    """ActClassEntry -- specDomain: V19444
    (C-0-D11527-V13856-V19445-V19444-cpt)
    
    """
    ENTRY='ENTRY'
    BATTERY='BATTERY'
    CLUSTER='CLUSTER'


class ActClassExtract(str, Enum):
    """ActClassExtract -- specDomain: V19441
    (C-0-D11527-V13856-V19445-V19441-cpt)
    
    """
    EXTRACT='EXTRACT'
    EHR='EHR'


class ActClassFinancialContract(str, Enum):
    """ActClassFinancialContract -- specDomain: V14003
    (C-0-D11527-V13856-V14002-V14003-cpt)
    
    """
    FCNTRCT='FCNTRCT'
    COV='COV'


class ActClassInvoiceElement(str, Enum):
    INVE='INVE'


class ActClassObservation(str, Enum):
    """ActClassObservation -- specDomain: V11529 (C-0-D11527-V13856-V11529-cpt)
    
    """
    OBS='OBS'
    ALRT='ALRT'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    DGIMG='DGIMG'
    INVSTG='INVSTG'
    SPCOBS='SPCOBS'


class ActClassObservationSeries(str, Enum):
    """ActClassObservationSeries -- specDomain: V18875
    (C-0-D11527-V13856-V11529-V18875-cpt)
    
    """
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'


class ActClassOrganizer(str, Enum):
    """ActClassOrganizer -- specDomain: V19443
    (C-0-D11527-V13856-V19445-V19443-cpt)
    
    """
    ORGANIZER='ORGANIZER'
    CATEGORY='CATEGORY'
    DOCBODY='DOCBODY'
    DOCSECT='DOCSECT'
    TOPIC='TOPIC'


class ActClassPublicHealthCase(str, Enum):
    """ActClassPublicHealthCase -- specDomain: V11530
    (C-0-D11527-V13856-V11529-V19580-V11530-cpt)
    
    """
    CASE='CASE'
    OUTB='OUTB'


class ActClassROI(str, Enum):
    """ActClassROI -- abstDomain: V17893
    (C-0-D11527-V13856-V11529-V17893-cpt)
    
    """
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'


class ActClassRoot(str, Enum):
    """ActClassRoot -- specDomain: V13856 (C-0-D11527-V13856-cpt)
    
    """
    ACT='ACT'
    ACCM='ACCM'
    ACCT='ACCT'
    ACSN='ACSN'
    ADJUD='ADJUD'
    CONS='CONS'
    CONTREG='CONTREG'
    CTTEVENT='CTTEVENT'
    DISPACT='DISPACT'
    ENC='ENC'
    INC='INC'
    INFRM='INFRM'
    INVE='INVE'
    LIST='LIST'
    MPROT='MPROT'
    PCPR='PCPR'
    PROC='PROC'
    REG='REG'
    REV='REV'
    SBADM='SBADM'
    SPCTRT='SPCTRT'
    SUBST='SUBST'
    TRNS='TRNS'
    VERIF='VERIF'
    XACT='XACT'


class ActClassSupply(str, Enum):
    """ActClassSupply -- specDomain: V11535 (C-0-D11527-V13856-V11535-cpt)
    
    """
    SPLY='SPLY'
    DIET='DIET'


class ActClinicalDocument(str, Enum):
    """ActClinicalDocument -- specDomain: V13948
    (C-0-D11527-V13856-V19445-V19442-V18938-V13948-cpt)
    
    """
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'


class ActContainer(str, Enum):
    """ActContainer -- abstDomain: V19445 (C-0-D11527-V13856-V19445-cpt)
    
    """
    FOLDER='FOLDER'


class ActMoodCompletionTrack(str, Enum):
    """ActMoodCompletionTrack -- abstDomain: V10197 (C-0-D10196-V10197-cpt)
    
    """
    DEF='DEF'
    EVN='EVN'


class ActMoodDefinition(str, Enum):
    DEF='DEF'


class ActMoodEventOccurrence(str, Enum):
    EVN='EVN'


class ActMoodGoal(str, Enum):
    GOL='GOL'


class ActMoodIntent(str, Enum):
    """ActMoodIntent -- specDomain: V10199 (C-0-D10196-V16742-V10199-cpt)
    
    """
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    SLOT='SLOT'


class ActMoodPredicate(str, Enum):
    """ActMoodPredicate -- abstDomain: V10202 (C-0-D10196-V10202-cpt)
    
    """
    EVNCRT='EVN.CRT'
    GOL='GOL'
    OPT='OPT'
    PERM='PERM'
    PERMRQ='PERMRQ'


class ActRelationshipConditional(str, Enum):
    """ActRelationshipConditional -- abstDomain: V18977 (C-0-D10317-V18977-cpt)
    
    """
    CIND='CIND'
    PRCN='PRCN'
    TRIG='TRIG'


class ActRelationshipCostTracking(str, Enum):
    """ActRelationshipCostTracking -- abstDomain: V19618
    (C-0-D10317-V10329-V14900-V19618-cpt)
    
    """
    CHRG='CHRG'
    COST='COST'


class ActRelationshipExcerpt(str, Enum):
    """ActRelationshipExcerpt -- specDomain: V18660 (C-0-D10317-V10337-V18660-cpt)
    
    """
    XCRPT='XCRPT'
    VRXCRPT='VRXCRPT'


class ActRelationshipFulfills(str, Enum):
    """ActRelationshipFulfills -- specDomain: V10342 (C-0-D10317-V10337-V10342-cpt)
    
    """
    FLFS='FLFS'
    OCCR='OCCR'
    OREF='OREF'
    SCH='SCH'


class ActRelationshipHasComponent(str, Enum):
    """ActRelationshipHasComponent -- specDomain: V10318 (C-0-D10317-V10318-cpt)
    
    """
    COMP='COMP'
    ARR='ARR'
    CTRLV='CTRLV'
    DEP='DEP'


class ActRelationshipObjective(str, Enum):
    """ActRelationshipObjective -- abstDomain: V19625 (C-0-D10317-V10324-V19625-cpt)
    
    """
    OBJC='OBJC'
    OBJF='OBJF'


class ActRelationshipOutcome(str, Enum):
    """ActRelationshipOutcome -- specDomain: V10324 (C-0-D10317-V10324-cpt)
    
    """
    OUTC='OUTC'
    GOAL='GOAL'
    RISK='RISK'


class ActRelationshipPertains(str, Enum):
    """ActRelationshipPertains -- specDomain: V10329 (C-0-D10317-V10329-cpt)
    
    """
    PERT='PERT'
    AUTH='AUTH'
    CAUS='CAUS'
    COVBY='COVBY'
    DRIV='DRIV'
    EXPL='EXPL'
    ITEMSLOC='ITEMSLOC'
    LIMIT='LIMIT'
    MFST='MFST'
    NAME='NAME'
    PREV='PREV'
    REFR='REFR'
    REFV='REFV'
    SUBJ='SUBJ'
    SUMM='SUMM'


class ActRelationshipPosting(str, Enum):
    """ActRelationshipPosting -- abstDomain: V19617
    (C-0-D10317-V10329-V14900-V19617-cpt)
    
    """
    CREDIT='CREDIT'
    DEBIT='DEBIT'


class ActRelationshipReason(str, Enum):
    """ActRelationshipReason -- specDomain: V19376 (C-0-D10317-V18977-V19376-cpt)
    
    """
    RSON='RSON'
    MITGT='MITGT'


class ActRelationshipReplacement(str, Enum):
    """ActRelationshipReplacement -- specDomain: V10338 (C-0-D10317-V10337-V10338-cpt)
    
    """
    RPLC='RPLC'
    SUCC='SUCC'


class ActRelationshipSequel(str, Enum):
    """ActRelationshipSequel -- specDomain: V10337 (C-0-D10317-V10337-cpt)
    
    """
    SEQL='SEQL'
    APND='APND'
    DOC='DOC'
    ELNK='ELNK'
    GEN='GEN'
    GEVL='GEVL'
    INST='INST'
    MTCH='MTCH'
    OPTN='OPTN'
    REV='REV'
    UPDT='UPDT'
    XFRM='XFRM'


class AdditionalLocator(str, Enum):
    """AdditionalLocator -- specDomain: V10651 (C-0-D10642-V10651-cpt)
    
    """
    ADL='ADL'
    UNID='UNID'
    UNIT='UNIT'


class AddressPartType(str, Enum):
    """AddressPartType -- vocSet: D10642 (C-0-D10642-cpt)
    
    """
    CAR='CAR'
    CEN='CEN'
    CNT='CNT'
    CPA='CPA'
    CTY='CTY'
    DEL='DEL'
    POB='POB'
    PRE='PRE'
    STA='STA'
    ZIP='ZIP'


class AddressUse(str, Enum):
    """AddressUse -- abstDomain: V190 (C-0-D201-V190-cpt)
    
    """
    BAD='BAD'
    TMP='TMP'


class ApplicationMediaType(str, Enum):
    """ApplicationMediaType -- abstDomain: V14832 (C-0-D14824-V14832-cpt)
    
    """
    APPLICATIONDICOM='application/dicom'
    APPLICATIONMSWORD='application/msword'
    APPLICATIONPDF='application/pdf'


class AskedButUnknown(str, Enum):
    """AskedButUnknown -- specDomain: V10614
    (C-0-D10609-V10610-V10612-V10614-cpt)
    
    """
    ASKU='ASKU'
    NAV='NAV'


class AudioMediaType(str, Enum):
    """AudioMediaType -- abstDomain: V14835 (C-0-D14824-V14835-cpt)
    
    """
    AUDIOBASIC='audio/basic'
    AUDIOK_32_ADPCM='audio/k32adpcm'
    AUDIOMPEG='audio/mpeg'


class BinaryDataEncoding(str, Enum):
    B_64='B64'
    TXT='TXT'


class BuildingNumber(str, Enum):
    """BuildingNumber -- specDomain: V10649 (C-0-D10642-V14822-V10649-cpt)
    
    """
    BNR='BNR'
    BNN='BNN'
    BNS='BNS'


class CalendarCycleOneLetter(str, Enum):
    """CalendarCycleOneLetter -- abstDomain: V10701 (C-0-D10684-V10701-cpt)
    
    """
    D='D'
    H='H'
    J='J'
    M='M'
    N='N'
    S='S'
    W='W'
    Y='Y'


class CalendarCycleTwoLetter(str, Enum):
    """CalendarCycleTwoLetter -- abstDomain: V10685 (C-0-D10684-V10685-cpt)
    
    """
    CD='CD'
    CH='CH'
    CM='CM'
    CN='CN'
    CS='CS'
    CW='CW'
    CY='CY'
    DM='DM'
    DW='DW'
    DY='DY'
    HD='HD'
    MY='MY'
    NH='NH'
    SN='SN'
    WY='WY'


class CommunicationFunctionType(str, Enum):
    """CommunicationFunctionType -- vocSet: D16031 (C-0-D16031-cpt)
    
    """
    RCV='RCV'
    RSP='RSP'
    SND='SND'


class CompressionAlgorithm(str, Enum):
    """CompressionAlgorithm -- vocSet: D10620 (C-0-D10620-cpt)
    
    """
    DF='DF'
    GZ='GZ'
    Z='Z'
    ZL='ZL'


class ContextControlAdditive(str, Enum):
    """ContextControlAdditive -- abstDomain: V18934 (C-0-D16478-V18934-cpt)
    
    """
    AN='AN'
    AP='AP'


class ContextControlNonPropagating(str, Enum):
    """ContextControlNonPropagating -- abstDomain: V18937 (C-0-D16478-V18937-cpt)
    
    """
    AN='AN'
    ON='ON'


class ContextControlOverriding(str, Enum):
    """ContextControlOverriding -- abstDomain: V18935 (C-0-D16478-V18935-cpt)
    
    """
    ON='ON'
    OP='OP'


class ContextControlPropagating(str, Enum):
    """ContextControlPropagating -- abstDomain: V18936 (C-0-D16478-V18936-cpt)
    
    """
    AP='AP'
    OP='OP'


class Currency(str, Enum):
    """Currency -- vocSet: D17388 (C-0-D17388-cpt)
    
    """
    ARS='ARS'
    AUD='AUD'
    BRL='BRL'
    CAD='CAD'
    CHF='CHF'
    CLF='CLF'
    CNY='CNY'
    DEM='DEM'
    ESP='ESP'
    EUR='EUR'
    FIM='FIM'
    FRF='FRF'
    GBP='GBP'
    ILS='ILS'
    INR='INR'
    JPY='JPY'
    KRW='KRW'
    MXN='MXN'
    NLG='NLG'
    NZD='NZD'
    PHP='PHP'
    RUR='RUR'
    THB='THB'
    TRL='TRL'
    TWD='TWD'
    USD='USD'
    ZAR='ZAR'


class DeliveryAddressLine(str, Enum):
    """DeliveryAddressLine -- specDomain: V17887 (C-0-D10642-V17887-cpt)
    
    """
    DAL='DAL'
    DINST='DINST'
    DINSTA='DINSTA'
    DINSTQ='DINSTQ'
    DMOD='DMOD'
    DMODID='DMODID'


class EntityClassContainer(str, Enum):
    """EntityClassContainer -- specDomain: V11622
    (C-0-D10882-V13922-V10883-V13934-V11622-cpt)
    
    """
    CONT='CONT'
    HOLD='HOLD'


class EntityClassDevice(str, Enum):
    """EntityClassDevice -- specDomain: V11623
    (C-0-D10882-V13922-V10883-V13934-V11623-cpt)
    
    """
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'


class EntityClassLivingSubject(str, Enum):
    """EntityClassLivingSubject -- specDomain: V10884 (C-0-D10882-V13922-V10884-cpt)
    
    """
    LIV='LIV'
    PSN='PSN'


class EntityClassManufacturedMaterial(str, Enum):
    """EntityClassManufacturedMaterial -- specDomain: V13934
    (C-0-D10882-V13922-V10883-V13934-cpt)
    
    """
    MMAT='MMAT'


class EntityClassMaterial(str, Enum):
    """EntityClassMaterial -- specDomain: V10883 (C-0-D10882-V13922-V10883-cpt)
    
    """
    MAT='MAT'
    CHEM='CHEM'
    FOOD='FOOD'


class EntityClassNonPersonLivingSubject(str, Enum):
    """EntityClassNonPersonLivingSubject -- specDomain: V11621
    (C-0-D10882-V13922-V10884-V11621-cpt)
    
    """
    NLIV='NLIV'
    ANM='ANM'
    MIC='MIC'
    PLNT='PLNT'


class EntityClassOrganization(str, Enum):
    """EntityClassOrganization -- specDomain: V10889 (C-0-D10882-V19463-V10889-cpt)
    
    """
    ORG='ORG'
    PUB='PUB'


class EntityClassPlace(str, Enum):
    """EntityClassPlace -- specDomain: V10892 (C-0-D10882-V13922-V10892-cpt)
    
    """
    PLC='PLC'
    CITY='CITY'
    COUNTRY='COUNTRY'
    COUNTY='COUNTY'
    PROVINCE='PROVINCE'


class EntityClassPublicInstitution(str, Enum):
    PUB='PUB'


class EntityClassRoot(str, Enum):
    """EntityClassRoot -- specDomain: V13922 (C-0-D10882-V13922-cpt)
    
    """
    ENT='ENT'
    HCE='HCE'
    RGRP='RGRP'


class EntityClassState(str, Enum):
    STATE='STATE'
    NAT='NAT'


class EntityDeterminer(str, Enum):
    """EntityDeterminer -- vocSet: D10878 (C-0-D10878-cpt)
    
    """
    INSTANCE='INSTANCE'


class EntityDeterminerDetermined(str, Enum):
    """EntityDeterminerDetermined -- specDomain: V10879 (C-0-D10878-V10879-cpt)
    
    """
    KIND='KIND'
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class EntityDeterminerSpecific(str, Enum):
    INSTANCE='INSTANCE'


class EntityNamePartType(str, Enum):
    """EntityNamePartType -- vocSet: D15880 (C-0-D15880-cpt)
    
    """
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class EntityNameSearchUse(str, Enum):
    """EntityNameSearchUse -- specDomain: V19619 (C-0-D15913-V200-V19619-cpt)
    
    """
    SRCH='SRCH'
    PHON='PHON'
    SNDX='SNDX'


class EntityNameUse(str, Enum):
    """EntityNameUse -- vocSet: D15913 (C-0-D15913-cpt)
    
    """
    C='C'


class HomeAddressUse(str, Enum):
    """HomeAddressUse -- specDomain: V10628 (C-0-D201-V190-V10628-cpt)
    
    """
    H='H'
    HP='HP'
    HV='HV'


class ImageMediaType(str, Enum):
    """ImageMediaType -- abstDomain: V14839 (C-0-D14824-V14839-cpt)
    
    """
    IMAGEG_3_FAX='image/g3fax'
    IMAGEGIF='image/gif'
    IMAGEJPEG='image/jpeg'
    IMAGEPNG='image/png'
    IMAGETIFF='image/tiff'


class IntegrityCheckAlgorithm(str, Enum):
    """IntegrityCheckAlgorithm -- vocSet: D17385 (C-0-D17385-cpt)
    
    """
    SHA_1='SHA-1'
    SHA_256='SHA-256'


class LicensedEntityRole(str, Enum):
    """LicensedEntityRole -- specDomain: V16773
    (C-0-D11555-V13940-V16930-V16773-cpt)
    
    """
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'


class ModelMediaType(str, Enum):
    """ModelMediaType -- abstDomain: V14848 (C-0-D14824-V14848-cpt)
    
    """
    MODELVRML='model/vrml'


class MultipartMediaType(str, Enum):
    """MultipartMediaType -- abstDomain: V14850 (C-0-D14824-V14850-cpt)
    
    """
    MULTIPARTXHL_7CDALEVEL_1='multipart/x-hl7-cda-level1'


class NamePseudonymUse(str, Enum):
    """NamePseudonymUse -- specDomain: V19591 (C-0-D15913-V200-V19591-cpt)
    
    """
    P='P'
    A='A'


class NameRepresentationUse(str, Enum):
    """NameRepresentationUse -- abstDomain: V17860 (C-0-D10637-V17860-cpt)
    
    """
    ABC='ABC'
    IDE='IDE'
    SYL='SYL'


class NoInformation(str, Enum):
    """NoInformation -- specDomain: V10610 (C-0-D10609-V10610-cpt)
    
    """
    NI='NI'
    MSK='MSK'
    NA='NA'


class NullFlavor(str, Enum):
    """NullFlavor -- vocSet: D10609 (C-0-D10609-cpt)
    
    """
    NP='NP'


class OrganizationNamePartQualifier(str, Enum):
    """OrganizationNamePartQualifier -- abstDomain: V15889 (C-0-D15888-V15889-cpt)
    
    """
    LS='LS'


class OrganizationNameUse(str, Enum):
    """OrganizationNameUse -- abstDomain: V15914 (C-0-D15913-V15914-cpt)
    
    """
    C='C'
    L='L'


class Other(str, Enum):
    """Other -- specDomain: V10616 (C-0-D10609-V10610-V10616-cpt)
    
    """
    OTH='OTH'
    NINF='NINF'
    PINF='PINF'


class ParticipationAncillary(str, Enum):
    """ParticipationAncillary -- abstDomain: V10247 (C-0-D10901-V10247-cpt)
    
    """
    ADM='ADM'
    ATND='ATND'
    CALLBCK='CALLBCK'
    CON='CON'
    DIS='DIS'
    ESC='ESC'
    REF='REF'


class ParticipationAuthorOriginator(str, Enum):
    AUT='AUT'


class ParticipationHolder(str, Enum):
    HLD='HLD'


class ParticipationIndirectTarget(str, Enum):
    """ParticipationIndirectTarget -- specDomain: V19032 (C-0-D10901-V19032-cpt)
    
    """
    IND='IND'
    BEN='BEN'
    COV='COV'
    HLD='HLD'
    RCT='RCT'
    RCV='RCV'


class ParticipationInformationGenerator(str, Enum):
    """ParticipationInformationGenerator -- abstDomain: V10251 (C-0-D10901-V10251-cpt)
    
    """
    AUT='AUT'
    ENT='ENT'
    INF='INF'
    WIT='WIT'


class ParticipationInformationRecipient(str, Enum):
    """ParticipationInformationRecipient -- specDomain: V10263 (C-0-D10901-V10263-cpt)
    
    """
    IRCP='IRCP'
    NOT='NOT'
    PRCP='PRCP'
    REFB='REFB'
    REFT='REFT'
    TRC='TRC'


class ParticipationPhysicalPerformer(str, Enum):
    """ParticipationPhysicalPerformer -- specDomain: V10248 (C-0-D10901-V10248-cpt)
    
    """
    PRF='PRF'
    DIST='DIST'
    PPRF='PPRF'
    SPRF='SPRF'


class ParticipationTargetDevice(str, Enum):
    """ParticipationTargetDevice -- specDomain: V10298 (C-0-D10901-V10286-V10298-cpt)
    
    """
    DEV='DEV'
    NRD='NRD'
    RDV='RDV'


class ParticipationTargetDirect(str, Enum):
    """ParticipationTargetDirect -- specDomain: V10286 (C-0-D10901-V10286-cpt)
    
    """
    DIR='DIR'
    BBY='BBY'
    CSM='CSM'
    DON='DON'
    PRD='PRD'


class ParticipationTargetLocation(str, Enum):
    """ParticipationTargetLocation -- specDomain: V10302 (C-0-D10901-V10302-cpt)
    
    """
    LOC='LOC'
    DST='DST'
    ELOC='ELOC'
    ORG='ORG'
    RML='RML'
    VIA='VIA'


class ParticipationTargetSubject(str, Enum):
    """ParticipationTargetSubject -- specDomain: V19584 (C-0-D10901-V10286-V19584-cpt)
    
    """
    SBJ='SBJ'
    SPC='SPC'


class ParticipationType(str, Enum):
    """ParticipationType -- vocSet: D10901 (C-0-D10901-cpt)
    
    """
    CST='CST'
    RESP='RESP'


class ParticipationVerifier(str, Enum):
    """ParticipationVerifier -- specDomain: V10259 (C-0-D10901-V10259-cpt)
    
    """
    VRF='VRF'
    AUTHEN='AUTHEN'
    LA='LA'


class PersonNamePartAffixTypes(str, Enum):
    """PersonNamePartAffixTypes -- abstDomain: V10666 (C-0-D15888-V10659-V10666-cpt)
    
    """
    AC='AC'
    NB='NB'
    PR='PR'
    VV='VV'


class PersonNamePartChangeQualifier(str, Enum):
    """PersonNamePartChangeQualifier -- abstDomain: V10660 (C-0-D15888-V10659-V10660-cpt)
    
    """
    AD='AD'
    BR='BR'
    SP='SP'


class PersonNamePartMiscQualifier(str, Enum):
    """PersonNamePartMiscQualifier -- abstDomain: V10671 (C-0-D15888-V10659-V10671-cpt)
    
    """
    CL='CL'


class PersonNamePartQualifier(str, Enum):
    """PersonNamePartQualifier -- abstDomain: V10659 (C-0-D15888-V10659-cpt)
    
    """
    IN='IN'
    TITLE='TITLE'


class PersonNameUse(str, Enum):
    """PersonNameUse -- abstDomain: V200 (C-0-D15913-V200-cpt)
    
    """
    A='A'
    ASGN='ASGN'
    C='C'
    I='I'
    L='L'
    R='R'


class PostalAddressUse(str, Enum):
    """PostalAddressUse -- vocSet: D10637 (C-0-D10637-cpt)
    
    """
    PHYS='PHYS'
    PST='PST'


class ProbabilityDistributionType(str, Enum):
    """ProbabilityDistributionType -- vocSet: D10747 (C-0-D10747-cpt)
    
    """
    B='B'
    E='E'
    F='F'
    G='G'
    LN='LN'
    N='N'
    T='T'
    U='U'
    X_2='X2'


class RelatedLinkType(str, Enum):
    """RelatedLinkType -- specDomain: V19615 (C-0-D11603-V19615-cpt)
    
    """
    REL='REL'
    BACKUP='BACKUP'
    DIRAUTH='DIRAUTH'
    INDAUTH='INDAUTH'
    PART='PART'
    REPL='REPL'


class RoleClassAdministerableMaterial(str, Enum):
    ADMM='ADMM'


class RoleClassAgent(str, Enum):
    """RoleClassAgent -- specDomain: V14006
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-cpt)
    
    """
    AGNT='AGNT'
    GUARD='GUARD'


class RoleClassAssignedEntity(str, Enum):
    """RoleClassAssignedEntity -- specDomain: V11595
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-V11595-cpt)
    
    """
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'


class RoleClassContact(str, Enum):
    """RoleClassContact -- specDomain: V12205
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-V11595-V12205-cpt)
    
    """
    CON='CON'
    ECON='ECON'
    NOK='NOK'


class RoleClassContent(str, Enum):
    CONT='CONT'


class RoleClassDistributedMaterial(str, Enum):
    """RoleClassDistributedMaterial -- specDomain: V10418
    (C-0-D11555-V13940-V19313-V19105-V10418-cpt)
    
    """
    DST='DST'
    RET='RET'


class RoleClassEmployee(str, Enum):
    """RoleClassEmployee -- specDomain: V11569
    (C-0-D11555-V13940-V19313-V19316-V10416-V11569-cpt)
    
    """
    EMP='EMP'
    MIL='MIL'


class RoleClassInactiveIngredient(str, Enum):
    """RoleClassInactiveIngredient -- specDomain: V19089
    (C-0-D11555-V13940-V10429-V10430-V19089-cpt)
    
    """
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'


class RoleClassIngredientEntity(str, Enum):
    """RoleClassIngredientEntity -- specDomain: V10430
    (C-0-D11555-V13940-V10429-V10430-cpt)
    
    """
    INGR='INGR'
    ACTI='ACTI'
    ACTM='ACTM'
    ADTV='ADTV'
    BASE='BASE'


class RoleClassInvestigationSubject(str, Enum):
    """RoleClassInvestigationSubject -- specDomain: V19587
    (C-0-D11555-V13940-V19313-V19316-V10416-V19587-cpt)
    
    """
    INVSBJ='INVSBJ'
    CASESBJ='CASESBJ'
    RESBJ='RESBJ'


class RoleClassIsSpeciesEntity(str, Enum):
    """RoleClassIsSpeciesEntity -- specDomain: V10441
    (C-0-D11555-V13940-V10428-V10441-cpt)
    
    """
    GEN='GEN'
    GRIC='GRIC'


class RoleClassLocatedEntity(str, Enum):
    """RoleClassLocatedEntity -- specDomain: V16815
    (C-0-D11555-V13940-V10429-V16815-cpt)
    
    """
    LOCE='LOCE'
    STOR='STOR'


class RoleClassManufacturedProduct(str, Enum):
    """RoleClassManufacturedProduct -- specDomain: V11580
    (C-0-D11555-V13940-V19313-V19105-V11580-cpt)
    
    """
    MANU='MANU'
    THER='THER'


class RoleClassMutualRelationship(str, Enum):
    """RoleClassMutualRelationship -- abstDomain: V19316
    (C-0-D11555-V13940-V19313-V19316-cpt)
    
    """
    CAREGIVER='CAREGIVER'
    PRS='PRS'


class RoleClassOntological(str, Enum):
    """RoleClassOntological -- abstDomain: V10428 (C-0-D11555-V13940-V10428-cpt)
    
    """
    INST='INST'
    SUBS='SUBS'
    SUBY='SUBY'


class RoleClassPart(str, Enum):
    PART='PART'
    ACTM='ACTM'


class RoleClassPartitive(str, Enum):
    """RoleClassPartitive -- abstDomain: V10429 (C-0-D11555-V13940-V10429-cpt)
    
    """
    CONT='CONT'
    MBR='MBR'
    PART='PART'


class RoleClassPassive(str, Enum):
    """RoleClassPassive -- abstDomain: V19105
    (C-0-D11555-V13940-V19313-V19105-cpt)
    
    """
    ACCESS='ACCESS'
    BIRTHPL='BIRTHPL'
    EXPR='EXPR'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IDENT='IDENT'
    MNT='MNT'
    OWN='OWN'
    RGPR='RGPR'
    TERR='TERR'
    WRTE='WRTE'


class RoleClassRelationshipFormal(str, Enum):
    """RoleClassRelationshipFormal -- abstDomain: V10416
    (C-0-D11555-V13940-V19313-V19316-V10416-cpt)
    
    """
    CIT='CIT'
    COVPTY='COVPTY'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    GUAR='GUAR'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'


class RoleClassRoot(str, Enum):
    """RoleClassRoot -- specDomain: V13940 (C-0-D11555-V13940-cpt)
    
    """
    ROL='ROL'


class RoleClassServiceDeliveryLocation(str, Enum):
    """RoleClassServiceDeliveryLocation -- specDomain: V16927
    (C-0-D11555-V13940-V19313-V19105-V16927-cpt)
    
    """
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'


class RoleClassSpecimen(str, Enum):
    """RoleClassSpecimen -- specDomain: V11591
    (C-0-D11555-V13940-V10429-V11591-cpt)
    
    """
    SPEC='SPEC'
    ALQT='ALQT'
    ISLT='ISLT'


class RoleClassTerritoryOfAuthority(str, Enum):
    TERR='TERR'


class SetOperator(str, Enum):
    """SetOperator -- vocSet: D17416 (C-0-D17416-cpt)
    
    """
    A='A'
    E='E'
    H='H'
    I='I'
    P='P'


class State(str, Enum):
    """State -- specDomain: V19455
    (C-0-D10882-V19463-V10889-V19455-cpt)
    
    """
    STATE='STATE'
    NAT='NAT'


class StreetAddressLine(str, Enum):
    """StreetAddressLine -- specDomain: V14822 (C-0-D10642-V14822-cpt)
    
    """
    SAL='SAL'
    DIR='DIR'


class StreetName(str, Enum):
    """StreetName -- specDomain: V10648 (C-0-D10642-V14822-V10648-cpt)
    
    """
    STR='STR'
    STB='STB'
    STTYP='STTYP'


class TelecommunicationAddressUse(str, Enum):
    """TelecommunicationAddressUse -- vocSet: D201 (C-0-D201-cpt)
    
    """
    AS='AS'
    EC='EC'
    MC='MC'
    PG='PG'


class TemporallyPertains(str, Enum):
    """TemporallyPertains -- abstDomain: V19590 (C-0-D10317-V10329-V19590-cpt)
    
    """
    SAS='SAS'


class TextMediaType(str, Enum):
    """TextMediaType -- abstDomain: V14825 (C-0-D14824-V14825-cpt)
    
    """
    TEXTHTML='text/html'
    TEXTPLAIN='text/plain'
    TEXTRTF='text/rtf'
    TEXTSGML='text/sgml'
    TEXTXHL_7FT='text/x-hl7-ft'
    TEXTXML='text/xml'


class TimingEvent(str, Enum):
    """TimingEvent -- vocSet: D10706 (C-0-D10706-cpt)
    
    """
    AC='AC'
    ACD='ACD'
    ACM='ACM'
    ACV='ACV'
    HS='HS'
    IC='IC'
    ICD='ICD'
    ICM='ICM'
    ICV='ICV'
    PC='PC'
    PCD='PCD'
    PCM='PCM'
    PCV='PCV'
    CM='CM'
    CD='CD'
    CV='CV'


class URLScheme(str, Enum):
    """URLScheme -- vocSet: D14866 (C-0-D14866-cpt)
    
    """
    FAX='fax'
    FILE='file'
    FTP='ftp'
    HTTP='http'
    MAILTO='mailto'
    MLLP='mllp'
    MODEM='modem'
    NFS='nfs'
    TEL='tel'
    TELNET='telnet'
    ME='me'
    HTTPS='https'


class Unknown(str, Enum):
    """Unknown -- specDomain: V10612 (C-0-D10609-V10610-V10612-cpt)
    
    """
    UNK='UNK'
    NASK='NASK'
    TRC='TRC'


class VideoMediaType(str, Enum):
    """VideoMediaType -- abstDomain: V14845 (C-0-D14824-V14845-cpt)
    
    """
    VIDEOMPEG='video/mpeg'
    VIDEOXAVI='video/x-avi'


class WorkPlaceAddressUse(str, Enum):
    """WorkPlaceAddressUse -- specDomain: V19613 (C-0-D201-V190-V19613-cpt)
    
    """
    WP='WP'
    DIR='DIR'
    PUB='PUB'


class alignType(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType1(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType10(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType12(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType14(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType3(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType5(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType7(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class frameType(str, Enum):
    VOID='void'
    ABOVE='above'
    BELOW='below'
    HSIDES='hsides'
    LHS='lhs'
    RHS='rhs'
    VSIDES='vsides'
    BOX='box'
    BORDER='border'


class hasSupport(str, Enum):
    """hasSupport -- specDomain: V10330 (C-0-D10317-V10329-V10330-cpt)
    
    """
    SPRT='SPRT'
    SPRTBND='SPRTBND'


class listTypeType(str, Enum):
    ORDERED='ordered'
    UNORDERED='unordered'


class revisedType(str, Enum):
    INSERT='insert'
    DELETE='delete'


class rulesType(str, Enum):
    NONE='none'
    GROUPS='groups'
    ROWS='rows'
    COLS='cols'
    ALL='all'


class scopeType(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class scopeType9(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class valignType(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType11(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType13(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType15(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType2(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType4(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType6(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType8(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class xELGA_TimingEvent(str, Enum):
    """xELGA_TimingEvent -- vocSet: D10706 (C-0-D10706-cpt)
    
    """
    AC='AC'
    ACD='ACD'
    ACM='ACM'
    ACV='ACV'
    HS='HS'
    IC='IC'
    ICD='ICD'
    ICM='ICM'
    ICV='ICV'
    PC='PC'
    PCD='PCD'
    PCM='PCM'
    PCV='PCV'
    CM='CM'
    CD='CD'
    CV='CV'


class xELGA_URLScheme(str, Enum):
    """xELGA_URLScheme -- vocSet: D14866 (C-0-D14866-cpt)
    
    """
    FAX='fax'
    FILE='file'
    FTP='ftp'
    HTTP='http'
    HTTPS='https'
    MAILTO='mailto'
    MLLP='mllp'
    MODEM='modem'
    NFS='nfs'
    TEL='tel'
    TELNET='telnet'
    ME='me'


class x_ActClassDocumentEntryAct(str, Enum):
    """x_ActClassDocumentEntryAct -- abstDomain: V19604 (C-0-D11527-V13856-V19604-cpt)
    
    """
    ACT='ACT'
    ACCM='ACCM'
    CONS='CONS'
    CTTEVENT='CTTEVENT'
    INC='INC'
    INFRM='INFRM'
    PCPR='PCPR'
    REG='REG'
    SPCTRT='SPCTRT'


class x_ActClassDocumentEntryOrganizer(str, Enum):
    """x_ActClassDocumentEntryOrganizer -- abstDomain: V19603 (C-0-D11527-V13856-V19603-cpt)
    
    """
    BATTERY='BATTERY'
    CLUSTER='CLUSTER'


class x_ActMoodDefEvn(str, Enum):
    """x_ActMoodDefEvn -- abstDomain: V19375 (C-0-D10196-V19375-cpt)
    
    """
    DEF='DEF'
    EVN='EVN'


class x_ActMoodDefEvnRqoPrmsPrp(str, Enum):
    """x_ActMoodDefEvnRqoPrmsPrp -- abstDomain: V19371 (C-0-D10196-V19371-cpt)
    
    """
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodDocumentObservation(str, Enum):
    """x_ActMoodDocumentObservation -- abstDomain: V18943 (C-0-D10196-V18943-cpt)
    
    """
    INT='INT'
    DEF='DEF'
    EVN='EVN'
    GOL='GOL'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodEvnOrdPrmsPrp(str, Enum):
    """x_ActMoodEvnOrdPrmsPrp -- abstDomain: V18965 (C-0-D10196-V18965-cpt)
    
    """
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodIntentEvent(str, Enum):
    """x_ActMoodIntentEvent -- abstDomain: V16742 (C-0-D10196-V16742-cpt)
    
    """
    EVN='EVN'


class x_ActMoodOrdPrms(str, Enum):
    """x_ActMoodOrdPrms -- abstDomain: V16735 (C-0-D10196-V16735-cpt)
    
    """
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodOrdPrmsEvn(str, Enum):
    """x_ActMoodOrdPrmsEvn -- abstDomain: V16730 (C-0-D10196-V16730-cpt)
    
    """
    EVN='EVN'
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodRqoPrpAptArq(str, Enum):
    """x_ActMoodRqoPrpAptArq -- abstDomain: V19372 (C-0-D10196-V19372-cpt)
    
    """
    APT='APT'
    ARQ='ARQ'
    PRP='PRP'
    RQO='RQO'


class x_ActRelationshipDocument(str, Enum):
    """x_ActRelationshipDocument -- abstDomain: V11610 (C-0-D10317-V11610-cpt)
    
    """
    RPLC='RPLC'
    APND='APND'
    XFRM='XFRM'


class x_ActRelationshipEntry(str, Enum):
    """x_ActRelationshipEntry -- abstDomain: V19446 (C-0-D10317-V19446-cpt)
    
    """
    COMP='COMP'
    DRIV='DRIV'


class x_ActRelationshipEntryRelationship(str, Enum):
    """x_ActRelationshipEntryRelationship -- abstDomain: V19447 (C-0-D10317-V19447-cpt)
    
    """
    XCRPT='XCRPT'
    COMP='COMP'
    RSON='RSON'
    SPRT='SPRT'
    CAUS='CAUS'
    GEVL='GEVL'
    MFST='MFST'
    REFR='REFR'
    SAS='SAS'
    SUBJ='SUBJ'


class x_ActRelationshipExternalReference(str, Enum):
    """x_ActRelationshipExternalReference -- abstDomain: V19000 (C-0-D10317-V19000-cpt)
    
    """
    XCRPT='XCRPT'
    RPLC='RPLC'
    SPRT='SPRT'
    ELNK='ELNK'
    REFR='REFR'
    SUBJ='SUBJ'


class x_ActRelationshipPatientTransport(str, Enum):
    """x_ActRelationshipPatientTransport -- abstDomain: V19005 (C-0-D10317-V19005-cpt)
    
    """
    ARR='ARR'
    DEP='DEP'


class x_ActRelationshipPertinentInfo(str, Enum):
    """x_ActRelationshipPertinentInfo -- abstDomain: V19562 (C-0-D10317-V19562-cpt)
    
    """
    SPRT='SPRT'
    CAUS='CAUS'
    MFST='MFST'
    REFR='REFR'
    SUBJ='SUBJ'


class x_DeterminerInstanceKind(str, Enum):
    """x_DeterminerInstanceKind -- abstDomain: V19647 (C-0-D10878-V19647-cpt)
    
    """
    KIND='KIND'
    INSTANCE='INSTANCE'


class x_DocumentActMood(str, Enum):
    """x_DocumentActMood -- abstDomain: V19458 (C-0-D10196-V19458-cpt)
    
    """
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentEncounterMood(str, Enum):
    """x_DocumentEncounterMood -- abstDomain: V19459 (C-0-D10196-V19459-cpt)
    
    """
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentEntrySubject(str, Enum):
    """x_DocumentEntrySubject -- abstDomain: V19367 (C-0-D11555-V13940-V19367-cpt)
    
    """
    SPEC='SPEC'
    PAT='PAT'
    PRS='PRS'


class x_DocumentProcedureMood(str, Enum):
    """x_DocumentProcedureMood -- abstDomain: V19460 (C-0-D10196-V19460-cpt)
    
    """
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentSubject(str, Enum):
    """x_DocumentSubject -- abstDomain: V19368 (C-0-D11555-V13940-V19368-cpt)
    
    """
    PAT='PAT'
    PRS='PRS'


class x_DocumentSubstanceMood(str, Enum):
    """x_DocumentSubstanceMood -- abstDomain: V19461 (C-0-D10196-V19461-cpt)
    
    """
    INT='INT'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_EncounterParticipant(str, Enum):
    """x_EncounterParticipant -- abstDomain: V19605 (C-0-D10901-V19605-cpt)
    
    """
    ADM='ADM'
    ATND='ATND'
    CON='CON'
    DIS='DIS'
    REF='REF'


class x_EncounterPerformerParticipation(str, Enum):
    """x_EncounterPerformerParticipation -- abstDomain: V16764 (C-0-D10901-V16764-cpt)
    
    """
    PRF='PRF'
    CON='CON'
    SPRF='SPRF'


class x_EntityClassDocumentReceiving(str, Enum):
    """x_EntityClassDocumentReceiving -- abstDomain: V19462 (C-0-D10882-V19462-cpt)
    
    """
    HCE='HCE'
    PSN='PSN'


class x_EntityClassPersonOrOrgReceiving(str, Enum):
    """x_EntityClassPersonOrOrgReceiving -- abstDomain: V19463 (C-0-D10882-V19463-cpt)
    
    """
    PSN='PSN'


class x_InformationRecipient(str, Enum):
    """x_InformationRecipient -- abstDomain: V19366 (C-0-D10901-V19366-cpt)
    
    """
    PRCP='PRCP'
    TRC='TRC'


class x_InformationRecipientRole(str, Enum):
    """x_InformationRecipientRole -- abstDomain: V16772 (C-0-D11555-V13940-V16772-cpt)
    
    """
    ASSIGNED='ASSIGNED'
    HLTHCHRT='HLTHCHRT'


class x_OrganizationNamePartType(str, Enum):
    """x_OrganizationNamePartType -- abstDomain: V15881 (C-0-D15880-V15881-cpt)
    
    """
    DEL='DEL'
    PFX='PFX'
    SFX='SFX'


class x_ParticipationAuthorPerformer(str, Enum):
    """x_ParticipationAuthorPerformer -- abstDomain: V19080 (C-0-D10901-V19080-cpt)
    
    """
    PRF='PRF'
    AUT='AUT'


class x_ParticipationEntVrf(str, Enum):
    """x_ParticipationEntVrf -- abstDomain: V19600 (C-0-D10901-V19600-cpt)
    
    """
    VRF='VRF'
    ENT='ENT'


class x_ParticipationPrfEntVrf(str, Enum):
    """x_ParticipationPrfEntVrf -- abstDomain: V19601 (C-0-D10901-V19601-cpt)
    
    """
    PRF='PRF'
    VRF='VRF'
    ENT='ENT'


class x_ParticipationVrfRespSprfWit(str, Enum):
    """x_ParticipationVrfRespSprfWit -- abstDomain: V19083 (C-0-D10901-V19083-cpt)
    
    """
    VRF='VRF'
    RESP='RESP'
    SPRF='SPRF'
    WIT='WIT'


class x_PersonNamePartType(str, Enum):
    """x_PersonNamePartType -- abstDomain: V10653 (C-0-D15880-V10653-cpt)
    
    """
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class x_RoleClassAccommodationRequestor(str, Enum):
    """x_RoleClassAccommodationRequestor -- abstDomain: V19382 (C-0-D11555-V13940-V19382-cpt)
    
    """
    AGNT='AGNT'
    PAT='PAT'
    PROV='PROV'
    PRS='PRS'


class x_RoleClassCoverage(str, Enum):
    """x_RoleClassCoverage -- abstDomain: V14008 (C-0-D11555-V13940-V14008-cpt)
    
    """
    COVPTY='COVPTY'
    POLHOLD='POLHOLD'
    SPNSR='SPNSR'
    UNDWRT='UNDWRT'


class x_RoleClassCoverageInvoice(str, Enum):
    """x_RoleClassCoverageInvoice -- abstDomain: V14013 (C-0-D11555-V13940-V14013-cpt)
    
    """
    PAYEE='PAYEE'
    PAYOR='PAYOR'


class x_RoleClassCredentialedEntity(str, Enum):
    """x_RoleClassCredentialedEntity -- abstDomain: V16930 (C-0-D11555-V13940-V16930-cpt)
    
    """
    ASSIGNED='ASSIGNED'
    QUAL='QUAL'


class x_RoleClassPayeePolicyRelationship(str, Enum):
    """x_RoleClassPayeePolicyRelationship -- abstDomain: V19395 (C-0-D11555-V13940-V19395-cpt)
    
    """
    COVPTY='COVPTY'
    GUAR='GUAR'
    POLHOLD='POLHOLD'
    PROV='PROV'
    PRS='PRS'


class x_ServiceEventPerformer(str, Enum):
    """x_ServiceEventPerformer -- abstDomain: V19606 (C-0-D10901-V19606-cpt)
    
    """
    PRF='PRF'
    PPRF='PPRF'
    SPRF='SPRF'


#
# Start data representation classes
#
class POCD_MT000040_Act(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_ActClassDocumentEntryAct' = None, moodCode: 'x_DocumentActMood' = None, negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, priorityCode: 'CE' = None, languageCode: 'CS' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Act)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Act.subclass:
            return POCD_MT000040_Act.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Act(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActClassDocumentEntryAct(self, value):
        # Validate type x_ActClassDocumentEntryAct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACT', 'ACCM', 'CONS', 'CTTEVENT', 'INC', 'INFRM', 'PCPR', 'REG', 'SPCTRT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryAct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryAct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryAct_patterns_, ))
    validate_x_ActClassDocumentEntryAct_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentActMood(self, value):
        # Validate type x_DocumentActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'DEF', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentActMood_patterns_, ))
    validate_x_DocumentActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.languageCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Act', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Act')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Act':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Act')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Act', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Act'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Act', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryAct(self.classCode)    # validate type x_ActClassDocumentEntryAct
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentActMood(self.moodCode)    # validate type x_DocumentActMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_Act


class POCD_MT000040_AssignedAuthor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassAssignedEntity' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, assignedPerson: 'POCD_MT000040.Person' = None, assignedAuthoringDevice: 'POCD_MT000040.AuthoringDevice' = None, representedOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.assignedAuthoringDevice = assignedAuthoringDevice
        self.assignedAuthoringDevice_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedAuthor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedAuthor.subclass:
            return POCD_MT000040_AssignedAuthor.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedAuthor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_assignedAuthoringDevice(self):
        return self.assignedAuthoringDevice
    def set_assignedAuthoringDevice(self, assignedAuthoringDevice):
        self.assignedAuthoringDevice = assignedAuthoringDevice
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.assignedAuthoringDevice is not None or
            self.representedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedAuthor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedAuthor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedAuthor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedAuthor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedAuthor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedAuthor'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedAuthor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.assignedAuthoringDevice is not None:
            namespaceprefix_ = self.assignedAuthoringDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthoringDevice_nsprefix_) else ''
            self.assignedAuthoringDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthoringDevice', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'assignedAuthoringDevice':
            obj_ = POCD_MT000040_AuthoringDevice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthoringDevice = obj_
            obj_.original_tagname_ = 'assignedAuthoringDevice'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
# end class POCD_MT000040_AssignedAuthor


class POCD_MT000040_AssignedCustodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassAssignedEntity' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, representedCustodianOrganization: 'POCD_MT000040.CustodianOrganization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.representedCustodianOrganization = representedCustodianOrganization
        self.representedCustodianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedCustodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedCustodian.subclass:
            return POCD_MT000040_AssignedCustodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedCustodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_representedCustodianOrganization(self):
        return self.representedCustodianOrganization
    def set_representedCustodianOrganization(self, representedCustodianOrganization):
        self.representedCustodianOrganization = representedCustodianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.representedCustodianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedCustodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedCustodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedCustodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedCustodian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedCustodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedCustodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedCustodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.representedCustodianOrganization is not None:
            namespaceprefix_ = self.representedCustodianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedCustodianOrganization_nsprefix_) else ''
            self.representedCustodianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedCustodianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'representedCustodianOrganization':
            obj_ = POCD_MT000040_CustodianOrganization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedCustodianOrganization = obj_
            obj_.original_tagname_ = 'representedCustodianOrganization'
# end class POCD_MT000040_AssignedCustodian


class POCD_MT000040_AssignedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassAssignedEntity' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, assignedPerson: 'POCD_MT000040.Person' = None, representedOrganization: 'POCD_MT000040.Organization' = None, patient: 'SdtcPatient' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
        self.patient = patient
        self.patient_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedEntity.subclass:
            return POCD_MT000040_AssignedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_patient(self):
        return self.patient
    def set_patient(self, patient):
        self.patient = patient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.representedOrganization is not None or
            self.patient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.AssignedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.AssignedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
        if self.patient is not None:
            namespaceprefix_ = self.patient_nsprefix_ + ':' if (UseCapturedNS_ and self.patient_nsprefix_) else ''
            self.patient.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='patient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
        elif nodeName_ == 'patient':
            obj_ = SdtcPatient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patient = obj_
            obj_.original_tagname_ = 'patient'
# end class POCD_MT000040_AssignedEntity


class POCD_MT000040_AssociatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassAssociative' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, associatedPerson: 'POCD_MT000040.Person' = None, scopingOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.associatedPerson = associatedPerson
        self.associatedPerson_nsprefix_ = None
        self.scopingOrganization = scopingOrganization
        self.scopingOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssociatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssociatedEntity.subclass:
            return POCD_MT000040_AssociatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssociatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_associatedPerson(self):
        return self.associatedPerson
    def set_associatedPerson(self, associatedPerson):
        self.associatedPerson = associatedPerson
    def get_scopingOrganization(self):
        return self.scopingOrganization
    def set_scopingOrganization(self, scopingOrganization):
        self.scopingOrganization = scopingOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssociative(self, value):
        # Validate type RoleClassAssociative, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.associatedPerson is not None or
            self.scopingOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssociatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssociatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssociatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssociatedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssociatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssociatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssociatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.associatedPerson is not None:
            namespaceprefix_ = self.associatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedPerson_nsprefix_) else ''
            self.associatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedPerson', pretty_print=pretty_print)
        if self.scopingOrganization is not None:
            namespaceprefix_ = self.scopingOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingOrganization_nsprefix_) else ''
            self.scopingOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssociative(self.classCode)    # validate type RoleClassAssociative
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'associatedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedPerson = obj_
            obj_.original_tagname_ = 'associatedPerson'
        elif nodeName_ == 'scopingOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingOrganization = obj_
            obj_.original_tagname_ = 'scopingOrganization'
# end class POCD_MT000040_AssociatedEntity


class POCD_MT000040_Authenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'AUTHEN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, signatureCode: 'CS' = None, signatureText: 'ED' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.signatureText = signatureText
        self.signatureText_nsprefix_ = "sdtc"
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Authenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Authenticator.subclass:
            return POCD_MT000040_Authenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Authenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_signatureText(self):
        return self.signatureText
    def set_signatureText(self, signatureText):
        self.signatureText = signatureText
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.signatureText is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Authenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Authenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Authenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Authenticator')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Authenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Authenticator'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Authenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.signatureText is not None:
            namespaceprefix_ = self.signatureText_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureText_nsprefix_) else ''
            self.signatureText.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='signatureText', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'signatureText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureText = obj_
            obj_.original_tagname_ = 'signatureText'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Authenticator


class POCD_MT000040_Author(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'AUT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'TS' = None, assignedAuthor: 'POCD_MT000040.AssignedAuthor' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedAuthor = assignedAuthor
        self.assignedAuthor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Author)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Author.subclass:
            return POCD_MT000040_Author.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Author(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedAuthor(self):
        return self.assignedAuthor
    def set_assignedAuthor(self, assignedAuthor):
        self.assignedAuthor = assignedAuthor
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedAuthor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Author', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Author')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Author':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Author')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Author', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Author'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Author', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedAuthor is not None:
            namespaceprefix_ = self.assignedAuthor_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthor_nsprefix_) else ''
            self.assignedAuthor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedAuthor':
            obj_ = POCD_MT000040_AssignedAuthor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthor = obj_
            obj_.original_tagname_ = 'assignedAuthor'
# end class POCD_MT000040_Author


class POCD_MT000040_AuthoringDevice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassDevice' = 'DEV', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, manufacturerModelName: 'SC' = None, softwareName: 'SC' = None, asMaintainedEntity: List_['POCD_MT000040.MaintainedEntity'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
        if asMaintainedEntity is None:
            self.asMaintainedEntity = []
        else:
            self.asMaintainedEntity = asMaintainedEntity
        self.asMaintainedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AuthoringDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AuthoringDevice.subclass:
            return POCD_MT000040_AuthoringDevice.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AuthoringDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_asMaintainedEntity(self):
        return self.asMaintainedEntity
    def set_asMaintainedEntity(self, asMaintainedEntity):
        self.asMaintainedEntity = asMaintainedEntity
    def add_asMaintainedEntity(self, value):
        self.asMaintainedEntity.append(value)
    def insert_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity.insert(index, value)
    def replace_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassDevice(self, value):
        # Validate type EntityClassDevice, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEV', 'CER', 'MODDV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassDevice' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassDevice_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassDevice_patterns_, ))
    validate_EntityClassDevice_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None or
            self.asMaintainedEntity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AuthoringDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AuthoringDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AuthoringDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AuthoringDevice')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AuthoringDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AuthoringDevice'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AuthoringDevice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
        for asMaintainedEntity_ in self.asMaintainedEntity:
            namespaceprefix_ = self.asMaintainedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.asMaintainedEntity_nsprefix_) else ''
            asMaintainedEntity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asMaintainedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassDevice(self.classCode)    # validate type EntityClassDevice
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
        elif nodeName_ == 'asMaintainedEntity':
            obj_ = POCD_MT000040_MaintainedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asMaintainedEntity.append(obj_)
            obj_.original_tagname_ = 'asMaintainedEntity'
# end class POCD_MT000040_AuthoringDevice


class POCD_MT000040_Authorization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'AUTH', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, consent: 'POCD_MT000040.Consent' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.consent = consent
        self.consent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Authorization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Authorization.subclass:
            return POCD_MT000040_Authorization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Authorization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_consent(self):
        return self.consent
    def set_consent(self, consent):
        self.consent = consent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.consent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authorization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Authorization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Authorization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Authorization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Authorization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Authorization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authorization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.consent is not None:
            namespaceprefix_ = self.consent_nsprefix_ + ':' if (UseCapturedNS_ and self.consent_nsprefix_) else ''
            self.consent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'consent':
            obj_ = POCD_MT000040_Consent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consent = obj_
            obj_.original_tagname_ = 'consent'
# end class POCD_MT000040_Authorization


class POCD_MT000040_Birthplace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'BIRTHPL', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, place: 'POCD_MT000040.Place' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.place = place
        self.place_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Birthplace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Birthplace.subclass:
            return POCD_MT000040_Birthplace.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Birthplace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.place is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Birthplace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Birthplace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Birthplace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Birthplace')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Birthplace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Birthplace'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Birthplace', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.place is not None:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            self.place.export(outfile, level, namespaceprefix_, namespacedef_='', name_='place', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'place':
            obj_ = POCD_MT000040_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
# end class POCD_MT000040_Birthplace


class POCD_MT000040_ClinicalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClinicalDocument' = 'DOCCLIN', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, code: 'CE' = None, title: 'ST' = None, statusCode: 'CS' = None, terminologyDate: 'TS' = None, formatCode: 'CD' = None, practiceSettingCode: 'CD' = None, effectiveTime: 'TS' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, setId: 'II' = None, versionNumber: 'INT' = None, copyTime: 'TS' = None, recordTarget: List_['POCD_MT000040.RecordTarget'] = None, author: List_['POCD_MT000040.Author'] = None, dataEnterer: 'POCD_MT000040.DataEnterer' = None, informant: List_['POCD_MT000040.Informant12'] = None, custodian: 'POCD_MT000040.Custodian' = None, informationRecipient: List_['POCD_MT000040.InformationRecipient'] = None, legalAuthenticator: List_['POCD_MT000040.LegalAuthenticator'] = None, authenticator: List_['POCD_MT000040.Authenticator'] = None, participant: List_['POCD_MT000040.Participant1'] = None, inFulfillmentOf: List_['POCD_MT000040.InFulfillmentOf'] = None, documentationOf: List_['POCD_MT000040.DocumentationOf'] = None, relatedDocument: List_['POCD_MT000040.RelatedDocument'] = None, authorization: List_['POCD_MT000040.Authorization'] = None, componentOf: 'POCD_MT000040.Component1' = None, component: 'POCD_MT000040.Component2' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = "sdtc"
        self.terminologyDate = terminologyDate
        self.terminologyDate_nsprefix_ = "hl7at"
        self.formatCode = formatCode
        self.formatCode_nsprefix_ = "hl7at"
        self.practiceSettingCode = practiceSettingCode
        self.practiceSettingCode_nsprefix_ = "hl7at"
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
        self.copyTime = copyTime
        self.copyTime_nsprefix_ = None
        if recordTarget is None:
            self.recordTarget = []
        else:
            self.recordTarget = recordTarget
        self.recordTarget_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        self.dataEnterer = dataEnterer
        self.dataEnterer_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        self.custodian = custodian
        self.custodian_nsprefix_ = None
        if informationRecipient is None:
            self.informationRecipient = []
        else:
            self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = None
        if legalAuthenticator is None:
            self.legalAuthenticator = []
        else:
            self.legalAuthenticator = legalAuthenticator
        self.legalAuthenticator_nsprefix_ = None
        if authenticator is None:
            self.authenticator = []
        else:
            self.authenticator = authenticator
        self.authenticator_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if inFulfillmentOf is None:
            self.inFulfillmentOf = []
        else:
            self.inFulfillmentOf = inFulfillmentOf
        self.inFulfillmentOf_nsprefix_ = None
        if documentationOf is None:
            self.documentationOf = []
        else:
            self.documentationOf = documentationOf
        self.documentationOf_nsprefix_ = None
        if relatedDocument is None:
            self.relatedDocument = []
        else:
            self.relatedDocument = relatedDocument
        self.relatedDocument_nsprefix_ = None
        if authorization is None:
            self.authorization = []
        else:
            self.authorization = authorization
        self.authorization_nsprefix_ = None
        self.componentOf = componentOf
        self.componentOf_nsprefix_ = None
        self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ClinicalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ClinicalDocument.subclass:
            return POCD_MT000040_ClinicalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ClinicalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_terminologyDate(self):
        return self.terminologyDate
    def set_terminologyDate(self, terminologyDate):
        self.terminologyDate = terminologyDate
    def get_formatCode(self):
        return self.formatCode
    def set_formatCode(self, formatCode):
        self.formatCode = formatCode
    def get_practiceSettingCode(self):
        return self.practiceSettingCode
    def set_practiceSettingCode(self, practiceSettingCode):
        self.practiceSettingCode = practiceSettingCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_copyTime(self):
        return self.copyTime
    def set_copyTime(self, copyTime):
        self.copyTime = copyTime
    def get_recordTarget(self):
        return self.recordTarget
    def set_recordTarget(self, recordTarget):
        self.recordTarget = recordTarget
    def add_recordTarget(self, value):
        self.recordTarget.append(value)
    def insert_recordTarget_at(self, index, value):
        self.recordTarget.insert(index, value)
    def replace_recordTarget_at(self, index, value):
        self.recordTarget[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_dataEnterer(self):
        return self.dataEnterer
    def set_dataEnterer(self, dataEnterer):
        self.dataEnterer = dataEnterer
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_custodian(self):
        return self.custodian
    def set_custodian(self, custodian):
        self.custodian = custodian
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def add_informationRecipient(self, value):
        self.informationRecipient.append(value)
    def insert_informationRecipient_at(self, index, value):
        self.informationRecipient.insert(index, value)
    def replace_informationRecipient_at(self, index, value):
        self.informationRecipient[index] = value
    def get_legalAuthenticator(self):
        return self.legalAuthenticator
    def set_legalAuthenticator(self, legalAuthenticator):
        self.legalAuthenticator = legalAuthenticator
    def add_legalAuthenticator(self, value):
        self.legalAuthenticator.append(value)
    def insert_legalAuthenticator_at(self, index, value):
        self.legalAuthenticator.insert(index, value)
    def replace_legalAuthenticator_at(self, index, value):
        self.legalAuthenticator[index] = value
    def get_authenticator(self):
        return self.authenticator
    def set_authenticator(self, authenticator):
        self.authenticator = authenticator
    def add_authenticator(self, value):
        self.authenticator.append(value)
    def insert_authenticator_at(self, index, value):
        self.authenticator.insert(index, value)
    def replace_authenticator_at(self, index, value):
        self.authenticator[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_inFulfillmentOf(self):
        return self.inFulfillmentOf
    def set_inFulfillmentOf(self, inFulfillmentOf):
        self.inFulfillmentOf = inFulfillmentOf
    def add_inFulfillmentOf(self, value):
        self.inFulfillmentOf.append(value)
    def insert_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf.insert(index, value)
    def replace_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf[index] = value
    def get_documentationOf(self):
        return self.documentationOf
    def set_documentationOf(self, documentationOf):
        self.documentationOf = documentationOf
    def add_documentationOf(self, value):
        self.documentationOf.append(value)
    def insert_documentationOf_at(self, index, value):
        self.documentationOf.insert(index, value)
    def replace_documentationOf_at(self, index, value):
        self.documentationOf[index] = value
    def get_relatedDocument(self):
        return self.relatedDocument
    def set_relatedDocument(self, relatedDocument):
        self.relatedDocument = relatedDocument
    def add_relatedDocument(self, value):
        self.relatedDocument.append(value)
    def insert_relatedDocument_at(self, index, value):
        self.relatedDocument.insert(index, value)
    def replace_relatedDocument_at(self, index, value):
        self.relatedDocument[index] = value
    def get_authorization(self):
        return self.authorization
    def set_authorization(self, authorization):
        self.authorization = authorization
    def add_authorization(self, value):
        self.authorization.append(value)
    def insert_authorization_at(self, index, value):
        self.authorization.insert(index, value)
    def replace_authorization_at(self, index, value):
        self.authorization[index] = value
    def get_componentOf(self):
        return self.componentOf
    def set_componentOf(self, componentOf):
        self.componentOf = componentOf
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClinicalDocument(self, value):
        # Validate type ActClinicalDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOCCLIN', 'CDALVLONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClinicalDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClinicalDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClinicalDocument_patterns_, ))
    validate_ActClinicalDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.statusCode is not None or
            self.terminologyDate is not None or
            self.formatCode is not None or
            self.practiceSettingCode is not None or
            self.effectiveTime is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.setId is not None or
            self.versionNumber is not None or
            self.copyTime is not None or
            self.recordTarget or
            self.author or
            self.dataEnterer is not None or
            self.informant or
            self.custodian is not None or
            self.informationRecipient or
            self.legalAuthenticator or
            self.authenticator or
            self.participant or
            self.inFulfillmentOf or
            self.documentationOf or
            self.relatedDocument or
            self.authorization or
            self.componentOf is not None or
            self.component is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc"  xmlns:hl7at="urn:hl7-at:v3" ', name_='POCD_MT000040.ClinicalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ClinicalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ClinicalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ClinicalDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ClinicalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ClinicalDocument'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc"  xmlns:hl7at="urn:hl7-at:v3" ', name_='POCD_MT000040.ClinicalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.terminologyDate is not None:
            namespaceprefix_ = self.terminologyDate_nsprefix_ + ':' if (UseCapturedNS_ and self.terminologyDate_nsprefix_) else ''
            self.terminologyDate.export(outfile, level, namespaceprefix_='hl7at:', namespacedef_='', name_='terminologyDate', pretty_print=pretty_print)
        if self.formatCode is not None:
            namespaceprefix_ = self.formatCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formatCode_nsprefix_) else ''
            self.formatCode.export(outfile, level, namespaceprefix_='hl7at:', namespacedef_='', name_='formatCode', pretty_print=pretty_print)
        if self.practiceSettingCode is not None:
            namespaceprefix_ = self.practiceSettingCode_nsprefix_ + ':' if (UseCapturedNS_ and self.practiceSettingCode_nsprefix_) else ''
            self.practiceSettingCode.export(outfile, level, namespaceprefix_='hl7at:', namespacedef_='', name_='practiceSettingCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
        if self.copyTime is not None:
            namespaceprefix_ = self.copyTime_nsprefix_ + ':' if (UseCapturedNS_ and self.copyTime_nsprefix_) else ''
            self.copyTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copyTime', pretty_print=pretty_print)
        for recordTarget_ in self.recordTarget:
            namespaceprefix_ = self.recordTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.recordTarget_nsprefix_) else ''
            recordTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordTarget', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        if self.dataEnterer is not None:
            namespaceprefix_ = self.dataEnterer_nsprefix_ + ':' if (UseCapturedNS_ and self.dataEnterer_nsprefix_) else ''
            self.dataEnterer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataEnterer', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        if self.custodian is not None:
            namespaceprefix_ = self.custodian_nsprefix_ + ':' if (UseCapturedNS_ and self.custodian_nsprefix_) else ''
            self.custodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='custodian', pretty_print=pretty_print)
        for informationRecipient_ in self.informationRecipient:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            informationRecipient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        for legalAuthenticator_ in self.legalAuthenticator:
            namespaceprefix_ = self.legalAuthenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.legalAuthenticator_nsprefix_) else ''
            legalAuthenticator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='legalAuthenticator', pretty_print=pretty_print)
        for authenticator_ in self.authenticator:
            namespaceprefix_ = self.authenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.authenticator_nsprefix_) else ''
            authenticator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authenticator', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for inFulfillmentOf_ in self.inFulfillmentOf:
            namespaceprefix_ = self.inFulfillmentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf_nsprefix_) else ''
            inFulfillmentOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inFulfillmentOf', pretty_print=pretty_print)
        for documentationOf_ in self.documentationOf:
            namespaceprefix_ = self.documentationOf_nsprefix_ + ':' if (UseCapturedNS_ and self.documentationOf_nsprefix_) else ''
            documentationOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentationOf', pretty_print=pretty_print)
        for relatedDocument_ in self.relatedDocument:
            namespaceprefix_ = self.relatedDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedDocument_nsprefix_) else ''
            relatedDocument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedDocument', pretty_print=pretty_print)
        for authorization_ in self.authorization:
            namespaceprefix_ = self.authorization_nsprefix_ + ':' if (UseCapturedNS_ and self.authorization_nsprefix_) else ''
            authorization_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authorization', pretty_print=pretty_print)
        if self.componentOf is not None:
            namespaceprefix_ = self.componentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.componentOf_nsprefix_) else ''
            self.componentOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentOf', pretty_print=pretty_print)
        if self.component is not None:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            self.component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClinicalDocument(self.classCode)    # validate type ActClinicalDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'terminologyDate':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.terminologyDate = obj_
            obj_.original_tagname_ = 'terminologyDate'
        elif nodeName_ == 'formatCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formatCode = obj_
            obj_.original_tagname_ = 'formatCode'
        elif nodeName_ == 'practiceSettingCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.practiceSettingCode = obj_
            obj_.original_tagname_ = 'practiceSettingCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
        elif nodeName_ == 'copyTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyTime = obj_
            obj_.original_tagname_ = 'copyTime'
        elif nodeName_ == 'recordTarget':
            obj_ = POCD_MT000040_RecordTarget.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordTarget.append(obj_)
            obj_.original_tagname_ = 'recordTarget'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'dataEnterer':
            obj_ = POCD_MT000040_DataEnterer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataEnterer = obj_
            obj_.original_tagname_ = 'dataEnterer'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'custodian':
            obj_ = POCD_MT000040_Custodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.custodian = obj_
            obj_.original_tagname_ = 'custodian'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040_InformationRecipient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient.append(obj_)
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'legalAuthenticator':
            obj_ = POCD_MT000040_LegalAuthenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalAuthenticator.append(obj_)
            obj_.original_tagname_ = 'legalAuthenticator'
        elif nodeName_ == 'authenticator':
            obj_ = POCD_MT000040_Authenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authenticator.append(obj_)
            obj_.original_tagname_ = 'authenticator'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'inFulfillmentOf':
            obj_ = POCD_MT000040_InFulfillmentOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf'
        elif nodeName_ == 'documentationOf':
            obj_ = POCD_MT000040_DocumentationOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documentationOf.append(obj_)
            obj_.original_tagname_ = 'documentationOf'
        elif nodeName_ == 'relatedDocument':
            obj_ = POCD_MT000040_RelatedDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedDocument.append(obj_)
            obj_.original_tagname_ = 'relatedDocument'
        elif nodeName_ == 'authorization':
            obj_ = POCD_MT000040_Authorization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authorization.append(obj_)
            obj_.original_tagname_ = 'authorization'
        elif nodeName_ == 'componentOf':
            obj_ = POCD_MT000040_Component1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentOf = obj_
            obj_.original_tagname_ = 'componentOf'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component = obj_
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_ClinicalDocument


class POCD_MT000040_Component1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipHasComponent' = 'COMP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, encompassingEncounter: 'POCD_MT000040.EncompassingEncounter' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.encompassingEncounter = encompassingEncounter
        self.encompassingEncounter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component1.subclass:
            return POCD_MT000040_Component1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_encompassingEncounter(self):
        return self.encompassingEncounter
    def set_encompassingEncounter(self, encompassingEncounter):
        self.encompassingEncounter = encompassingEncounter
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.encompassingEncounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.encompassingEncounter is not None:
            namespaceprefix_ = self.encompassingEncounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encompassingEncounter_nsprefix_) else ''
            self.encompassingEncounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encompassingEncounter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'encompassingEncounter':
            obj_ = POCD_MT000040_EncompassingEncounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encompassingEncounter = obj_
            obj_.original_tagname_ = 'encompassingEncounter'
# end class POCD_MT000040_Component1


class POCD_MT000040_Component2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipHasComponent' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, nonXMLBody: 'POCD_MT000040.NonXMLBody' = None, structuredBody: 'POCD_MT000040.StructuredBody' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.nonXMLBody = nonXMLBody
        self.nonXMLBody_nsprefix_ = None
        self.structuredBody = structuredBody
        self.structuredBody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component2.subclass:
            return POCD_MT000040_Component2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_nonXMLBody(self):
        return self.nonXMLBody
    def set_nonXMLBody(self, nonXMLBody):
        self.nonXMLBody = nonXMLBody
    def get_structuredBody(self):
        return self.structuredBody
    def set_structuredBody(self, structuredBody):
        self.structuredBody = structuredBody
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.nonXMLBody is not None or
            self.structuredBody is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextConductionInd is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.nonXMLBody is not None:
            namespaceprefix_ = self.nonXMLBody_nsprefix_ + ':' if (UseCapturedNS_ and self.nonXMLBody_nsprefix_) else ''
            self.nonXMLBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonXMLBody', pretty_print=pretty_print)
        if self.structuredBody is not None:
            namespaceprefix_ = self.structuredBody_nsprefix_ + ':' if (UseCapturedNS_ and self.structuredBody_nsprefix_) else ''
            self.structuredBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structuredBody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'nonXMLBody':
            obj_ = POCD_MT000040_NonXMLBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonXMLBody = obj_
            obj_.original_tagname_ = 'nonXMLBody'
        elif nodeName_ == 'structuredBody':
            obj_ = POCD_MT000040_StructuredBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structuredBody = obj_
            obj_.original_tagname_ = 'structuredBody'
# end class POCD_MT000040_Component2


class POCD_MT000040_Component3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipHasComponent' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, section: 'POCD_MT000040.Section' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component3.subclass:
            return POCD_MT000040_Component3.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component3'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextConductionInd is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040_Component3


class POCD_MT000040_Component4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipHasComponent' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, sequenceNumber: 'INT' = None, priorityNumber: 'INT' = None, seperatableInd: 'BL' = None, act: 'POCD_MT000040.Act' = None, encounter: 'POCD_MT000040.Encounter' = None, observation: 'POCD_MT000040.Observation' = None, observationMedia: 'POCD_MT000040.ObservationMedia' = None, organizer: 'POCD_MT000040.Organizer' = None, procedure: 'POCD_MT000040.Procedure' = None, regionOfInterest: 'POCD_MT000040.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040.SubstanceAdministration' = None, supply: 'POCD_MT000040.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.priorityNumber = priorityNumber
        self.priorityNumber_nsprefix_ = "sdtc"
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component4.subclass:
            return POCD_MT000040_Component4.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_priorityNumber(self):
        return self.priorityNumber
    def set_priorityNumber(self, priorityNumber):
        self.priorityNumber = priorityNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.priorityNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Component4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component4'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextConductionInd is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Component4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.priorityNumber is not None:
            namespaceprefix_ = self.priorityNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityNumber_nsprefix_) else ''
            self.priorityNumber.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='priorityNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'priorityNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityNumber = obj_
            obj_.original_tagname_ = 'priorityNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_Component4


class POCD_MT000040_Component5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipHasComponent' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, section: 'POCD_MT000040.Section' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component5.subclass:
            return POCD_MT000040_Component5.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component5')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component5'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextConductionInd is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040_Component5


class POCD_MT000040_Consent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'CONS', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, statusCode: 'CS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Consent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Consent.subclass:
            return POCD_MT000040_Consent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Consent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Consent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Consent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Consent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Consent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Consent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
# end class POCD_MT000040_Consent


class POCD_MT000040_Consumable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'CSM', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, manufacturedProduct: 'POCD_MT000040.ManufacturedProduct' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Consumable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Consumable.subclass:
            return POCD_MT000040_Consumable.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Consumable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consumable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Consumable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Consumable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Consumable')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Consumable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Consumable'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consumable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040_Consumable


class POCD_MT000040_Criterion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN.CRT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, value: 'ANY' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Criterion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Criterion.subclass:
            return POCD_MT000040_Criterion.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Criterion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Criterion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Criterion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Criterion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Criterion')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Criterion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Criterion'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Criterion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class POCD_MT000040_Criterion


class POCD_MT000040_Custodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'CST', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedCustodian: 'POCD_MT000040.AssignedCustodian' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedCustodian = assignedCustodian
        self.assignedCustodian_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Custodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Custodian.subclass:
            return POCD_MT000040_Custodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Custodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedCustodian(self):
        return self.assignedCustodian
    def set_assignedCustodian(self, assignedCustodian):
        self.assignedCustodian = assignedCustodian
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedCustodian is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Custodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Custodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Custodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Custodian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Custodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Custodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Custodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedCustodian is not None:
            namespaceprefix_ = self.assignedCustodian_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedCustodian_nsprefix_) else ''
            self.assignedCustodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedCustodian', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedCustodian':
            obj_ = POCD_MT000040_AssignedCustodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedCustodian = obj_
            obj_.original_tagname_ = 'assignedCustodian'
# end class POCD_MT000040_Custodian


class POCD_MT000040_CustodianOrganization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassOrganization' = 'ORG', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: 'ON' = None, telecom: List_['TEL'] = None, addr: 'AD' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_CustodianOrganization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_CustodianOrganization.subclass:
            return POCD_MT000040_CustodianOrganization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_CustodianOrganization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassOrganization(self, value):
        # Validate type EntityClassOrganization, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name is not None or
            self.telecom or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.CustodianOrganization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.CustodianOrganization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.CustodianOrganization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.CustodianOrganization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.CustodianOrganization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.CustodianOrganization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.CustodianOrganization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassOrganization(self.classCode)    # validate type EntityClassOrganization
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040_CustodianOrganization


class POCD_MT000040_DataEnterer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'ENT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_DataEnterer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_DataEnterer.subclass:
            return POCD_MT000040_DataEnterer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_DataEnterer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DataEnterer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.DataEnterer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.DataEnterer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.DataEnterer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.DataEnterer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.DataEnterer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DataEnterer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_DataEnterer


class POCD_MT000040_Device(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassDevice' = 'DEV', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, manufacturerModelName: 'SC' = None, softwareName: 'SC' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Device)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Device.subclass:
            return POCD_MT000040_Device.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassDevice(self, value):
        # Validate type EntityClassDevice, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEV', 'CER', 'MODDV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassDevice' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassDevice_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassDevice_patterns_, ))
    validate_EntityClassDevice_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Device', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Device':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Device')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Device'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DEV" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Device', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassDevice(self.classCode)    # validate type EntityClassDevice
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
# end class POCD_MT000040_Device


class POCD_MT000040_DocumentationOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'DOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, serviceEvent: 'POCD_MT000040.ServiceEvent' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.serviceEvent = serviceEvent
        self.serviceEvent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_DocumentationOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_DocumentationOf.subclass:
            return POCD_MT000040_DocumentationOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_DocumentationOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_serviceEvent(self):
        return self.serviceEvent
    def set_serviceEvent(self, serviceEvent):
        self.serviceEvent = serviceEvent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.serviceEvent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DocumentationOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.DocumentationOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.DocumentationOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.DocumentationOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.DocumentationOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.DocumentationOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DocumentationOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.serviceEvent is not None:
            namespaceprefix_ = self.serviceEvent_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceEvent_nsprefix_) else ''
            self.serviceEvent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceEvent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'serviceEvent':
            obj_ = POCD_MT000040_ServiceEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceEvent = obj_
            obj_.original_tagname_ = 'serviceEvent'
# end class POCD_MT000040_DocumentationOf


class POCD_MT000040_EncompassingEncounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'ENC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, effectiveTime: 'IVL_TS' = None, dischargeDispositionCode: 'CE' = None, responsibleParty: 'POCD_MT000040.ResponsibleParty' = None, encounterParticipant: List_['POCD_MT000040.EncounterParticipant'] = None, location: 'POCD_MT000040.Location' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.dischargeDispositionCode = dischargeDispositionCode
        self.dischargeDispositionCode_nsprefix_ = None
        self.responsibleParty = responsibleParty
        self.responsibleParty_nsprefix_ = None
        if encounterParticipant is None:
            self.encounterParticipant = []
        else:
            self.encounterParticipant = encounterParticipant
        self.encounterParticipant_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EncompassingEncounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EncompassingEncounter.subclass:
            return POCD_MT000040_EncompassingEncounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EncompassingEncounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_dischargeDispositionCode(self):
        return self.dischargeDispositionCode
    def set_dischargeDispositionCode(self, dischargeDispositionCode):
        self.dischargeDispositionCode = dischargeDispositionCode
    def get_responsibleParty(self):
        return self.responsibleParty
    def set_responsibleParty(self, responsibleParty):
        self.responsibleParty = responsibleParty
    def get_encounterParticipant(self):
        return self.encounterParticipant
    def set_encounterParticipant(self, encounterParticipant):
        self.encounterParticipant = encounterParticipant
    def add_encounterParticipant(self, value):
        self.encounterParticipant.append(value)
    def insert_encounterParticipant_at(self, index, value):
        self.encounterParticipant.insert(index, value)
    def replace_encounterParticipant_at(self, index, value):
        self.encounterParticipant[index] = value
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.dischargeDispositionCode is not None or
            self.responsibleParty is not None or
            self.encounterParticipant or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncompassingEncounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EncompassingEncounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EncompassingEncounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EncompassingEncounter')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EncompassingEncounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EncompassingEncounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncompassingEncounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.dischargeDispositionCode is not None:
            namespaceprefix_ = self.dischargeDispositionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dischargeDispositionCode_nsprefix_) else ''
            self.dischargeDispositionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dischargeDispositionCode', pretty_print=pretty_print)
        if self.responsibleParty is not None:
            namespaceprefix_ = self.responsibleParty_nsprefix_ + ':' if (UseCapturedNS_ and self.responsibleParty_nsprefix_) else ''
            self.responsibleParty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='responsibleParty', pretty_print=pretty_print)
        for encounterParticipant_ in self.encounterParticipant:
            namespaceprefix_ = self.encounterParticipant_nsprefix_ + ':' if (UseCapturedNS_ and self.encounterParticipant_nsprefix_) else ''
            encounterParticipant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounterParticipant', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'dischargeDispositionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dischargeDispositionCode = obj_
            obj_.original_tagname_ = 'dischargeDispositionCode'
        elif nodeName_ == 'responsibleParty':
            obj_ = POCD_MT000040_ResponsibleParty.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.responsibleParty = obj_
            obj_.original_tagname_ = 'responsibleParty'
        elif nodeName_ == 'encounterParticipant':
            obj_ = POCD_MT000040_EncounterParticipant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounterParticipant.append(obj_)
            obj_.original_tagname_ = 'encounterParticipant'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040_Location.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class POCD_MT000040_EncompassingEncounter


class POCD_MT000040_Encounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = None, moodCode: 'x_DocumentEncounterMood' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, dischargeDispositionCode: 'CE' = None, priorityCode: 'CE' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.dischargeDispositionCode = dischargeDispositionCode
        self.dischargeDispositionCode_nsprefix_ = "sdtc"
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Encounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Encounter.subclass:
            return POCD_MT000040_Encounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Encounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_dischargeDispositionCode(self):
        return self.dischargeDispositionCode
    def set_dischargeDispositionCode(self, dischargeDispositionCode):
        self.dischargeDispositionCode = dischargeDispositionCode
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentEncounterMood(self, value):
        # Validate type x_DocumentEncounterMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentEncounterMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentEncounterMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentEncounterMood_patterns_, ))
    validate_x_DocumentEncounterMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.dischargeDispositionCode is not None or
            self.priorityCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Encounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Encounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Encounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Encounter')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Encounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Encounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Encounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.dischargeDispositionCode is not None:
            namespaceprefix_ = self.dischargeDispositionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dischargeDispositionCode_nsprefix_) else ''
            self.dischargeDispositionCode.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='dischargeDispositionCode', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentEncounterMood(self.moodCode)    # validate type x_DocumentEncounterMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'dischargeDispositionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dischargeDispositionCode = obj_
            obj_.original_tagname_ = 'dischargeDispositionCode'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_Encounter


class POCD_MT000040_EncounterParticipant(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_EncounterParticipant' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'IVL_TS' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EncounterParticipant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EncounterParticipant.subclass:
            return POCD_MT000040_EncounterParticipant.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EncounterParticipant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_EncounterParticipant(self, value):
        # Validate type x_EncounterParticipant, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ATND', 'CON', 'DIS', 'REF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_EncounterParticipant' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_EncounterParticipant_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_EncounterParticipant_patterns_, ))
    validate_x_EncounterParticipant_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncounterParticipant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EncounterParticipant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EncounterParticipant':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EncounterParticipant')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EncounterParticipant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EncounterParticipant'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncounterParticipant', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_EncounterParticipant(self.typeCode)    # validate type x_EncounterParticipant
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_EncounterParticipant


class POCD_MT000040_Entity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassRoot' = 'ENT', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, desc: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Entity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Entity.subclass:
            return POCD_MT000040_Entity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Entity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Entity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Entity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Entity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Entity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040_Entity


class POCD_MT000040_Entry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipEntry' = 'COMP', contextConductionInd: 'bl' = 'true', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, act: 'POCD_MT000040.Act' = None, encounter: 'POCD_MT000040.Encounter' = None, observation: 'POCD_MT000040.Observation' = None, observationMedia: 'POCD_MT000040.ObservationMedia' = None, organizer: 'POCD_MT000040.Organizer' = None, procedure: 'POCD_MT000040.Procedure' = None, regionOfInterest: 'POCD_MT000040.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040.SubstanceAdministration' = None, supply: 'POCD_MT000040.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Entry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Entry.subclass:
            return POCD_MT000040_Entry.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipEntry(self, value):
        # Validate type x_ActRelationshipEntry, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'DRIV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipEntry' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipEntry_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipEntry_patterns_, ))
    validate_x_ActRelationshipEntry_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Entry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Entry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Entry')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Entry'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextConductionInd is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipEntry(self.typeCode)    # validate type x_ActRelationshipEntry
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_Entry


class POCD_MT000040_EntryRelationship(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipEntryRelationship' = None, inversionInd: 'bl' = None, contextConductionInd: 'bl' = 'true', negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, sequenceNumber: 'INT' = None, seperatableInd: 'BL' = None, act: 'POCD_MT000040.Act' = None, encounter: 'POCD_MT000040.Encounter' = None, observation: 'POCD_MT000040.Observation' = None, observationMedia: 'POCD_MT000040.ObservationMedia' = None, organizer: 'POCD_MT000040.Organizer' = None, procedure: 'POCD_MT000040.Procedure' = None, regionOfInterest: 'POCD_MT000040.RegionOfInterest' = None, substanceAdministration: 'POCD_MT000040.SubstanceAdministration' = None, supply: 'POCD_MT000040.Supply' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.inversionInd = _cast(bool, inversionInd)
        self.inversionInd_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EntryRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EntryRelationship.subclass:
            return POCD_MT000040_EntryRelationship.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EntryRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_inversionInd(self):
        return self.inversionInd
    def set_inversionInd(self, inversionInd):
        self.inversionInd = inversionInd
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipEntryRelationship(self, value):
        # Validate type x_ActRelationshipEntryRelationship, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['XCRPT', 'COMP', 'RSON', 'SPRT', 'CAUS', 'GEVL', 'MFST', 'REFR', 'SAS', 'SUBJ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipEntryRelationship' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipEntryRelationship_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipEntryRelationship_patterns_, ))
    validate_x_ActRelationshipEntryRelationship_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EntryRelationship', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EntryRelationship')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EntryRelationship':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EntryRelationship')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EntryRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EntryRelationship'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.inversionInd is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            outfile.write(' inversionInd="%s"' % self.gds_format_boolean(self.inversionInd, input_name='inversionInd'))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EntryRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipEntryRelationship(self.typeCode)    # validate type x_ActRelationshipEntryRelationship
        value = find_attr_value_('inversionInd', node)
        if value is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            if value in ('true', '1'):
                self.inversionInd = True
            elif value in ('false', '0'):
                self.inversionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inversionInd)    # validate type bl
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_EntryRelationship


class POCD_MT000040_ExternalAct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalAct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalAct.subclass:
            return POCD_MT000040_ExternalAct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalAct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalAct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalAct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalAct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalAct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalAct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalAct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalAct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalAct


class POCD_MT000040_ExternalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassDocument' = 'DOC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, setId: 'II' = None, versionNumber: 'INT' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalDocument.subclass:
            return POCD_MT000040_ExternalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassDocument(self, value):
        # Validate type ActClassDocument, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassDocument(self.classCode)    # validate type ActClassDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040_ExternalDocument


class POCD_MT000040_ExternalObservation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalObservation.subclass:
            return POCD_MT000040_ExternalObservation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalObservation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalObservation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalObservation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalObservation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalObservation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalObservation


class POCD_MT000040_ExternalProcedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'PROC', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalProcedure.subclass:
            return POCD_MT000040_ExternalProcedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalProcedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalProcedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalProcedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalProcedure')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalProcedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalProcedure


class POCD_MT000040_Guardian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'GUARD', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, guardianPerson: 'POCD_MT000040.Person' = None, guardianOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.guardianPerson = guardianPerson
        self.guardianPerson_nsprefix_ = None
        self.guardianOrganization = guardianOrganization
        self.guardianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Guardian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Guardian.subclass:
            return POCD_MT000040_Guardian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Guardian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_guardianPerson(self):
        return self.guardianPerson
    def set_guardianPerson(self, guardianPerson):
        self.guardianPerson = guardianPerson
    def get_guardianOrganization(self):
        return self.guardianOrganization
    def set_guardianOrganization(self, guardianOrganization):
        self.guardianOrganization = guardianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.guardianPerson is not None or
            self.guardianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Guardian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Guardian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Guardian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Guardian')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Guardian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Guardian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Guardian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.guardianPerson is not None:
            namespaceprefix_ = self.guardianPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianPerson_nsprefix_) else ''
            self.guardianPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianPerson', pretty_print=pretty_print)
        if self.guardianOrganization is not None:
            namespaceprefix_ = self.guardianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianOrganization_nsprefix_) else ''
            self.guardianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'guardianPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianPerson = obj_
            obj_.original_tagname_ = 'guardianPerson'
        elif nodeName_ == 'guardianOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianOrganization = obj_
            obj_.original_tagname_ = 'guardianOrganization'
# end class POCD_MT000040_Guardian


class POCD_MT000040_HealthCareFacility(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassServiceDeliveryLocation' = 'SDLOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, location: 'POCD_MT000040.Place' = None, serviceProviderOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        self.serviceProviderOrganization = serviceProviderOrganization
        self.serviceProviderOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_HealthCareFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_HealthCareFacility.subclass:
            return POCD_MT000040_HealthCareFacility.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_HealthCareFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_serviceProviderOrganization(self):
        return self.serviceProviderOrganization
    def set_serviceProviderOrganization(self, serviceProviderOrganization):
        self.serviceProviderOrganization = serviceProviderOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassServiceDeliveryLocation(self, value):
        # Validate type RoleClassServiceDeliveryLocation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SDLOC', 'DSDLOC', 'ISDLOC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassServiceDeliveryLocation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassServiceDeliveryLocation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassServiceDeliveryLocation_patterns_, ))
    validate_RoleClassServiceDeliveryLocation_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.location is not None or
            self.serviceProviderOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.HealthCareFacility', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.HealthCareFacility')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.HealthCareFacility':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.HealthCareFacility')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.HealthCareFacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.HealthCareFacility'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SDLOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.HealthCareFacility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        if self.serviceProviderOrganization is not None:
            namespaceprefix_ = self.serviceProviderOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceProviderOrganization_nsprefix_) else ''
            self.serviceProviderOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceProviderOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassServiceDeliveryLocation(self.classCode)    # validate type RoleClassServiceDeliveryLocation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'serviceProviderOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceProviderOrganization = obj_
            obj_.original_tagname_ = 'serviceProviderOrganization'
# end class POCD_MT000040_HealthCareFacility


class POCD_MT000040_Informant12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'INF', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, relatedEntity: 'POCD_MT000040.RelatedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
        self.relatedEntity = relatedEntity
        self.relatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Informant12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Informant12.subclass:
            return POCD_MT000040_Informant12.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Informant12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_relatedEntity(self):
        return self.relatedEntity
    def set_relatedEntity(self, relatedEntity):
        self.relatedEntity = relatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None or
            self.relatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Informant12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Informant12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Informant12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Informant12')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Informant12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Informant12'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Informant12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
        if self.relatedEntity is not None:
            namespaceprefix_ = self.relatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedEntity_nsprefix_) else ''
            self.relatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
        elif nodeName_ == 'relatedEntity':
            obj_ = POCD_MT000040_RelatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedEntity = obj_
            obj_.original_tagname_ = 'relatedEntity'
# end class POCD_MT000040_Informant12


class POCD_MT000040_InformationRecipient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_InformationRecipient' = 'PRCP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, intendedRecipient: 'POCD_MT000040.IntendedRecipient' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.intendedRecipient = intendedRecipient
        self.intendedRecipient_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InformationRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InformationRecipient.subclass:
            return POCD_MT000040_InformationRecipient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InformationRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_intendedRecipient(self):
        return self.intendedRecipient
    def set_intendedRecipient(self, intendedRecipient):
        self.intendedRecipient = intendedRecipient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_InformationRecipient(self, value):
        # Validate type x_InformationRecipient, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRCP', 'TRC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipient' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipient_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipient_patterns_, ))
    validate_x_InformationRecipient_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.intendedRecipient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InformationRecipient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InformationRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InformationRecipient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InformationRecipient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InformationRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InformationRecipient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InformationRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.intendedRecipient is not None:
            namespaceprefix_ = self.intendedRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.intendedRecipient_nsprefix_) else ''
            self.intendedRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intendedRecipient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_InformationRecipient(self.typeCode)    # validate type x_InformationRecipient
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'intendedRecipient':
            obj_ = POCD_MT000040_IntendedRecipient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intendedRecipient = obj_
            obj_.original_tagname_ = 'intendedRecipient'
# end class POCD_MT000040_InformationRecipient


class POCD_MT000040_InFulfillmentOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipFulfills' = 'FLFS', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, order: 'POCD_MT000040.Order' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.order = order
        self.order_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InFulfillmentOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InFulfillmentOf.subclass:
            return POCD_MT000040_InFulfillmentOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InFulfillmentOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipFulfills(self, value):
        # Validate type ActRelationshipFulfills, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FLFS', 'OCCR', 'OREF', 'SCH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipFulfills' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipFulfills_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipFulfills_patterns_, ))
    validate_ActRelationshipFulfills_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.order is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InFulfillmentOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InFulfillmentOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InFulfillmentOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InFulfillmentOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InFulfillmentOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InFulfillmentOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InFulfillmentOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.order is not None:
            namespaceprefix_ = self.order_nsprefix_ + ':' if (UseCapturedNS_ and self.order_nsprefix_) else ''
            self.order.export(outfile, level, namespaceprefix_, namespacedef_='', name_='order', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipFulfills(self.typeCode)    # validate type ActRelationshipFulfills
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'order':
            obj_ = POCD_MT000040_Order.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.order = obj_
            obj_.original_tagname_ = 'order'
# end class POCD_MT000040_InFulfillmentOf


class POCD_MT000040_IntendedRecipient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_InformationRecipientRole' = 'ASSIGNED', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, informationRecipient: 'POCD_MT000040.Person' = None, receivedOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = None
        self.receivedOrganization = receivedOrganization
        self.receivedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_IntendedRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_IntendedRecipient.subclass:
            return POCD_MT000040_IntendedRecipient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_IntendedRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def get_receivedOrganization(self):
        return self.receivedOrganization
    def set_receivedOrganization(self, receivedOrganization):
        self.receivedOrganization = receivedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_InformationRecipientRole(self, value):
        # Validate type x_InformationRecipientRole, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASSIGNED', 'HLTHCHRT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipientRole' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipientRole_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipientRole_patterns_, ))
    validate_x_InformationRecipientRole_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.informationRecipient is not None or
            self.receivedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.IntendedRecipient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.IntendedRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.IntendedRecipient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.IntendedRecipient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.IntendedRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.IntendedRecipient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.IntendedRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.informationRecipient is not None:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            self.informationRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        if self.receivedOrganization is not None:
            namespaceprefix_ = self.receivedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.receivedOrganization_nsprefix_) else ''
            self.receivedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receivedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_InformationRecipientRole(self.classCode)    # validate type x_InformationRecipientRole
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient = obj_
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'receivedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receivedOrganization = obj_
            obj_.original_tagname_ = 'receivedOrganization'
# end class POCD_MT000040_IntendedRecipient


class POCD_MT000040_LabeledDrug(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassManufacturedMaterial' = 'MMAT', determinerCode: 'EntityDeterminerDetermined' = 'KIND', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, name: 'EN' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LabeledDrug)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LabeledDrug.subclass:
            return POCD_MT000040_LabeledDrug.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LabeledDrug(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminerDetermined(self, value):
        # Validate type EntityDeterminerDetermined, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerDetermined' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerDetermined_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerDetermined_patterns_, ))
    validate_EntityDeterminerDetermined_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LabeledDrug', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LabeledDrug')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LabeledDrug':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LabeledDrug')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LabeledDrug', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LabeledDrug'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LabeledDrug', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerDetermined(self.determinerCode)    # validate type EntityDeterminerDetermined
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class POCD_MT000040_LabeledDrug


class POCD_MT000040_LanguageCommunication(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, languageCode: 'CS' = None, modeCode: 'CE' = None, proficiencyLevelCode: 'CE' = None, preferenceInd: 'BL' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.proficiencyLevelCode = proficiencyLevelCode
        self.proficiencyLevelCode_nsprefix_ = None
        self.preferenceInd = preferenceInd
        self.preferenceInd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LanguageCommunication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LanguageCommunication.subclass:
            return POCD_MT000040_LanguageCommunication.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LanguageCommunication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_proficiencyLevelCode(self):
        return self.proficiencyLevelCode
    def set_proficiencyLevelCode(self, proficiencyLevelCode):
        self.proficiencyLevelCode = proficiencyLevelCode
    def get_preferenceInd(self):
        return self.preferenceInd
    def set_preferenceInd(self, preferenceInd):
        self.preferenceInd = preferenceInd
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.languageCode is not None or
            self.modeCode is not None or
            self.proficiencyLevelCode is not None or
            self.preferenceInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LanguageCommunication', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LanguageCommunication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LanguageCommunication':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LanguageCommunication')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LanguageCommunication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LanguageCommunication'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LanguageCommunication', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.proficiencyLevelCode is not None:
            namespaceprefix_ = self.proficiencyLevelCode_nsprefix_ + ':' if (UseCapturedNS_ and self.proficiencyLevelCode_nsprefix_) else ''
            self.proficiencyLevelCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proficiencyLevelCode', pretty_print=pretty_print)
        if self.preferenceInd is not None:
            namespaceprefix_ = self.preferenceInd_nsprefix_ + ':' if (UseCapturedNS_ and self.preferenceInd_nsprefix_) else ''
            self.preferenceInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preferenceInd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'proficiencyLevelCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proficiencyLevelCode = obj_
            obj_.original_tagname_ = 'proficiencyLevelCode'
        elif nodeName_ == 'preferenceInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preferenceInd = obj_
            obj_.original_tagname_ = 'preferenceInd'
# end class POCD_MT000040_LanguageCommunication


class POCD_MT000040_LegalAuthenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'LA', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, time: 'TS' = None, signatureCode: 'CS' = None, signatureText: 'ED' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.signatureText = signatureText
        self.signatureText_nsprefix_ = "sdtc"
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LegalAuthenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LegalAuthenticator.subclass:
            return POCD_MT000040_LegalAuthenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LegalAuthenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_signatureText(self):
        return self.signatureText
    def set_signatureText(self, signatureText):
        self.signatureText = signatureText
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.signatureText is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.LegalAuthenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LegalAuthenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LegalAuthenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LegalAuthenticator')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LegalAuthenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LegalAuthenticator'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.LegalAuthenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.signatureText is not None:
            namespaceprefix_ = self.signatureText_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureText_nsprefix_) else ''
            self.signatureText.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='signatureText', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'signatureText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureText = obj_
            obj_.original_tagname_ = 'signatureText'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_LegalAuthenticator


class POCD_MT000040_Location(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationTargetLocation' = 'LOC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, healthCareFacility: 'POCD_MT000040.HealthCareFacility' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.healthCareFacility = healthCareFacility
        self.healthCareFacility_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Location.subclass:
            return POCD_MT000040_Location.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_healthCareFacility(self):
        return self.healthCareFacility
    def set_healthCareFacility(self, healthCareFacility):
        self.healthCareFacility = healthCareFacility
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetLocation(self, value):
        # Validate type ParticipationTargetLocation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LOC', 'DST', 'ELOC', 'ORG', 'RML', 'VIA']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetLocation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetLocation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetLocation_patterns_, ))
    validate_ParticipationTargetLocation_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.healthCareFacility is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Location', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Location':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Location')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Location'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.healthCareFacility is not None:
            namespaceprefix_ = self.healthCareFacility_nsprefix_ + ':' if (UseCapturedNS_ and self.healthCareFacility_nsprefix_) else ''
            self.healthCareFacility.export(outfile, level, namespaceprefix_, namespacedef_='', name_='healthCareFacility', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetLocation(self.typeCode)    # validate type ParticipationTargetLocation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'healthCareFacility':
            obj_ = POCD_MT000040_HealthCareFacility.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.healthCareFacility = obj_
            obj_.original_tagname_ = 'healthCareFacility'
# end class POCD_MT000040_Location


class POCD_MT000040_MaintainedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'MNT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, effectiveTime: 'IVL_TS' = None, maintainingPerson: 'POCD_MT000040.Person' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.maintainingPerson = maintainingPerson
        self.maintainingPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_MaintainedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_MaintainedEntity.subclass:
            return POCD_MT000040_MaintainedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_MaintainedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_maintainingPerson(self):
        return self.maintainingPerson
    def set_maintainingPerson(self, maintainingPerson):
        self.maintainingPerson = maintainingPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.effectiveTime is not None or
            self.maintainingPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.MaintainedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.MaintainedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.MaintainedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.MaintainedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.MaintainedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.MaintainedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.MaintainedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.maintainingPerson is not None:
            namespaceprefix_ = self.maintainingPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.maintainingPerson_nsprefix_) else ''
            self.maintainingPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maintainingPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'maintainingPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maintainingPerson = obj_
            obj_.original_tagname_ = 'maintainingPerson'
# end class POCD_MT000040_MaintainedEntity


class POCD_MT000040_ManufacturedProduct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassManufacturedProduct' = 'MANU', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, manufacturedLabeledDrug: 'POCD_MT000040.LabeledDrug' = None, manufacturedMaterial: 'POCD_MT000040.Material' = None, manufacturerOrganization: 'POCD_MT000040.Organization' = None, subjectOf1: List_['COCT_MT230100UV.Subject2'] = None, subjectOf2: List_['COCT_MT230100UV.Subject1'] = None, subjectOf3: List_['COCT_MT230100UV.Subject22'] = None, subjectOf4: List_['COCT_MT230100UV.Subject3'] = None, subjectOf5: 'COCT_MT230100UV.Subject7' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
        self.manufacturedLabeledDrug_nsprefix_ = None
        self.manufacturedMaterial = manufacturedMaterial
        self.manufacturedMaterial_nsprefix_ = None
        self.manufacturerOrganization = manufacturerOrganization
        self.manufacturerOrganization_nsprefix_ = None
        if subjectOf1 is None:
            self.subjectOf1 = []
        else:
            self.subjectOf1 = subjectOf1
        self.subjectOf1_nsprefix_ = "pharm"
        if subjectOf2 is None:
            self.subjectOf2 = []
        else:
            self.subjectOf2 = subjectOf2
        self.subjectOf2_nsprefix_ = "pharm"
        if subjectOf3 is None:
            self.subjectOf3 = []
        else:
            self.subjectOf3 = subjectOf3
        self.subjectOf3_nsprefix_ = "pharm"
        if subjectOf4 is None:
            self.subjectOf4 = []
        else:
            self.subjectOf4 = subjectOf4
        self.subjectOf4_nsprefix_ = "pharm"
        self.subjectOf5 = subjectOf5
        self.subjectOf5_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ManufacturedProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ManufacturedProduct.subclass:
            return POCD_MT000040_ManufacturedProduct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ManufacturedProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_manufacturedLabeledDrug(self):
        return self.manufacturedLabeledDrug
    def set_manufacturedLabeledDrug(self, manufacturedLabeledDrug):
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
    def get_manufacturedMaterial(self):
        return self.manufacturedMaterial
    def set_manufacturedMaterial(self, manufacturedMaterial):
        self.manufacturedMaterial = manufacturedMaterial
    def get_manufacturerOrganization(self):
        return self.manufacturerOrganization
    def set_manufacturerOrganization(self, manufacturerOrganization):
        self.manufacturerOrganization = manufacturerOrganization
    def get_subjectOf1(self):
        return self.subjectOf1
    def set_subjectOf1(self, subjectOf1):
        self.subjectOf1 = subjectOf1
    def add_subjectOf1(self, value):
        self.subjectOf1.append(value)
    def insert_subjectOf1_at(self, index, value):
        self.subjectOf1.insert(index, value)
    def replace_subjectOf1_at(self, index, value):
        self.subjectOf1[index] = value
    def get_subjectOf2(self):
        return self.subjectOf2
    def set_subjectOf2(self, subjectOf2):
        self.subjectOf2 = subjectOf2
    def add_subjectOf2(self, value):
        self.subjectOf2.append(value)
    def insert_subjectOf2_at(self, index, value):
        self.subjectOf2.insert(index, value)
    def replace_subjectOf2_at(self, index, value):
        self.subjectOf2[index] = value
    def get_subjectOf3(self):
        return self.subjectOf3
    def set_subjectOf3(self, subjectOf3):
        self.subjectOf3 = subjectOf3
    def add_subjectOf3(self, value):
        self.subjectOf3.append(value)
    def insert_subjectOf3_at(self, index, value):
        self.subjectOf3.insert(index, value)
    def replace_subjectOf3_at(self, index, value):
        self.subjectOf3[index] = value
    def get_subjectOf4(self):
        return self.subjectOf4
    def set_subjectOf4(self, subjectOf4):
        self.subjectOf4 = subjectOf4
    def add_subjectOf4(self, value):
        self.subjectOf4.append(value)
    def insert_subjectOf4_at(self, index, value):
        self.subjectOf4.insert(index, value)
    def replace_subjectOf4_at(self, index, value):
        self.subjectOf4[index] = value
    def get_subjectOf5(self):
        return self.subjectOf5
    def set_subjectOf5(self, subjectOf5):
        self.subjectOf5 = subjectOf5
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassManufacturedProduct(self, value):
        # Validate type RoleClassManufacturedProduct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANU', 'THER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassManufacturedProduct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassManufacturedProduct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassManufacturedProduct_patterns_, ))
    validate_RoleClassManufacturedProduct_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.manufacturedLabeledDrug is not None or
            self.manufacturedMaterial is not None or
            self.manufacturerOrganization is not None or
            self.subjectOf1 or
            self.subjectOf2 or
            self.subjectOf3 or
            self.subjectOf4 or
            self.subjectOf5 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='POCD_MT000040.ManufacturedProduct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ManufacturedProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ManufacturedProduct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ManufacturedProduct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ManufacturedProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ManufacturedProduct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='POCD_MT000040.ManufacturedProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.manufacturedLabeledDrug is not None:
            namespaceprefix_ = self.manufacturedLabeledDrug_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedLabeledDrug_nsprefix_) else ''
            self.manufacturedLabeledDrug.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedLabeledDrug', pretty_print=pretty_print)
        if self.manufacturedMaterial is not None:
            namespaceprefix_ = self.manufacturedMaterial_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedMaterial_nsprefix_) else ''
            self.manufacturedMaterial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedMaterial', pretty_print=pretty_print)
        if self.manufacturerOrganization is not None:
            namespaceprefix_ = self.manufacturerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerOrganization_nsprefix_) else ''
            self.manufacturerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerOrganization', pretty_print=pretty_print)
        for subjectOf1_ in self.subjectOf1:
            namespaceprefix_ = self.subjectOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf1_nsprefix_) else ''
            subjectOf1_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='subjectOf1', pretty_print=pretty_print)
        for subjectOf2_ in self.subjectOf2:
            namespaceprefix_ = self.subjectOf2_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf2_nsprefix_) else ''
            subjectOf2_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='subjectOf2', pretty_print=pretty_print)
        for subjectOf3_ in self.subjectOf3:
            namespaceprefix_ = self.subjectOf3_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf3_nsprefix_) else ''
            subjectOf3_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='subjectOf3', pretty_print=pretty_print)
        for subjectOf4_ in self.subjectOf4:
            namespaceprefix_ = self.subjectOf4_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf4_nsprefix_) else ''
            subjectOf4_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='subjectOf4', pretty_print=pretty_print)
        if self.subjectOf5 is not None:
            namespaceprefix_ = self.subjectOf5_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf5_nsprefix_) else ''
            self.subjectOf5.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='subjectOf5', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassManufacturedProduct(self.classCode)    # validate type RoleClassManufacturedProduct
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'manufacturedLabeledDrug':
            obj_ = POCD_MT000040_LabeledDrug.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedLabeledDrug = obj_
            obj_.original_tagname_ = 'manufacturedLabeledDrug'
        elif nodeName_ == 'manufacturedMaterial':
            obj_ = POCD_MT000040_Material.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedMaterial = obj_
            obj_.original_tagname_ = 'manufacturedMaterial'
        elif nodeName_ == 'manufacturerOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerOrganization = obj_
            obj_.original_tagname_ = 'manufacturerOrganization'
        elif nodeName_ == 'subjectOf1':
            obj_ = COCT_MT230100UV_Subject2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf1.append(obj_)
            obj_.original_tagname_ = 'subjectOf1'
        elif nodeName_ == 'subjectOf2':
            obj_ = COCT_MT230100UV_Subject1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf2.append(obj_)
            obj_.original_tagname_ = 'subjectOf2'
        elif nodeName_ == 'subjectOf3':
            obj_ = COCT_MT230100UV_Subject22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf3.append(obj_)
            obj_.original_tagname_ = 'subjectOf3'
        elif nodeName_ == 'subjectOf4':
            obj_ = COCT_MT230100UV_Subject3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf4.append(obj_)
            obj_.original_tagname_ = 'subjectOf4'
        elif nodeName_ == 'subjectOf5':
            obj_ = COCT_MT230100UV_Subject7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf5 = obj_
            obj_.original_tagname_ = 'subjectOf5'
# end class POCD_MT000040_ManufacturedProduct


class POCD_MT000040_Material(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassManufacturedMaterial' = 'MMAT', determinerCode: 'EntityDeterminerDetermined' = 'KIND', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, name: 'EN' = None, desc: 'ED' = None, riskCode: 'CE' = None, handlingCode: 'CE' = None, formCode: 'CE' = None, lotNumberText: 'ST' = None, expirationTime: 'IVL_TS' = None, stabilityTime: 'IVL_TS' = None, asDistributedProduct: List_['COCT_MT230100UV.DistributedProduct'] = None, asMedicineManufacturer: List_['COCT_MT230100UV.MedicineManufacturer'] = None, asContent: 'COCT_MT230100UV.Content' = None, asSpecializedKind: List_['COCT_MT230100UV.SpecializedKind'] = None, part: List_['COCT_MT230100UV.Part'] = None, ingredient: List_['COCT_MT230100UV.Ingredient'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = "pharm"
        self.riskCode = riskCode
        self.riskCode_nsprefix_ = "pharm"
        self.handlingCode = handlingCode
        self.handlingCode_nsprefix_ = "pharm"
        self.formCode = formCode
        self.formCode_nsprefix_ = "pharm"
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = None
        self.expirationTime = expirationTime
        self.expirationTime_nsprefix_ = "pharm"
        self.stabilityTime = stabilityTime
        self.stabilityTime_nsprefix_ = "pharm"
        if asDistributedProduct is None:
            self.asDistributedProduct = []
        else:
            self.asDistributedProduct = asDistributedProduct
        self.asDistributedProduct_nsprefix_ = "pharm"
        if asMedicineManufacturer is None:
            self.asMedicineManufacturer = []
        else:
            self.asMedicineManufacturer = asMedicineManufacturer
        self.asMedicineManufacturer_nsprefix_ = "pharm"
        self.asContent = asContent
        self.asContent_nsprefix_ = "pharm"
        if asSpecializedKind is None:
            self.asSpecializedKind = []
        else:
            self.asSpecializedKind = asSpecializedKind
        self.asSpecializedKind_nsprefix_ = "pharm"
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = "pharm"
        if ingredient is None:
            self.ingredient = []
        else:
            self.ingredient = ingredient
        self.ingredient_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Material.subclass:
            return POCD_MT000040_Material.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_riskCode(self):
        return self.riskCode
    def set_riskCode(self, riskCode):
        self.riskCode = riskCode
    def get_handlingCode(self):
        return self.handlingCode
    def set_handlingCode(self, handlingCode):
        self.handlingCode = handlingCode
    def get_formCode(self):
        return self.formCode
    def set_formCode(self, formCode):
        self.formCode = formCode
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_expirationTime(self):
        return self.expirationTime
    def set_expirationTime(self, expirationTime):
        self.expirationTime = expirationTime
    def get_stabilityTime(self):
        return self.stabilityTime
    def set_stabilityTime(self, stabilityTime):
        self.stabilityTime = stabilityTime
    def get_asDistributedProduct(self):
        return self.asDistributedProduct
    def set_asDistributedProduct(self, asDistributedProduct):
        self.asDistributedProduct = asDistributedProduct
    def add_asDistributedProduct(self, value):
        self.asDistributedProduct.append(value)
    def insert_asDistributedProduct_at(self, index, value):
        self.asDistributedProduct.insert(index, value)
    def replace_asDistributedProduct_at(self, index, value):
        self.asDistributedProduct[index] = value
    def get_asMedicineManufacturer(self):
        return self.asMedicineManufacturer
    def set_asMedicineManufacturer(self, asMedicineManufacturer):
        self.asMedicineManufacturer = asMedicineManufacturer
    def add_asMedicineManufacturer(self, value):
        self.asMedicineManufacturer.append(value)
    def insert_asMedicineManufacturer_at(self, index, value):
        self.asMedicineManufacturer.insert(index, value)
    def replace_asMedicineManufacturer_at(self, index, value):
        self.asMedicineManufacturer[index] = value
    def get_asContent(self):
        return self.asContent
    def set_asContent(self, asContent):
        self.asContent = asContent
    def get_asSpecializedKind(self):
        return self.asSpecializedKind
    def set_asSpecializedKind(self, asSpecializedKind):
        self.asSpecializedKind = asSpecializedKind
    def add_asSpecializedKind(self, value):
        self.asSpecializedKind.append(value)
    def insert_asSpecializedKind_at(self, index, value):
        self.asSpecializedKind.insert(index, value)
    def replace_asSpecializedKind_at(self, index, value):
        self.asSpecializedKind[index] = value
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_ingredient(self):
        return self.ingredient
    def set_ingredient(self, ingredient):
        self.ingredient = ingredient
    def add_ingredient(self, value):
        self.ingredient.append(value)
    def insert_ingredient_at(self, index, value):
        self.ingredient.insert(index, value)
    def replace_ingredient_at(self, index, value):
        self.ingredient[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminerDetermined(self, value):
        # Validate type EntityDeterminerDetermined, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerDetermined' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerDetermined_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerDetermined_patterns_, ))
    validate_EntityDeterminerDetermined_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None or
            self.desc is not None or
            self.riskCode is not None or
            self.handlingCode is not None or
            self.formCode is not None or
            self.lotNumberText is not None or
            self.expirationTime is not None or
            self.stabilityTime is not None or
            self.asDistributedProduct or
            self.asMedicineManufacturer or
            self.asContent is not None or
            self.asSpecializedKind or
            self.part or
            self.ingredient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='POCD_MT000040.Material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Material':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Material')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Material'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='POCD_MT000040.Material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.riskCode is not None:
            namespaceprefix_ = self.riskCode_nsprefix_ + ':' if (UseCapturedNS_ and self.riskCode_nsprefix_) else ''
            self.riskCode.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='riskCode', pretty_print=pretty_print)
        if self.handlingCode is not None:
            namespaceprefix_ = self.handlingCode_nsprefix_ + ':' if (UseCapturedNS_ and self.handlingCode_nsprefix_) else ''
            self.handlingCode.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='handlingCode', pretty_print=pretty_print)
        if self.formCode is not None:
            namespaceprefix_ = self.formCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formCode_nsprefix_) else ''
            self.formCode.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='formCode', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
        if self.expirationTime is not None:
            namespaceprefix_ = self.expirationTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expirationTime_nsprefix_) else ''
            self.expirationTime.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='expirationTime', pretty_print=pretty_print)
        if self.stabilityTime is not None:
            namespaceprefix_ = self.stabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.stabilityTime_nsprefix_) else ''
            self.stabilityTime.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='stabilityTime', pretty_print=pretty_print)
        for asDistributedProduct_ in self.asDistributedProduct:
            namespaceprefix_ = self.asDistributedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.asDistributedProduct_nsprefix_) else ''
            asDistributedProduct_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='asDistributedProduct', pretty_print=pretty_print)
        for asMedicineManufacturer_ in self.asMedicineManufacturer:
            namespaceprefix_ = self.asMedicineManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.asMedicineManufacturer_nsprefix_) else ''
            asMedicineManufacturer_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='asMedicineManufacturer', pretty_print=pretty_print)
        if self.asContent is not None:
            namespaceprefix_ = self.asContent_nsprefix_ + ':' if (UseCapturedNS_ and self.asContent_nsprefix_) else ''
            self.asContent.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='asContent', pretty_print=pretty_print)
        for asSpecializedKind_ in self.asSpecializedKind:
            namespaceprefix_ = self.asSpecializedKind_nsprefix_ + ':' if (UseCapturedNS_ and self.asSpecializedKind_nsprefix_) else ''
            asSpecializedKind_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='asSpecializedKind', pretty_print=pretty_print)
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='part', pretty_print=pretty_print)
        for ingredient_ in self.ingredient:
            namespaceprefix_ = self.ingredient_nsprefix_ + ':' if (UseCapturedNS_ and self.ingredient_nsprefix_) else ''
            ingredient_.export(outfile, level, namespaceprefix_='pharm:', namespacedef_='', name_='ingredient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerDetermined(self.determinerCode)    # validate type EntityDeterminerDetermined
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'riskCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.riskCode = obj_
            obj_.original_tagname_ = 'riskCode'
        elif nodeName_ == 'handlingCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.handlingCode = obj_
            obj_.original_tagname_ = 'handlingCode'
        elif nodeName_ == 'formCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formCode = obj_
            obj_.original_tagname_ = 'formCode'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
        elif nodeName_ == 'expirationTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'stabilityTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stabilityTime = obj_
            obj_.original_tagname_ = 'stabilityTime'
        elif nodeName_ == 'asDistributedProduct':
            obj_ = COCT_MT230100UV_DistributedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asDistributedProduct.append(obj_)
            obj_.original_tagname_ = 'asDistributedProduct'
        elif nodeName_ == 'asMedicineManufacturer':
            obj_ = COCT_MT230100UV_MedicineManufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asMedicineManufacturer.append(obj_)
            obj_.original_tagname_ = 'asMedicineManufacturer'
        elif nodeName_ == 'asContent':
            obj_ = COCT_MT230100UV_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asContent = obj_
            obj_.original_tagname_ = 'asContent'
        elif nodeName_ == 'asSpecializedKind':
            obj_ = COCT_MT230100UV_SpecializedKind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asSpecializedKind.append(obj_)
            obj_.original_tagname_ = 'asSpecializedKind'
        elif nodeName_ == 'part':
            obj_ = COCT_MT230100UV_Part.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
        elif nodeName_ == 'ingredient':
            obj_ = COCT_MT230100UV_Ingredient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ingredient.append(obj_)
            obj_.original_tagname_ = 'ingredient'
# end class POCD_MT000040_Material


class POCD_MT000040_NonXMLBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCBODY', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, text: 'ED' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_NonXMLBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_NonXMLBody.subclass:
            return POCD_MT000040_NonXMLBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_NonXMLBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.NonXMLBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.NonXMLBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.NonXMLBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.NonXMLBody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.NonXMLBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.NonXMLBody'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.NonXMLBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
# end class POCD_MT000040_NonXMLBody


class POCD_MT000040_Observation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = None, moodCode: 'x_ActMoodDocumentObservation' = None, negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, derivationExpr: 'ST' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, priorityCode: 'CE' = None, repeatNumber: 'IVL_INT' = None, languageCode: 'CS' = None, value: List_['ANY'] = None, interpretationCode: List_['CE'] = None, methodCode: List_['CE'] = None, targetSiteCode: List_['CD'] = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, referenceRange: List_['POCD_MT000040.ReferenceRange'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.derivationExpr = derivationExpr
        self.derivationExpr_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        if interpretationCode is None:
            self.interpretationCode = []
        else:
            self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if referenceRange is None:
            self.referenceRange = []
        else:
            self.referenceRange = referenceRange
        self.referenceRange_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Observation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Observation.subclass:
            return POCD_MT000040_Observation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Observation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_derivationExpr(self):
        return self.derivationExpr
    def set_derivationExpr(self, derivationExpr):
        self.derivationExpr = derivationExpr
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def add_value(self, value):
        self.value.append(value)
    def add_value_with_type(self, value):
        self.value.append(value)
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def add_interpretationCode(self, value):
        self.interpretationCode.append(value)
    def insert_interpretationCode_at(self, index, value):
        self.interpretationCode.insert(index, value)
    def replace_interpretationCode_at(self, index, value):
        self.interpretationCode[index] = value
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_referenceRange(self):
        return self.referenceRange
    def set_referenceRange(self, referenceRange):
        self.referenceRange = referenceRange
    def add_referenceRange(self, value):
        self.referenceRange.append(value)
    def insert_referenceRange_at(self, index, value):
        self.referenceRange.insert(index, value)
    def replace_referenceRange_at(self, index, value):
        self.referenceRange[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_x_ActMoodDocumentObservation(self, value):
        # Validate type x_ActMoodDocumentObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'DEF', 'EVN', 'GOL', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActMoodDocumentObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActMoodDocumentObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActMoodDocumentObservation_patterns_, ))
    validate_x_ActMoodDocumentObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.derivationExpr is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.repeatNumber is not None or
            self.languageCode is not None or
            self.value or
            self.interpretationCode or
            self.methodCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.referenceRange or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Observation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Observation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Observation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Observation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Observation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Observation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Observation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.derivationExpr is not None:
            namespaceprefix_ = self.derivationExpr_nsprefix_ + ':' if (UseCapturedNS_ and self.derivationExpr_nsprefix_) else ''
            self.derivationExpr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='derivationExpr', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
        for interpretationCode_ in self.interpretationCode:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            interpretationCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for referenceRange_ in self.referenceRange:
            namespaceprefix_ = self.referenceRange_nsprefix_ + ':' if (UseCapturedNS_ and self.referenceRange_nsprefix_) else ''
            referenceRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referenceRange', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_ActMoodDocumentObservation(self.moodCode)    # validate type x_ActMoodDocumentObservation
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'derivationExpr':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.derivationExpr = obj_
            obj_.original_tagname_ = 'derivationExpr'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode.append(obj_)
            obj_.original_tagname_ = 'interpretationCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'referenceRange':
            obj_ = POCD_MT000040_ReferenceRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referenceRange.append(obj_)
            obj_.original_tagname_ = 'referenceRange'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_Observation


class POCD_MT000040_ObservationMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = None, moodCode: 'ActMood' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, languageCode: 'CS' = None, value: 'ED' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ObservationMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ObservationMedia.subclass:
            return POCD_MT000040_ObservationMedia.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ObservationMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.languageCode is not None or
            self.value is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ObservationMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ObservationMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ObservationMedia')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ObservationMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ObservationMedia'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_ObservationMedia


class POCD_MT000040_ObservationRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassObservation' = 'OBS', moodCode: 'ActMood' = 'EVN.CRT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, value: 'ANY' = None, interpretationCode: 'CE' = None, precondition1: List_['Precondition1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
        if precondition1 is None:
            self.precondition1 = []
        else:
            self.precondition1 = precondition1
        self.precondition1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ObservationRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ObservationRange.subclass:
            return POCD_MT000040_ObservationRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ObservationRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def get_precondition1(self):
        return self.precondition1
    def set_precondition1(self, precondition1):
        self.precondition1 = precondition1
    def add_precondition1(self, value):
        self.precondition1.append(value)
    def insert_precondition1_at(self, index, value):
        self.precondition1.insert(index, value)
    def replace_precondition1_at(self, index, value):
        self.precondition1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None or
            self.interpretationCode is not None or
            self.precondition1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.ObservationRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ObservationRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ObservationRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ObservationRange')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ObservationRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ObservationRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.ObservationRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
        if self.interpretationCode is not None:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            self.interpretationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
        for precondition1_ in self.precondition1:
            namespaceprefix_ = self.precondition1_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition1_nsprefix_) else ''
            precondition1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='precondition1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode = obj_
            obj_.original_tagname_ = 'interpretationCode'
        elif nodeName_ == 'precondition1':
            obj_ = Precondition1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition1.append(obj_)
            obj_.original_tagname_ = 'precondition1'
# end class POCD_MT000040_ObservationRange


class POCD_MT000040_Order(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'RQO', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, priorityCode: 'CE' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Order)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Order.subclass:
            return POCD_MT000040_Order.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Order(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.priorityCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Order', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Order')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Order':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Order')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Order', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Order'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Order', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
# end class POCD_MT000040_Order


class POCD_MT000040_Organization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassOrganization' = 'ORG', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: List_['ON'] = None, telecom: List_['TEL'] = None, addr: List_['AD'] = None, standardIndustryClassCode: 'CE' = None, asOrganizationPartOf: 'POCD_MT000040.OrganizationPartOf' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        self.standardIndustryClassCode = standardIndustryClassCode
        self.standardIndustryClassCode_nsprefix_ = None
        self.asOrganizationPartOf = asOrganizationPartOf
        self.asOrganizationPartOf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Organization.subclass:
            return POCD_MT000040_Organization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_standardIndustryClassCode(self):
        return self.standardIndustryClassCode
    def set_standardIndustryClassCode(self, standardIndustryClassCode):
        self.standardIndustryClassCode = standardIndustryClassCode
    def get_asOrganizationPartOf(self):
        return self.asOrganizationPartOf
    def set_asOrganizationPartOf(self, asOrganizationPartOf):
        self.asOrganizationPartOf = asOrganizationPartOf
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassOrganization(self, value):
        # Validate type EntityClassOrganization, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name or
            self.telecom or
            self.addr or
            self.standardIndustryClassCode is not None or
            self.asOrganizationPartOf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Organization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Organization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Organization')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Organization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Organization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        if self.standardIndustryClassCode is not None:
            namespaceprefix_ = self.standardIndustryClassCode_nsprefix_ + ':' if (UseCapturedNS_ and self.standardIndustryClassCode_nsprefix_) else ''
            self.standardIndustryClassCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardIndustryClassCode', pretty_print=pretty_print)
        if self.asOrganizationPartOf is not None:
            namespaceprefix_ = self.asOrganizationPartOf_nsprefix_ + ':' if (UseCapturedNS_ and self.asOrganizationPartOf_nsprefix_) else ''
            self.asOrganizationPartOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asOrganizationPartOf', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassOrganization(self.classCode)    # validate type EntityClassOrganization
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'standardIndustryClassCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardIndustryClassCode = obj_
            obj_.original_tagname_ = 'standardIndustryClassCode'
        elif nodeName_ == 'asOrganizationPartOf':
            obj_ = POCD_MT000040_OrganizationPartOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asOrganizationPartOf = obj_
            obj_.original_tagname_ = 'asOrganizationPartOf'
# end class POCD_MT000040_Organization


class POCD_MT000040_OrganizationPartOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'PART', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, wholeOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.wholeOrganization = wholeOrganization
        self.wholeOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_OrganizationPartOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_OrganizationPartOf.subclass:
            return POCD_MT000040_OrganizationPartOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_OrganizationPartOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_wholeOrganization(self):
        return self.wholeOrganization
    def set_wholeOrganization(self, wholeOrganization):
        self.wholeOrganization = wholeOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.wholeOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.OrganizationPartOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.OrganizationPartOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.OrganizationPartOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.OrganizationPartOf')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.OrganizationPartOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.OrganizationPartOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.OrganizationPartOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.wholeOrganization is not None:
            namespaceprefix_ = self.wholeOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.wholeOrganization_nsprefix_) else ''
            self.wholeOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wholeOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'wholeOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wholeOrganization = obj_
            obj_.original_tagname_ = 'wholeOrganization'
# end class POCD_MT000040_OrganizationPartOf


class POCD_MT000040_Organizer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_ActClassDocumentEntryOrganizer' = None, moodCode: 'ActMood' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, component: List_['POCD_MT000040.Component4'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = "sdtc"
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Organizer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Organizer.subclass:
            return POCD_MT000040_Organizer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Organizer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActClassDocumentEntryOrganizer(self, value):
        # Validate type x_ActClassDocumentEntryOrganizer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BATTERY', 'CLUSTER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryOrganizer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryOrganizer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryOrganizer_patterns_, ))
    validate_x_ActClassDocumentEntryOrganizer_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.reference or
            self.precondition or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Organizer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Organizer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Organizer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Organizer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Organizer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Organizer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Organizer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryOrganizer(self.classCode)    # validate type x_ActClassDocumentEntryOrganizer
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_Organizer


class POCD_MT000040_ParentDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClinicalDocument' = 'DOCCLIN', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, setId: 'II' = None, versionNumber: 'INT' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ParentDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ParentDocument.subclass:
            return POCD_MT000040_ParentDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ParentDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClinicalDocument(self, value):
        # Validate type ActClinicalDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOCCLIN', 'CDALVLONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClinicalDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClinicalDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClinicalDocument_patterns_, ))
    validate_ActClinicalDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParentDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ParentDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ParentDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ParentDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ParentDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ParentDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParentDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClinicalDocument(self.classCode)    # validate type ActClinicalDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040_ParentDocument


class POCD_MT000040_Participant1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = None, contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, associatedEntity: 'POCD_MT000040.AssociatedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.associatedEntity = associatedEntity
        self.associatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Participant1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Participant1.subclass:
            return POCD_MT000040_Participant1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Participant1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_associatedEntity(self):
        return self.associatedEntity
    def set_associatedEntity(self, associatedEntity):
        self.associatedEntity = associatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.associatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Participant1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Participant1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Participant1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Participant1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Participant1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.associatedEntity is not None:
            namespaceprefix_ = self.associatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedEntity_nsprefix_) else ''
            self.associatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'associatedEntity':
            obj_ = POCD_MT000040_AssociatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedEntity = obj_
            obj_.original_tagname_ = 'associatedEntity'
# end class POCD_MT000040_Participant1


class POCD_MT000040_Participant2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = None, contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, awarenessCode: 'CE' = None, participantRole: 'POCD_MT000040.ParticipantRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.participantRole = participantRole
        self.participantRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Participant2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Participant2.subclass:
            return POCD_MT000040_Participant2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Participant2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_participantRole(self):
        return self.participantRole
    def set_participantRole(self, participantRole):
        self.participantRole = participantRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.awarenessCode is not None or
            self.participantRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Participant2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Participant2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Participant2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Participant2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Participant2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.participantRole is not None:
            namespaceprefix_ = self.participantRole_nsprefix_ + ':' if (UseCapturedNS_ and self.participantRole_nsprefix_) else ''
            self.participantRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participantRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'participantRole':
            obj_ = POCD_MT000040_ParticipantRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participantRole = obj_
            obj_.original_tagname_ = 'participantRole'
# end class POCD_MT000040_Participant2


class functionCode(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, functionCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if functionCode.subclass:
            return functionCode.subclass(*args_, **kwargs_)
        else:
            return functionCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='functionCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('functionCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'functionCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='functionCode')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='functionCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='functionCode'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='functionCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class functionCode


class POCD_MT000040_ParticipantRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassRoot' = 'ROL', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, playingDevice: 'POCD_MT000040.Device' = None, playingEntity: 'POCD_MT000040.PlayingEntity' = None, scopingEntity: 'POCD_MT000040.Entity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.playingDevice = playingDevice
        self.playingDevice_nsprefix_ = None
        self.playingEntity = playingEntity
        self.playingEntity_nsprefix_ = None
        self.scopingEntity = scopingEntity
        self.scopingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ParticipantRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ParticipantRole.subclass:
            return POCD_MT000040_ParticipantRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ParticipantRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_playingDevice(self):
        return self.playingDevice
    def set_playingDevice(self, playingDevice):
        self.playingDevice = playingDevice
    def get_playingEntity(self):
        return self.playingEntity
    def set_playingEntity(self, playingEntity):
        self.playingEntity = playingEntity
    def get_scopingEntity(self):
        return self.scopingEntity
    def set_scopingEntity(self, scopingEntity):
        self.scopingEntity = scopingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassRoot(self, value):
        # Validate type RoleClassRoot, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.playingDevice is not None or
            self.playingEntity is not None or
            self.scopingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParticipantRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ParticipantRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ParticipantRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ParticipantRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ParticipantRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ParticipantRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ROL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParticipantRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.playingDevice is not None:
            namespaceprefix_ = self.playingDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.playingDevice_nsprefix_) else ''
            self.playingDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingDevice', pretty_print=pretty_print)
        if self.playingEntity is not None:
            namespaceprefix_ = self.playingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.playingEntity_nsprefix_) else ''
            self.playingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingEntity', pretty_print=pretty_print)
        if self.scopingEntity is not None:
            namespaceprefix_ = self.scopingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingEntity_nsprefix_) else ''
            self.scopingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassRoot(self.classCode)    # validate type RoleClassRoot
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'playingDevice':
            obj_ = POCD_MT000040_Device.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingDevice = obj_
            obj_.original_tagname_ = 'playingDevice'
        elif nodeName_ == 'playingEntity':
            obj_ = POCD_MT000040_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingEntity = obj_
            obj_.original_tagname_ = 'playingEntity'
        elif nodeName_ == 'scopingEntity':
            obj_ = POCD_MT000040_Entity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingEntity = obj_
            obj_.original_tagname_ = 'scopingEntity'
# end class POCD_MT000040_ParticipantRole


class POCD_MT000040_Patient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, name: List_['PN'] = None, desc: 'ED' = None, administrativeGenderCode: 'CE' = None, birthTime: 'TS' = None, deceasedInd: 'BL' = None, deceasedTime: 'TS' = None, multipleBirthInd: 'BL' = None, multipleBirthOrderNumber: 'INT_POS' = None, maritalStatusCode: 'CE' = None, religiousAffiliationCode: 'CE' = None, raceCode: List_['CE'] = None, ethnicGroupCode: List_['CE'] = None, guardian: List_['POCD_MT000040.Guardian'] = None, birthplace: 'POCD_MT000040.Birthplace' = None, languageCommunication: List_['POCD_MT000040.LanguageCommunication'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = "sdtc"
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
        self.deceasedInd = deceasedInd
        self.deceasedInd_nsprefix_ = "sdtc"
        self.deceasedTime = deceasedTime
        self.deceasedTime_nsprefix_ = "sdtc"
        self.multipleBirthInd = multipleBirthInd
        self.multipleBirthInd_nsprefix_ = "sdtc"
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
        self.multipleBirthOrderNumber_nsprefix_ = "sdtc"
        self.maritalStatusCode = maritalStatusCode
        self.maritalStatusCode_nsprefix_ = None
        self.religiousAffiliationCode = religiousAffiliationCode
        self.religiousAffiliationCode_nsprefix_ = None
        if raceCode is None:
            self.raceCode = []
        else:
            self.raceCode = raceCode
        self.raceCode_nsprefix_ = "sdtc"
        if ethnicGroupCode is None:
            self.ethnicGroupCode = []
        else:
            self.ethnicGroupCode = ethnicGroupCode
        self.ethnicGroupCode_nsprefix_ = "sdtc"
        if guardian is None:
            self.guardian = []
        else:
            self.guardian = guardian
        self.guardian_nsprefix_ = None
        self.birthplace = birthplace
        self.birthplace_nsprefix_ = None
        if languageCommunication is None:
            self.languageCommunication = []
        else:
            self.languageCommunication = languageCommunication
        self.languageCommunication_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Patient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Patient.subclass:
            return POCD_MT000040_Patient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Patient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_deceasedInd(self):
        return self.deceasedInd
    def set_deceasedInd(self, deceasedInd):
        self.deceasedInd = deceasedInd
    def get_deceasedTime(self):
        return self.deceasedTime
    def set_deceasedTime(self, deceasedTime):
        self.deceasedTime = deceasedTime
    def get_multipleBirthInd(self):
        return self.multipleBirthInd
    def set_multipleBirthInd(self, multipleBirthInd):
        self.multipleBirthInd = multipleBirthInd
    def get_multipleBirthOrderNumber(self):
        return self.multipleBirthOrderNumber
    def set_multipleBirthOrderNumber(self, multipleBirthOrderNumber):
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
    def get_maritalStatusCode(self):
        return self.maritalStatusCode
    def set_maritalStatusCode(self, maritalStatusCode):
        self.maritalStatusCode = maritalStatusCode
    def get_religiousAffiliationCode(self):
        return self.religiousAffiliationCode
    def set_religiousAffiliationCode(self, religiousAffiliationCode):
        self.religiousAffiliationCode = religiousAffiliationCode
    def get_raceCode(self):
        return self.raceCode
    def set_raceCode(self, raceCode):
        self.raceCode = raceCode
    def add_raceCode(self, value):
        self.raceCode.append(value)
    def insert_raceCode_at(self, index, value):
        self.raceCode.insert(index, value)
    def replace_raceCode_at(self, index, value):
        self.raceCode[index] = value
    def get_ethnicGroupCode(self):
        return self.ethnicGroupCode
    def set_ethnicGroupCode(self, ethnicGroupCode):
        self.ethnicGroupCode = ethnicGroupCode
    def add_ethnicGroupCode(self, value):
        self.ethnicGroupCode.append(value)
    def insert_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode.insert(index, value)
    def replace_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode[index] = value
    def get_guardian(self):
        return self.guardian
    def set_guardian(self, guardian):
        self.guardian = guardian
    def add_guardian(self, value):
        self.guardian.append(value)
    def insert_guardian_at(self, index, value):
        self.guardian.insert(index, value)
    def replace_guardian_at(self, index, value):
        self.guardian[index] = value
    def get_birthplace(self):
        return self.birthplace
    def set_birthplace(self, birthplace):
        self.birthplace = birthplace
    def get_languageCommunication(self):
        return self.languageCommunication
    def set_languageCommunication(self, languageCommunication):
        self.languageCommunication = languageCommunication
    def add_languageCommunication(self, value):
        self.languageCommunication.append(value)
    def insert_languageCommunication_at(self, index, value):
        self.languageCommunication.insert(index, value)
    def replace_languageCommunication_at(self, index, value):
        self.languageCommunication[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name or
            self.desc is not None or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.deceasedInd is not None or
            self.deceasedTime is not None or
            self.multipleBirthInd is not None or
            self.multipleBirthOrderNumber is not None or
            self.maritalStatusCode is not None or
            self.religiousAffiliationCode is not None or
            self.raceCode or
            self.ethnicGroupCode or
            self.guardian or
            self.birthplace is not None or
            self.languageCommunication
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Patient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Patient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Patient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Patient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Patient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Patient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Patient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.deceasedInd is not None:
            namespaceprefix_ = self.deceasedInd_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedInd_nsprefix_) else ''
            self.deceasedInd.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='deceasedInd', pretty_print=pretty_print)
        if self.deceasedTime is not None:
            namespaceprefix_ = self.deceasedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedTime_nsprefix_) else ''
            self.deceasedTime.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='deceasedTime', pretty_print=pretty_print)
        if self.multipleBirthInd is not None:
            namespaceprefix_ = self.multipleBirthInd_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthInd_nsprefix_) else ''
            self.multipleBirthInd.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='multipleBirthInd', pretty_print=pretty_print)
        if self.multipleBirthOrderNumber is not None:
            namespaceprefix_ = self.multipleBirthOrderNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthOrderNumber_nsprefix_) else ''
            self.multipleBirthOrderNumber.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='multipleBirthOrderNumber', pretty_print=pretty_print)
        if self.maritalStatusCode is not None:
            namespaceprefix_ = self.maritalStatusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.maritalStatusCode_nsprefix_) else ''
            self.maritalStatusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maritalStatusCode', pretty_print=pretty_print)
        if self.religiousAffiliationCode is not None:
            namespaceprefix_ = self.religiousAffiliationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.religiousAffiliationCode_nsprefix_) else ''
            self.religiousAffiliationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='religiousAffiliationCode', pretty_print=pretty_print)
        for raceCode_ in self.raceCode:
            namespaceprefix_ = self.raceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.raceCode_nsprefix_) else ''
            raceCode_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='raceCode', pretty_print=pretty_print)
        for ethnicGroupCode_ in self.ethnicGroupCode:
            namespaceprefix_ = self.ethnicGroupCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ethnicGroupCode_nsprefix_) else ''
            ethnicGroupCode_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='ethnicGroupCode', pretty_print=pretty_print)
        for guardian_ in self.guardian:
            namespaceprefix_ = self.guardian_nsprefix_ + ':' if (UseCapturedNS_ and self.guardian_nsprefix_) else ''
            guardian_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardian', pretty_print=pretty_print)
        if self.birthplace is not None:
            namespaceprefix_ = self.birthplace_nsprefix_ + ':' if (UseCapturedNS_ and self.birthplace_nsprefix_) else ''
            self.birthplace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthplace', pretty_print=pretty_print)
        for languageCommunication_ in self.languageCommunication:
            namespaceprefix_ = self.languageCommunication_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCommunication_nsprefix_) else ''
            languageCommunication_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCommunication', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'deceasedInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedInd = obj_
            obj_.original_tagname_ = 'deceasedInd'
        elif nodeName_ == 'deceasedTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedTime = obj_
            obj_.original_tagname_ = 'deceasedTime'
        elif nodeName_ == 'multipleBirthInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthInd = obj_
            obj_.original_tagname_ = 'multipleBirthInd'
        elif nodeName_ == 'multipleBirthOrderNumber':
            obj_ = INT_POS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthOrderNumber = obj_
            obj_.original_tagname_ = 'multipleBirthOrderNumber'
        elif nodeName_ == 'maritalStatusCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maritalStatusCode = obj_
            obj_.original_tagname_ = 'maritalStatusCode'
        elif nodeName_ == 'religiousAffiliationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.religiousAffiliationCode = obj_
            obj_.original_tagname_ = 'religiousAffiliationCode'
        elif nodeName_ == 'raceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.raceCode.append(obj_)
            obj_.original_tagname_ = 'raceCode'
        elif nodeName_ == 'ethnicGroupCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ethnicGroupCode.append(obj_)
            obj_.original_tagname_ = 'ethnicGroupCode'
        elif nodeName_ == 'guardian':
            obj_ = POCD_MT000040_Guardian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardian.append(obj_)
            obj_.original_tagname_ = 'guardian'
        elif nodeName_ == 'birthplace':
            obj_ = POCD_MT000040_Birthplace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthplace = obj_
            obj_.original_tagname_ = 'birthplace'
        elif nodeName_ == 'languageCommunication':
            obj_ = POCD_MT000040_LanguageCommunication.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCommunication.append(obj_)
            obj_.original_tagname_ = 'languageCommunication'
# end class POCD_MT000040_Patient


class POCD_MT000040_PatientRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClass' = 'PAT', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, patient: 'POCD_MT000040.Patient' = None, providerOrganization: 'POCD_MT000040.Organization' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.patient = patient
        self.patient_nsprefix_ = None
        self.providerOrganization = providerOrganization
        self.providerOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_PatientRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_PatientRole.subclass:
            return POCD_MT000040_PatientRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_PatientRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_patient(self):
        return self.patient
    def set_patient(self, patient):
        self.patient = patient
    def get_providerOrganization(self):
        return self.providerOrganization
    def set_providerOrganization(self, providerOrganization):
        self.providerOrganization = providerOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.patient is not None or
            self.providerOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PatientRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.PatientRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.PatientRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.PatientRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.PatientRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.PatientRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PatientRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.patient is not None:
            namespaceprefix_ = self.patient_nsprefix_ + ':' if (UseCapturedNS_ and self.patient_nsprefix_) else ''
            self.patient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patient', pretty_print=pretty_print)
        if self.providerOrganization is not None:
            namespaceprefix_ = self.providerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.providerOrganization_nsprefix_) else ''
            self.providerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='providerOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'patient':
            obj_ = POCD_MT000040_Patient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patient = obj_
            obj_.original_tagname_ = 'patient'
        elif nodeName_ == 'providerOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.providerOrganization = obj_
            obj_.original_tagname_ = 'providerOrganization'
# end class POCD_MT000040_PatientRole


class POCD_MT000040_Performer1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ServiceEventPerformer' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Performer1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Performer1.subclass:
            return POCD_MT000040_Performer1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Performer1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ServiceEventPerformer(self, value):
        # Validate type x_ServiceEventPerformer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRF', 'PPRF', 'SPRF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ServiceEventPerformer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ServiceEventPerformer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ServiceEventPerformer_patterns_, ))
    validate_x_ServiceEventPerformer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Performer1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Performer1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Performer1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Performer1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Performer1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ServiceEventPerformer(self.typeCode)    # validate type x_ServiceEventPerformer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Performer1


class POCD_MT000040_Performer2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationPhysicalPerformer' = 'PRF', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, functionCode: 'CE' = None, time: 'IVL_TS' = None, modeCode: 'CE' = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = "sdtc"
        self.time = time
        self.time_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Performer2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Performer2.subclass:
            return POCD_MT000040_Performer2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Performer2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationPhysicalPerformer(self, value):
        # Validate type ParticipationPhysicalPerformer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRF', 'DIST', 'PPRF', 'SPRF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationPhysicalPerformer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationPhysicalPerformer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationPhysicalPerformer_patterns_, ))
    validate_ParticipationPhysicalPerformer_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.modeCode is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Performer2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Performer2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Performer2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Performer2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Performer2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Performer2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Performer2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationPhysicalPerformer(self.typeCode)    # validate type ParticipationPhysicalPerformer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Performer2


class POCD_MT000040_Person(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, name: List_['PN'] = None, desc: 'ED' = None, asPatientRelationship: 'AsPatientRelationship' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = "sdtc"
        self.asPatientRelationship = asPatientRelationship
        self.asPatientRelationship_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Person.subclass:
            return POCD_MT000040_Person.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_asPatientRelationship(self):
        return self.asPatientRelationship
    def set_asPatientRelationship(self, asPatientRelationship):
        self.asPatientRelationship = asPatientRelationship
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name or
            self.desc is not None or
            self.asPatientRelationship is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Person', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Person':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Person')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Person'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.asPatientRelationship is not None:
            namespaceprefix_ = self.asPatientRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.asPatientRelationship_nsprefix_) else ''
            self.asPatientRelationship.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='asPatientRelationship', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'asPatientRelationship':
            obj_ = AsPatientRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asPatientRelationship = obj_
            obj_.original_tagname_ = 'asPatientRelationship'
# end class POCD_MT000040_Person


class POCD_MT000040_Place(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassPlace' = 'PLC', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, name: 'EN' = None, addr: 'AD' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Place.subclass:
            return POCD_MT000040_Place.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassPlace(self, value):
        # Validate type EntityClassPlace, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PLC', 'CITY', 'COUNTRY', 'COUNTY', 'PROVINCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassPlace' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassPlace_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassPlace_patterns_, ))
    validate_EntityClassPlace_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name is not None or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Place', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Place')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Place':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Place')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Place'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassPlace(self.classCode)    # validate type EntityClassPlace
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040_Place


class POCD_MT000040_PlayingEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClassRoot' = 'ENT', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, quantity: List_['PQ'] = None, name: List_['PN'] = None, birthTime: 'TS' = None, desc: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.quantity_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = "sdtc"
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_PlayingEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_PlayingEntity.subclass:
            return POCD_MT000040_PlayingEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_PlayingEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def add_quantity(self, value):
        self.quantity.append(value)
    def insert_quantity_at(self, index, value):
        self.quantity.insert(index, value)
    def replace_quantity_at(self, index, value):
        self.quantity[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.quantity or
            self.name or
            self.birthTime is not None or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.PlayingEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.PlayingEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.PlayingEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.PlayingEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.PlayingEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.PlayingEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.PlayingEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for quantity_ in self.quantity:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            quantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity.append(obj_)
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040_PlayingEntity


class POCD_MT000040_Precondition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'PRCN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, criterion: 'POCD_MT000040.Criterion' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.criterion = criterion
        self.criterion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Precondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Precondition.subclass:
            return POCD_MT000040_Precondition.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Precondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.criterion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Precondition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Precondition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Precondition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Precondition')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Precondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Precondition'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Precondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.criterion is not None:
            namespaceprefix_ = self.criterion_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion_nsprefix_) else ''
            self.criterion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'criterion':
            obj_ = POCD_MT000040_Criterion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion = obj_
            obj_.original_tagname_ = 'criterion'
# end class POCD_MT000040_Precondition


class POCD_MT000040_Procedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = None, moodCode: 'x_DocumentProcedureMood' = None, negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: 'IVL_TS' = None, priorityCode: 'CE' = None, languageCode: 'CS' = None, methodCode: List_['CE'] = None, approachSiteCode: List_['CD'] = None, targetSiteCode: List_['CD'] = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Procedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Procedure.subclass:
            return POCD_MT000040_Procedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Procedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentProcedureMood(self, value):
        # Validate type x_DocumentProcedureMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'DEF', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentProcedureMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentProcedureMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentProcedureMood_patterns_, ))
    validate_x_DocumentProcedureMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.languageCode is not None or
            self.methodCode or
            self.approachSiteCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Procedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Procedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Procedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Procedure')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Procedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Procedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Procedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentProcedureMood(self.moodCode)    # validate type x_DocumentProcedureMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_Procedure


class POCD_MT000040_Product(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'PRD', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, manufacturedProduct: 'POCD_MT000040.ManufacturedProduct' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Product.subclass:
            return POCD_MT000040_Product.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Product', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Product')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Product':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Product')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Product'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040_Product


class POCD_MT000040_RecordTarget(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'RCT', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, patientRole: 'POCD_MT000040.PatientRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.patientRole = patientRole
        self.patientRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RecordTarget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RecordTarget.subclass:
            return POCD_MT000040_RecordTarget.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RecordTarget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_patientRole(self):
        return self.patientRole
    def set_patientRole(self, patientRole):
        self.patientRole = patientRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.patientRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RecordTarget', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RecordTarget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RecordTarget':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RecordTarget')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RecordTarget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RecordTarget'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RecordTarget', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.patientRole is not None:
            namespaceprefix_ = self.patientRole_nsprefix_ + ':' if (UseCapturedNS_ and self.patientRole_nsprefix_) else ''
            self.patientRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'patientRole':
            obj_ = POCD_MT000040_PatientRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientRole = obj_
            obj_.original_tagname_ = 'patientRole'
# end class POCD_MT000040_RecordTarget


class POCD_MT000040_Reference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipExternalReference' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, seperatableInd: 'BL' = None, externalAct: 'POCD_MT000040.ExternalAct' = None, externalObservation: 'POCD_MT000040.ExternalObservation' = None, externalProcedure: 'POCD_MT000040.ExternalProcedure' = None, externalDocument: 'POCD_MT000040.ExternalDocument' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.externalAct = externalAct
        self.externalAct_nsprefix_ = None
        self.externalObservation = externalObservation
        self.externalObservation_nsprefix_ = None
        self.externalProcedure = externalProcedure
        self.externalProcedure_nsprefix_ = None
        self.externalDocument = externalDocument
        self.externalDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Reference.subclass:
            return POCD_MT000040_Reference.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_externalAct(self):
        return self.externalAct
    def set_externalAct(self, externalAct):
        self.externalAct = externalAct
    def get_externalObservation(self):
        return self.externalObservation
    def set_externalObservation(self, externalObservation):
        self.externalObservation = externalObservation
    def get_externalProcedure(self):
        return self.externalProcedure
    def set_externalProcedure(self, externalProcedure):
        self.externalProcedure = externalProcedure
    def get_externalDocument(self):
        return self.externalDocument
    def set_externalDocument(self, externalDocument):
        self.externalDocument = externalDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipExternalReference(self, value):
        # Validate type x_ActRelationshipExternalReference, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['XCRPT', 'RPLC', 'SPRT', 'ELNK', 'REFR', 'SUBJ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipExternalReference' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipExternalReference_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipExternalReference_patterns_, ))
    validate_x_ActRelationshipExternalReference_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.seperatableInd is not None or
            self.externalAct is not None or
            self.externalObservation is not None or
            self.externalProcedure is not None or
            self.externalDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Reference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Reference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Reference'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.externalAct is not None:
            namespaceprefix_ = self.externalAct_nsprefix_ + ':' if (UseCapturedNS_ and self.externalAct_nsprefix_) else ''
            self.externalAct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalAct', pretty_print=pretty_print)
        if self.externalObservation is not None:
            namespaceprefix_ = self.externalObservation_nsprefix_ + ':' if (UseCapturedNS_ and self.externalObservation_nsprefix_) else ''
            self.externalObservation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalObservation', pretty_print=pretty_print)
        if self.externalProcedure is not None:
            namespaceprefix_ = self.externalProcedure_nsprefix_ + ':' if (UseCapturedNS_ and self.externalProcedure_nsprefix_) else ''
            self.externalProcedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalProcedure', pretty_print=pretty_print)
        if self.externalDocument is not None:
            namespaceprefix_ = self.externalDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.externalDocument_nsprefix_) else ''
            self.externalDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipExternalReference(self.typeCode)    # validate type x_ActRelationshipExternalReference
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'externalAct':
            obj_ = POCD_MT000040_ExternalAct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalAct = obj_
            obj_.original_tagname_ = 'externalAct'
        elif nodeName_ == 'externalObservation':
            obj_ = POCD_MT000040_ExternalObservation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalObservation = obj_
            obj_.original_tagname_ = 'externalObservation'
        elif nodeName_ == 'externalProcedure':
            obj_ = POCD_MT000040_ExternalProcedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalProcedure = obj_
            obj_.original_tagname_ = 'externalProcedure'
        elif nodeName_ == 'externalDocument':
            obj_ = POCD_MT000040_ExternalDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalDocument = obj_
            obj_.original_tagname_ = 'externalDocument'
# end class POCD_MT000040_Reference


class POCD_MT000040_ReferenceRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ActRelationshipType' = 'REFV', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, observationRange: 'POCD_MT000040.ObservationRange' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.observationRange = observationRange
        self.observationRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ReferenceRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ReferenceRange.subclass:
            return POCD_MT000040_ReferenceRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ReferenceRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_observationRange(self):
        return self.observationRange
    def set_observationRange(self, observationRange):
        self.observationRange = observationRange
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.observationRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ReferenceRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ReferenceRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ReferenceRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ReferenceRange')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ReferenceRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ReferenceRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ReferenceRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.observationRange is not None:
            namespaceprefix_ = self.observationRange_nsprefix_ + ':' if (UseCapturedNS_ and self.observationRange_nsprefix_) else ''
            self.observationRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'observationRange':
            obj_ = POCD_MT000040_ObservationRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationRange = obj_
            obj_.original_tagname_ = 'observationRange'
# end class POCD_MT000040_ReferenceRange


class POCD_MT000040_RegionOfInterest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'ROIOVL', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CS' = None, value: List_['POCD_MT000040.RegionOfInterest.value'] = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RegionOfInterest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RegionOfInterest.subclass:
            return POCD_MT000040_RegionOfInterest.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RegionOfInterest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.value or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RegionOfInterest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RegionOfInterest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RegionOfInterest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RegionOfInterest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RegionOfInterest'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RegionOfInterest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'value':
            obj_ = POCD_MT000040_RegionOfInterest_value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_RegionOfInterest


class POCD_MT000040_RelatedDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'x_ActRelationshipDocument' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, parentDocument: 'POCD_MT000040.ParentDocument' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.parentDocument = parentDocument
        self.parentDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedDocument.subclass:
            return POCD_MT000040_RelatedDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_parentDocument(self):
        return self.parentDocument
    def set_parentDocument(self, parentDocument):
        self.parentDocument = parentDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipDocument(self, value):
        # Validate type x_ActRelationshipDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RPLC', 'APND', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipDocument_patterns_, ))
    validate_x_ActRelationshipDocument_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.parentDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedDocument')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.parentDocument is not None:
            namespaceprefix_ = self.parentDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.parentDocument_nsprefix_) else ''
            self.parentDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parentDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipDocument(self.typeCode)    # validate type x_ActRelationshipDocument
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'parentDocument':
            obj_ = POCD_MT000040_ParentDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parentDocument = obj_
            obj_.original_tagname_ = 'parentDocument'
# end class POCD_MT000040_RelatedDocument


class POCD_MT000040_RelatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassMutualRelationship' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, effectiveTime: 'IVL_TS' = None, relatedPerson: 'POCD_MT000040.Person' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.relatedPerson = relatedPerson
        self.relatedPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedEntity.subclass:
            return POCD_MT000040_RelatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_relatedPerson(self):
        return self.relatedPerson
    def set_relatedPerson(self, relatedPerson):
        self.relatedPerson = relatedPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassMutualRelationship(self, value):
        # Validate type RoleClassMutualRelationship, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.addr or
            self.telecom or
            self.effectiveTime is not None or
            self.relatedPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedEntity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.relatedPerson is not None:
            namespaceprefix_ = self.relatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedPerson_nsprefix_) else ''
            self.relatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassMutualRelationship(self.classCode)    # validate type RoleClassMutualRelationship
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'relatedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedPerson = obj_
            obj_.original_tagname_ = 'relatedPerson'
# end class POCD_MT000040_RelatedEntity


class POCD_MT000040_RelatedSubject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'x_DocumentSubject' = 'PRS', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, addr: List_['AD'] = None, telecom: List_['TEL'] = None, subject: 'POCD_MT000040.SubjectPerson' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = "sdtc"
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedSubject.subclass:
            return POCD_MT000040_RelatedSubject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_DocumentSubject(self, value):
        # Validate type x_DocumentSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PAT', 'PRS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubject_patterns_, ))
    validate_x_DocumentSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.subject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.RelatedSubject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedSubject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedSubject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedSubject')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedSubject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedSubject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PRS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.RelatedSubject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_DocumentSubject(self.classCode)    # validate type x_DocumentSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_SubjectPerson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
# end class POCD_MT000040_RelatedSubject


class POCD_MT000040_ResponsibleParty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'RESP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, assignedEntity: 'POCD_MT000040.AssignedEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ResponsibleParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ResponsibleParty.subclass:
            return POCD_MT000040_ResponsibleParty.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ResponsibleParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ResponsibleParty', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ResponsibleParty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ResponsibleParty':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ResponsibleParty')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ResponsibleParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ResponsibleParty'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ResponsibleParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_ResponsibleParty


class POCD_MT000040_Section(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCSECT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: 'II' = None, code: 'CE' = None, title: 'ST' = None, text: 'StrucDoc.Text' = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, subject: 'POCD_MT000040.Subject' = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, entry: List_['POCD_MT000040.Entry'] = None, component: List_['POCD_MT000040.Component5'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        self.entry_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Section)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Section.subclass:
            return POCD_MT000040_Section.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Section(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_entry(self):
        return self.entry
    def set_entry(self, entry):
        self.entry = entry
    def add_entry(self, value):
        self.entry.append(value)
    def insert_entry_at(self, index, value):
        self.entry.insert(index, value)
    def replace_entry_at(self, index, value):
        self.entry[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.subject is not None or
            self.author or
            self.informant or
            self.entry or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Section', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Section')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Section':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Section')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Section', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Section'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Section', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for entry_ in self.entry:
            namespaceprefix_ = self.entry_nsprefix_ + ':' if (UseCapturedNS_ and self.entry_nsprefix_) else ''
            entry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entry', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'text':
            obj_ = StrucDoc_Text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'entry':
            obj_ = POCD_MT000040_Entry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entry.append(obj_)
            obj_.original_tagname_ = 'entry'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_Section


class POCD_MT000040_ServiceEvent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassRoot' = 'ACT', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CE' = None, effectiveTime: 'IVL_TS' = None, performer: List_['POCD_MT000040.Performer1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ServiceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ServiceEvent.subclass:
            return POCD_MT000040_ServiceEvent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ServiceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.performer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ServiceEvent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ServiceEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ServiceEvent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ServiceEvent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ServiceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ServiceEvent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ServiceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
# end class POCD_MT000040_ServiceEvent


class POCD_MT000040_Specimen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationType' = 'SPC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, specimenRole: 'POCD_MT000040.SpecimenRole' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.specimenRole = specimenRole
        self.specimenRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Specimen)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Specimen.subclass:
            return POCD_MT000040_Specimen.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Specimen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_specimenRole(self):
        return self.specimenRole
    def set_specimenRole(self, specimenRole):
        self.specimenRole = specimenRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.specimenRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Specimen', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Specimen')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Specimen':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Specimen')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Specimen', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Specimen'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Specimen', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.specimenRole is not None:
            namespaceprefix_ = self.specimenRole_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenRole_nsprefix_) else ''
            self.specimenRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'specimenRole':
            obj_ = POCD_MT000040_SpecimenRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenRole = obj_
            obj_.original_tagname_ = 'specimenRole'
# end class POCD_MT000040_Specimen


class POCD_MT000040_SpecimenRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'RoleClassSpecimen' = 'SPEC', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, specimenPlayingEntity: 'POCD_MT000040.PlayingEntity' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.specimenPlayingEntity = specimenPlayingEntity
        self.specimenPlayingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SpecimenRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SpecimenRole.subclass:
            return POCD_MT000040_SpecimenRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SpecimenRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_specimenPlayingEntity(self):
        return self.specimenPlayingEntity
    def set_specimenPlayingEntity(self, specimenPlayingEntity):
        self.specimenPlayingEntity = specimenPlayingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassSpecimen(self, value):
        # Validate type RoleClassSpecimen, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SPEC', 'ALQT', 'ISLT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassSpecimen' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassSpecimen_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassSpecimen_patterns_, ))
    validate_RoleClassSpecimen_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.specimenPlayingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SpecimenRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SpecimenRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SpecimenRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SpecimenRole')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SpecimenRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SpecimenRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SpecimenRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.specimenPlayingEntity is not None:
            namespaceprefix_ = self.specimenPlayingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenPlayingEntity_nsprefix_) else ''
            self.specimenPlayingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenPlayingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassSpecimen(self.classCode)    # validate type RoleClassSpecimen
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'specimenPlayingEntity':
            obj_ = POCD_MT000040_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenPlayingEntity = obj_
            obj_.original_tagname_ = 'specimenPlayingEntity'
# end class POCD_MT000040_SpecimenRole


class POCD_MT000040_StructuredBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'DOCBODY', moodCode: 'ActMood' = 'EVN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, confidentialityCode: 'CE' = None, languageCode: 'CS' = None, component: List_['POCD_MT000040.Component3'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_StructuredBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_StructuredBody.subclass:
            return POCD_MT000040_StructuredBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_StructuredBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.StructuredBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.StructuredBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.StructuredBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.StructuredBody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.StructuredBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.StructuredBody'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.StructuredBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_StructuredBody


class POCD_MT000040_Subject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, typeCode: 'ParticipationTargetSubject' = 'SBJ', contextControlCode: 'ContextControl' = 'OP', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, awarenessCode: 'CE' = None, relatedSubject: 'POCD_MT000040.RelatedSubject' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.relatedSubject = relatedSubject
        self.relatedSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Subject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Subject.subclass:
            return POCD_MT000040_Subject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_relatedSubject(self):
        return self.relatedSubject
    def set_relatedSubject(self, relatedSubject):
        self.relatedSubject = relatedSubject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.awarenessCode is not None or
            self.relatedSubject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Subject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Subject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Subject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Subject')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Subject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Subject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Subject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.relatedSubject is not None:
            namespaceprefix_ = self.relatedSubject_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedSubject_nsprefix_) else ''
            self.relatedSubject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedSubject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'relatedSubject':
            obj_ = POCD_MT000040_RelatedSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedSubject = obj_
            obj_.original_tagname_ = 'relatedSubject'
# end class POCD_MT000040_Subject


class POCD_MT000040_SubjectPerson(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'EntityClass' = 'PSN', determinerCode: 'EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, name: List_['PN'] = None, desc: 'ED' = None, administrativeGenderCode: 'CE' = None, birthTime: 'TS' = None, deceasedInd: 'BL' = None, deceasedTime: 'TS' = None, multipleBirthInd: 'BL' = None, multipleBirthOrderNumber: 'INT_POS' = None, raceCode: List_['CE'] = None, ethnicGroupCode: List_['CE'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = "sdtc"
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = "sdtc"
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
        self.deceasedInd = deceasedInd
        self.deceasedInd_nsprefix_ = "sdtc"
        self.deceasedTime = deceasedTime
        self.deceasedTime_nsprefix_ = "sdtc"
        self.multipleBirthInd = multipleBirthInd
        self.multipleBirthInd_nsprefix_ = "sdtc"
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
        self.multipleBirthOrderNumber_nsprefix_ = "sdtc"
        if raceCode is None:
            self.raceCode = []
        else:
            self.raceCode = raceCode
        self.raceCode_nsprefix_ = "sdtc"
        if ethnicGroupCode is None:
            self.ethnicGroupCode = []
        else:
            self.ethnicGroupCode = ethnicGroupCode
        self.ethnicGroupCode_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SubjectPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SubjectPerson.subclass:
            return POCD_MT000040_SubjectPerson.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SubjectPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_deceasedInd(self):
        return self.deceasedInd
    def set_deceasedInd(self, deceasedInd):
        self.deceasedInd = deceasedInd
    def get_deceasedTime(self):
        return self.deceasedTime
    def set_deceasedTime(self, deceasedTime):
        self.deceasedTime = deceasedTime
    def get_multipleBirthInd(self):
        return self.multipleBirthInd
    def set_multipleBirthInd(self, multipleBirthInd):
        self.multipleBirthInd = multipleBirthInd
    def get_multipleBirthOrderNumber(self):
        return self.multipleBirthOrderNumber
    def set_multipleBirthOrderNumber(self, multipleBirthOrderNumber):
        self.multipleBirthOrderNumber = multipleBirthOrderNumber
    def get_raceCode(self):
        return self.raceCode
    def set_raceCode(self, raceCode):
        self.raceCode = raceCode
    def add_raceCode(self, value):
        self.raceCode.append(value)
    def insert_raceCode_at(self, index, value):
        self.raceCode.insert(index, value)
    def replace_raceCode_at(self, index, value):
        self.raceCode[index] = value
    def get_ethnicGroupCode(self):
        return self.ethnicGroupCode
    def set_ethnicGroupCode(self, ethnicGroupCode):
        self.ethnicGroupCode = ethnicGroupCode
    def add_ethnicGroupCode(self, value):
        self.ethnicGroupCode.append(value)
    def insert_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode.insert(index, value)
    def replace_ethnicGroupCode_at(self, index, value):
        self.ethnicGroupCode[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name or
            self.desc is not None or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.deceasedInd is not None or
            self.deceasedTime is not None or
            self.multipleBirthInd is not None or
            self.multipleBirthOrderNumber is not None or
            self.raceCode or
            self.ethnicGroupCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.SubjectPerson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SubjectPerson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SubjectPerson':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SubjectPerson')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SubjectPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SubjectPerson'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.SubjectPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.deceasedInd is not None:
            namespaceprefix_ = self.deceasedInd_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedInd_nsprefix_) else ''
            self.deceasedInd.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='deceasedInd', pretty_print=pretty_print)
        if self.deceasedTime is not None:
            namespaceprefix_ = self.deceasedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.deceasedTime_nsprefix_) else ''
            self.deceasedTime.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='deceasedTime', pretty_print=pretty_print)
        if self.multipleBirthInd is not None:
            namespaceprefix_ = self.multipleBirthInd_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthInd_nsprefix_) else ''
            self.multipleBirthInd.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='multipleBirthInd', pretty_print=pretty_print)
        if self.multipleBirthOrderNumber is not None:
            namespaceprefix_ = self.multipleBirthOrderNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleBirthOrderNumber_nsprefix_) else ''
            self.multipleBirthOrderNumber.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='multipleBirthOrderNumber', pretty_print=pretty_print)
        for raceCode_ in self.raceCode:
            namespaceprefix_ = self.raceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.raceCode_nsprefix_) else ''
            raceCode_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='raceCode', pretty_print=pretty_print)
        for ethnicGroupCode_ in self.ethnicGroupCode:
            namespaceprefix_ = self.ethnicGroupCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ethnicGroupCode_nsprefix_) else ''
            ethnicGroupCode_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='ethnicGroupCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'deceasedInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedInd = obj_
            obj_.original_tagname_ = 'deceasedInd'
        elif nodeName_ == 'deceasedTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deceasedTime = obj_
            obj_.original_tagname_ = 'deceasedTime'
        elif nodeName_ == 'multipleBirthInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthInd = obj_
            obj_.original_tagname_ = 'multipleBirthInd'
        elif nodeName_ == 'multipleBirthOrderNumber':
            obj_ = INT_POS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleBirthOrderNumber = obj_
            obj_.original_tagname_ = 'multipleBirthOrderNumber'
        elif nodeName_ == 'raceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.raceCode.append(obj_)
            obj_.original_tagname_ = 'raceCode'
        elif nodeName_ == 'ethnicGroupCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ethnicGroupCode.append(obj_)
            obj_.original_tagname_ = 'ethnicGroupCode'
# end class POCD_MT000040_SubjectPerson


class POCD_MT000040_SubstanceAdministration(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClass' = 'SBADM', moodCode: 'x_DocumentSubstanceMood' = None, negationInd: 'bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: List_['SXCM_TS'] = None, priorityCode: 'CE' = None, repeatNumber: 'IVL_INT' = None, routeCode: 'CE' = None, approachSiteCode: List_['CD'] = None, doseQuantity: 'IVL_PQ' = None, rateQuantity: 'IVL_PQ' = None, maxDoseQuantity: 'RTO_PQ_PQ' = None, administrationUnitCode: 'CE' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, consumable: 'POCD_MT000040.Consumable' = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.routeCode = routeCode
        self.routeCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        self.doseQuantity = doseQuantity
        self.doseQuantity_nsprefix_ = None
        self.rateQuantity = rateQuantity
        self.rateQuantity_nsprefix_ = None
        self.maxDoseQuantity = maxDoseQuantity
        self.maxDoseQuantity_nsprefix_ = None
        self.administrationUnitCode = administrationUnitCode
        self.administrationUnitCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.consumable = consumable
        self.consumable_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SubstanceAdministration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SubstanceAdministration.subclass:
            return POCD_MT000040_SubstanceAdministration.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SubstanceAdministration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_routeCode(self):
        return self.routeCode
    def set_routeCode(self, routeCode):
        self.routeCode = routeCode
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_doseQuantity(self):
        return self.doseQuantity
    def set_doseQuantity(self, doseQuantity):
        self.doseQuantity = doseQuantity
    def get_rateQuantity(self):
        return self.rateQuantity
    def set_rateQuantity(self, rateQuantity):
        self.rateQuantity = rateQuantity
    def get_maxDoseQuantity(self):
        return self.maxDoseQuantity
    def set_maxDoseQuantity(self, maxDoseQuantity):
        self.maxDoseQuantity = maxDoseQuantity
    def get_administrationUnitCode(self):
        return self.administrationUnitCode
    def set_administrationUnitCode(self, administrationUnitCode):
        self.administrationUnitCode = administrationUnitCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_consumable(self):
        return self.consumable
    def set_consumable(self, consumable):
        self.consumable = consumable
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.priorityCode is not None or
            self.repeatNumber is not None or
            self.routeCode is not None or
            self.approachSiteCode or
            self.doseQuantity is not None or
            self.rateQuantity is not None or
            self.maxDoseQuantity is not None or
            self.administrationUnitCode is not None or
            self.subject is not None or
            self.specimen or
            self.consumable is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.SubstanceAdministration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SubstanceAdministration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SubstanceAdministration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SubstanceAdministration')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SubstanceAdministration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SubstanceAdministration'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.SubstanceAdministration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.routeCode is not None:
            namespaceprefix_ = self.routeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.routeCode_nsprefix_) else ''
            self.routeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        if self.doseQuantity is not None:
            namespaceprefix_ = self.doseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.doseQuantity_nsprefix_) else ''
            self.doseQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doseQuantity', pretty_print=pretty_print)
        if self.rateQuantity is not None:
            namespaceprefix_ = self.rateQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.rateQuantity_nsprefix_) else ''
            self.rateQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rateQuantity', pretty_print=pretty_print)
        if self.maxDoseQuantity is not None:
            namespaceprefix_ = self.maxDoseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.maxDoseQuantity_nsprefix_) else ''
            self.maxDoseQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxDoseQuantity', pretty_print=pretty_print)
        if self.administrationUnitCode is not None:
            namespaceprefix_ = self.administrationUnitCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrationUnitCode_nsprefix_) else ''
            self.administrationUnitCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrationUnitCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.consumable is not None:
            namespaceprefix_ = self.consumable_nsprefix_ + ':' if (UseCapturedNS_ and self.consumable_nsprefix_) else ''
            self.consumable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consumable', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'routeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeCode = obj_
            obj_.original_tagname_ = 'routeCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'doseQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doseQuantity = obj_
            obj_.original_tagname_ = 'doseQuantity'
        elif nodeName_ == 'rateQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rateQuantity = obj_
            obj_.original_tagname_ = 'rateQuantity'
        elif nodeName_ == 'maxDoseQuantity':
            obj_ = RTO_PQ_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxDoseQuantity = obj_
            obj_.original_tagname_ = 'maxDoseQuantity'
        elif nodeName_ == 'administrationUnitCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrationUnitCode = obj_
            obj_.original_tagname_ = 'administrationUnitCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'consumable':
            obj_ = POCD_MT000040_Consumable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consumable = obj_
            obj_.original_tagname_ = 'consumable'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_SubstanceAdministration


class POCD_MT000040_Supply(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, classCode: 'ActClassSupply' = 'SPLY', moodCode: 'x_DocumentSubstanceMood' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, code: 'CD' = None, text: 'ED' = None, statusCode: 'CS' = None, effectiveTime: List_['SXCM_TS'] = None, priorityCode: List_['CE'] = None, repeatNumber: 'IVL_INT' = None, independentInd: 'BL' = None, quantity: 'PQ' = None, expectedUseTime: 'IVL_TS' = None, subject: 'POCD_MT000040.Subject' = None, specimen: List_['POCD_MT000040.Specimen'] = None, product: 'POCD_MT000040.Product' = None, performer: List_['POCD_MT000040.Performer2'] = None, author: List_['POCD_MT000040.Author'] = None, informant: List_['POCD_MT000040.Informant12'] = None, participant: List_['POCD_MT000040.Participant2'] = None, entryRelationship: List_['POCD_MT000040.EntryRelationship'] = None, reference: List_['POCD_MT000040.Reference'] = None, precondition: List_['POCD_MT000040.Precondition'] = None, inFulfillmentOf1: List_['InFulfillmentOf1'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if priorityCode is None:
            self.priorityCode = []
        else:
            self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.independentInd = independentInd
        self.independentInd_nsprefix_ = None
        self.quantity = quantity
        self.quantity_nsprefix_ = None
        self.expectedUseTime = expectedUseTime
        self.expectedUseTime_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if inFulfillmentOf1 is None:
            self.inFulfillmentOf1 = []
        else:
            self.inFulfillmentOf1 = inFulfillmentOf1
        self.inFulfillmentOf1_nsprefix_ = "sdtc"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Supply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Supply.subclass:
            return POCD_MT000040_Supply.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Supply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def add_priorityCode(self, value):
        self.priorityCode.append(value)
    def insert_priorityCode_at(self, index, value):
        self.priorityCode.insert(index, value)
    def replace_priorityCode_at(self, index, value):
        self.priorityCode[index] = value
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_independentInd(self):
        return self.independentInd
    def set_independentInd(self, independentInd):
        self.independentInd = independentInd
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_expectedUseTime(self):
        return self.expectedUseTime
    def set_expectedUseTime(self, expectedUseTime):
        self.expectedUseTime = expectedUseTime
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_inFulfillmentOf1(self):
        return self.inFulfillmentOf1
    def set_inFulfillmentOf1(self, inFulfillmentOf1):
        self.inFulfillmentOf1 = inFulfillmentOf1
    def add_inFulfillmentOf1(self, value):
        self.inFulfillmentOf1.append(value)
    def insert_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1.insert(index, value)
    def replace_inFulfillmentOf1_at(self, index, value):
        self.inFulfillmentOf1[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassSupply(self, value):
        # Validate type ActClassSupply, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SPLY', 'DIET']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassSupply' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassSupply_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassSupply_patterns_, ))
    validate_ActClassSupply_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.priorityCode or
            self.repeatNumber is not None or
            self.independentInd is not None or
            self.quantity is not None or
            self.expectedUseTime is not None or
            self.subject is not None or
            self.specimen or
            self.product is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.inFulfillmentOf1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Supply', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Supply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Supply':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Supply')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Supply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Supply'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:sdtc="urn:hl7-org:sdtc" ', name_='POCD_MT000040.Supply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for priorityCode_ in self.priorityCode:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            priorityCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.independentInd is not None:
            namespaceprefix_ = self.independentInd_nsprefix_ + ':' if (UseCapturedNS_ and self.independentInd_nsprefix_) else ''
            self.independentInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='independentInd', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.expectedUseTime is not None:
            namespaceprefix_ = self.expectedUseTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expectedUseTime_nsprefix_) else ''
            self.expectedUseTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expectedUseTime', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.product is not None:
            namespaceprefix_ = self.product_nsprefix_ + ':' if (UseCapturedNS_ and self.product_nsprefix_) else ''
            self.product.export(outfile, level, namespaceprefix_, namespacedef_='', name_='product', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for inFulfillmentOf1_ in self.inFulfillmentOf1:
            namespaceprefix_ = self.inFulfillmentOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf1_nsprefix_) else ''
            inFulfillmentOf1_.export(outfile, level, namespaceprefix_='sdtc:', namespacedef_='', name_='inFulfillmentOf1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassSupply(self.classCode)    # validate type ActClassSupply
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode.append(obj_)
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'independentInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.independentInd = obj_
            obj_.original_tagname_ = 'independentInd'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'expectedUseTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expectedUseTime = obj_
            obj_.original_tagname_ = 'expectedUseTime'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'product':
            obj_ = POCD_MT000040_Product.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'inFulfillmentOf1':
            obj_ = InFulfillmentOf1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf1.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf1'
# end class POCD_MT000040_Supply


class ANY(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'NullFlavor' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANY.subclass:
            return ANY.subclass(*args_, **kwargs_)
        else:
            return ANY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANY'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ANY


class BL(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'bl' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BL"), self).__init__(nullFlavor,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BL.subclass:
            return BL.subclass(*args_, **kwargs_)
        else:
            return BL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(BL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BL'):
        super(BL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_boolean(self.value, input_name='value'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', fromsubclass_=False, pretty_print=True):
        super(BL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.value)    # validate type bl
        super(BL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BL


class ANYNonNull(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANYNonNull"), self).__init__(nullFlavor, extensiontype_,  **kwargs_)
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANYNonNull)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANYNonNull.subclass:
            return ANYNonNull.subclass(*args_, **kwargs_)
        else:
            return ANYNonNull(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def has__content(self):
        if (
            super(ANYNonNull, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANYNonNull')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANYNonNull':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANYNonNull', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANYNonNull'):
        super(ANYNonNull, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ANYNonNull, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ANYNonNull


class BN(ANYNonNull):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANYNonNull
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'bn' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BN"), self).__init__(nullFlavor,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BN.subclass:
            return BN.subclass(*args_, **kwargs_)
        else:
            return BN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(BN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BN'):
        super(BN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', fromsubclass_=False, pretty_print=True):
        super(BN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.value)    # validate type bn
        super(BN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BN


class BIN(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BIN"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BIN.subclass:
            return BIN.subclass(*args_, **kwargs_)
        else:
            return BIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BIN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BIN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BIN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BIN'):
        super(BIN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', fromsubclass_=False, pretty_print=True):
        super(BIN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BIN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BIN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BIN


class ED(BIN):
    """reference --  A telecommunication address (TEL), such as a URL for
    HTTP or FTP, which will resolve to precisely the same binary data
    that could as well have been provided as inline data.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ED"), self).__init__(nullFlavor, representation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED.subclass:
            return ED.subclass(*args_, **kwargs_)
        else:
            return ED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ED, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ED', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ED':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ED'):
        super(ED, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ED', fromsubclass_=False, pretty_print=True):
        super(ED, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        super(ED, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ED, self)._buildChildren(child_, node, nodeName_, True)
# end class ED


class thumbnail(ED):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = 'SHA-1', reference: 'TEL' = None, thumbnail: 'thumbnail' = None, anytypeobjs_=None, thumbnail_member: 'thumbnail' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("thumbnail"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail_member
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thumbnail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thumbnail.subclass:
            return thumbnail.subclass(*args_, **kwargs_)
        else:
            return thumbnail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(thumbnail, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='thumbnail', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('thumbnail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'thumbnail':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='thumbnail'):
        super(thumbnail, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='thumbnail', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(thumbnail, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class thumbnail


class ST(ED):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ST"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ST.subclass:
            return ST.subclass(*args_, **kwargs_)
        else:
            return ST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_representation(self):
        return self.representation
    def get_mediaType(self):
        return self.mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ST, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ST', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ST':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ST'):
        super(ST, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        if self.representation is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ST', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ST, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ST


class CD(ANY):
    """originalText --  The text or phrase used as the basis for the coding.
      
    * qualifier --  Specifies additional codes that increase the
      specificity of the primary code.
    * translation --  A set of other concept descriptors that translate
      this concept descriptor into other code systems.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, designation: List_['ST'] = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CD"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.valueSet = _cast(None, valueSet)
        self.valueSet_nsprefix_ = None
        self.valueSetVersion = _cast(None, valueSetVersion)
        self.valueSetVersion_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        if designation is None:
            self.designation = []
        else:
            self.designation = designation
        self.designation_nsprefix_ = "ips"
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CD.subclass:
            return CD.subclass(*args_, **kwargs_)
        else:
            return CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def add_qualifier(self, value):
        self.qualifier.append(value)
    def insert_qualifier_at(self, index, value):
        self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value):
        self.qualifier[index] = value
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_designation(self):
        return self.designation
    def set_designation(self, designation):
        self.designation = designation
    def add_designation(self, value):
        self.designation.append(value)
    def insert_designation_at(self, index, value):
        self.designation.insert(index, value)
    def replace_designation_at(self, index, value):
        self.designation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueSet(self):
        return self.valueSet
    def set_valueSet(self, valueSet):
        self.valueSet = valueSet
    def get_valueSetVersion(self):
        return self.valueSetVersion
    def set_valueSetVersion(self, valueSetVersion):
        self.valueSetVersion = valueSetVersion
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_oid(self, value):
        # Validate type hl7:oid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_oid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_oid_patterns_, ))
    validate_oid_patterns_ = [['^([0-2](\\.(0|[1-9][0-9]*))*)$']]
    def has__content(self):
        if (
            self.originalText is not None or
            self.qualifier or
            self.translation or
            self.designation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CD'):
        super(CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.valueSet is not None and 'valueSet' not in already_processed:
            already_processed.add('valueSet')
            outfile.write(' valueSet=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueSet), input_name='valueSet')), ))
        if self.valueSetVersion is not None and 'valueSetVersion' not in already_processed:
            already_processed.add('valueSetVersion')
            outfile.write(' valueSetVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueSetVersion), input_name='valueSetVersion')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CD', fromsubclass_=False, pretty_print=True):
        super(CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            qualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
        for designation_ in self.designation:
            namespaceprefix_ = self.designation_nsprefix_ + ':' if (UseCapturedNS_ and self.designation_nsprefix_) else ''
            designation_.export(outfile, level, namespaceprefix_='ips:', namespacedef_='', name_='designation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('valueSet', node)
        if value is not None and 'valueSet' not in already_processed:
            already_processed.add('valueSet')
            self.valueSet = value
            self.validate_oid(self.valueSet)    # validate type oid
        value = find_attr_value_('valueSetVersion', node)
        if value is not None and 'valueSetVersion' not in already_processed:
            already_processed.add('valueSetVersion')
            self.valueSetVersion = value
            self.validate_st(self.valueSetVersion)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'originalText', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_originalText'):
              self.add_originalText(obj_.value)
            elif hasattr(self, 'set_originalText'):
              self.set_originalText(obj_.value)
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'qualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_qualifier'):
              self.add_qualifier(obj_.value)
            elif hasattr(self, 'set_qualifier'):
              self.set_qualifier(obj_.value)
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        elif nodeName_ == 'designation':
            obj_ = ST.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'designation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_designation'):
              self.add_designation(obj_.value)
            elif hasattr(self, 'set_designation'):
              self.set_designation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CD, self)._buildChildren(child_, node, nodeName_, True)
# end class CD


class CE(CD):
    """originalText --  The text or phrase used as the basis for the coding.
      
    * translation --  A set of other concept descriptors that translate
      this concept descriptor into other code systems.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: List_['CD'] = None, designation: List_['ST'] = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CE"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        if designation is None:
            self.designation = []
        else:
            self.designation = designation
        self.designation_nsprefix_ = "ips"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CE.subclass:
            return CE.subclass(*args_, **kwargs_)
        else:
            return CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_designation(self):
        return self.designation
    def set_designation(self, designation):
        self.designation = designation
    def add_designation(self, value):
        self.designation.append(value)
    def insert_designation_at(self, index, value):
        self.designation.insert(index, value)
    def replace_designation_at(self, index, value):
        self.designation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.originalText is not None or
            self.qualifier is not None or
            self.translation or
            self.designation or
            super(CE, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CE'):
        super(CE, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.qualifier is not None:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            self.qualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
        for designation_ in self.designation:
            namespaceprefix_ = self.designation_nsprefix_ + ':' if (UseCapturedNS_ and self.designation_nsprefix_) else ''
            designation_.export(outfile, level, namespaceprefix_='ips:', namespacedef_='', name_='designation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CE, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'
        elif nodeName_ == 'designation':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designation.append(obj_)
            obj_.original_tagname_ = 'designation'
# end class CE


class CV(CE):
    """originalText --  The text or phrase used as the basis for the coding.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: 'CD' = None, designation: List_['ST'] = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CV"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.translation = translation
        self.translation_nsprefix_ = None
        if designation is None:
            self.designation = []
        else:
            self.designation = designation
        self.designation_nsprefix_ = "ips"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV.subclass:
            return CV.subclass(*args_, **kwargs_)
        else:
            return CV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def get_designation(self):
        return self.designation
    def set_designation(self, designation):
        self.designation = designation
    def add_designation(self, value):
        self.designation.append(value)
    def insert_designation_at(self, index, value):
        self.designation.insert(index, value)
    def replace_designation_at(self, index, value):
        self.designation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.originalText is not None or
            self.translation is not None or
            self.designation or
            super(CV, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CV', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CV':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CV'):
        super(CV, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:ips="urn:hl7-org:ips" ', name_='CV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.translation is not None:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            self.translation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
        for designation_ in self.designation:
            namespaceprefix_ = self.designation_nsprefix_ + ':' if (UseCapturedNS_ and self.designation_nsprefix_) else ''
            designation_.export(outfile, level, namespaceprefix_='ips:', namespacedef_='', name_='designation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CV, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation = obj_
            obj_.original_tagname_ = 'translation'
        elif nodeName_ == 'designation':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designation.append(obj_)
            obj_.original_tagname_ = 'designation'
# end class CV


class CS(CV):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: 'CD' = None, designation: List_['ST'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CS"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CS.subclass:
            return CS.subclass(*args_, **kwargs_)
        else:
            return CS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(CS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CS'):
        super(CS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CS


class CO(CV):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: 'CD' = None, designation: List_['ST'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CO"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CO.subclass:
            return CO.subclass(*args_, **kwargs_)
        else:
            return CO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(CO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CO'):
        super(CO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', fromsubclass_=False, pretty_print=True):
        super(CO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CO


class CR(ANY):
    """name --  Specifies the manner in which the concept role value
    contributes to the meaning of a code phrase. For example, if SNOMED
    RT defines a concept "leg", a role relation "has-laterality", and
    another concept "left", the concept role relation allows to add the
    qualifier "has-laterality: left" to a primary code "leg" to
    construct the meaning "left leg". In this example "has-laterality"
    is the CR.name.
    value --  The concept that modifies the primary code of a code
    phrase through the role relation. For example, if SNOMED RT defines
    a concept "leg", a role relation "has-laterality", and another
    concept "left", the concept role relation allows adding the
    qualifier "has-laterality: left" to a primary code "leg" to
    construct the meaning "left leg". In this example "left" is the
    CR.value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, inverted: 'bn' = 'false', name: 'CV' = None, value: 'CD' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CR"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inverted = _cast(bool, inverted)
        self.inverted_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CR.subclass:
            return CR.subclass(*args_, **kwargs_)
        else:
            return CR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_inverted(self):
        return self.inverted
    def set_inverted(self, inverted):
        self.inverted = inverted
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.name is not None or
            self.value is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CR, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CR'):
        super(CR, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        if self.inverted != "false" and 'inverted' not in already_processed:
            already_processed.add('inverted')
            outfile.write(' inverted=%s' % (quote_attrib(self.inverted), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CR', fromsubclass_=False, pretty_print=True):
        super(CR, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inverted', node)
        if value is not None and 'inverted' not in already_processed:
            already_processed.add('inverted')
            if value in ('true', '1'):
                self.inverted = True
            elif value in ('false', '0'):
                self.inverted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.inverted)    # validate type bn
        super(CR, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'name', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_name'):
              self.add_name(obj_.value)
            elif hasattr(self, 'set_name'):
              self.set_name(obj_.value)
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CR, self)._buildChildren(child_, node, nodeName_, True)
# end class CR


class SC(ST):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SC"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SC.subclass:
            return SC.subclass(*args_, **kwargs_)
        else:
            return SC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SC, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SC':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SC'):
        super(SC, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', fromsubclass_=False, pretty_print=True):
        super(SC, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(SC, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SC, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SC


class II(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, root: 'uid' = None, extension: 'st' = None, assigningAuthorityName: 'st' = None, displayable: 'bl' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("II"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.assigningAuthorityName_nsprefix_ = None
        self.displayable = _cast(bool, displayable)
        self.displayable_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II.subclass:
            return II.subclass(*args_, **kwargs_)
        else:
            return II(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def get_assigningAuthorityName(self):
        return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName):
        self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self):
        return self.displayable
    def set_displayable(self, displayable):
        self.displayable = displayable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(II, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'II':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='II'):
        super(II, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.assigningAuthorityName), input_name='assigningAuthorityName')), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable="%s"' % self.gds_format_boolean(self.displayable, input_name='displayable'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', fromsubclass_=False, pretty_print=True):
        super(II, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            if value in ('true', '1'):
                self.displayable = True
            elif value in ('false', '0'):
                self.displayable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.displayable)    # validate type bl
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(II, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(II, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class II


class URL(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'url' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("URL"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL.subclass:
            return URL.subclass(*args_, **kwargs_)
        else:
            return URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_url(self, value):
        # Validate type url, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(URL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URL'):
        super(URL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', fromsubclass_=False, pretty_print=True):
        super(URL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_url(self.value)    # validate type url
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(URL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(URL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class URL


class TEL(URL):
    """useablePeriod --  Specifies the periods of time during which the
    telecommunication address can be used. For a telephone number, this
    can indicate the time of day in which the party can be reached on
    that telephone. For a web address, it may specify a time range in
    which the web content is promised to be available under the given
    address.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = URL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'url' = None, use: 'set_TelecommunicationAddressUse' = None, useablePeriod: List_['SXCM_TS'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TEL"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEL.subclass:
            return TEL.subclass(*args_, **kwargs_)
        else:
            return TEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_TelecommunicationAddressUse(self, value):
        # Validate type set_TelecommunicationAddressUse, a restriction on TelecommunicationAddressUse.
        pass
    def has__content(self):
        if (
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TEL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TEL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEL'):
        super(TEL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TEL', fromsubclass_=False, pretty_print=True):
        super(TEL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_TelecommunicationAddressUse(self.use.split())    # validate type set_TelecommunicationAddressUse
        super(TEL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TEL, self)._buildChildren(child_, node, nodeName_, True)
# end class TEL


class ADXP(ST):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ADXP"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP.subclass:
            return ADXP.subclass(*args_, **kwargs_)
        else:
            return ADXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ADXP, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADXP'):
        super(ADXP, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', fromsubclass_=False, pretty_print=True):
        super(ADXP, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(ADXP, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ADXP, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ADXP


class adxp_delimiter(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DEL', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_delimiter"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_delimiter.subclass:
            return adxp_delimiter.subclass(*args_, **kwargs_)
        else:
            return adxp_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_delimiter, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.delimiter'):
        super(adxp_delimiter, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_delimiter, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_delimiter


class adxp_country(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'CNT', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_country"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_country.subclass:
            return adxp_country.subclass(*args_, **kwargs_)
        else:
            return adxp_country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_country, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.country':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.country'):
        super(adxp_country, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_country, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_country


class adxp_state(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'STA', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_state"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_state)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_state.subclass:
            return adxp_state.subclass(*args_, **kwargs_)
        else:
            return adxp_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_state, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.state')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.state':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.state'):
        super(adxp_state, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_state, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_state


class adxp_county(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'CPA', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_county"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_county)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_county.subclass:
            return adxp_county.subclass(*args_, **kwargs_)
        else:
            return adxp_county(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_county, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.county')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.county':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.county'):
        super(adxp_county, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_county, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_county


class adxp_city(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'CTY', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_city"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_city)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_city.subclass:
            return adxp_city.subclass(*args_, **kwargs_)
        else:
            return adxp_city(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_city, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.city')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.city':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.city'):
        super(adxp_city, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_city, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_city


class adxp_postalCode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'ZIP', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_postalCode"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postalCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postalCode.subclass:
            return adxp_postalCode.subclass(*args_, **kwargs_)
        else:
            return adxp_postalCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postalCode, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postalCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postalCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postalCode'):
        super(adxp_postalCode, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postalCode, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postalCode


class adxp_streetAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'SAL', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetAddressLine"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetAddressLine.subclass:
            return adxp_streetAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_streetAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetAddressLine, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetAddressLine'):
        super(adxp_streetAddressLine, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetAddressLine, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetAddressLine


class adxp_houseNumber(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'BNR', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_houseNumber"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumber.subclass:
            return adxp_houseNumber.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumber, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumber')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumber':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumber'):
        super(adxp_houseNumber, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumber, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumber


class adxp_houseNumberNumeric(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'BNN', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_houseNumberNumeric"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumberNumeric)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumberNumeric.subclass:
            return adxp_houseNumberNumeric.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumberNumeric(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumberNumeric, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumberNumeric')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumberNumeric':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumberNumeric'):
        super(adxp_houseNumberNumeric, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumberNumeric, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumberNumeric


class adxp_direction(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DIR', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_direction"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_direction.subclass:
            return adxp_direction.subclass(*args_, **kwargs_)
        else:
            return adxp_direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_direction, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.direction'):
        super(adxp_direction, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_direction, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_direction


class adxp_streetName(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'STR', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetName"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetName.subclass:
            return adxp_streetName.subclass(*args_, **kwargs_)
        else:
            return adxp_streetName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetName, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetName'):
        super(adxp_streetName, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetName, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetName


class adxp_streetNameBase(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'STB', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetNameBase"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameBase.subclass:
            return adxp_streetNameBase.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameBase, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameBase'):
        super(adxp_streetNameBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameBase


class adxp_streetNameType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'STTYP', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_streetNameType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameType.subclass:
            return adxp_streetNameType.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameType'):
        super(adxp_streetNameType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameType


class adxp_additionalLocator(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'ADL', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_additionalLocator"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_additionalLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_additionalLocator.subclass:
            return adxp_additionalLocator.subclass(*args_, **kwargs_)
        else:
            return adxp_additionalLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_additionalLocator, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.additionalLocator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.additionalLocator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.additionalLocator'):
        super(adxp_additionalLocator, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_additionalLocator, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_additionalLocator


class adxp_unitID(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'UNID', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_unitID"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitID.subclass:
            return adxp_unitID.subclass(*args_, **kwargs_)
        else:
            return adxp_unitID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitID, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitID':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitID'):
        super(adxp_unitID, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitID, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitID


class adxp_unitType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'UNIT', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_unitType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitType.subclass:
            return adxp_unitType.subclass(*args_, **kwargs_)
        else:
            return adxp_unitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitType'):
        super(adxp_unitType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitType


class adxp_careOf(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'CAR', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_careOf"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_careOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_careOf.subclass:
            return adxp_careOf.subclass(*args_, **kwargs_)
        else:
            return adxp_careOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_careOf, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.careOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.careOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.careOf'):
        super(adxp_careOf, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_careOf, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_careOf


class adxp_censusTract(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'CEN', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_censusTract"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_censusTract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_censusTract.subclass:
            return adxp_censusTract.subclass(*args_, **kwargs_)
        else:
            return adxp_censusTract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_censusTract, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.censusTract')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.censusTract':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.censusTract'):
        super(adxp_censusTract, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_censusTract, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_censusTract


class adxp_deliveryAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DAL', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryAddressLine"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryAddressLine.subclass:
            return adxp_deliveryAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryAddressLine, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryAddressLine'):
        super(adxp_deliveryAddressLine, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryAddressLine, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryAddressLine


class adxp_deliveryInstallationType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DINST', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationType"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationType.subclass:
            return adxp_deliveryInstallationType.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationType'):
        super(adxp_deliveryInstallationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationType


class adxp_deliveryInstallationArea(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DINSTA', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationArea"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationArea.subclass:
            return adxp_deliveryInstallationArea.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationArea, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationArea':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationArea'):
        super(adxp_deliveryInstallationArea, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationArea, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationArea


class adxp_deliveryInstallationQualifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DINSTQ', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryInstallationQualifier"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationQualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationQualifier.subclass:
            return adxp_deliveryInstallationQualifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationQualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationQualifier, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationQualifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationQualifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationQualifier'):
        super(adxp_deliveryInstallationQualifier, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationQualifier, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationQualifier


class adxp_deliveryMode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DMOD', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryMode"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryMode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryMode.subclass:
            return adxp_deliveryMode.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryMode, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryMode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryMode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryMode'):
        super(adxp_deliveryMode, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryMode, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryMode


class adxp_deliveryModeIdentifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'DMODID', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_deliveryModeIdentifier"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryModeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryModeIdentifier.subclass:
            return adxp_deliveryModeIdentifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryModeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryModeIdentifier, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryModeIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryModeIdentifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryModeIdentifier'):
        super(adxp_deliveryModeIdentifier, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryModeIdentifier, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryModeIdentifier


class adxp_buildingNumberSuffix(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'BNS', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_buildingNumberSuffix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_buildingNumberSuffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_buildingNumberSuffix.subclass:
            return adxp_buildingNumberSuffix.subclass(*args_, **kwargs_)
        else:
            return adxp_buildingNumberSuffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_buildingNumberSuffix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.buildingNumberSuffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.buildingNumberSuffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.buildingNumberSuffix'):
        super(adxp_buildingNumberSuffix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_buildingNumberSuffix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_buildingNumberSuffix


class adxp_postBox(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'POB', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_postBox"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postBox.subclass:
            return adxp_postBox.subclass(*args_, **kwargs_)
        else:
            return adxp_postBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postBox, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postBox':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postBox'):
        super(adxp_postBox, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postBox, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postBox


class adxp_precinct(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'AddressPartType' = 'PRE', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("adxp_precinct"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_precinct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_precinct.subclass:
            return adxp_precinct.subclass(*args_, **kwargs_)
        else:
            return adxp_precinct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_precinct, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.precinct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.precinct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.precinct'):
        super(adxp_precinct, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_precinct, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_precinct


class AD(ANY):
    """useablePeriod --  A General Timing Specification (GTS) specifying the
    periods of time during which the address can be used. This is used
    to specify different addresses for different times of the year or to
    refer to historical addresses.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_PostalAddressUse' = None, isNotOrdered: 'bl' = None, delimiter: List_['adxp.delimiter'] = None, country: List_['adxp.country'] = None, state: List_['adxp.state'] = None, county: List_['adxp.county'] = None, city: List_['adxp.city'] = None, postalCode: List_['adxp.postalCode'] = None, streetAddressLine: List_['adxp.streetAddressLine'] = None, houseNumber: List_['adxp.houseNumber'] = None, houseNumberNumeric: List_['adxp.houseNumberNumeric'] = None, direction: List_['adxp.direction'] = None, streetName: List_['adxp.streetName'] = None, streetNameBase: List_['adxp.streetNameBase'] = None, streetNameType: List_['adxp.streetNameType'] = None, additionalLocator: List_['adxp.additionalLocator'] = None, unitID: List_['adxp.unitID'] = None, unitType: List_['adxp.unitType'] = None, careOf: List_['adxp.careOf'] = None, censusTract: List_['adxp.censusTract'] = None, deliveryAddressLine: List_['adxp.deliveryAddressLine'] = None, deliveryInstallationType: List_['adxp.deliveryInstallationType'] = None, deliveryInstallationArea: List_['adxp.deliveryInstallationArea'] = None, deliveryInstallationQualifier: List_['adxp.deliveryInstallationQualifier'] = None, deliveryMode: List_['adxp.deliveryMode'] = None, deliveryModeIdentifier: List_['adxp.deliveryModeIdentifier'] = None, buildingNumberSuffix: List_['adxp.buildingNumberSuffix'] = None, postBox: List_['adxp.postBox'] = None, precinct: List_['adxp.precinct'] = None, useablePeriod: List_['SXCM_TS'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AD"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        self.isNotOrdered = _cast(bool, isNotOrdered)
        self.isNotOrdered_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if country is None:
            self.country = []
        else:
            self.country = country
        self.country_nsprefix_ = None
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = None
        if county is None:
            self.county = []
        else:
            self.county = county
        self.county_nsprefix_ = None
        if city is None:
            self.city = []
        else:
            self.city = city
        self.city_nsprefix_ = None
        if postalCode is None:
            self.postalCode = []
        else:
            self.postalCode = postalCode
        self.postalCode_nsprefix_ = None
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        self.streetAddressLine_nsprefix_ = None
        if houseNumber is None:
            self.houseNumber = []
        else:
            self.houseNumber = houseNumber
        self.houseNumber_nsprefix_ = None
        if houseNumberNumeric is None:
            self.houseNumberNumeric = []
        else:
            self.houseNumberNumeric = houseNumberNumeric
        self.houseNumberNumeric_nsprefix_ = None
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        self.direction_nsprefix_ = None
        if streetName is None:
            self.streetName = []
        else:
            self.streetName = streetName
        self.streetName_nsprefix_ = None
        if streetNameBase is None:
            self.streetNameBase = []
        else:
            self.streetNameBase = streetNameBase
        self.streetNameBase_nsprefix_ = None
        if streetNameType is None:
            self.streetNameType = []
        else:
            self.streetNameType = streetNameType
        self.streetNameType_nsprefix_ = None
        if additionalLocator is None:
            self.additionalLocator = []
        else:
            self.additionalLocator = additionalLocator
        self.additionalLocator_nsprefix_ = None
        if unitID is None:
            self.unitID = []
        else:
            self.unitID = unitID
        self.unitID_nsprefix_ = None
        if unitType is None:
            self.unitType = []
        else:
            self.unitType = unitType
        self.unitType_nsprefix_ = None
        if careOf is None:
            self.careOf = []
        else:
            self.careOf = careOf
        self.careOf_nsprefix_ = None
        if censusTract is None:
            self.censusTract = []
        else:
            self.censusTract = censusTract
        self.censusTract_nsprefix_ = None
        if deliveryAddressLine is None:
            self.deliveryAddressLine = []
        else:
            self.deliveryAddressLine = deliveryAddressLine
        self.deliveryAddressLine_nsprefix_ = None
        if deliveryInstallationType is None:
            self.deliveryInstallationType = []
        else:
            self.deliveryInstallationType = deliveryInstallationType
        self.deliveryInstallationType_nsprefix_ = None
        if deliveryInstallationArea is None:
            self.deliveryInstallationArea = []
        else:
            self.deliveryInstallationArea = deliveryInstallationArea
        self.deliveryInstallationArea_nsprefix_ = None
        if deliveryInstallationQualifier is None:
            self.deliveryInstallationQualifier = []
        else:
            self.deliveryInstallationQualifier = deliveryInstallationQualifier
        self.deliveryInstallationQualifier_nsprefix_ = None
        if deliveryMode is None:
            self.deliveryMode = []
        else:
            self.deliveryMode = deliveryMode
        self.deliveryMode_nsprefix_ = None
        if deliveryModeIdentifier is None:
            self.deliveryModeIdentifier = []
        else:
            self.deliveryModeIdentifier = deliveryModeIdentifier
        self.deliveryModeIdentifier_nsprefix_ = None
        if buildingNumberSuffix is None:
            self.buildingNumberSuffix = []
        else:
            self.buildingNumberSuffix = buildingNumberSuffix
        self.buildingNumberSuffix_nsprefix_ = None
        if postBox is None:
            self.postBox = []
        else:
            self.postBox = postBox
        self.postBox_nsprefix_ = None
        if precinct is None:
            self.precinct = []
        else:
            self.precinct = precinct
        self.precinct_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD.subclass:
            return AD.subclass(*args_, **kwargs_)
        else:
            return AD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def add_country(self, value):
        self.country.append(value)
    def insert_country_at(self, index, value):
        self.country.insert(index, value)
    def replace_country_at(self, index, value):
        self.country[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def get_county(self):
        return self.county
    def set_county(self, county):
        self.county = county
    def add_county(self, value):
        self.county.append(value)
    def insert_county_at(self, index, value):
        self.county.insert(index, value)
    def replace_county_at(self, index, value):
        self.county[index] = value
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def add_city(self, value):
        self.city.append(value)
    def insert_city_at(self, index, value):
        self.city.insert(index, value)
    def replace_city_at(self, index, value):
        self.city[index] = value
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def add_postalCode(self, value):
        self.postalCode.append(value)
    def insert_postalCode_at(self, index, value):
        self.postalCode.insert(index, value)
    def replace_postalCode_at(self, index, value):
        self.postalCode[index] = value
    def get_streetAddressLine(self):
        return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine):
        self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value):
        self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value):
        self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value):
        self.streetAddressLine[index] = value
    def get_houseNumber(self):
        return self.houseNumber
    def set_houseNumber(self, houseNumber):
        self.houseNumber = houseNumber
    def add_houseNumber(self, value):
        self.houseNumber.append(value)
    def insert_houseNumber_at(self, index, value):
        self.houseNumber.insert(index, value)
    def replace_houseNumber_at(self, index, value):
        self.houseNumber[index] = value
    def get_houseNumberNumeric(self):
        return self.houseNumberNumeric
    def set_houseNumberNumeric(self, houseNumberNumeric):
        self.houseNumberNumeric = houseNumberNumeric
    def add_houseNumberNumeric(self, value):
        self.houseNumberNumeric.append(value)
    def insert_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric.insert(index, value)
    def replace_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric[index] = value
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def add_direction(self, value):
        self.direction.append(value)
    def insert_direction_at(self, index, value):
        self.direction.insert(index, value)
    def replace_direction_at(self, index, value):
        self.direction[index] = value
    def get_streetName(self):
        return self.streetName
    def set_streetName(self, streetName):
        self.streetName = streetName
    def add_streetName(self, value):
        self.streetName.append(value)
    def insert_streetName_at(self, index, value):
        self.streetName.insert(index, value)
    def replace_streetName_at(self, index, value):
        self.streetName[index] = value
    def get_streetNameBase(self):
        return self.streetNameBase
    def set_streetNameBase(self, streetNameBase):
        self.streetNameBase = streetNameBase
    def add_streetNameBase(self, value):
        self.streetNameBase.append(value)
    def insert_streetNameBase_at(self, index, value):
        self.streetNameBase.insert(index, value)
    def replace_streetNameBase_at(self, index, value):
        self.streetNameBase[index] = value
    def get_streetNameType(self):
        return self.streetNameType
    def set_streetNameType(self, streetNameType):
        self.streetNameType = streetNameType
    def add_streetNameType(self, value):
        self.streetNameType.append(value)
    def insert_streetNameType_at(self, index, value):
        self.streetNameType.insert(index, value)
    def replace_streetNameType_at(self, index, value):
        self.streetNameType[index] = value
    def get_additionalLocator(self):
        return self.additionalLocator
    def set_additionalLocator(self, additionalLocator):
        self.additionalLocator = additionalLocator
    def add_additionalLocator(self, value):
        self.additionalLocator.append(value)
    def insert_additionalLocator_at(self, index, value):
        self.additionalLocator.insert(index, value)
    def replace_additionalLocator_at(self, index, value):
        self.additionalLocator[index] = value
    def get_unitID(self):
        return self.unitID
    def set_unitID(self, unitID):
        self.unitID = unitID
    def add_unitID(self, value):
        self.unitID.append(value)
    def insert_unitID_at(self, index, value):
        self.unitID.insert(index, value)
    def replace_unitID_at(self, index, value):
        self.unitID[index] = value
    def get_unitType(self):
        return self.unitType
    def set_unitType(self, unitType):
        self.unitType = unitType
    def add_unitType(self, value):
        self.unitType.append(value)
    def insert_unitType_at(self, index, value):
        self.unitType.insert(index, value)
    def replace_unitType_at(self, index, value):
        self.unitType[index] = value
    def get_careOf(self):
        return self.careOf
    def set_careOf(self, careOf):
        self.careOf = careOf
    def add_careOf(self, value):
        self.careOf.append(value)
    def insert_careOf_at(self, index, value):
        self.careOf.insert(index, value)
    def replace_careOf_at(self, index, value):
        self.careOf[index] = value
    def get_censusTract(self):
        return self.censusTract
    def set_censusTract(self, censusTract):
        self.censusTract = censusTract
    def add_censusTract(self, value):
        self.censusTract.append(value)
    def insert_censusTract_at(self, index, value):
        self.censusTract.insert(index, value)
    def replace_censusTract_at(self, index, value):
        self.censusTract[index] = value
    def get_deliveryAddressLine(self):
        return self.deliveryAddressLine
    def set_deliveryAddressLine(self, deliveryAddressLine):
        self.deliveryAddressLine = deliveryAddressLine
    def add_deliveryAddressLine(self, value):
        self.deliveryAddressLine.append(value)
    def insert_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine.insert(index, value)
    def replace_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine[index] = value
    def get_deliveryInstallationType(self):
        return self.deliveryInstallationType
    def set_deliveryInstallationType(self, deliveryInstallationType):
        self.deliveryInstallationType = deliveryInstallationType
    def add_deliveryInstallationType(self, value):
        self.deliveryInstallationType.append(value)
    def insert_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType.insert(index, value)
    def replace_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType[index] = value
    def get_deliveryInstallationArea(self):
        return self.deliveryInstallationArea
    def set_deliveryInstallationArea(self, deliveryInstallationArea):
        self.deliveryInstallationArea = deliveryInstallationArea
    def add_deliveryInstallationArea(self, value):
        self.deliveryInstallationArea.append(value)
    def insert_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea.insert(index, value)
    def replace_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea[index] = value
    def get_deliveryInstallationQualifier(self):
        return self.deliveryInstallationQualifier
    def set_deliveryInstallationQualifier(self, deliveryInstallationQualifier):
        self.deliveryInstallationQualifier = deliveryInstallationQualifier
    def add_deliveryInstallationQualifier(self, value):
        self.deliveryInstallationQualifier.append(value)
    def insert_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier.insert(index, value)
    def replace_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier[index] = value
    def get_deliveryMode(self):
        return self.deliveryMode
    def set_deliveryMode(self, deliveryMode):
        self.deliveryMode = deliveryMode
    def add_deliveryMode(self, value):
        self.deliveryMode.append(value)
    def insert_deliveryMode_at(self, index, value):
        self.deliveryMode.insert(index, value)
    def replace_deliveryMode_at(self, index, value):
        self.deliveryMode[index] = value
    def get_deliveryModeIdentifier(self):
        return self.deliveryModeIdentifier
    def set_deliveryModeIdentifier(self, deliveryModeIdentifier):
        self.deliveryModeIdentifier = deliveryModeIdentifier
    def add_deliveryModeIdentifier(self, value):
        self.deliveryModeIdentifier.append(value)
    def insert_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier.insert(index, value)
    def replace_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier[index] = value
    def get_buildingNumberSuffix(self):
        return self.buildingNumberSuffix
    def set_buildingNumberSuffix(self, buildingNumberSuffix):
        self.buildingNumberSuffix = buildingNumberSuffix
    def add_buildingNumberSuffix(self, value):
        self.buildingNumberSuffix.append(value)
    def insert_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix.insert(index, value)
    def replace_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix[index] = value
    def get_postBox(self):
        return self.postBox
    def set_postBox(self, postBox):
        self.postBox = postBox
    def add_postBox(self, value):
        self.postBox.append(value)
    def insert_postBox_at(self, index, value):
        self.postBox.insert(index, value)
    def replace_postBox_at(self, index, value):
        self.postBox[index] = value
    def get_precinct(self):
        return self.precinct
    def set_precinct(self, precinct):
        self.precinct = precinct
    def add_precinct(self, value):
        self.precinct.append(value)
    def insert_precinct_at(self, index, value):
        self.precinct.insert(index, value)
    def replace_precinct_at(self, index, value):
        self.precinct[index] = value
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_isNotOrdered(self):
        return self.isNotOrdered
    def set_isNotOrdered(self, isNotOrdered):
        self.isNotOrdered = isNotOrdered
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_PostalAddressUse(self, value):
        # Validate type set_PostalAddressUse, a restriction on PostalAddressUse.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.delimiter or
            self.country or
            self.state or
            self.county or
            self.city or
            self.postalCode or
            self.streetAddressLine or
            self.houseNumber or
            self.houseNumberNumeric or
            self.direction or
            self.streetName or
            self.streetNameBase or
            self.streetNameType or
            self.additionalLocator or
            self.unitID or
            self.unitType or
            self.careOf or
            self.censusTract or
            self.deliveryAddressLine or
            self.deliveryInstallationType or
            self.deliveryInstallationArea or
            self.deliveryInstallationQualifier or
            self.deliveryMode or
            self.deliveryModeIdentifier or
            self.buildingNumberSuffix or
            self.postBox or
            self.precinct or
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(AD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='AD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AD'):
        super(AD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.isNotOrdered is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            outfile.write(' isNotOrdered="%s"' % self.gds_format_boolean(self.isNotOrdered, input_name='isNotOrdered'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='AD', fromsubclass_=False, pretty_print=True):
        super(AD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for country_ in self.country:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            country_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='country', pretty_print=pretty_print)
        for state_ in self.state:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        for county_ in self.county:
            namespaceprefix_ = self.county_nsprefix_ + ':' if (UseCapturedNS_ and self.county_nsprefix_) else ''
            county_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            city_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='city', pretty_print=pretty_print)
        for postalCode_ in self.postalCode:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            postalCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            namespaceprefix_ = self.streetAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.streetAddressLine_nsprefix_) else ''
            streetAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetAddressLine', pretty_print=pretty_print)
        for houseNumber_ in self.houseNumber:
            namespaceprefix_ = self.houseNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumber_nsprefix_) else ''
            houseNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumber', pretty_print=pretty_print)
        for houseNumberNumeric_ in self.houseNumberNumeric:
            namespaceprefix_ = self.houseNumberNumeric_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumberNumeric_nsprefix_) else ''
            houseNumberNumeric_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumberNumeric', pretty_print=pretty_print)
        for direction_ in self.direction:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            direction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        for streetName_ in self.streetName:
            namespaceprefix_ = self.streetName_nsprefix_ + ':' if (UseCapturedNS_ and self.streetName_nsprefix_) else ''
            streetName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetName', pretty_print=pretty_print)
        for streetNameBase_ in self.streetNameBase:
            namespaceprefix_ = self.streetNameBase_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameBase_nsprefix_) else ''
            streetNameBase_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameBase', pretty_print=pretty_print)
        for streetNameType_ in self.streetNameType:
            namespaceprefix_ = self.streetNameType_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameType_nsprefix_) else ''
            streetNameType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameType', pretty_print=pretty_print)
        for additionalLocator_ in self.additionalLocator:
            namespaceprefix_ = self.additionalLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalLocator_nsprefix_) else ''
            additionalLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalLocator', pretty_print=pretty_print)
        for unitID_ in self.unitID:
            namespaceprefix_ = self.unitID_nsprefix_ + ':' if (UseCapturedNS_ and self.unitID_nsprefix_) else ''
            unitID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitID', pretty_print=pretty_print)
        for unitType_ in self.unitType:
            namespaceprefix_ = self.unitType_nsprefix_ + ':' if (UseCapturedNS_ and self.unitType_nsprefix_) else ''
            unitType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitType', pretty_print=pretty_print)
        for careOf_ in self.careOf:
            namespaceprefix_ = self.careOf_nsprefix_ + ':' if (UseCapturedNS_ and self.careOf_nsprefix_) else ''
            careOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='careOf', pretty_print=pretty_print)
        for censusTract_ in self.censusTract:
            namespaceprefix_ = self.censusTract_nsprefix_ + ':' if (UseCapturedNS_ and self.censusTract_nsprefix_) else ''
            censusTract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='censusTract', pretty_print=pretty_print)
        for deliveryAddressLine_ in self.deliveryAddressLine:
            namespaceprefix_ = self.deliveryAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryAddressLine_nsprefix_) else ''
            deliveryAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryAddressLine', pretty_print=pretty_print)
        for deliveryInstallationType_ in self.deliveryInstallationType:
            namespaceprefix_ = self.deliveryInstallationType_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationType_nsprefix_) else ''
            deliveryInstallationType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationType', pretty_print=pretty_print)
        for deliveryInstallationArea_ in self.deliveryInstallationArea:
            namespaceprefix_ = self.deliveryInstallationArea_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationArea_nsprefix_) else ''
            deliveryInstallationArea_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationArea', pretty_print=pretty_print)
        for deliveryInstallationQualifier_ in self.deliveryInstallationQualifier:
            namespaceprefix_ = self.deliveryInstallationQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationQualifier_nsprefix_) else ''
            deliveryInstallationQualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationQualifier', pretty_print=pretty_print)
        for deliveryMode_ in self.deliveryMode:
            namespaceprefix_ = self.deliveryMode_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryMode_nsprefix_) else ''
            deliveryMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryMode', pretty_print=pretty_print)
        for deliveryModeIdentifier_ in self.deliveryModeIdentifier:
            namespaceprefix_ = self.deliveryModeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryModeIdentifier_nsprefix_) else ''
            deliveryModeIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryModeIdentifier', pretty_print=pretty_print)
        for buildingNumberSuffix_ in self.buildingNumberSuffix:
            namespaceprefix_ = self.buildingNumberSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.buildingNumberSuffix_nsprefix_) else ''
            buildingNumberSuffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buildingNumberSuffix', pretty_print=pretty_print)
        for postBox_ in self.postBox:
            namespaceprefix_ = self.postBox_nsprefix_ + ':' if (UseCapturedNS_ and self.postBox_nsprefix_) else ''
            postBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postBox', pretty_print=pretty_print)
        for precinct_ in self.precinct:
            namespaceprefix_ = self.precinct_nsprefix_ + ':' if (UseCapturedNS_ and self.precinct_nsprefix_) else ''
            precinct_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precinct', pretty_print=pretty_print)
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_PostalAddressUse(self.use.split())    # validate type set_PostalAddressUse
        value = find_attr_value_('isNotOrdered', node)
        if value is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            if value in ('true', '1'):
                self.isNotOrdered = True
            elif value in ('false', '0'):
                self.isNotOrdered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isNotOrdered)    # validate type bl
        super(AD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = adxp_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'country':
            obj_ = adxp_country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'country', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_country'):
              self.add_country(obj_.value)
            elif hasattr(self, 'set_country'):
              self.set_country(obj_.value)
        elif nodeName_ == 'state':
            obj_ = adxp_state.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'county':
            obj_ = adxp_county.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'county', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_county'):
              self.add_county(obj_.value)
            elif hasattr(self, 'set_county'):
              self.set_county(obj_.value)
        elif nodeName_ == 'city':
            obj_ = adxp_city.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'city', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_city'):
              self.add_city(obj_.value)
            elif hasattr(self, 'set_city'):
              self.set_city(obj_.value)
        elif nodeName_ == 'postalCode':
            obj_ = adxp_postalCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = adxp_streetAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        elif nodeName_ == 'houseNumber':
            obj_ = adxp_houseNumber.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumber', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumber'):
              self.add_houseNumber(obj_.value)
            elif hasattr(self, 'set_houseNumber'):
              self.set_houseNumber(obj_.value)
        elif nodeName_ == 'houseNumberNumeric':
            obj_ = adxp_houseNumberNumeric.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumberNumeric', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumberNumeric'):
              self.add_houseNumberNumeric(obj_.value)
            elif hasattr(self, 'set_houseNumberNumeric'):
              self.set_houseNumberNumeric(obj_.value)
        elif nodeName_ == 'direction':
            obj_ = adxp_direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'direction', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_direction'):
              self.add_direction(obj_.value)
            elif hasattr(self, 'set_direction'):
              self.set_direction(obj_.value)
        elif nodeName_ == 'streetName':
            obj_ = adxp_streetName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetName', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetName'):
              self.add_streetName(obj_.value)
            elif hasattr(self, 'set_streetName'):
              self.set_streetName(obj_.value)
        elif nodeName_ == 'streetNameBase':
            obj_ = adxp_streetNameBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameBase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameBase'):
              self.add_streetNameBase(obj_.value)
            elif hasattr(self, 'set_streetNameBase'):
              self.set_streetNameBase(obj_.value)
        elif nodeName_ == 'streetNameType':
            obj_ = adxp_streetNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameType'):
              self.add_streetNameType(obj_.value)
            elif hasattr(self, 'set_streetNameType'):
              self.set_streetNameType(obj_.value)
        elif nodeName_ == 'additionalLocator':
            obj_ = adxp_additionalLocator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'additionalLocator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_additionalLocator'):
              self.add_additionalLocator(obj_.value)
            elif hasattr(self, 'set_additionalLocator'):
              self.set_additionalLocator(obj_.value)
        elif nodeName_ == 'unitID':
            obj_ = adxp_unitID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitID', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitID'):
              self.add_unitID(obj_.value)
            elif hasattr(self, 'set_unitID'):
              self.set_unitID(obj_.value)
        elif nodeName_ == 'unitType':
            obj_ = adxp_unitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitType'):
              self.add_unitType(obj_.value)
            elif hasattr(self, 'set_unitType'):
              self.set_unitType(obj_.value)
        elif nodeName_ == 'careOf':
            obj_ = adxp_careOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'careOf', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_careOf'):
              self.add_careOf(obj_.value)
            elif hasattr(self, 'set_careOf'):
              self.set_careOf(obj_.value)
        elif nodeName_ == 'censusTract':
            obj_ = adxp_censusTract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'censusTract', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_censusTract'):
              self.add_censusTract(obj_.value)
            elif hasattr(self, 'set_censusTract'):
              self.set_censusTract(obj_.value)
        elif nodeName_ == 'deliveryAddressLine':
            obj_ = adxp_deliveryAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryAddressLine'):
              self.add_deliveryAddressLine(obj_.value)
            elif hasattr(self, 'set_deliveryAddressLine'):
              self.set_deliveryAddressLine(obj_.value)
        elif nodeName_ == 'deliveryInstallationType':
            obj_ = adxp_deliveryInstallationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationType'):
              self.add_deliveryInstallationType(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationType'):
              self.set_deliveryInstallationType(obj_.value)
        elif nodeName_ == 'deliveryInstallationArea':
            obj_ = adxp_deliveryInstallationArea.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationArea', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationArea'):
              self.add_deliveryInstallationArea(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationArea'):
              self.set_deliveryInstallationArea(obj_.value)
        elif nodeName_ == 'deliveryInstallationQualifier':
            obj_ = adxp_deliveryInstallationQualifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationQualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationQualifier'):
              self.add_deliveryInstallationQualifier(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationQualifier'):
              self.set_deliveryInstallationQualifier(obj_.value)
        elif nodeName_ == 'deliveryMode':
            obj_ = adxp_deliveryMode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryMode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryMode'):
              self.add_deliveryMode(obj_.value)
            elif hasattr(self, 'set_deliveryMode'):
              self.set_deliveryMode(obj_.value)
        elif nodeName_ == 'deliveryModeIdentifier':
            obj_ = adxp_deliveryModeIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryModeIdentifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryModeIdentifier'):
              self.add_deliveryModeIdentifier(obj_.value)
            elif hasattr(self, 'set_deliveryModeIdentifier'):
              self.set_deliveryModeIdentifier(obj_.value)
        elif nodeName_ == 'buildingNumberSuffix':
            obj_ = adxp_buildingNumberSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'buildingNumberSuffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_buildingNumberSuffix'):
              self.add_buildingNumberSuffix(obj_.value)
            elif hasattr(self, 'set_buildingNumberSuffix'):
              self.set_buildingNumberSuffix(obj_.value)
        elif nodeName_ == 'postBox':
            obj_ = adxp_postBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postBox', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postBox'):
              self.add_postBox(obj_.value)
            elif hasattr(self, 'set_postBox'):
              self.set_postBox(obj_.value)
        elif nodeName_ == 'precinct':
            obj_ = adxp_precinct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'precinct', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_precinct'):
              self.add_precinct(obj_.value)
            elif hasattr(self, 'set_precinct'):
              self.set_precinct(obj_.value)
        elif nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD, self)._buildChildren(child_, node, nodeName_, True)
# end class AD


class ENXP(ST):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = None, qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ENXP"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENXP.subclass:
            return ENXP.subclass(*args_, **kwargs_)
        else:
            return ENXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def validate_set_EntityNamePartQualifier(self, value):
        # Validate type set_EntityNamePartQualifier, a restriction on EntityNamePartQualifier.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ENXP, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ENXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ENXP'):
        super(ENXP, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', fromsubclass_=False, pretty_print=True):
        super(ENXP, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
            self.validate_set_EntityNamePartQualifier(self.qualifier.split())    # validate type set_EntityNamePartQualifier
        super(ENXP, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ENXP, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ENXP


class en_delimiter(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = 'DEL', qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_delimiter"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_delimiter.subclass:
            return en_delimiter.subclass(*args_, **kwargs_)
        else:
            return en_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_delimiter, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.delimiter'):
        super(en_delimiter, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_delimiter, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_delimiter


class en_family(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = 'FAM', qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_family"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_family)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_family.subclass:
            return en_family.subclass(*args_, **kwargs_)
        else:
            return en_family(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_family, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.family')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.family':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.family'):
        super(en_family, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_family, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_family


class en_given(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = 'GIV', qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_given"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_given)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_given.subclass:
            return en_given.subclass(*args_, **kwargs_)
        else:
            return en_given(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_given, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.given')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.given':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.given'):
        super(en_given, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_given, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_given


class en_prefix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = 'PFX', qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_prefix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_prefix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_prefix.subclass:
            return en_prefix.subclass(*args_, **kwargs_)
        else:
            return en_prefix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_prefix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.prefix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.prefix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.prefix'):
        super(en_prefix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_prefix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_prefix


class en_suffix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor: 'NullFlavor' = None, representation: 'BinaryDataEncoding' = 'TXT', mediaType: 'cs' = 'text/plain', language: 'cs' = None, compression: 'CompressionAlgorithm' = None, integrityCheck: 'bin' = None, integrityCheckAlgorithm: 'IntegrityCheckAlgorithm' = None, reference: 'TEL' = None, thumbnail: 'ED' = None, anytypeobjs_=None, partType: 'EntityNamePartType' = 'SFX', qualifier: 'set_EntityNamePartQualifier' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("en_suffix"), self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_suffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_suffix.subclass:
            return en_suffix.subclass(*args_, **kwargs_)
        else:
            return en_suffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_suffix, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.suffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.suffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.suffix'):
        super(en_suffix, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_suffix, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_suffix


class EN(ANY):
    """validTime --  An interval of time specifying the time during which
    the name is or was used for the entity. This accomodates the fact
    that people change names for people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EN"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if family is None:
            self.family = []
        else:
            self.family = family
        self.family_nsprefix_ = None
        if given is None:
            self.given = []
        else:
            self.given = given
        self.given_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EN.subclass:
            return EN.subclass(*args_, **kwargs_)
        else:
            return EN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    def add_family(self, value):
        self.family.append(value)
    def insert_family_at(self, index, value):
        self.family.insert(index, value)
    def replace_family_at(self, index, value):
        self.family[index] = value
    def get_given(self):
        return self.given
    def set_given(self, given):
        self.given = given
    def add_given(self, value):
        self.given.append(value)
    def insert_given_at(self, index, value):
        self.given.insert(index, value)
    def replace_given_at(self, index, value):
        self.given[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def has__content(self):
        if (
            self.delimiter or
            self.family or
            self.given or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EN'):
        super(EN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EN', fromsubclass_=False, pretty_print=True):
        super(EN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for family_ in self.family:
            namespaceprefix_ = self.family_nsprefix_ + ':' if (UseCapturedNS_ and self.family_nsprefix_) else ''
            family_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='family', pretty_print=pretty_print)
        for given_ in self.given:
            namespaceprefix_ = self.given_nsprefix_ + ':' if (UseCapturedNS_ and self.given_nsprefix_) else ''
            given_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='given', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use.split())    # validate type set_EntityNameUse
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EN, self)._buildChildren(child_, node, nodeName_, True)
# end class EN


class PN(EN):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PN"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN.subclass:
            return PN.subclass(*args_, **kwargs_)
        else:
            return PN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PN'):
        super(PN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', fromsubclass_=False, pretty_print=True):
        super(PN, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PN, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PN


class ON(EN):
    """validTime --  An interval of time specifying the time during which
    the name is or was used for the entity. This accomodates the fact
    that people change names for people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ON"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = use
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ON)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ON.subclass:
            return ON.subclass(*args_, **kwargs_)
        else:
            return ON(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def has__content(self):
        if (
            self.delimiter or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ON, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ON', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ON')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ON':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ON'):
        super(ON, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ON', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use.split())    # validate type set_EntityNameUse
        super(ON, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ON


class TN(EN):
    """validTime --  An interval of time specifying the time during which
    the name is or was used for the entity. This accomodates the fact
    that people change names for people, places and things.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor: 'NullFlavor' = None, use: 'set_EntityNameUse' = None, delimiter: List_['en.delimiter'] = None, family: List_['en.family'] = None, given: List_['en.given'] = None, prefix: List_['en.prefix'] = None, suffix: List_['en.suffix'] = None, validTime: 'IVL_TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TN"), self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TN.subclass:
            return TN.subclass(*args_, **kwargs_)
        else:
            return TN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TN, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TN'):
        super(TN, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TN', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TN, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TN


class QTY(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QTY"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QTY.subclass:
            return QTY.subclass(*args_, **kwargs_)
        else:
            return QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(QTY, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QTY'):
        super(QTY, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', fromsubclass_=False, pretty_print=True):
        super(QTY, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QTY, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(QTY, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QTY


class INT(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("INT"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT.subclass:
            return INT.subclass(*args_, **kwargs_)
        else:
            return INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT'):
        super(INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', fromsubclass_=False, pretty_print=True):
        super(INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
            self.validate_int(self.value)    # validate type int
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class INT


class REAL(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("REAL"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL.subclass:
            return REAL.subclass(*args_, **kwargs_)
        else:
            return REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REAL'):
        super(REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', fromsubclass_=False, pretty_print=True):
        super(REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class REAL


class PQR(CV):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: 'CD' = None, designation: List_['ST'] = None, value: 'real' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PQR"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQR.subclass:
            return PQR.subclass(*args_, **kwargs_)
        else:
            return PQR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def has__content(self):
        if (
            super(PQR, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PQR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQR'):
        super(PQR, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', fromsubclass_=False, pretty_print=True):
        super(PQR, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        super(PQR, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PQR, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PQR


class PQ(QTY):
    """translation --  An alternative representation of the same physical
    quantity expressed in a different unit, of a different unit code
    system and possibly with a different value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PQ"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQ.subclass:
            return PQ.subclass(*args_, **kwargs_)
        else:
            return PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQ'):
        super(PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit != "1" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PQ', fromsubclass_=False, pretty_print=True):
        super(PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_cs(self.unit)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'translation':
            obj_ = PQR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class PQ


class MO(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MO"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.currency = _cast(None, currency)
        self.currency_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MO.subclass:
            return MO.subclass(*args_, **kwargs_)
        else:
            return MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MO'):
        super(MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', fromsubclass_=False, pretty_print=True):
        super(MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
            self.currency = ' '.join(self.currency.split())
            self.validate_cs(self.currency)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MO


class EIVL_event(CE):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'TimingEvent' = None, codeSystem: 'uid' = '2.16.840.1.113883.5.139', codeSystemName: 'st' = 'TimingEvent', codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: List_['CD'] = None, designation: List_['ST'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_event"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_event.subclass:
            return EIVL_event.subclass(*args_, **kwargs_)
        else:
            return EIVL_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def validate_TimingEvent(self, value):
        # Validate type TimingEvent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'ACD', 'ACM', 'ACV', 'HS', 'IC', 'ICD', 'ICM', 'ICV', 'PC', 'PCD', 'PCM', 'PCV', 'CM', 'CD', 'CV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimingEvent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TimingEvent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TimingEvent_patterns_, ))
    validate_TimingEvent_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(EIVL_event, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL.event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL.event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL.event', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL.event'):
        super(EIVL_event, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_TimingEvent(self.code)    # validate type TimingEvent
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        super(EIVL_event, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EIVL_event


class RTO_QTY_QTY(QTY):
    """numerator --  The quantity that is being divided in the ratio. The
    default is the integer number 1 (one).
    denominator --  The quantity that devides the numerator in the ratio.
    The default is the integer number 1 (one). The denominator must not
    be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_QTY_QTY"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_QTY_QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_QTY_QTY.subclass:
            return RTO_QTY_QTY.subclass(*args_, **kwargs_)
        else:
            return RTO_QTY_QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def set_numerator_with_type(self, value):
        self.numerator = value
        value.original_tagname_ = 'numerator'
        value.extensiontype_ = value.__class__.__name__
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def set_denominator_with_type(self, value):
        self.denominator = value
        value.original_tagname_ = 'denominator'
        value.extensiontype_ = value.__class__.__name__
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO_QTY_QTY, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_QTY_QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_QTY_QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_QTY_QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_QTY_QTY'):
        super(RTO_QTY_QTY, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_QTY_QTY', fromsubclass_=False, pretty_print=True):
        super(RTO_QTY_QTY, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            self.numerator.export(outfile, level, namespaceprefix_, name_='numerator', namespacedef_='', pretty_print=pretty_print)
        if self.denominator is not None:
            self.denominator.export(outfile, level, namespaceprefix_, name_='denominator', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RTO_QTY_QTY, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <numerator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <denominator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_QTY_QTY, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_QTY_QTY


class INT_POS(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int_pos' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "sdtc"
        super(globals().get("INT_POS"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT_POS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT_POS.subclass:
            return INT_POS.subclass(*args_, **kwargs_)
        else:
            return INT_POS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int_pos(self, value):
        # Validate type int_pos, a restriction on hl7:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on int_pos' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(INT_POS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc"', name_='INT_POS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT_POS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT_POS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT_POS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT_POS'):
        super(INT_POS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT_POS')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc"', name_='INT_POS', fromsubclass_=False, pretty_print=True):
        super(INT_POS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
            self.validate_int_pos(self.value)    # validate type int_pos
        super(INT_POS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(INT_POS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class INT_POS


class ActReference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7_ActClass' = None, moodCode: 'hl7_x_DocumentActMood' = None, determinerCode: 'hl7_EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, id: List_['II'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7"
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = "hl7"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActReference.subclass:
            return ActReference.subclass(*args_, **kwargs_)
        else:
            return ActReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_ActClass(self, value):
        # Validate type hl7:ActClass, a restriction on None.
        pass
    def validate_x_DocumentActMood(self, value):
        # Validate type hl7:x_DocumentActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'DEF', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentActMood_patterns_, ))
    validate_x_DocumentActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type hl7:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='ActReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActReference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActReference'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='ActReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentActMood(self.moodCode)    # validate type x_DocumentActMood
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
# end class ActReference


class InFulfillmentOf1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, typeCode: 'hl7_ActRelationshipFulfills' = 'FLFS', inversionInd: 'hl7_bl' = None, negationInd: 'hl7_bl' = None, realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, actReference: 'ActReference' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.inversionInd = _cast(bool, inversionInd)
        self.inversionInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7"
        self.actReference = actReference
        self.actReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InFulfillmentOf1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InFulfillmentOf1.subclass:
            return InFulfillmentOf1.subclass(*args_, **kwargs_)
        else:
            return InFulfillmentOf1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_actReference(self):
        return self.actReference
    def set_actReference(self, actReference):
        self.actReference = actReference
    def get_typeCode(self):
        return self.typeCode
    def get_inversionInd(self):
        return self.inversionInd
    def set_inversionInd(self, inversionInd):
        self.inversionInd = inversionInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_ActRelationshipFulfills(self, value):
        # Validate type hl7:ActRelationshipFulfills, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FLFS', 'OCCR', 'OREF', 'SCH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipFulfills' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipFulfills_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipFulfills_patterns_, ))
    validate_ActRelationshipFulfills_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type hl7:bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.actReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='InFulfillmentOf1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InFulfillmentOf1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InFulfillmentOf1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InFulfillmentOf1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InFulfillmentOf1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InFulfillmentOf1'):
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.inversionInd is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            outfile.write(' inversionInd="%s"' % self.gds_format_boolean(self.inversionInd, input_name='inversionInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='InFulfillmentOf1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.actReference is not None:
            namespaceprefix_ = self.actReference_nsprefix_ + ':' if (UseCapturedNS_ and self.actReference_nsprefix_) else ''
            self.actReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='actReference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipFulfills(self.typeCode)    # validate type ActRelationshipFulfills
        value = find_attr_value_('inversionInd', node)
        if value is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            if value in ('true', '1'):
                self.inversionInd = True
            elif value in ('false', '0'):
                self.inversionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inversionInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'actReference':
            obj_ = ActReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.actReference = obj_
            obj_.original_tagname_ = 'actReference'
# end class InFulfillmentOf1


class SdtcPatient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id: 'II' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7"
        self.id = id
        self.id_nsprefix_ = "hl7"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SdtcPatient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SdtcPatient.subclass:
            return SdtcPatient.subclass(*args_, **kwargs_)
        else:
            return SdtcPatient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='SdtcPatient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SdtcPatient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SdtcPatient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SdtcPatient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SdtcPatient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SdtcPatient'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='SdtcPatient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
# end class SdtcPatient


class AsPatientRelationship(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7_x_DocumentSubject' = 'PRS', determinerCode: 'hl7_EntityDeterminer' = 'INSTANCE', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, code: 'CE' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7"
        self.code = code
        self.code_nsprefix_ = "hl7"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AsPatientRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AsPatientRelationship.subclass:
            return AsPatientRelationship.subclass(*args_, **kwargs_)
        else:
            return AsPatientRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_classCode(self):
        return self.classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_x_DocumentSubject(self, value):
        # Validate type hl7:x_DocumentSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PAT', 'PRS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubject_patterns_, ))
    validate_x_DocumentSubject_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type hl7:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='AsPatientRelationship', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AsPatientRelationship')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AsPatientRelationship':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AsPatientRelationship')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AsPatientRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AsPatientRelationship'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='AsPatientRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_DocumentSubject(self.classCode)    # validate type x_DocumentSubject
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
# end class AsPatientRelationship


class Precondition1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7_NullFlavor' = None, typeCode: 'hl7_ActRelationshipType' = 'PRCN', realmCode: List_['CS'] = None, typeId: 'POCD_MT000040.InfrastructureRoot.typeId' = None, templateId: List_['II'] = None, conjunctionCode: 'CS' = None, criterion1: 'POCD_MT000040.Criterion' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7"
        self.conjunctionCode = conjunctionCode
        self.conjunctionCode_nsprefix_ = "hl7"
        self.criterion1 = criterion1
        self.criterion1_nsprefix_ = "hl7"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Precondition1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Precondition1.subclass:
            return Precondition1.subclass(*args_, **kwargs_)
        else:
            return Precondition1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_conjunctionCode(self):
        return self.conjunctionCode
    def set_conjunctionCode(self, conjunctionCode):
        self.conjunctionCode = conjunctionCode
    def get_criterion1(self):
        return self.criterion1
    def set_criterion1(self, criterion1):
        self.criterion1 = criterion1
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7:NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type hl7:ActRelationshipType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.conjunctionCode is not None or
            self.criterion1 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='Precondition1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Precondition1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Precondition1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Precondition1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Precondition1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Precondition1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sdtc="urn:hl7-org:sdtc" xmlns:hl7="urn:hl7-org:v3" ', name_='Precondition1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.conjunctionCode is not None:
            namespaceprefix_ = self.conjunctionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.conjunctionCode_nsprefix_) else ''
            self.conjunctionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conjunctionCode', pretty_print=pretty_print)
        if self.criterion1 is not None:
            namespaceprefix_ = self.criterion1_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion1_nsprefix_) else ''
            self.criterion1.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'conjunctionCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conjunctionCode = obj_
            obj_.original_tagname_ = 'conjunctionCode'
        elif nodeName_ == 'criterion1':
            obj_ = POCD_MT000040_Criterion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion1 = obj_
            obj_.original_tagname_ = 'criterion1'
# end class Precondition1


class StrucDoc_Text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, mediaType: 'xs_string' = 'text/plain', content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Text.subclass:
            return StrucDoc_Text.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Text')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Text'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Text', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Text


class StrucDoc_Title(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, mediaType: 'xs_string' = 'text/x-hl7-title+xml', content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.TitleFootnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Title)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Title.subclass:
            return StrucDoc_Title.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Title', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Title')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Title':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Title')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Title'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Title', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Title


class StrucDoc_Br(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Br)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Br.subclass:
            return StrucDoc_Br.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Br(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Br')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Br':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Br')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Br', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Br'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Br


class StrucDoc_Caption(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Caption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Caption.subclass:
            return StrucDoc_Caption.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.linkHtml or
            self.sub or
            self.sup or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Caption', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Caption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Caption':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Caption')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Caption'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Caption', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Caption


class StrucDoc_Col(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, span: 'xs_string' = '1', width: 'xs_string' = None, align: 'alignType' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Col)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Col.subclass:
            return StrucDoc_Col.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Col(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType(self, value):
        # Validate type alignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType(self, value):
        # Validate type valignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Col')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Col':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Col')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Col', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Col'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType(self.align)    # validate type alignType
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType(self.valign)    # validate type valignType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Col


class StrucDoc_Colgroup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, span: 'xs_string' = '1', width: 'xs_string' = None, align: 'alignType1' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType2' = None, col: List_['StrucDoc.Col'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Colgroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Colgroup.subclass:
            return StrucDoc_Colgroup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Colgroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType1(self, value):
        # Validate type alignType1, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType2(self, value):
        # Validate type valignType2, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.col
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Colgroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Colgroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Colgroup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Colgroup')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Colgroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Colgroup'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Colgroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType1(self.align)    # validate type alignType1
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType2(self.valign)    # validate type valignType2
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
# end class StrucDoc_Colgroup


class StrucDoc_Content(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, revised: 'revisedType' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.revised = _cast(None, revised)
        self.revised_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Content.subclass:
            return StrucDoc_Content.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_revised(self):
        return self.revised
    def set_revised(self, revised):
        self.revised = revised
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_revisedType(self, value):
        # Validate type revisedType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['insert', 'delete']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on revisedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Content', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Content')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Content':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Content')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Content'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.revised is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            outfile.write(' revised=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revised), input_name='revised')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Content', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('revised', node)
        if value is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            self.revised = value
            self.validate_revisedType(self.revised)    # validate type revisedType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Content


class StrucDoc_TitleContent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.TitleFootnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleContent.subclass:
            return StrucDoc_TitleContent.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleContent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleContent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleContent')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleContent'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleContent', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleContent


class StrucDoc_Footnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Footnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Footnote.subclass:
            return StrucDoc_Footnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Footnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Footnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Footnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Footnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Footnote')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Footnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Footnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Footnote


class StrucDoc_TitleFootnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, content: List_['StrucDoc.TitleContent'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleFootnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleFootnote.subclass:
            return StrucDoc_TitleFootnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleFootnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleFootnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleFootnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleFootnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleFootnote')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleFootnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleFootnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleFootnote


class StrucDoc_FootnoteRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, IDREF: 'xs_string' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.IDREF = _cast(None, IDREF)
        self.IDREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_FootnoteRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_FootnoteRef.subclass:
            return StrucDoc_FootnoteRef.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_FootnoteRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_IDREF(self):
        return self.IDREF
    def set_IDREF(self, IDREF):
        self.IDREF = IDREF
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.FootnoteRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.FootnoteRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.FootnoteRef')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.FootnoteRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.FootnoteRef'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.IDREF is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            outfile.write(' IDREF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDREF), input_name='IDREF')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('IDREF', node)
        if value is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            self.IDREF = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_FootnoteRef


class StrucDoc_Item(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, table: List_['StrucDoc.Table'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Item.subclass:
            return StrucDoc_Item.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Item', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Item':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Item')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Item'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Item', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Item


class StrucDoc_LinkHtml(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name: 'xs_string' = None, href: 'xs_string' = None, rel: 'xs_string' = None, rev: 'xs_string' = None, title: 'xs_string' = None, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.rel = _cast(None, rel)
        self.rel_nsprefix_ = None
        self.rev = _cast(None, rev)
        self.rev_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_LinkHtml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_LinkHtml.subclass:
            return StrucDoc_LinkHtml.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_LinkHtml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_rel(self):
        return self.rel
    def set_rel(self, rel):
        self.rel = rel
    def get_rev(self):
        return self.rev
    def set_rev(self, rev):
        self.rev = rev
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.LinkHtml', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.LinkHtml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.LinkHtml':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.LinkHtml')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.LinkHtml'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            outfile.write(' rev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rev), input_name='rev')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.LinkHtml', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('rev', node)
        if value is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            self.rev = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_LinkHtml


class StrucDoc_List(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, listType: 'listTypeType' = 'unordered', caption: 'StrucDoc.Caption' = None, item: List_['StrucDoc.Item'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.listType = _cast(None, listType)
        self.listType_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_List)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_List.subclass:
            return StrucDoc_List.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_listType(self):
        return self.listType
    def set_listType(self, listType):
        self.listType = listType
    def validate_listTypeType(self, value):
        # Validate type listTypeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ordered', 'unordered']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on listTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.caption is not None or
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.List', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.List')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.List':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.List')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.List', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.List'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.listType != "unordered" and 'listType' not in already_processed:
            already_processed.add('listType')
            outfile.write(' listType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.listType), input_name='listType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.List', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('listType', node)
        if value is not None and 'listType' not in already_processed:
            already_processed.add('listType')
            self.listType = value
            self.validate_listTypeType(self.listType)    # validate type listTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'item':
            obj_ = StrucDoc_Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class StrucDoc_List


class StrucDoc_Paragraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Paragraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Paragraph.subclass:
            return StrucDoc_Paragraph.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Paragraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Paragraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Paragraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Paragraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Paragraph')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Paragraph'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Paragraph', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Paragraph


class StrucDoc_RenderMultiMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, referencedObject: 'xs_string' = None, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, caption: 'StrucDoc.Caption' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.referencedObject = _cast(None, referencedObject)
        self.referencedObject_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_RenderMultiMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_RenderMultiMedia.subclass:
            return StrucDoc_RenderMultiMedia.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_RenderMultiMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_referencedObject(self):
        return self.referencedObject
    def set_referencedObject(self, referencedObject):
        self.referencedObject = referencedObject
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def has__content(self):
        if (
            self.caption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.RenderMultiMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.RenderMultiMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.RenderMultiMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.RenderMultiMedia')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.RenderMultiMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.RenderMultiMedia'):
        if self.referencedObject is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            outfile.write(' referencedObject=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referencedObject), input_name='referencedObject')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.RenderMultiMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referencedObject', node)
        if value is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            self.referencedObject = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
# end class StrucDoc_RenderMultiMedia


class StrucDoc_Sub(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sub.subclass:
            return StrucDoc_Sub.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sub':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sub')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sub'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sub


class StrucDoc_Sup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sup.subclass:
            return StrucDoc_Sup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sup')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sup'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sup


class StrucDoc_Table(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, summary: 'xs_string' = None, width: 'xs_string' = None, border: 'xs_string' = None, frame: 'frameType' = None, rules: 'rulesType' = None, cellspacing: 'xs_string' = None, cellpadding: 'xs_string' = None, caption: 'StrucDoc.Caption' = None, col: List_['StrucDoc.Col'] = None, colgroup: List_['StrucDoc.Colgroup'] = None, thead: 'StrucDoc.Thead' = None, tfoot: 'StrucDoc.Tfoot' = None, tbody: List_['StrucDoc.Tbody'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.summary = _cast(None, summary)
        self.summary_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.border = _cast(None, border)
        self.border_nsprefix_ = None
        self.frame = _cast(None, frame)
        self.frame_nsprefix_ = None
        self.rules = _cast(None, rules)
        self.rules_nsprefix_ = None
        self.cellspacing = _cast(None, cellspacing)
        self.cellspacing_nsprefix_ = None
        self.cellpadding = _cast(None, cellpadding)
        self.cellpadding_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
        if colgroup is None:
            self.colgroup = []
        else:
            self.colgroup = colgroup
        self.colgroup_nsprefix_ = None
        self.thead = thead
        self.thead_nsprefix_ = None
        self.tfoot = tfoot
        self.tfoot_nsprefix_ = None
        if tbody is None:
            self.tbody = []
        else:
            self.tbody = tbody
        self.tbody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Table)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Table.subclass:
            return StrucDoc_Table.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_colgroup(self):
        return self.colgroup
    def set_colgroup(self, colgroup):
        self.colgroup = colgroup
    def add_colgroup(self, value):
        self.colgroup.append(value)
    def insert_colgroup_at(self, index, value):
        self.colgroup.insert(index, value)
    def replace_colgroup_at(self, index, value):
        self.colgroup[index] = value
    def get_thead(self):
        return self.thead
    def set_thead(self, thead):
        self.thead = thead
    def get_tfoot(self):
        return self.tfoot
    def set_tfoot(self, tfoot):
        self.tfoot = tfoot
    def get_tbody(self):
        return self.tbody
    def set_tbody(self, tbody):
        self.tbody = tbody
    def add_tbody(self, value):
        self.tbody.append(value)
    def insert_tbody_at(self, index, value):
        self.tbody.insert(index, value)
    def replace_tbody_at(self, index, value):
        self.tbody[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def get_rules(self):
        return self.rules
    def set_rules(self, rules):
        self.rules = rules
    def get_cellspacing(self):
        return self.cellspacing
    def set_cellspacing(self, cellspacing):
        self.cellspacing = cellspacing
    def get_cellpadding(self):
        return self.cellpadding
    def set_cellpadding(self, cellpadding):
        self.cellpadding = cellpadding
    def validate_frameType(self, value):
        # Validate type frameType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on frameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_rulesType(self, value):
        # Validate type rulesType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'groups', 'rows', 'cols', 'all']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.caption is not None or
            self.col or
            self.colgroup or
            self.thead is not None or
            self.tfoot is not None or
            self.tbody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Table', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Table')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Table':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Table')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Table'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.summary), input_name='summary')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.border is not None and 'border' not in already_processed:
            already_processed.add('border')
            outfile.write(' border=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.border), input_name='border')), ))
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            outfile.write(' frame=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.frame), input_name='frame')), ))
        if self.rules is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            outfile.write(' rules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rules), input_name='rules')), ))
        if self.cellspacing is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            outfile.write(' cellspacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellspacing), input_name='cellspacing')), ))
        if self.cellpadding is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            outfile.write(' cellpadding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellpadding), input_name='cellpadding')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
        for colgroup_ in self.colgroup:
            namespaceprefix_ = self.colgroup_nsprefix_ + ':' if (UseCapturedNS_ and self.colgroup_nsprefix_) else ''
            colgroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='colgroup', pretty_print=pretty_print)
        if self.thead is not None:
            namespaceprefix_ = self.thead_nsprefix_ + ':' if (UseCapturedNS_ and self.thead_nsprefix_) else ''
            self.thead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thead', pretty_print=pretty_print)
        if self.tfoot is not None:
            namespaceprefix_ = self.tfoot_nsprefix_ + ':' if (UseCapturedNS_ and self.tfoot_nsprefix_) else ''
            self.tfoot.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfoot', pretty_print=pretty_print)
        for tbody_ in self.tbody:
            namespaceprefix_ = self.tbody_nsprefix_ + ':' if (UseCapturedNS_ and self.tbody_nsprefix_) else ''
            tbody_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tbody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('border', node)
        if value is not None and 'border' not in already_processed:
            already_processed.add('border')
            self.border = value
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            self.frame = value
            self.validate_frameType(self.frame)    # validate type frameType
        value = find_attr_value_('rules', node)
        if value is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            self.rules = value
            self.validate_rulesType(self.rules)    # validate type rulesType
        value = find_attr_value_('cellspacing', node)
        if value is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            self.cellspacing = value
        value = find_attr_value_('cellpadding', node)
        if value is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            self.cellpadding = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
        elif nodeName_ == 'colgroup':
            obj_ = StrucDoc_Colgroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.colgroup.append(obj_)
            obj_.original_tagname_ = 'colgroup'
        elif nodeName_ == 'thead':
            obj_ = StrucDoc_Thead.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.thead = obj_
            obj_.original_tagname_ = 'thead'
        elif nodeName_ == 'tfoot':
            obj_ = StrucDoc_Tfoot.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfoot = obj_
            obj_.original_tagname_ = 'tfoot'
        elif nodeName_ == 'tbody':
            obj_ = StrucDoc_Tbody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tbody.append(obj_)
            obj_.original_tagname_ = 'tbody'
# end class StrucDoc_Table


class StrucDoc_Tbody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, align: 'alignType3' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType4' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tbody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tbody.subclass:
            return StrucDoc_Tbody.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tbody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType3(self, value):
        # Validate type alignType3, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType4(self, value):
        # Validate type valignType4, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tbody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tbody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tbody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tbody')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tbody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tbody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tbody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType3(self.align)    # validate type alignType3
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType4(self.valign)    # validate type valignType4
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tbody


class StrucDoc_Td(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, abbr: 'xs_string' = None, axis: 'xs_string' = None, headers: 'xs_string' = None, scope: 'scopeType' = None, rowspan: 'xs_string' = '1', colspan: 'xs_string' = '1', align: 'alignType5' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType6' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, paragraph: List_['StrucDoc.Paragraph'] = None, list: List_['StrucDoc.List'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Td)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Td.subclass:
            return StrucDoc_Td.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Td(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType(self, value):
        # Validate type scopeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType5(self, value):
        # Validate type alignType5, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType6(self, value):
        # Validate type valignType6, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Td', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Td')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Td':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Td')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Td'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Td', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType(self.scope)    # validate type scopeType
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType5(self.align)    # validate type alignType5
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType6(self.valign)    # validate type valignType6
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Td


class StrucDoc_Tfoot(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, align: 'alignType7' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType8' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tfoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tfoot.subclass:
            return StrucDoc_Tfoot.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tfoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType7(self, value):
        # Validate type alignType7, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType8(self, value):
        # Validate type valignType8, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tfoot', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tfoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tfoot':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tfoot')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tfoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tfoot'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tfoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType7(self.align)    # validate type alignType7
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType8(self.valign)    # validate type valignType8
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tfoot


class StrucDoc_Th(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, abbr: 'xs_string' = None, axis: 'xs_string' = None, headers: 'xs_string' = None, scope: 'scopeType9' = None, rowspan: 'xs_string' = '1', colspan: 'xs_string' = '1', align: 'alignType10' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType11' = None, content: List_['StrucDoc.Content'] = None, linkHtml: List_['StrucDoc.LinkHtml'] = None, sub: List_['StrucDoc.Sub'] = None, sup: List_['StrucDoc.Sup'] = None, br: List_['StrucDoc.Br'] = None, footnote: List_['StrucDoc.Footnote'] = None, footnoteRef: List_['StrucDoc.FootnoteRef'] = None, renderMultiMedia: List_['StrucDoc.RenderMultiMedia'] = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Th)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Th.subclass:
            return StrucDoc_Th.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Th(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType9(self, value):
        # Validate type scopeType9, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType10(self, value):
        # Validate type alignType10, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType10' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType11(self, value):
        # Validate type valignType11, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType11' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Th', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Th')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Th':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Th')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Th'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Th', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType9(self.scope)    # validate type scopeType9
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType10(self.align)    # validate type alignType10
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType11(self.valign)    # validate type valignType11
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Th


class StrucDoc_Thead(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, align: 'alignType12' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType13' = None, tr: List_['StrucDoc.Tr'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Thead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Thead.subclass:
            return StrucDoc_Thead.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Thead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType12(self, value):
        # Validate type alignType12, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType12' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType13(self, value):
        # Validate type valignType13, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType13' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Thead', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Thead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Thead':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Thead')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Thead', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Thead'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Thead', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType12(self.align)    # validate type alignType12
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType13(self.valign)    # validate type valignType13
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Thead


class StrucDoc_Tr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID: 'xs_string' = None, language: 'xs_NMTOKEN' = None, styleCode: 'xs_NMTOKENS' = None, align: 'alignType14' = None, char: 'xs_string' = None, charoff: 'xs_string' = None, valign: 'valignType15' = None, th: List_['StrucDoc.Th'] = None, td: List_['StrucDoc.Td'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if th is None:
            self.th = []
        else:
            self.th = th
        self.th_nsprefix_ = None
        if td is None:
            self.td = []
        else:
            self.td = td
        self.td_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tr.subclass:
            return StrucDoc_Tr.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_th(self):
        return self.th
    def set_th(self, th):
        self.th = th
    def add_th(self, value):
        self.th.append(value)
    def insert_th_at(self, index, value):
        self.th.insert(index, value)
    def replace_th_at(self, index, value):
        self.th[index] = value
    def get_td(self):
        return self.td
    def set_td(self, td):
        self.td = td
    def add_td(self, value):
        self.td.append(value)
    def insert_td_at(self, index, value):
        self.td.insert(index, value)
    def replace_td_at(self, index, value):
        self.td[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType14(self, value):
        # Validate type alignType14, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType14' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType15(self, value):
        # Validate type valignType15, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.th or
            self.td
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tr':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tr')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tr'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for th_ in self.th:
            namespaceprefix_ = self.th_nsprefix_ + ':' if (UseCapturedNS_ and self.th_nsprefix_) else ''
            th_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='th', pretty_print=pretty_print)
        for td_ in self.td:
            namespaceprefix_ = self.td_nsprefix_ + ':' if (UseCapturedNS_ and self.td_nsprefix_) else ''
            td_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='td', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType14(self.align)    # validate type alignType14
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType15(self.valign)    # validate type valignType15
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'th':
            obj_ = StrucDoc_Th.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.th.append(obj_)
            obj_.original_tagname_ = 'th'
        elif nodeName_ == 'td':
            obj_ = StrucDoc_Td.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.td.append(obj_)
            obj_.original_tagname_ = 'td'
# end class StrucDoc_Tr


class all_InfrastructureRoot_typeId(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, root: 'hl7v3_uid' = '2.16.840.1.113883.1.3', extension: 'hl7v3_st' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, all_InfrastructureRoot_typeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if all_InfrastructureRoot_typeId.subclass:
            return all_InfrastructureRoot_typeId.subclass(*args_, **kwargs_)
        else:
            return all_InfrastructureRoot_typeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def validate_uid(self, value):
        # Validate type hl7v3:uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type hl7v3:st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='all.InfrastructureRoot.typeId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('all.InfrastructureRoot.typeId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'all.InfrastructureRoot.typeId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='all.InfrastructureRoot.typeId')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='all.InfrastructureRoot.typeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='hl7v3:', name_='all.InfrastructureRoot.typeId'):
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='all.InfrastructureRoot.typeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class all_InfrastructureRoot_typeId


class all_InfrastructureRoot_templateId(II):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = II
    def __init__(self, nullFlavor: 'NullFlavor' = None, root: 'uid' = None, extension: 'st' = None, assigningAuthorityName: 'st' = None, displayable: 'bl' = None, unsorted: 'xs_boolean' = 'false', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("all_InfrastructureRoot_templateId"), self).__init__(nullFlavor, root, extension, assigningAuthorityName, displayable, valueOf_, mixedclass_, content_,  **kwargs_)
        self.unsorted = _cast(bool, unsorted)
        self.unsorted_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, all_InfrastructureRoot_templateId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if all_InfrastructureRoot_templateId.subclass:
            return all_InfrastructureRoot_templateId.subclass(*args_, **kwargs_)
        else:
            return all_InfrastructureRoot_templateId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unsorted(self):
        return self.unsorted
    def set_unsorted(self, unsorted):
        self.unsorted = unsorted
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(all_InfrastructureRoot_templateId, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='all.InfrastructureRoot.templateId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('all.InfrastructureRoot.templateId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'all.InfrastructureRoot.templateId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='all.InfrastructureRoot.templateId')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='hl7v3:', name_='all.InfrastructureRoot.templateId'):
        super(all_InfrastructureRoot_templateId, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='all.InfrastructureRoot.templateId')
        if self.unsorted and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            outfile.write(' unsorted="%s"' % self.gds_format_boolean(self.unsorted, input_name='unsorted'))
    def _exportChildren(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='all.InfrastructureRoot.templateId', fromsubclass_=False, pretty_print=True):
        super(all_InfrastructureRoot_templateId, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unsorted', node)
        if value is not None and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            if value in ('true', '1'):
                self.unsorted = True
            elif value in ('false', '0'):
                self.unsorted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(all_InfrastructureRoot_templateId, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(all_InfrastructureRoot_templateId, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class all_InfrastructureRoot_templateId


class xELGA_EIVL_event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code: 'hl7v3_xELGA_TimingEvent' = None, codeSystem: 'hl7v3_uid' = '2.16.840.1.113883.5.139', codeSystemName: 'hl7v3_st' = 'xELGA_TimingEvent', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xELGA_EIVL_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xELGA_EIVL_event.subclass:
            return xELGA_EIVL_event.subclass(*args_, **kwargs_)
        else:
            return xELGA_EIVL_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def validate_xELGA_TimingEvent(self, value):
        # Validate type hl7v3:xELGA_TimingEvent, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'ACD', 'ACM', 'ACV', 'HS', 'IC', 'ICD', 'ICM', 'ICV', 'PC', 'PCD', 'PCM', 'PCV', 'CM', 'CD', 'CV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on xELGA_TimingEvent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xELGA_TimingEvent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xELGA_TimingEvent_patterns_, ))
    validate_xELGA_TimingEvent_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type hl7v3:uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type hl7v3:st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='xELGA_EIVL.event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xELGA_EIVL.event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'xELGA_EIVL.event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xELGA_EIVL.event')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='xELGA_EIVL.event', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='hl7v3:', name_='xELGA_EIVL.event'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_='', name_='xELGA_EIVL.event', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_xELGA_TimingEvent(self.code)    # validate type xELGA_TimingEvent
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class xELGA_EIVL_event


class COCT_MT230100UV_Agency(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassPublicInstitution' = None, determinerCode: 'hl7v3_EntityDeterminerSpecific' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: 'II' = None, name: 'ON' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.name = name
        self.name_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Agency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Agency.subclass:
            return COCT_MT230100UV_Agency.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Agency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassPublicInstitution(self, value):
        # Validate type hl7v3:EntityClassPublicInstitution, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PUB']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassPublicInstitution' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassPublicInstitution_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassPublicInstitution_patterns_, ))
    validate_EntityClassPublicInstitution_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminerSpecific(self, value):
        # Validate type hl7v3:EntityDeterminerSpecific, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerSpecific' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerSpecific_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerSpecific_patterns_, ))
    validate_EntityDeterminerSpecific_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Agency', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Agency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Agency':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Agency')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Agency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Agency'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Agency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassPublicInstitution(self.classCode)    # validate type EntityClassPublicInstitution
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerSpecific(self.determinerCode)    # validate type EntityDeterminerSpecific
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class COCT_MT230100UV_Agency


class COCT_MT230100UV_Approval(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_ActClassContract' = None, moodCode: 'hl7v3_ActMoodEventOccurrence' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: 'II' = None, code: 'CD' = None, statusCode: 'CS' = None, holder: 'COCT_MT230100UV.Holder' = None, author: 'COCT_MT230100UV.Author' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = "hl7v3"
        self.holder = holder
        self.holder_nsprefix_ = "pharm"
        self.author = author
        self.author_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Approval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Approval.subclass:
            return COCT_MT230100UV_Approval.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Approval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_holder(self):
        return self.holder
    def set_holder(self, holder):
        self.holder = holder
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ActClassContract(self, value):
        # Validate type hl7v3:ActClassContract, a restriction on cs.
        pass
    def validate_ActMoodEventOccurrence(self, value):
        # Validate type hl7v3:ActMoodEventOccurrence, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['EVN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMoodEventOccurrence' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMoodEventOccurrence_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMoodEventOccurrence_patterns_, ))
    validate_ActMoodEventOccurrence_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.statusCode is not None or
            self.holder is not None or
            self.author is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Approval', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Approval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Approval':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Approval')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Approval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Approval'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Approval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.holder is not None:
            namespaceprefix_ = self.holder_nsprefix_ + ':' if (UseCapturedNS_ and self.holder_nsprefix_) else ''
            self.holder.export(outfile, level, namespaceprefix_, namespacedef_='', name_='holder', pretty_print=pretty_print)
        if self.author is not None:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            self.author.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassContract(self.classCode)    # validate type ActClassContract
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMoodEventOccurrence(self.moodCode)    # validate type ActMoodEventOccurrence
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'holder':
            obj_ = COCT_MT230100UV_Holder.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.holder = obj_
            obj_.original_tagname_ = 'holder'
        elif nodeName_ == 'author':
            obj_ = COCT_MT230100UV_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author = obj_
            obj_.original_tagname_ = 'author'
# end class COCT_MT230100UV_Approval


class COCT_MT230100UV_Author(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, typeCode: 'hl7v3_ParticipationAuthorOriginator' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, time: 'TS' = None, territorialAuthority: 'COCT_MT230100UV.TerritorialAuthority' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.time = time
        self.time_nsprefix_ = "hl7v3"
        self.territorialAuthority = territorialAuthority
        self.territorialAuthority_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Author)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Author.subclass:
            return COCT_MT230100UV_Author.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Author(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_territorialAuthority(self):
        return self.territorialAuthority
    def set_territorialAuthority(self, territorialAuthority):
        self.territorialAuthority = territorialAuthority
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_ParticipationAuthorOriginator(self, value):
        # Validate type hl7v3:ParticipationAuthorOriginator, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AUT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationAuthorOriginator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationAuthorOriginator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationAuthorOriginator_patterns_, ))
    validate_ParticipationAuthorOriginator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.territorialAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Author', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Author')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Author':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Author')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Author', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Author'):
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Author', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.territorialAuthority is not None:
            namespaceprefix_ = self.territorialAuthority_nsprefix_ + ':' if (UseCapturedNS_ and self.territorialAuthority_nsprefix_) else ''
            self.territorialAuthority.export(outfile, level, namespaceprefix_, namespacedef_='', name_='territorialAuthority', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationAuthorOriginator(self.typeCode)    # validate type ParticipationAuthorOriginator
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'territorialAuthority':
            obj_ = COCT_MT230100UV_TerritorialAuthority.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.territorialAuthority = obj_
            obj_.original_tagname_ = 'territorialAuthority'
# end class COCT_MT230100UV_Author


class COCT_MT230100UV_Characteristic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_ActClassObservation' = None, moodCode: 'hl7v3_ActMoodEventOccurrence' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CE' = None, text: 'ED' = None, value: 'ANY' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.text = text
        self.text_nsprefix_ = "hl7v3"
        self.value = value
        self.value_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Characteristic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Characteristic.subclass:
            return COCT_MT230100UV_Characteristic.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Characteristic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type hl7v3:ActClassObservation, a restriction on cs.
        pass
    def validate_ActMoodEventOccurrence(self, value):
        # Validate type hl7v3:ActMoodEventOccurrence, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['EVN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMoodEventOccurrence' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMoodEventOccurrence_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMoodEventOccurrence_patterns_, ))
    validate_ActMoodEventOccurrence_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Characteristic', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Characteristic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Characteristic':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Characteristic')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Characteristic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Characteristic'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Characteristic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMoodEventOccurrence(self.moodCode)    # validate type ActMoodEventOccurrence
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class COCT_MT230100UV_Characteristic


class COCT_MT230100UV_Content(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassContent' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, containerPackagedMedicine: 'COCT_MT230100UV.PackagedMedicine' = None, subjectOf1: List_['COCT_MT230100UV.Subject14'] = None, subjectOf2: List_['COCT_MT230100UV.Subject11'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.containerPackagedMedicine = containerPackagedMedicine
        self.containerPackagedMedicine_nsprefix_ = "pharm"
        if subjectOf1 is None:
            self.subjectOf1 = []
        else:
            self.subjectOf1 = subjectOf1
        self.subjectOf1_nsprefix_ = "pharm"
        if subjectOf2 is None:
            self.subjectOf2 = []
        else:
            self.subjectOf2 = subjectOf2
        self.subjectOf2_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Content.subclass:
            return COCT_MT230100UV_Content.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_containerPackagedMedicine(self):
        return self.containerPackagedMedicine
    def set_containerPackagedMedicine(self, containerPackagedMedicine):
        self.containerPackagedMedicine = containerPackagedMedicine
    def get_subjectOf1(self):
        return self.subjectOf1
    def set_subjectOf1(self, subjectOf1):
        self.subjectOf1 = subjectOf1
    def add_subjectOf1(self, value):
        self.subjectOf1.append(value)
    def insert_subjectOf1_at(self, index, value):
        self.subjectOf1.insert(index, value)
    def replace_subjectOf1_at(self, index, value):
        self.subjectOf1[index] = value
    def get_subjectOf2(self):
        return self.subjectOf2
    def set_subjectOf2(self, subjectOf2):
        self.subjectOf2 = subjectOf2
    def add_subjectOf2(self, value):
        self.subjectOf2.append(value)
    def insert_subjectOf2_at(self, index, value):
        self.subjectOf2.insert(index, value)
    def replace_subjectOf2_at(self, index, value):
        self.subjectOf2[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassContent(self, value):
        # Validate type hl7v3:RoleClassContent, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CONT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassContent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassContent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassContent_patterns_, ))
    validate_RoleClassContent_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.containerPackagedMedicine is not None or
            self.subjectOf1 or
            self.subjectOf2
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Content', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Content')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Content':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Content')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Content', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Content'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Content', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.containerPackagedMedicine is not None:
            namespaceprefix_ = self.containerPackagedMedicine_nsprefix_ + ':' if (UseCapturedNS_ and self.containerPackagedMedicine_nsprefix_) else ''
            self.containerPackagedMedicine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='containerPackagedMedicine', pretty_print=pretty_print)
        for subjectOf1_ in self.subjectOf1:
            namespaceprefix_ = self.subjectOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf1_nsprefix_) else ''
            subjectOf1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf1', pretty_print=pretty_print)
        for subjectOf2_ in self.subjectOf2:
            namespaceprefix_ = self.subjectOf2_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf2_nsprefix_) else ''
            subjectOf2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf2', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassContent(self.classCode)    # validate type RoleClassContent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'containerPackagedMedicine':
            obj_ = COCT_MT230100UV_PackagedMedicine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.containerPackagedMedicine = obj_
            obj_.original_tagname_ = 'containerPackagedMedicine'
        elif nodeName_ == 'subjectOf1':
            obj_ = COCT_MT230100UV_Subject14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf1.append(obj_)
            obj_.original_tagname_ = 'subjectOf1'
        elif nodeName_ == 'subjectOf2':
            obj_ = COCT_MT230100UV_Subject11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf2.append(obj_)
            obj_.original_tagname_ = 'subjectOf2'
# end class COCT_MT230100UV_Content


class COCT_MT230100UV_Country(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassState' = None, determinerCode: 'hl7v3_EntityDeterminerSpecific' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CD' = None, name: 'TN' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.name = name
        self.name_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Country.subclass:
            return COCT_MT230100UV_Country.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassState(self, value):
        # Validate type hl7v3:EntityClassState, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STATE', 'NAT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassState' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassState_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassState_patterns_, ))
    validate_EntityClassState_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminerSpecific(self, value):
        # Validate type hl7v3:EntityDeterminerSpecific, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerSpecific' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerSpecific_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerSpecific_patterns_, ))
    validate_EntityDeterminerSpecific_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Country':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Country')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Country', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Country'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Country', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassState(self.classCode)    # validate type EntityClassState
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerSpecific(self.determinerCode)    # validate type EntityDeterminerSpecific
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            obj_ = TN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class COCT_MT230100UV_Country


class COCT_MT230100UV_DistributedProduct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassDistributedMaterial' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, distributingManufacturer: 'COCT_MT230100UV.Manufacturer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.distributingManufacturer = distributingManufacturer
        self.distributingManufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_DistributedProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_DistributedProduct.subclass:
            return COCT_MT230100UV_DistributedProduct.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_DistributedProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_distributingManufacturer(self):
        return self.distributingManufacturer
    def set_distributingManufacturer(self, distributingManufacturer):
        self.distributingManufacturer = distributingManufacturer
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassDistributedMaterial(self, value):
        # Validate type hl7v3:RoleClassDistributedMaterial, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DST', 'RET']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassDistributedMaterial' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassDistributedMaterial_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassDistributedMaterial_patterns_, ))
    validate_RoleClassDistributedMaterial_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.distributingManufacturer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.DistributedProduct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.DistributedProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.DistributedProduct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.DistributedProduct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.DistributedProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.DistributedProduct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.DistributedProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.distributingManufacturer is not None:
            namespaceprefix_ = self.distributingManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.distributingManufacturer_nsprefix_) else ''
            self.distributingManufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distributingManufacturer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassDistributedMaterial(self.classCode)    # validate type RoleClassDistributedMaterial
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'distributingManufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distributingManufacturer = obj_
            obj_.original_tagname_ = 'distributingManufacturer'
# end class COCT_MT230100UV_DistributedProduct


class COCT_MT230100UV_Holder(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationHolder' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, role: 'COCT_MT230100UV.Role' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.role = role
        self.role_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Holder)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Holder.subclass:
            return COCT_MT230100UV_Holder.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Holder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationHolder(self, value):
        # Validate type hl7v3:ParticipationHolder, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationHolder' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationHolder_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationHolder_patterns_, ))
    validate_ParticipationHolder_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Holder', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Holder')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Holder':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Holder')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Holder', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Holder'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Holder', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.role is not None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            self.role.export(outfile, level, namespaceprefix_, namespacedef_='', name_='role', pretty_print=pretty_print)
        if self.role is None:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationHolder(self.typeCode)    # validate type ParticipationHolder
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'role':
            obj_ = COCT_MT230100UV_Role.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class COCT_MT230100UV_Holder


class COCT_MT230100UV_Ingredient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassIngredientEntity' = None, negationInd: 'hl7v3_bl' = 'false', realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, ingredient: 'COCT_MT230100UV.Substance' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.ingredient = ingredient
        self.ingredient_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Ingredient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Ingredient.subclass:
            return COCT_MT230100UV_Ingredient.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Ingredient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_ingredient(self):
        return self.ingredient
    def set_ingredient(self, ingredient):
        self.ingredient = ingredient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassIngredientEntity(self, value):
        # Validate type hl7v3:RoleClassIngredientEntity, a restriction on cs.
        pass
    def validate_bl(self, value):
        # Validate type hl7v3:bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.ingredient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Ingredient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Ingredient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Ingredient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Ingredient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Ingredient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Ingredient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.negationInd and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Ingredient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.ingredient is not None:
            namespaceprefix_ = self.ingredient_nsprefix_ + ':' if (UseCapturedNS_ and self.ingredient_nsprefix_) else ''
            self.ingredient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ingredient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassIngredientEntity(self.classCode)    # validate type RoleClassIngredientEntity
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'ingredient':
            obj_ = COCT_MT230100UV_Substance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ingredient = obj_
            obj_.original_tagname_ = 'ingredient'
# end class COCT_MT230100UV_Ingredient


class COCT_MT230100UV_ManufacturedProduct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassManufacturedProduct' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, manufacturer: 'COCT_MT230100UV.Manufacturer' = None, subjectOf1: List_['COCT_MT230100UV.Subject25'] = None, subjectOf2: List_['COCT_MT230100UV.Subject15'] = None, subjectOf3: List_['COCT_MT230100UV.Subject16'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.manufacturer = manufacturer
        self.manufacturer_nsprefix_ = "pharm"
        if subjectOf1 is None:
            self.subjectOf1 = []
        else:
            self.subjectOf1 = subjectOf1
        self.subjectOf1_nsprefix_ = "pharm"
        if subjectOf2 is None:
            self.subjectOf2 = []
        else:
            self.subjectOf2 = subjectOf2
        self.subjectOf2_nsprefix_ = "pharm"
        if subjectOf3 is None:
            self.subjectOf3 = []
        else:
            self.subjectOf3 = subjectOf3
        self.subjectOf3_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_ManufacturedProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_ManufacturedProduct.subclass:
            return COCT_MT230100UV_ManufacturedProduct.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_ManufacturedProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturer(self):
        return self.manufacturer
    def set_manufacturer(self, manufacturer):
        self.manufacturer = manufacturer
    def get_subjectOf1(self):
        return self.subjectOf1
    def set_subjectOf1(self, subjectOf1):
        self.subjectOf1 = subjectOf1
    def add_subjectOf1(self, value):
        self.subjectOf1.append(value)
    def insert_subjectOf1_at(self, index, value):
        self.subjectOf1.insert(index, value)
    def replace_subjectOf1_at(self, index, value):
        self.subjectOf1[index] = value
    def get_subjectOf2(self):
        return self.subjectOf2
    def set_subjectOf2(self, subjectOf2):
        self.subjectOf2 = subjectOf2
    def add_subjectOf2(self, value):
        self.subjectOf2.append(value)
    def insert_subjectOf2_at(self, index, value):
        self.subjectOf2.insert(index, value)
    def replace_subjectOf2_at(self, index, value):
        self.subjectOf2[index] = value
    def get_subjectOf3(self):
        return self.subjectOf3
    def set_subjectOf3(self, subjectOf3):
        self.subjectOf3 = subjectOf3
    def add_subjectOf3(self, value):
        self.subjectOf3.append(value)
    def insert_subjectOf3_at(self, index, value):
        self.subjectOf3.insert(index, value)
    def replace_subjectOf3_at(self, index, value):
        self.subjectOf3[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassManufacturedProduct(self, value):
        # Validate type hl7v3:RoleClassManufacturedProduct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANU', 'THER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassManufacturedProduct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassManufacturedProduct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassManufacturedProduct_patterns_, ))
    validate_RoleClassManufacturedProduct_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturer is not None or
            self.subjectOf1 or
            self.subjectOf2 or
            self.subjectOf3
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.ManufacturedProduct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.ManufacturedProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.ManufacturedProduct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.ManufacturedProduct')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.ManufacturedProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.ManufacturedProduct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.ManufacturedProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturer is not None:
            namespaceprefix_ = self.manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturer_nsprefix_) else ''
            self.manufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturer', pretty_print=pretty_print)
        for subjectOf1_ in self.subjectOf1:
            namespaceprefix_ = self.subjectOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf1_nsprefix_) else ''
            subjectOf1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf1', pretty_print=pretty_print)
        for subjectOf2_ in self.subjectOf2:
            namespaceprefix_ = self.subjectOf2_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf2_nsprefix_) else ''
            subjectOf2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf2', pretty_print=pretty_print)
        for subjectOf3_ in self.subjectOf3:
            namespaceprefix_ = self.subjectOf3_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf3_nsprefix_) else ''
            subjectOf3_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf3', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassManufacturedProduct(self.classCode)    # validate type RoleClassManufacturedProduct
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturer = obj_
            obj_.original_tagname_ = 'manufacturer'
        elif nodeName_ == 'subjectOf1':
            obj_ = COCT_MT230100UV_Subject25.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf1.append(obj_)
            obj_.original_tagname_ = 'subjectOf1'
        elif nodeName_ == 'subjectOf2':
            obj_ = COCT_MT230100UV_Subject15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf2.append(obj_)
            obj_.original_tagname_ = 'subjectOf2'
        elif nodeName_ == 'subjectOf3':
            obj_ = COCT_MT230100UV_Subject16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf3.append(obj_)
            obj_.original_tagname_ = 'subjectOf3'
# end class COCT_MT230100UV_ManufacturedProduct


class COCT_MT230100UV_Manufacturer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassOrganization' = None, determinerCode: 'hl7v3_EntityDeterminerSpecific' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: 'II' = None, name: 'EN' = None, telecom: 'TEL' = None, addr: 'AD' = None, asRelatedManufacturer: List_['COCT_MT230100UV.RelatedManufacturer'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.name = name
        self.name_nsprefix_ = "hl7v3"
        self.telecom = telecom
        self.telecom_nsprefix_ = "hl7v3"
        self.addr = addr
        self.addr_nsprefix_ = "hl7v3"
        if asRelatedManufacturer is None:
            self.asRelatedManufacturer = []
        else:
            self.asRelatedManufacturer = asRelatedManufacturer
        self.asRelatedManufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Manufacturer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Manufacturer.subclass:
            return COCT_MT230100UV_Manufacturer.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Manufacturer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_asRelatedManufacturer(self):
        return self.asRelatedManufacturer
    def set_asRelatedManufacturer(self, asRelatedManufacturer):
        self.asRelatedManufacturer = asRelatedManufacturer
    def add_asRelatedManufacturer(self, value):
        self.asRelatedManufacturer.append(value)
    def insert_asRelatedManufacturer_at(self, index, value):
        self.asRelatedManufacturer.insert(index, value)
    def replace_asRelatedManufacturer_at(self, index, value):
        self.asRelatedManufacturer[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassOrganization(self, value):
        # Validate type hl7v3:EntityClassOrganization, a restriction on cs.
        pass
    def validate_EntityDeterminerSpecific(self, value):
        # Validate type hl7v3:EntityDeterminerSpecific, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INSTANCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerSpecific' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerSpecific_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerSpecific_patterns_, ))
    validate_EntityDeterminerSpecific_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name is not None or
            self.telecom is not None or
            self.addr is not None or
            self.asRelatedManufacturer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Manufacturer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Manufacturer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Manufacturer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Manufacturer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Manufacturer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Manufacturer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Manufacturer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.telecom is not None:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            self.telecom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for asRelatedManufacturer_ in self.asRelatedManufacturer:
            namespaceprefix_ = self.asRelatedManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.asRelatedManufacturer_nsprefix_) else ''
            asRelatedManufacturer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asRelatedManufacturer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassOrganization(self.classCode)    # validate type EntityClassOrganization
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerSpecific(self.determinerCode)    # validate type EntityDeterminerSpecific
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom = obj_
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'asRelatedManufacturer':
            obj_ = COCT_MT230100UV_RelatedManufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asRelatedManufacturer.append(obj_)
            obj_.original_tagname_ = 'asRelatedManufacturer'
# end class COCT_MT230100UV_Manufacturer


class COCT_MT230100UV_Medication(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7v3_RoleClassAdministerableMaterial' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, administerableMedicine: 'COCT_MT230100UV.Medicine' = None, subjectOf1: List_['COCT_MT230100UV.Subject2'] = None, subjectOf2: List_['COCT_MT230100UV.Subject1'] = None, subjectOf3: List_['COCT_MT230100UV.Subject22'] = None, subjectOf4: List_['COCT_MT230100UV.Subject3'] = None, subjectOf5: 'COCT_MT230100UV.Subject7' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.administerableMedicine = administerableMedicine
        self.administerableMedicine_nsprefix_ = "pharm"
        if subjectOf1 is None:
            self.subjectOf1 = []
        else:
            self.subjectOf1 = subjectOf1
        self.subjectOf1_nsprefix_ = "pharm"
        if subjectOf2 is None:
            self.subjectOf2 = []
        else:
            self.subjectOf2 = subjectOf2
        self.subjectOf2_nsprefix_ = "pharm"
        if subjectOf3 is None:
            self.subjectOf3 = []
        else:
            self.subjectOf3 = subjectOf3
        self.subjectOf3_nsprefix_ = "pharm"
        if subjectOf4 is None:
            self.subjectOf4 = []
        else:
            self.subjectOf4 = subjectOf4
        self.subjectOf4_nsprefix_ = "pharm"
        self.subjectOf5 = subjectOf5
        self.subjectOf5_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Medication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Medication.subclass:
            return COCT_MT230100UV_Medication.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Medication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_administerableMedicine(self):
        return self.administerableMedicine
    def set_administerableMedicine(self, administerableMedicine):
        self.administerableMedicine = administerableMedicine
    def get_subjectOf1(self):
        return self.subjectOf1
    def set_subjectOf1(self, subjectOf1):
        self.subjectOf1 = subjectOf1
    def add_subjectOf1(self, value):
        self.subjectOf1.append(value)
    def insert_subjectOf1_at(self, index, value):
        self.subjectOf1.insert(index, value)
    def replace_subjectOf1_at(self, index, value):
        self.subjectOf1[index] = value
    def get_subjectOf2(self):
        return self.subjectOf2
    def set_subjectOf2(self, subjectOf2):
        self.subjectOf2 = subjectOf2
    def add_subjectOf2(self, value):
        self.subjectOf2.append(value)
    def insert_subjectOf2_at(self, index, value):
        self.subjectOf2.insert(index, value)
    def replace_subjectOf2_at(self, index, value):
        self.subjectOf2[index] = value
    def get_subjectOf3(self):
        return self.subjectOf3
    def set_subjectOf3(self, subjectOf3):
        self.subjectOf3 = subjectOf3
    def add_subjectOf3(self, value):
        self.subjectOf3.append(value)
    def insert_subjectOf3_at(self, index, value):
        self.subjectOf3.insert(index, value)
    def replace_subjectOf3_at(self, index, value):
        self.subjectOf3[index] = value
    def get_subjectOf4(self):
        return self.subjectOf4
    def set_subjectOf4(self, subjectOf4):
        self.subjectOf4 = subjectOf4
    def add_subjectOf4(self, value):
        self.subjectOf4.append(value)
    def insert_subjectOf4_at(self, index, value):
        self.subjectOf4.insert(index, value)
    def replace_subjectOf4_at(self, index, value):
        self.subjectOf4[index] = value
    def get_subjectOf5(self):
        return self.subjectOf5
    def set_subjectOf5(self, subjectOf5):
        self.subjectOf5 = subjectOf5
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_RoleClassAdministerableMaterial(self, value):
        # Validate type hl7v3:RoleClassAdministerableMaterial, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADMM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassAdministerableMaterial' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassAdministerableMaterial_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassAdministerableMaterial_patterns_, ))
    validate_RoleClassAdministerableMaterial_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.administerableMedicine is not None or
            self.subjectOf1 or
            self.subjectOf2 or
            self.subjectOf3 or
            self.subjectOf4 or
            self.subjectOf5 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Medication', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Medication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Medication':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Medication')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Medication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Medication'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Medication', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.administerableMedicine is not None:
            namespaceprefix_ = self.administerableMedicine_nsprefix_ + ':' if (UseCapturedNS_ and self.administerableMedicine_nsprefix_) else ''
            self.administerableMedicine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administerableMedicine', pretty_print=pretty_print)
        for subjectOf1_ in self.subjectOf1:
            namespaceprefix_ = self.subjectOf1_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf1_nsprefix_) else ''
            subjectOf1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf1', pretty_print=pretty_print)
        for subjectOf2_ in self.subjectOf2:
            namespaceprefix_ = self.subjectOf2_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf2_nsprefix_) else ''
            subjectOf2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf2', pretty_print=pretty_print)
        for subjectOf3_ in self.subjectOf3:
            namespaceprefix_ = self.subjectOf3_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf3_nsprefix_) else ''
            subjectOf3_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf3', pretty_print=pretty_print)
        for subjectOf4_ in self.subjectOf4:
            namespaceprefix_ = self.subjectOf4_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf4_nsprefix_) else ''
            subjectOf4_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf4', pretty_print=pretty_print)
        if self.subjectOf5 is not None:
            namespaceprefix_ = self.subjectOf5_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf5_nsprefix_) else ''
            self.subjectOf5.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf5', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAdministerableMaterial(self.classCode)    # validate type RoleClassAdministerableMaterial
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'administerableMedicine':
            obj_ = COCT_MT230100UV_Medicine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administerableMedicine = obj_
            obj_.original_tagname_ = 'administerableMedicine'
        elif nodeName_ == 'subjectOf1':
            obj_ = COCT_MT230100UV_Subject2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf1.append(obj_)
            obj_.original_tagname_ = 'subjectOf1'
        elif nodeName_ == 'subjectOf2':
            obj_ = COCT_MT230100UV_Subject1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf2.append(obj_)
            obj_.original_tagname_ = 'subjectOf2'
        elif nodeName_ == 'subjectOf3':
            obj_ = COCT_MT230100UV_Subject22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf3.append(obj_)
            obj_.original_tagname_ = 'subjectOf3'
        elif nodeName_ == 'subjectOf4':
            obj_ = COCT_MT230100UV_Subject3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf4.append(obj_)
            obj_.original_tagname_ = 'subjectOf4'
        elif nodeName_ == 'subjectOf5':
            obj_ = COCT_MT230100UV_Subject7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf5 = obj_
            obj_.original_tagname_ = 'subjectOf5'
# end class COCT_MT230100UV_Medication


class COCT_MT230100UV_Medicine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7v3_EntityClassManufacturedMaterial' = None, determinerCode: 'hl7v3_EntityDeterminer' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: 'II' = None, code: 'CE' = None, name: List_['TN'] = None, desc: 'ED' = None, riskCode: 'CE' = None, handlingCode: 'CE' = None, formCode: 'CE' = None, lotNumberText: 'ST' = None, expirationTime: 'IVL_TS' = None, stabilityTime: 'IVL_TS' = None, asDistributedProduct: List_['COCT_MT230100UV.DistributedProduct'] = None, asMedicineManufacturer: List_['COCT_MT230100UV.MedicineManufacturer'] = None, asContent: 'COCT_MT230100UV.Content' = None, asSpecializedKind: List_['COCT_MT230100UV.SpecializedKind'] = None, part: List_['COCT_MT230100UV.Part'] = None, ingredient: List_['COCT_MT230100UV.Ingredient'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = "hl7v3"
        self.desc = desc
        self.desc_nsprefix_ = "hl7v3"
        self.riskCode = riskCode
        self.riskCode_nsprefix_ = "hl7v3"
        self.handlingCode = handlingCode
        self.handlingCode_nsprefix_ = "hl7v3"
        self.formCode = formCode
        self.formCode_nsprefix_ = "hl7v3"
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = "hl7v3"
        self.expirationTime = expirationTime
        self.expirationTime_nsprefix_ = "hl7v3"
        self.stabilityTime = stabilityTime
        self.stabilityTime_nsprefix_ = "hl7v3"
        if asDistributedProduct is None:
            self.asDistributedProduct = []
        else:
            self.asDistributedProduct = asDistributedProduct
        self.asDistributedProduct_nsprefix_ = "pharm"
        if asMedicineManufacturer is None:
            self.asMedicineManufacturer = []
        else:
            self.asMedicineManufacturer = asMedicineManufacturer
        self.asMedicineManufacturer_nsprefix_ = "pharm"
        self.asContent = asContent
        self.asContent_nsprefix_ = "pharm"
        if asSpecializedKind is None:
            self.asSpecializedKind = []
        else:
            self.asSpecializedKind = asSpecializedKind
        self.asSpecializedKind_nsprefix_ = "pharm"
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = "pharm"
        if ingredient is None:
            self.ingredient = []
        else:
            self.ingredient = ingredient
        self.ingredient_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Medicine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Medicine.subclass:
            return COCT_MT230100UV_Medicine.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Medicine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_riskCode(self):
        return self.riskCode
    def set_riskCode(self, riskCode):
        self.riskCode = riskCode
    def get_handlingCode(self):
        return self.handlingCode
    def set_handlingCode(self, handlingCode):
        self.handlingCode = handlingCode
    def get_formCode(self):
        return self.formCode
    def set_formCode(self, formCode):
        self.formCode = formCode
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_expirationTime(self):
        return self.expirationTime
    def set_expirationTime(self, expirationTime):
        self.expirationTime = expirationTime
    def get_stabilityTime(self):
        return self.stabilityTime
    def set_stabilityTime(self, stabilityTime):
        self.stabilityTime = stabilityTime
    def get_asDistributedProduct(self):
        return self.asDistributedProduct
    def set_asDistributedProduct(self, asDistributedProduct):
        self.asDistributedProduct = asDistributedProduct
    def add_asDistributedProduct(self, value):
        self.asDistributedProduct.append(value)
    def insert_asDistributedProduct_at(self, index, value):
        self.asDistributedProduct.insert(index, value)
    def replace_asDistributedProduct_at(self, index, value):
        self.asDistributedProduct[index] = value
    def get_asMedicineManufacturer(self):
        return self.asMedicineManufacturer
    def set_asMedicineManufacturer(self, asMedicineManufacturer):
        self.asMedicineManufacturer = asMedicineManufacturer
    def add_asMedicineManufacturer(self, value):
        self.asMedicineManufacturer.append(value)
    def insert_asMedicineManufacturer_at(self, index, value):
        self.asMedicineManufacturer.insert(index, value)
    def replace_asMedicineManufacturer_at(self, index, value):
        self.asMedicineManufacturer[index] = value
    def get_asContent(self):
        return self.asContent
    def set_asContent(self, asContent):
        self.asContent = asContent
    def get_asSpecializedKind(self):
        return self.asSpecializedKind
    def set_asSpecializedKind(self, asSpecializedKind):
        self.asSpecializedKind = asSpecializedKind
    def add_asSpecializedKind(self, value):
        self.asSpecializedKind.append(value)
    def insert_asSpecializedKind_at(self, index, value):
        self.asSpecializedKind.insert(index, value)
    def replace_asSpecializedKind_at(self, index, value):
        self.asSpecializedKind[index] = value
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_ingredient(self):
        return self.ingredient
    def set_ingredient(self, ingredient):
        self.ingredient = ingredient
    def add_ingredient(self, value):
        self.ingredient.append(value)
    def insert_ingredient_at(self, index, value):
        self.ingredient.insert(index, value)
    def replace_ingredient_at(self, index, value):
        self.ingredient[index] = value
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type hl7v3:EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type hl7v3:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.name or
            self.desc is not None or
            self.riskCode is not None or
            self.handlingCode is not None or
            self.formCode is not None or
            self.lotNumberText is not None or
            self.expirationTime is not None or
            self.stabilityTime is not None or
            self.asDistributedProduct or
            self.asMedicineManufacturer or
            self.asContent is not None or
            self.asSpecializedKind or
            self.part or
            self.ingredient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Medicine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Medicine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Medicine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Medicine')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Medicine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Medicine'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Medicine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.riskCode is not None:
            namespaceprefix_ = self.riskCode_nsprefix_ + ':' if (UseCapturedNS_ and self.riskCode_nsprefix_) else ''
            self.riskCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='riskCode', pretty_print=pretty_print)
        if self.handlingCode is not None:
            namespaceprefix_ = self.handlingCode_nsprefix_ + ':' if (UseCapturedNS_ and self.handlingCode_nsprefix_) else ''
            self.handlingCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='handlingCode', pretty_print=pretty_print)
        if self.formCode is not None:
            namespaceprefix_ = self.formCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formCode_nsprefix_) else ''
            self.formCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formCode', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
        if self.expirationTime is not None:
            namespaceprefix_ = self.expirationTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expirationTime_nsprefix_) else ''
            self.expirationTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expirationTime', pretty_print=pretty_print)
        if self.stabilityTime is not None:
            namespaceprefix_ = self.stabilityTime_nsprefix_ + ':' if (UseCapturedNS_ and self.stabilityTime_nsprefix_) else ''
            self.stabilityTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stabilityTime', pretty_print=pretty_print)
        for asDistributedProduct_ in self.asDistributedProduct:
            namespaceprefix_ = self.asDistributedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.asDistributedProduct_nsprefix_) else ''
            asDistributedProduct_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asDistributedProduct', pretty_print=pretty_print)
        for asMedicineManufacturer_ in self.asMedicineManufacturer:
            namespaceprefix_ = self.asMedicineManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.asMedicineManufacturer_nsprefix_) else ''
            asMedicineManufacturer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asMedicineManufacturer', pretty_print=pretty_print)
        if self.asContent is not None:
            namespaceprefix_ = self.asContent_nsprefix_ + ':' if (UseCapturedNS_ and self.asContent_nsprefix_) else ''
            self.asContent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asContent', pretty_print=pretty_print)
        for asSpecializedKind_ in self.asSpecializedKind:
            namespaceprefix_ = self.asSpecializedKind_nsprefix_ + ':' if (UseCapturedNS_ and self.asSpecializedKind_nsprefix_) else ''
            asSpecializedKind_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asSpecializedKind', pretty_print=pretty_print)
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part', pretty_print=pretty_print)
        for ingredient_ in self.ingredient:
            namespaceprefix_ = self.ingredient_nsprefix_ + ':' if (UseCapturedNS_ and self.ingredient_nsprefix_) else ''
            ingredient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ingredient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            obj_ = TN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'riskCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.riskCode = obj_
            obj_.original_tagname_ = 'riskCode'
        elif nodeName_ == 'handlingCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.handlingCode = obj_
            obj_.original_tagname_ = 'handlingCode'
        elif nodeName_ == 'formCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formCode = obj_
            obj_.original_tagname_ = 'formCode'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
        elif nodeName_ == 'expirationTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'stabilityTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stabilityTime = obj_
            obj_.original_tagname_ = 'stabilityTime'
        elif nodeName_ == 'asDistributedProduct':
            obj_ = COCT_MT230100UV_DistributedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asDistributedProduct.append(obj_)
            obj_.original_tagname_ = 'asDistributedProduct'
        elif nodeName_ == 'asMedicineManufacturer':
            obj_ = COCT_MT230100UV_MedicineManufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asMedicineManufacturer.append(obj_)
            obj_.original_tagname_ = 'asMedicineManufacturer'
        elif nodeName_ == 'asContent':
            obj_ = COCT_MT230100UV_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asContent = obj_
            obj_.original_tagname_ = 'asContent'
        elif nodeName_ == 'asSpecializedKind':
            obj_ = COCT_MT230100UV_SpecializedKind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asSpecializedKind.append(obj_)
            obj_.original_tagname_ = 'asSpecializedKind'
        elif nodeName_ == 'part':
            obj_ = COCT_MT230100UV_Part.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
        elif nodeName_ == 'ingredient':
            obj_ = COCT_MT230100UV_Ingredient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ingredient.append(obj_)
            obj_.original_tagname_ = 'ingredient'
# end class COCT_MT230100UV_Medicine


class COCT_MT230100UV_MedicineClass(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassManufacturedMaterial' = None, determinerCode: 'hl7v3_EntityDeterminer' = 'KIND', realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CE' = None, name: List_['TN'] = None, desc: 'ED' = None, formCode: 'CE' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = "hl7v3"
        self.desc = desc
        self.desc_nsprefix_ = "hl7v3"
        self.formCode = formCode
        self.formCode_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_MedicineClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_MedicineClass.subclass:
            return COCT_MT230100UV_MedicineClass.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_MedicineClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_formCode(self):
        return self.formCode
    def set_formCode(self, formCode):
        self.formCode = formCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type hl7v3:EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type hl7v3:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name or
            self.desc is not None or
            self.formCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.MedicineClass', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.MedicineClass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.MedicineClass':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.MedicineClass')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.MedicineClass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.MedicineClass'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.MedicineClass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.formCode is not None:
            namespaceprefix_ = self.formCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formCode_nsprefix_) else ''
            self.formCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            obj_ = TN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'formCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formCode = obj_
            obj_.original_tagname_ = 'formCode'
# end class COCT_MT230100UV_MedicineClass


class COCT_MT230100UV_MedicineManufacturer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassManufacturedProduct' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, manufacturer: 'COCT_MT230100UV.Manufacturer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.manufacturer = manufacturer
        self.manufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_MedicineManufacturer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_MedicineManufacturer.subclass:
            return COCT_MT230100UV_MedicineManufacturer.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_MedicineManufacturer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturer(self):
        return self.manufacturer
    def set_manufacturer(self, manufacturer):
        self.manufacturer = manufacturer
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassManufacturedProduct(self, value):
        # Validate type hl7v3:RoleClassManufacturedProduct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANU', 'THER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassManufacturedProduct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassManufacturedProduct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassManufacturedProduct_patterns_, ))
    validate_RoleClassManufacturedProduct_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.MedicineManufacturer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.MedicineManufacturer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.MedicineManufacturer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.MedicineManufacturer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.MedicineManufacturer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.MedicineManufacturer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.MedicineManufacturer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturer is not None:
            namespaceprefix_ = self.manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturer_nsprefix_) else ''
            self.manufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturer', pretty_print=pretty_print)
        if self.manufacturer is None:
            namespaceprefix_ = self.manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanufacturer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassManufacturedProduct(self.classCode)    # validate type RoleClassManufacturedProduct
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturer = obj_
            obj_.original_tagname_ = 'manufacturer'
# end class COCT_MT230100UV_MedicineManufacturer


class COCT_MT230100UV_ObservationGoal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_ActClassObservation' = None, moodCode: 'hl7v3_ActMoodGoal' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CD' = None, text: 'ED' = None, value: 'ANY' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.text = text
        self.text_nsprefix_ = "hl7v3"
        self.value = value
        self.value_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_ObservationGoal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_ObservationGoal.subclass:
            return COCT_MT230100UV_ObservationGoal.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_ObservationGoal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type hl7v3:ActClassObservation, a restriction on cs.
        pass
    def validate_ActMoodGoal(self, value):
        # Validate type hl7v3:ActMoodGoal, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GOL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMoodGoal' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMoodGoal_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMoodGoal_patterns_, ))
    validate_ActMoodGoal_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.ObservationGoal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.ObservationGoal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.ObservationGoal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.ObservationGoal')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.ObservationGoal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.ObservationGoal'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.ObservationGoal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMoodGoal(self.moodCode)    # validate type ActMoodGoal
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class COCT_MT230100UV_ObservationGoal


class COCT_MT230100UV_PackagedMedicine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassContainer' = None, determinerCode: 'hl7v3_EntityDeterminer' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: 'II' = None, code: 'CE' = None, name: List_['TN'] = None, formCode: 'CE' = None, lotNumberText: 'ST' = None, capacityQuantity: 'PQ' = None, capTypeCode: 'CE' = None, asManufacturedProduct: List_['COCT_MT230100UV.ManufacturedProduct'] = None, asSuperContent: 'COCT_MT230100UV.SuperContent' = None, subContent: 'COCT_MT230100UV.SubContent' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = "hl7v3"
        self.formCode = formCode
        self.formCode_nsprefix_ = "hl7v3"
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = "hl7v3"
        self.capacityQuantity = capacityQuantity
        self.capacityQuantity_nsprefix_ = "hl7v3"
        self.capTypeCode = capTypeCode
        self.capTypeCode_nsprefix_ = "hl7v3"
        if asManufacturedProduct is None:
            self.asManufacturedProduct = []
        else:
            self.asManufacturedProduct = asManufacturedProduct
        self.asManufacturedProduct_nsprefix_ = "pharm"
        self.asSuperContent = asSuperContent
        self.asSuperContent_nsprefix_ = "pharm"
        self.subContent = subContent
        self.subContent_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_PackagedMedicine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_PackagedMedicine.subclass:
            return COCT_MT230100UV_PackagedMedicine.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_PackagedMedicine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_formCode(self):
        return self.formCode
    def set_formCode(self, formCode):
        self.formCode = formCode
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_capacityQuantity(self):
        return self.capacityQuantity
    def set_capacityQuantity(self, capacityQuantity):
        self.capacityQuantity = capacityQuantity
    def get_capTypeCode(self):
        return self.capTypeCode
    def set_capTypeCode(self, capTypeCode):
        self.capTypeCode = capTypeCode
    def get_asManufacturedProduct(self):
        return self.asManufacturedProduct
    def set_asManufacturedProduct(self, asManufacturedProduct):
        self.asManufacturedProduct = asManufacturedProduct
    def add_asManufacturedProduct(self, value):
        self.asManufacturedProduct.append(value)
    def insert_asManufacturedProduct_at(self, index, value):
        self.asManufacturedProduct.insert(index, value)
    def replace_asManufacturedProduct_at(self, index, value):
        self.asManufacturedProduct[index] = value
    def get_asSuperContent(self):
        return self.asSuperContent
    def set_asSuperContent(self, asSuperContent):
        self.asSuperContent = asSuperContent
    def get_subContent(self):
        return self.subContent
    def set_subContent(self, subContent):
        self.subContent = subContent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassContainer(self, value):
        # Validate type hl7v3:EntityClassContainer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CONT', 'HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassContainer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassContainer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassContainer_patterns_, ))
    validate_EntityClassContainer_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type hl7v3:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.name or
            self.formCode is not None or
            self.lotNumberText is not None or
            self.capacityQuantity is not None or
            self.capTypeCode is not None or
            self.asManufacturedProduct or
            self.asSuperContent is not None or
            self.subContent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.PackagedMedicine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.PackagedMedicine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.PackagedMedicine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.PackagedMedicine')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.PackagedMedicine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.PackagedMedicine'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.PackagedMedicine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.formCode is not None:
            namespaceprefix_ = self.formCode_nsprefix_ + ':' if (UseCapturedNS_ and self.formCode_nsprefix_) else ''
            self.formCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formCode', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
        if self.capacityQuantity is not None:
            namespaceprefix_ = self.capacityQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.capacityQuantity_nsprefix_) else ''
            self.capacityQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='capacityQuantity', pretty_print=pretty_print)
        if self.capTypeCode is not None:
            namespaceprefix_ = self.capTypeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.capTypeCode_nsprefix_) else ''
            self.capTypeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='capTypeCode', pretty_print=pretty_print)
        for asManufacturedProduct_ in self.asManufacturedProduct:
            namespaceprefix_ = self.asManufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.asManufacturedProduct_nsprefix_) else ''
            asManufacturedProduct_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asManufacturedProduct', pretty_print=pretty_print)
        if self.asSuperContent is not None:
            namespaceprefix_ = self.asSuperContent_nsprefix_ + ':' if (UseCapturedNS_ and self.asSuperContent_nsprefix_) else ''
            self.asSuperContent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asSuperContent', pretty_print=pretty_print)
        if self.subContent is not None:
            namespaceprefix_ = self.subContent_nsprefix_ + ':' if (UseCapturedNS_ and self.subContent_nsprefix_) else ''
            self.subContent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subContent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassContainer(self.classCode)    # validate type EntityClassContainer
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            obj_ = TN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'formCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.formCode = obj_
            obj_.original_tagname_ = 'formCode'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
        elif nodeName_ == 'capacityQuantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.capacityQuantity = obj_
            obj_.original_tagname_ = 'capacityQuantity'
        elif nodeName_ == 'capTypeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.capTypeCode = obj_
            obj_.original_tagname_ = 'capTypeCode'
        elif nodeName_ == 'asManufacturedProduct':
            obj_ = COCT_MT230100UV_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asManufacturedProduct.append(obj_)
            obj_.original_tagname_ = 'asManufacturedProduct'
        elif nodeName_ == 'asSuperContent':
            obj_ = COCT_MT230100UV_SuperContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asSuperContent = obj_
            obj_.original_tagname_ = 'asSuperContent'
        elif nodeName_ == 'subContent':
            obj_ = COCT_MT230100UV_SubContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subContent = obj_
            obj_.original_tagname_ = 'subContent'
# end class COCT_MT230100UV_PackagedMedicine


class COCT_MT230100UV_Part(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassPart' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, partMedicine: 'COCT_MT230100UV.Medicine' = None, subjectOf: List_['COCT_MT230100UV.Subject4'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.partMedicine = partMedicine
        self.partMedicine_nsprefix_ = "pharm"
        if subjectOf is None:
            self.subjectOf = []
        else:
            self.subjectOf = subjectOf
        self.subjectOf_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Part)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Part.subclass:
            return COCT_MT230100UV_Part.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Part(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_partMedicine(self):
        return self.partMedicine
    def set_partMedicine(self, partMedicine):
        self.partMedicine = partMedicine
    def get_subjectOf(self):
        return self.subjectOf
    def set_subjectOf(self, subjectOf):
        self.subjectOf = subjectOf
    def add_subjectOf(self, value):
        self.subjectOf.append(value)
    def insert_subjectOf_at(self, index, value):
        self.subjectOf.insert(index, value)
    def replace_subjectOf_at(self, index, value):
        self.subjectOf[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassPart(self, value):
        # Validate type hl7v3:RoleClassPart, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PART', 'ACTM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassPart' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassPart_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassPart_patterns_, ))
    validate_RoleClassPart_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.partMedicine is not None or
            self.subjectOf
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Part', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Part')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Part':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Part')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Part', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Part'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Part', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.partMedicine is not None:
            namespaceprefix_ = self.partMedicine_nsprefix_ + ':' if (UseCapturedNS_ and self.partMedicine_nsprefix_) else ''
            self.partMedicine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partMedicine', pretty_print=pretty_print)
        for subjectOf_ in self.subjectOf:
            namespaceprefix_ = self.subjectOf_nsprefix_ + ':' if (UseCapturedNS_ and self.subjectOf_nsprefix_) else ''
            subjectOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subjectOf', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassPart(self.classCode)    # validate type RoleClassPart
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'partMedicine':
            obj_ = COCT_MT230100UV_Medicine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partMedicine = obj_
            obj_.original_tagname_ = 'partMedicine'
        elif nodeName_ == 'subjectOf':
            obj_ = COCT_MT230100UV_Subject4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subjectOf.append(obj_)
            obj_.original_tagname_ = 'subjectOf'
# end class COCT_MT230100UV_Part


class COCT_MT230100UV_Policy(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_ActClassRoot' = None, moodCode: 'hl7v3_ActMoodDefinition' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CD' = None, text: 'ED' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.text = text
        self.text_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Policy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Policy.subclass:
            return COCT_MT230100UV_Policy.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Policy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type hl7v3:ActClassRoot, a restriction on cs.
        pass
    def validate_ActMoodDefinition(self, value):
        # Validate type hl7v3:ActMoodDefinition, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActMoodDefinition' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActMoodDefinition_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActMoodDefinition_patterns_, ))
    validate_ActMoodDefinition_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Policy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Policy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Policy':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Policy')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Policy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Policy'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT230100UV.Policy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_ActMoodDefinition(self.moodCode)    # validate type ActMoodDefinition
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class COCT_MT230100UV_Policy


class COCT_MT230100UV_RelatedManufacturer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassAssignedEntity' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: List_['II'] = None, representedManufacturer: 'COCT_MT230100UV.Manufacturer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.representedManufacturer = representedManufacturer
        self.representedManufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_RelatedManufacturer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_RelatedManufacturer.subclass:
            return COCT_MT230100UV_RelatedManufacturer.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_RelatedManufacturer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_representedManufacturer(self):
        return self.representedManufacturer
    def set_representedManufacturer(self, representedManufacturer):
        self.representedManufacturer = representedManufacturer
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type hl7v3:RoleClassAssignedEntity, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.representedManufacturer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.RelatedManufacturer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.RelatedManufacturer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.RelatedManufacturer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.RelatedManufacturer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.RelatedManufacturer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.RelatedManufacturer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.RelatedManufacturer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.representedManufacturer is not None:
            namespaceprefix_ = self.representedManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.representedManufacturer_nsprefix_) else ''
            self.representedManufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedManufacturer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'representedManufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedManufacturer = obj_
            obj_.original_tagname_ = 'representedManufacturer'
# end class COCT_MT230100UV_RelatedManufacturer


class COCT_MT230100UV_Role(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassRoot' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, playingManufacturer: 'COCT_MT230100UV.Manufacturer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.playingManufacturer = playingManufacturer
        self.playingManufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Role)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Role.subclass:
            return COCT_MT230100UV_Role.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Role(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_playingManufacturer(self):
        return self.playingManufacturer
    def set_playingManufacturer(self, playingManufacturer):
        self.playingManufacturer = playingManufacturer
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassRoot(self, value):
        # Validate type hl7v3:RoleClassRoot, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.playingManufacturer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Role', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Role')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Role':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Role')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Role', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Role'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Role', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.playingManufacturer is not None:
            namespaceprefix_ = self.playingManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.playingManufacturer_nsprefix_) else ''
            self.playingManufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingManufacturer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassRoot(self.classCode)    # validate type RoleClassRoot
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'playingManufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingManufacturer = obj_
            obj_.original_tagname_ = 'playingManufacturer'
# end class COCT_MT230100UV_Role


class COCT_MT230100UV_SpecializedKind(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassIsSpeciesEntity' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CE' = None, generalizedMedicineClass: 'COCT_MT230100UV.MedicineClass' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.generalizedMedicineClass = generalizedMedicineClass
        self.generalizedMedicineClass_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_SpecializedKind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_SpecializedKind.subclass:
            return COCT_MT230100UV_SpecializedKind.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_SpecializedKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_generalizedMedicineClass(self):
        return self.generalizedMedicineClass
    def set_generalizedMedicineClass(self, generalizedMedicineClass):
        self.generalizedMedicineClass = generalizedMedicineClass
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassIsSpeciesEntity(self, value):
        # Validate type hl7v3:RoleClassIsSpeciesEntity, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GEN', 'GRIC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassIsSpeciesEntity' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassIsSpeciesEntity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassIsSpeciesEntity_patterns_, ))
    validate_RoleClassIsSpeciesEntity_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.generalizedMedicineClass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SpecializedKind', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.SpecializedKind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.SpecializedKind':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.SpecializedKind')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.SpecializedKind', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.SpecializedKind'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SpecializedKind', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.generalizedMedicineClass is not None:
            namespaceprefix_ = self.generalizedMedicineClass_nsprefix_ + ':' if (UseCapturedNS_ and self.generalizedMedicineClass_nsprefix_) else ''
            self.generalizedMedicineClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generalizedMedicineClass', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassIsSpeciesEntity(self.classCode)    # validate type RoleClassIsSpeciesEntity
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'generalizedMedicineClass':
            obj_ = COCT_MT230100UV_MedicineClass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generalizedMedicineClass = obj_
            obj_.original_tagname_ = 'generalizedMedicineClass'
# end class COCT_MT230100UV_SpecializedKind


class COCT_MT230100UV_SubContent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassContent' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, containedPackagedMedicine: 'COCT_MT230100UV.PackagedMedicine' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.containedPackagedMedicine = containedPackagedMedicine
        self.containedPackagedMedicine_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_SubContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_SubContent.subclass:
            return COCT_MT230100UV_SubContent.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_SubContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_containedPackagedMedicine(self):
        return self.containedPackagedMedicine
    def set_containedPackagedMedicine(self, containedPackagedMedicine):
        self.containedPackagedMedicine = containedPackagedMedicine
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassContent(self, value):
        # Validate type hl7v3:RoleClassContent, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CONT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassContent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassContent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassContent_patterns_, ))
    validate_RoleClassContent_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.containedPackagedMedicine is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubContent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.SubContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.SubContent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.SubContent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.SubContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.SubContent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.containedPackagedMedicine is not None:
            namespaceprefix_ = self.containedPackagedMedicine_nsprefix_ + ':' if (UseCapturedNS_ and self.containedPackagedMedicine_nsprefix_) else ''
            self.containedPackagedMedicine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='containedPackagedMedicine', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassContent(self.classCode)    # validate type RoleClassContent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'containedPackagedMedicine':
            obj_ = COCT_MT230100UV_PackagedMedicine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.containedPackagedMedicine = obj_
            obj_.original_tagname_ = 'containedPackagedMedicine'
# end class COCT_MT230100UV_SubContent


class COCT_MT230100UV_SubIngredient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassIngredientEntity' = None, negationInd: 'hl7v3_bl' = 'false', realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, ingredient: 'COCT_MT230100UV.Substance' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.ingredient = ingredient
        self.ingredient_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_SubIngredient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_SubIngredient.subclass:
            return COCT_MT230100UV_SubIngredient.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_SubIngredient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_ingredient(self):
        return self.ingredient
    def set_ingredient(self, ingredient):
        self.ingredient = ingredient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassIngredientEntity(self, value):
        # Validate type hl7v3:RoleClassIngredientEntity, a restriction on cs.
        pass
    def validate_bl(self, value):
        # Validate type hl7v3:bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.ingredient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubIngredient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.SubIngredient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.SubIngredient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.SubIngredient')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.SubIngredient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.SubIngredient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.negationInd and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubIngredient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.ingredient is not None:
            namespaceprefix_ = self.ingredient_nsprefix_ + ':' if (UseCapturedNS_ and self.ingredient_nsprefix_) else ''
            self.ingredient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ingredient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassIngredientEntity(self.classCode)    # validate type RoleClassIngredientEntity
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'ingredient':
            obj_ = COCT_MT230100UV_Substance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ingredient = obj_
            obj_.original_tagname_ = 'ingredient'
# end class COCT_MT230100UV_SubIngredient


class COCT_MT230100UV_Subject1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, approval: 'COCT_MT230100UV.Approval' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.approval = approval
        self.approval_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject1.subclass:
            return COCT_MT230100UV_Subject1.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_approval(self):
        return self.approval
    def set_approval(self, approval):
        self.approval = approval
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.approval is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.approval is not None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            self.approval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approval', pretty_print=pretty_print)
        if self.approval is None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapproval xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'approval':
            obj_ = COCT_MT230100UV_Approval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approval = obj_
            obj_.original_tagname_ = 'approval'
# end class COCT_MT230100UV_Subject1


class COCT_MT230100UV_Subject11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, approval: 'COCT_MT230100UV.Approval' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.approval = approval
        self.approval_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject11.subclass:
            return COCT_MT230100UV_Subject11.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_approval(self):
        return self.approval
    def set_approval(self, approval):
        self.approval = approval
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.approval is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject11')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject11'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.approval is not None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            self.approval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approval', pretty_print=pretty_print)
        if self.approval is None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapproval xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'approval':
            obj_ = COCT_MT230100UV_Approval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approval = obj_
            obj_.original_tagname_ = 'approval'
# end class COCT_MT230100UV_Subject11


class COCT_MT230100UV_Subject14(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, policy: 'COCT_MT230100UV.Policy' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.policy = policy
        self.policy_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject14.subclass:
            return COCT_MT230100UV_Subject14.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.policy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject14')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject14'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.policy is not None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            self.policy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='policy', pretty_print=pretty_print)
        if self.policy is None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'policy':
            obj_ = COCT_MT230100UV_Policy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.policy = obj_
            obj_.original_tagname_ = 'policy'
# end class COCT_MT230100UV_Subject14


class COCT_MT230100UV_Subject15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, policy: 'COCT_MT230100UV.Policy' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.policy = policy
        self.policy_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject15.subclass:
            return COCT_MT230100UV_Subject15.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.policy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject15')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject15'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.policy is not None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            self.policy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='policy', pretty_print=pretty_print)
        if self.policy is None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'policy':
            obj_ = COCT_MT230100UV_Policy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.policy = obj_
            obj_.original_tagname_ = 'policy'
# end class COCT_MT230100UV_Subject15


class COCT_MT230100UV_Subject16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, approval: 'COCT_MT230100UV.Approval' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.approval = approval
        self.approval_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject16.subclass:
            return COCT_MT230100UV_Subject16.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_approval(self):
        return self.approval
    def set_approval(self, approval):
        self.approval = approval
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.approval is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject16'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.approval is not None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            self.approval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approval', pretty_print=pretty_print)
        if self.approval is None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapproval xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'approval':
            obj_ = COCT_MT230100UV_Approval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approval = obj_
            obj_.original_tagname_ = 'approval'
# end class COCT_MT230100UV_Subject16


class COCT_MT230100UV_Subject2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, policy: 'COCT_MT230100UV.Policy' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.policy = policy
        self.policy_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject2.subclass:
            return COCT_MT230100UV_Subject2.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.policy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.policy is not None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            self.policy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='policy', pretty_print=pretty_print)
        if self.policy is None:
            namespaceprefix_ = self.policy_nsprefix_ + ':' if (UseCapturedNS_ and self.policy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'policy':
            obj_ = COCT_MT230100UV_Policy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.policy = obj_
            obj_.original_tagname_ = 'policy'
# end class COCT_MT230100UV_Subject2


class COCT_MT230100UV_Subject22(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, characteristic: 'COCT_MT230100UV.Characteristic' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.characteristic = characteristic
        self.characteristic_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject22.subclass:
            return COCT_MT230100UV_Subject22.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_characteristic(self):
        return self.characteristic
    def set_characteristic(self, characteristic):
        self.characteristic = characteristic
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.characteristic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject22')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject22'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.characteristic is not None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            self.characteristic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='characteristic', pretty_print=pretty_print)
        if self.characteristic is None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scharacteristic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'characteristic':
            obj_ = COCT_MT230100UV_Characteristic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristic = obj_
            obj_.original_tagname_ = 'characteristic'
# end class COCT_MT230100UV_Subject22


class COCT_MT230100UV_Subject25(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, characteristic: 'COCT_MT230100UV.Characteristic' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.characteristic = characteristic
        self.characteristic_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject25.subclass:
            return COCT_MT230100UV_Subject25.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_characteristic(self):
        return self.characteristic
    def set_characteristic(self, characteristic):
        self.characteristic = characteristic
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.characteristic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject25')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject25'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.characteristic is not None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            self.characteristic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='characteristic', pretty_print=pretty_print)
        if self.characteristic is None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scharacteristic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'characteristic':
            obj_ = COCT_MT230100UV_Characteristic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristic = obj_
            obj_.original_tagname_ = 'characteristic'
# end class COCT_MT230100UV_Subject25


class COCT_MT230100UV_Subject3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, observationGoal: 'COCT_MT230100UV.ObservationGoal' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.observationGoal = observationGoal
        self.observationGoal_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject3.subclass:
            return COCT_MT230100UV_Subject3.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_observationGoal(self):
        return self.observationGoal
    def set_observationGoal(self, observationGoal):
        self.observationGoal = observationGoal
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.observationGoal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject3'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.observationGoal is not None:
            namespaceprefix_ = self.observationGoal_nsprefix_ + ':' if (UseCapturedNS_ and self.observationGoal_nsprefix_) else ''
            self.observationGoal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationGoal', pretty_print=pretty_print)
        if self.observationGoal is None:
            namespaceprefix_ = self.observationGoal_nsprefix_ + ':' if (UseCapturedNS_ and self.observationGoal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationGoal xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'observationGoal':
            obj_ = COCT_MT230100UV_ObservationGoal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationGoal = obj_
            obj_.original_tagname_ = 'observationGoal'
# end class COCT_MT230100UV_Subject3


class COCT_MT230100UV_Subject4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationTargetSubject' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, characteristic: 'COCT_MT230100UV.Characteristic' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.characteristic = characteristic
        self.characteristic_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject4.subclass:
            return COCT_MT230100UV_Subject4.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_characteristic(self):
        return self.characteristic
    def set_characteristic(self, characteristic):
        self.characteristic = characteristic
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type hl7v3:ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.characteristic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject4'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.characteristic is not None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            self.characteristic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='characteristic', pretty_print=pretty_print)
        if self.characteristic is None:
            namespaceprefix_ = self.characteristic_nsprefix_ + ':' if (UseCapturedNS_ and self.characteristic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scharacteristic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'characteristic':
            obj_ = COCT_MT230100UV_Characteristic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.characteristic = obj_
            obj_.original_tagname_ = 'characteristic'
# end class COCT_MT230100UV_Subject4


class COCT_MT230100UV_Subject7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, typeCode: 'hl7v3_ParticipationType' = 'SBJ', realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, valuedItem: 'COCT_MT440001UV09.ValuedItem' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.valuedItem = valuedItem
        self.valuedItem_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Subject7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Subject7.subclass:
            return COCT_MT230100UV_Subject7.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Subject7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_valuedItem(self):
        return self.valuedItem
    def set_valuedItem(self, valuedItem):
        self.valuedItem = valuedItem
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type hl7v3:ParticipationType, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.valuedItem is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Subject7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Subject7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Subject7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Subject7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Subject7'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Subject7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.valuedItem is not None:
            namespaceprefix_ = self.valuedItem_nsprefix_ + ':' if (UseCapturedNS_ and self.valuedItem_nsprefix_) else ''
            self.valuedItem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='valuedItem', pretty_print=pretty_print)
        if self.valuedItem is None:
            namespaceprefix_ = self.valuedItem_nsprefix_ + ':' if (UseCapturedNS_ and self.valuedItem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluedItem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'valuedItem':
            obj_ = COCT_MT440001UV09_ValuedItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.valuedItem = obj_
            obj_.original_tagname_ = 'valuedItem'
# end class COCT_MT230100UV_Subject7


class COCT_MT230100UV_Substance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_EntityClassManufacturedMaterial' = None, determinerCode: 'hl7v3_EntityDeterminer' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, code: 'CE' = None, name: List_['TN'] = None, desc: 'ED' = None, lotNumberText: 'ST' = None, asSubstanceManufacturer: List_['COCT_MT230100UV.SubstanceManufacturer'] = None, subIngredient: List_['COCT_MT230100UV.SubIngredient'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = "hl7v3"
        self.desc = desc
        self.desc_nsprefix_ = "hl7v3"
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = "hl7v3"
        if asSubstanceManufacturer is None:
            self.asSubstanceManufacturer = []
        else:
            self.asSubstanceManufacturer = asSubstanceManufacturer
        self.asSubstanceManufacturer_nsprefix_ = "pharm"
        if subIngredient is None:
            self.subIngredient = []
        else:
            self.subIngredient = subIngredient
        self.subIngredient_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_Substance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_Substance.subclass:
            return COCT_MT230100UV_Substance.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_Substance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_asSubstanceManufacturer(self):
        return self.asSubstanceManufacturer
    def set_asSubstanceManufacturer(self, asSubstanceManufacturer):
        self.asSubstanceManufacturer = asSubstanceManufacturer
    def add_asSubstanceManufacturer(self, value):
        self.asSubstanceManufacturer.append(value)
    def insert_asSubstanceManufacturer_at(self, index, value):
        self.asSubstanceManufacturer.insert(index, value)
    def replace_asSubstanceManufacturer_at(self, index, value):
        self.asSubstanceManufacturer[index] = value
    def get_subIngredient(self):
        return self.subIngredient
    def set_subIngredient(self, subIngredient):
        self.subIngredient = subIngredient
    def add_subIngredient(self, value):
        self.subIngredient.append(value)
    def insert_subIngredient_at(self, index, value):
        self.subIngredient.insert(index, value)
    def replace_subIngredient_at(self, index, value):
        self.subIngredient[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type hl7v3:EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type hl7v3:EntityDeterminer, a restriction on cs.
        pass
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name or
            self.desc is not None or
            self.lotNumberText is not None or
            self.asSubstanceManufacturer or
            self.subIngredient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Substance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.Substance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.Substance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.Substance')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.Substance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.Substance'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.Substance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
        for asSubstanceManufacturer_ in self.asSubstanceManufacturer:
            namespaceprefix_ = self.asSubstanceManufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.asSubstanceManufacturer_nsprefix_) else ''
            asSubstanceManufacturer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asSubstanceManufacturer', pretty_print=pretty_print)
        for subIngredient_ in self.subIngredient:
            namespaceprefix_ = self.subIngredient_nsprefix_ + ':' if (UseCapturedNS_ and self.subIngredient_nsprefix_) else ''
            subIngredient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subIngredient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            obj_ = TN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
        elif nodeName_ == 'asSubstanceManufacturer':
            obj_ = COCT_MT230100UV_SubstanceManufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asSubstanceManufacturer.append(obj_)
            obj_.original_tagname_ = 'asSubstanceManufacturer'
        elif nodeName_ == 'subIngredient':
            obj_ = COCT_MT230100UV_SubIngredient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subIngredient.append(obj_)
            obj_.original_tagname_ = 'subIngredient'
# end class COCT_MT230100UV_Substance


class COCT_MT230100UV_SubstanceManufacturer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassManufacturedProduct' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, manufacturer: 'COCT_MT230100UV.Manufacturer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.manufacturer = manufacturer
        self.manufacturer_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_SubstanceManufacturer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_SubstanceManufacturer.subclass:
            return COCT_MT230100UV_SubstanceManufacturer.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_SubstanceManufacturer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturer(self):
        return self.manufacturer
    def set_manufacturer(self, manufacturer):
        self.manufacturer = manufacturer
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassManufacturedProduct(self, value):
        # Validate type hl7v3:RoleClassManufacturedProduct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANU', 'THER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassManufacturedProduct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassManufacturedProduct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassManufacturedProduct_patterns_, ))
    validate_RoleClassManufacturedProduct_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubstanceManufacturer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.SubstanceManufacturer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.SubstanceManufacturer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.SubstanceManufacturer')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.SubstanceManufacturer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.SubstanceManufacturer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SubstanceManufacturer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturer is not None:
            namespaceprefix_ = self.manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturer_nsprefix_) else ''
            self.manufacturer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturer', pretty_print=pretty_print)
        if self.manufacturer is None:
            namespaceprefix_ = self.manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanufacturer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassManufacturedProduct(self.classCode)    # validate type RoleClassManufacturedProduct
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturer':
            obj_ = COCT_MT230100UV_Manufacturer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturer = obj_
            obj_.original_tagname_ = 'manufacturer'
# end class COCT_MT230100UV_SubstanceManufacturer


class COCT_MT230100UV_SuperContent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor: 'hl7v3_NullFlavor' = None, classCode: 'hl7v3_RoleClassContent' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, quantity: 'RTO_QTY_QTY' = None, containerPackagedMedicine: 'COCT_MT230100UV.PackagedMedicine' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.quantity = quantity
        self.quantity_nsprefix_ = "hl7v3"
        self.containerPackagedMedicine = containerPackagedMedicine
        self.containerPackagedMedicine_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_SuperContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_SuperContent.subclass:
            return COCT_MT230100UV_SuperContent.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_SuperContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_containerPackagedMedicine(self):
        return self.containerPackagedMedicine
    def set_containerPackagedMedicine(self, containerPackagedMedicine):
        self.containerPackagedMedicine = containerPackagedMedicine
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type hl7v3:NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassContent(self, value):
        # Validate type hl7v3:RoleClassContent, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CONT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassContent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassContent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassContent_patterns_, ))
    validate_RoleClassContent_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.quantity is not None or
            self.containerPackagedMedicine is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SuperContent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.SuperContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.SuperContent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.SuperContent')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.SuperContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.SuperContent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.SuperContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.containerPackagedMedicine is not None:
            namespaceprefix_ = self.containerPackagedMedicine_nsprefix_ + ':' if (UseCapturedNS_ and self.containerPackagedMedicine_nsprefix_) else ''
            self.containerPackagedMedicine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='containerPackagedMedicine', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassContent(self.classCode)    # validate type RoleClassContent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, RTO_QTY_QTY)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'containerPackagedMedicine':
            obj_ = COCT_MT230100UV_PackagedMedicine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.containerPackagedMedicine = obj_
            obj_.original_tagname_ = 'containerPackagedMedicine'
# end class COCT_MT230100UV_SuperContent


class COCT_MT230100UV_TerritorialAuthority(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7v3_RoleClassTerritoryOfAuthority' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, territory: 'COCT_MT230100UV.Agency' = None, governingCountry: 'COCT_MT230100UV.Country' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        self.territory = territory
        self.territory_nsprefix_ = "pharm"
        self.governingCountry = governingCountry
        self.governingCountry_nsprefix_ = "pharm"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT230100UV_TerritorialAuthority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT230100UV_TerritorialAuthority.subclass:
            return COCT_MT230100UV_TerritorialAuthority.subclass(*args_, **kwargs_)
        else:
            return COCT_MT230100UV_TerritorialAuthority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_territory(self):
        return self.territory
    def set_territory(self, territory):
        self.territory = territory
    def get_governingCountry(self):
        return self.governingCountry
    def set_governingCountry(self, governingCountry):
        self.governingCountry = governingCountry
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_RoleClassTerritoryOfAuthority(self, value):
        # Validate type hl7v3:RoleClassTerritoryOfAuthority, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['TERR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassTerritoryOfAuthority' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassTerritoryOfAuthority_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassTerritoryOfAuthority_patterns_, ))
    validate_RoleClassTerritoryOfAuthority_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.territory is not None or
            self.governingCountry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.TerritorialAuthority', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT230100UV.TerritorialAuthority')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT230100UV.TerritorialAuthority':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT230100UV.TerritorialAuthority')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT230100UV.TerritorialAuthority', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT230100UV.TerritorialAuthority'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication" ', name_='COCT_MT230100UV.TerritorialAuthority', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.territory is not None:
            namespaceprefix_ = self.territory_nsprefix_ + ':' if (UseCapturedNS_ and self.territory_nsprefix_) else ''
            self.territory.export(outfile, level, namespaceprefix_, namespacedef_='', name_='territory', pretty_print=pretty_print)
        if self.governingCountry is not None:
            namespaceprefix_ = self.governingCountry_nsprefix_ + ':' if (UseCapturedNS_ and self.governingCountry_nsprefix_) else ''
            self.governingCountry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='governingCountry', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassTerritoryOfAuthority(self.classCode)    # validate type RoleClassTerritoryOfAuthority
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'territory':
            obj_ = COCT_MT230100UV_Agency.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.territory = obj_
            obj_.original_tagname_ = 'territory'
        elif nodeName_ == 'governingCountry':
            obj_ = COCT_MT230100UV_Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.governingCountry = obj_
            obj_.original_tagname_ = 'governingCountry'
# end class COCT_MT230100UV_TerritorialAuthority


class COCT_MT440001UV09_ValuedItem(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classCode: 'hl7v3_ActClassInvoiceElement' = None, moodCode: 'hl7v3_x_ActMoodDefEvn' = None, realmCode: List_['CS'] = None, typeId: 'all.InfrastructureRoot.typeId' = None, templateId: List_['all.InfrastructureRoot.templateId'] = None, id: List_['II'] = None, code: 'CD' = None, effectiveTime: 'IVL_TS' = None, unitQuantity: 'RTO_PQ_PQ' = None, unitPriceAmt: 'RTO_MO_PQ' = None, netAmt: 'MO' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = "hl7v3"
        self.typeId = typeId
        self.typeId_nsprefix_ = "hl7v3"
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = "hl7v3"
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = "hl7v3"
        self.code = code
        self.code_nsprefix_ = "hl7v3"
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = "hl7v3"
        self.unitQuantity = unitQuantity
        self.unitQuantity_nsprefix_ = "hl7v3"
        self.unitPriceAmt = unitPriceAmt
        self.unitPriceAmt_nsprefix_ = "hl7v3"
        self.netAmt = netAmt
        self.netAmt_nsprefix_ = "hl7v3"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COCT_MT440001UV09_ValuedItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COCT_MT440001UV09_ValuedItem.subclass:
            return COCT_MT440001UV09_ValuedItem.subclass(*args_, **kwargs_)
        else:
            return COCT_MT440001UV09_ValuedItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_unitQuantity(self):
        return self.unitQuantity
    def set_unitQuantity(self, unitQuantity):
        self.unitQuantity = unitQuantity
    def get_unitPriceAmt(self):
        return self.unitPriceAmt
    def set_unitPriceAmt(self, unitPriceAmt):
        self.unitPriceAmt = unitPriceAmt
    def get_netAmt(self):
        return self.netAmt
    def set_netAmt(self, netAmt):
        self.netAmt = netAmt
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_ActClassInvoiceElement(self, value):
        # Validate type hl7v3:ActClassInvoiceElement, a restriction on hl7v3:cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INVE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassInvoiceElement' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassInvoiceElement_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassInvoiceElement_patterns_, ))
    validate_ActClassInvoiceElement_patterns_ = [['^([^\\s]+)$']]
    def validate_x_ActMoodDefEvn(self, value):
        # Validate type hl7v3:x_ActMoodDefEvn, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEF', 'EVN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActMoodDefEvn' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActMoodDefEvn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActMoodDefEvn_patterns_, ))
    validate_x_ActMoodDefEvn_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.unitQuantity is not None or
            self.unitPriceAmt is not None or
            self.netAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT440001UV09.ValuedItem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COCT_MT440001UV09.ValuedItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COCT_MT440001UV09.ValuedItem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COCT_MT440001UV09.ValuedItem')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COCT_MT440001UV09.ValuedItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='pharm:', name_='COCT_MT440001UV09.ValuedItem'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='pharm:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3"  xmlns:pharm="urn:ihe:pharm:medication"', name_='COCT_MT440001UV09.ValuedItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.unitQuantity is not None:
            namespaceprefix_ = self.unitQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.unitQuantity_nsprefix_) else ''
            self.unitQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitQuantity', pretty_print=pretty_print)
        if self.unitPriceAmt is not None:
            namespaceprefix_ = self.unitPriceAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.unitPriceAmt_nsprefix_) else ''
            self.unitPriceAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitPriceAmt', pretty_print=pretty_print)
        if self.netAmt is not None:
            namespaceprefix_ = self.netAmt_nsprefix_ + ':' if (UseCapturedNS_ and self.netAmt_nsprefix_) else ''
            self.netAmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='netAmt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassInvoiceElement(self.classCode)    # validate type ActClassInvoiceElement
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_ActMoodDefEvn(self.moodCode)    # validate type x_ActMoodDefEvn
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = all_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = all_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'unitQuantity':
            obj_ = RTO_PQ_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unitQuantity = obj_
            obj_.original_tagname_ = 'unitQuantity'
        elif nodeName_ == 'unitPriceAmt':
            obj_ = RTO_MO_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unitPriceAmt = obj_
            obj_.original_tagname_ = 'unitPriceAmt'
        elif nodeName_ == 'netAmt':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.netAmt = obj_
            obj_.original_tagname_ = 'netAmt'
# end class COCT_MT440001UV09_ValuedItem


class RTO(RTO_QTY_QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RTO_QTY_QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'QTY' = None, denominator: 'QTY' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO"), self).__init__(nullFlavor, numerator, denominator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO.subclass:
            return RTO.subclass(*args_, **kwargs_)
        else:
            return RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO'):
        super(RTO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', fromsubclass_=False, pretty_print=True):
        super(RTO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RTO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RTO


class TS(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TS"), self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS.subclass:
            return TS.subclass(*args_, **kwargs_)
        else:
            return TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ts(self, value):
        # Validate type ts, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^([0-9]{1,8}|([0-9]{9,14}|[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TS'):
        super(TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', fromsubclass_=False, pretty_print=True):
        super(TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TS


class UVP_TS(TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, probability: 'probability' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UVP_TS"), self).__init__(nullFlavor, value,  **kwargs_)
        self.probability = _cast(float, probability)
        self.probability_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UVP_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UVP_TS.subclass:
            return UVP_TS.subclass(*args_, **kwargs_)
        else:
            return UVP_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_probability(self):
        return self.probability
    def set_probability(self, probability):
        self.probability = probability
    def validate_probability(self, value):
        # Validate type probability, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(UVP_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UVP_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UVP_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UVP_TS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UVP_TS'):
        super(UVP_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            outfile.write(' probability="%s"' % self.gds_format_double(self.probability, input_name='probability'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', fromsubclass_=False, pretty_print=True):
        super(UVP_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('probability', node)
        if value is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            value = self.gds_parse_double(value, node, 'probability')
            self.probability = value
            self.validate_probability(self.probability)    # validate type probability
        super(UVP_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(UVP_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class UVP_TS


class RTO_MO_PQ(QTY):
    """numerator --  The quantity that is being divided in the ratio. The
    default is the integer number 1 (one).
    denominator --  The quantity that devides the numerator in the ratio.
    The default is the integer number 1 (one). The denominator must not
    be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'MO' = None, denominator: 'PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_MO_PQ"), self).__init__(nullFlavor,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_MO_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_MO_PQ.subclass:
            return RTO_MO_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_MO_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            super(RTO_MO_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_MO_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_MO_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_MO_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO_MO_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_MO_PQ'):
        super(RTO_MO_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_MO_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_MO_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RTO_MO_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numerator = obj_
            obj_.original_tagname_ = 'numerator'
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.denominator = obj_
            obj_.original_tagname_ = 'denominator'
        super(RTO_MO_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_MO_PQ


class RTO_PQ_PQ(QTY):
    """numerator --  The quantity that is being divided in the ratio. The
    default is the integer number 1 (one).
    denominator --  The quantity that devides the numerator in the ratio.
    The default is the integer number 1 (one). The denominator must not
    be zero.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor: 'NullFlavor' = None, numerator: 'PQ' = None, denominator: 'PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RTO_PQ_PQ"), self).__init__(nullFlavor,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_PQ_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_PQ_PQ.subclass:
            return RTO_PQ_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_PQ_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def has__content(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            super(RTO_PQ_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_PQ_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_PQ_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_PQ_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO_PQ_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_PQ_PQ'):
        super(RTO_PQ_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_PQ_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_PQ_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RTO_PQ_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numerator = obj_
            obj_.original_tagname_ = 'numerator'
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.denominator = obj_
            obj_.original_tagname_ = 'denominator'
        super(RTO_PQ_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class RTO_PQ_PQ


class GLIST_PQ(ANY):
    """head --  This is the start-value of the generated list.
      
    * increment --  The difference between one value and its previous
      different value. For example, to generate the sequence (1; 4; 7; 10;
      13; ...) the increment is 3; likewise to generate the sequence (1;
      1; 4; 4; 7; 7; 10; 10; 13; 13; ...) the increment is also 3.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, period: 'int' = None, denominator: 'int' = None, head: 'PQ' = None, increment: 'PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GLIST_PQ"), self).__init__(nullFlavor,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_PQ.subclass:
            return GLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return GLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.head is not None or
            self.increment is not None or
            super(GLIST_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='GLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_PQ'):
        super(GLIST_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='GLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(GLIST_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.increment = obj_
            obj_.original_tagname_ = 'increment'
        super(GLIST_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class GLIST_PQ


class GLIST_TS(ANY):
    """head --  This is the start-value of the generated list.
      
    * increment --  The difference between one value and its previous
      different value. For example, to generate the sequence (1; 4; 7; 10;
      13; ...) the increment is 3; likewise to generate the sequence (1;
      1; 4; 4; 7; 7; 10; 10; 13; 13; ...) the increment is also 3.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, period: 'int' = None, denominator: 'int' = None, head: 'TS' = None, increment: 'PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GLIST_TS"), self).__init__(nullFlavor,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_TS.subclass:
            return GLIST_TS.subclass(*args_, **kwargs_)
        else:
            return GLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.head is not None or
            self.increment is not None or
            super(GLIST_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='GLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GLIST_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_TS'):
        super(GLIST_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='GLIST_TS', fromsubclass_=False, pretty_print=True):
        super(GLIST_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.increment = obj_
            obj_.original_tagname_ = 'increment'
        super(GLIST_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class GLIST_TS


class SLIST_TS(ANY):
    """origin --  The origin of the list item value scale, i.e., the
    physical quantity that a zero-digit in the sequence would represent.
      
    * scale --  A ratio-scale quantity that is factored out of the
      digit sequence.
    * digits --  A sequence of raw digits for the sample values. This
      is typically the raw output of an A/D converter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, origin: 'TS' = None, scale: 'PQ' = None, digits: 'integer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SLIST_TS"), self).__init__(nullFlavor,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_TS.subclass:
            return SLIST_TS.subclass(*args_, **kwargs_)
        else:
            return SLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def has__content(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            super(SLIST_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SLIST_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_TS'):
        super(SLIST_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SLIST_TS', fromsubclass_=False, pretty_print=True):
        super(SLIST_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SLIST_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'digits':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'digits')
            self.digits = value_
            self.digits_nsprefix_ = child_.prefix
            # validate type list_int
            self.validate_list_int(self.digits)
        super(SLIST_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class SLIST_TS


class SLIST_PQ(ANY):
    """origin --  The origin of the list item value scale, i.e., the
    physical quantity that a zero-digit in the sequence would represent.
      
    * scale --  A ratio-scale quantity that is factored out of the
      digit sequence.
    * digits --  A sequence of raw digits for the sample values. This
      is typically the raw output of an A/D converter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor: 'NullFlavor' = None, origin: 'PQ' = None, scale: 'PQ' = None, digits: 'integer' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SLIST_PQ"), self).__init__(nullFlavor,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_PQ.subclass:
            return SLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return SLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def has__content(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            super(SLIST_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_PQ'):
        super(SLIST_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(SLIST_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SLIST_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'digits':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'digits')
            self.digits = value_
            self.digits_nsprefix_ = child_.prefix
            # validate type list_int
            self.validate_list_int(self.digits)
        super(SLIST_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class SLIST_PQ


class BXIT_CD(CD):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, designation: List_['ST'] = None, qty: 'int' = '1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BXIT_CD"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_CD.subclass:
            return BXIT_CD.subclass(*args_, **kwargs_)
        else:
            return BXIT_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            super(BXIT_CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BXIT_CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_CD'):
        super(BXIT_CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', fromsubclass_=False, pretty_print=True):
        super(BXIT_CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BXIT_CD, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_CD


class HXIT_CE(CE):
    """validTime --  The time interval during which the given information
    was, is, or is expected to be valid. The interval can be open or
    closed, as well as infinite or undefined on either side.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: 'CR' = None, translation: List_['CD'] = None, designation: List_['ST'] = None, validTime: 'IVL_TS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HXIT_CE"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_CE.subclass:
            return HXIT_CE.subclass(*args_, **kwargs_)
        else:
            return HXIT_CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def has__content(self):
        if (
            self.validTime is not None or
            super(HXIT_CE, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='HXIT_CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HXIT_CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_CE'):
        super(HXIT_CE, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='HXIT_CE', fromsubclass_=False, pretty_print=True):
        super(HXIT_CE, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HXIT_CE, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTime = obj_
            obj_.original_tagname_ = 'validTime'
        super(HXIT_CE, self)._buildChildren(child_, node, nodeName_, True)
# end class HXIT_CE


class HXIT_PQ(PQ):
    """validTime --  The time interval during which the given information
    was, is, or is expected to be valid. The interval can be open or
    closed, as well as infinite or undefined on either side.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, validTime: 'IVL_TS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HXIT_PQ"), self).__init__(nullFlavor, value, unit, translation,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_PQ.subclass:
            return HXIT_PQ.subclass(*args_, **kwargs_)
        else:
            return HXIT_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def has__content(self):
        if (
            self.validTime is not None or
            super(HXIT_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='HXIT_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HXIT_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_PQ'):
        super(HXIT_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='HXIT_PQ', fromsubclass_=False, pretty_print=True):
        super(HXIT_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HXIT_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTime = obj_
            obj_.original_tagname_ = 'validTime'
        super(HXIT_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class HXIT_PQ


class IVXB_MO(MO):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_MO"), self).__init__(nullFlavor, value, currency,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_MO.subclass:
            return IVXB_MO.subclass(*args_, **kwargs_)
        else:
            return IVXB_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_MO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_MO'):
        super(IVXB_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', fromsubclass_=False, pretty_print=True):
        super(IVXB_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_MO


class IVXB_REAL(REAL):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_REAL"), self).__init__(nullFlavor, value,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_REAL.subclass:
            return IVXB_REAL.subclass(*args_, **kwargs_)
        else:
            return IVXB_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_REAL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_REAL'):
        super(IVXB_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', fromsubclass_=False, pretty_print=True):
        super(IVXB_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_REAL


class IVXB_INT(INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_INT"), self).__init__(nullFlavor, value,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_INT.subclass:
            return IVXB_INT.subclass(*args_, **kwargs_)
        else:
            return IVXB_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_INT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_INT'):
        super(IVXB_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', fromsubclass_=False, pretty_print=True):
        super(IVXB_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_INT


class SXCM_REAL(REAL):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_REAL"), self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_REAL.subclass:
            return SXCM_REAL.subclass(*args_, **kwargs_)
        else:
            return SXCM_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_REAL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_REAL'):
        super(SXCM_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', fromsubclass_=False, pretty_print=True):
        super(SXCM_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_REAL, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_REAL


class SXCM_INT(INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_INT"), self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_INT.subclass:
            return SXCM_INT.subclass(*args_, **kwargs_)
        else:
            return SXCM_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_INT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_INT'):
        super(SXCM_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', fromsubclass_=False, pretty_print=True):
        super(SXCM_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_INT, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_INT


class SXCM_MO(MO):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_MO"), self).__init__(nullFlavor, value, currency, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_MO.subclass:
            return SXCM_MO.subclass(*args_, **kwargs_)
        else:
            return SXCM_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_MO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_MO'):
        super(SXCM_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', fromsubclass_=False, pretty_print=True):
        super(SXCM_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_MO, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_MO


class SXCM_CD(CD):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor: 'NullFlavor' = None, code: 'cs' = None, codeSystem: 'uid' = None, codeSystemName: 'st' = None, codeSystemVersion: 'st' = None, displayName: 'st' = None, valueSet: 'hl7_oid' = None, valueSetVersion: 'hl7_st' = None, originalText: 'ED' = None, qualifier: List_['CR'] = None, translation: List_['CD'] = None, designation: List_['ST'] = None, operator: 'SetOperator' = 'I', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_CD"), self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, valueSet, valueSetVersion, originalText, qualifier, translation, designation,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_CD.subclass:
            return SXCM_CD.subclass(*args_, **kwargs_)
        else:
            return SXCM_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_CD, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_CD'):
        super(SXCM_CD, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', fromsubclass_=False, pretty_print=True):
        super(SXCM_CD, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        super(SXCM_CD, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_CD, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_CD


class PPD_PQ(PQ):
    """standardDeviation --  The primary measure of variance/uncertainty of the
    value (the square root of the sum of the squares of the differences
    between all data points and the mean). The standard deviation is
    used to normalize the data for computing the distribution function.
    Applications that cannot deal with probability distributions can
    still get an idea about the confidence level by looking at the
    standard deviation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_PQ.subclass:
            return PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.standardDeviation is not None or
            super(PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_PQ'):
        super(PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardDeviation = obj_
            obj_.original_tagname_ = 'standardDeviation'
        super(PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class PPD_PQ


class PPD_TS(TS):
    """standardDeviation --  The primary measure of variance/uncertainty of the
    value (the square root of the sum of the squares of the differences
    between all data points and the mean). The standard deviation is
    used to normalize the data for computing the distribution function.
    Applications that cannot deal with probability distributions can
    still get an idea about the confidence level by looking at the
    standard deviation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PPD_TS"), self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_TS.subclass:
            return PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            self.standardDeviation is not None or
            super(PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_TS'):
        super(PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardDeviation = obj_
            obj_.original_tagname_ = 'standardDeviation'
        super(PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PPD_TS


class IVXB_PQ(PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PQ"), self).__init__(nullFlavor, value, unit, translation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PQ.subclass:
            return IVXB_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PQ'):
        super(IVXB_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PQ


class SXCM_PQ(PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PQ"), self).__init__(nullFlavor, value, unit, translation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PQ.subclass:
            return SXCM_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PQ'):
        super(SXCM_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PQ


class IVL_PQ(SXCM_PQ):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', low: 'IVXB_PQ' = None, high: 'IVXB_PQ' = None, width: 'PQ' = None, center: 'PQ' = None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PQ"), self).__init__(nullFlavor, value, unit, translation, operator, extensiontype_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PQ.subclass:
            return IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PQ'):
        super(IVL_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IVL_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PQ


class POCD_MT000040_RegionOfInterest_value(INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, unsorted: 'xs_boolean' = 'false', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("POCD_MT000040_RegionOfInterest_value"), self).__init__(nullFlavor, value,  **kwargs_)
        self.unsorted = _cast(bool, unsorted)
        self.unsorted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RegionOfInterest_value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RegionOfInterest_value.subclass:
            return POCD_MT000040_RegionOfInterest_value.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RegionOfInterest_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unsorted(self):
        return self.unsorted
    def set_unsorted(self, unsorted):
        self.unsorted = unsorted
    def has__content(self):
        if (
            super(POCD_MT000040_RegionOfInterest_value, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.RegionOfInterest.value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RegionOfInterest.value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RegionOfInterest.value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest.value')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RegionOfInterest.value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RegionOfInterest.value'):
        super(POCD_MT000040_RegionOfInterest_value, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest.value')
        if self.unsorted and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            outfile.write(' unsorted="%s"' % self.gds_format_boolean(self.unsorted, input_name='unsorted'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.RegionOfInterest.value', fromsubclass_=False, pretty_print=True):
        super(POCD_MT000040_RegionOfInterest_value, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unsorted', node)
        if value is not None and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            if value in ('true', '1'):
                self.unsorted = True
            elif value in ('false', '0'):
                self.unsorted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(POCD_MT000040_RegionOfInterest_value, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(POCD_MT000040_RegionOfInterest_value, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class POCD_MT000040_RegionOfInterest_value


class POCD_MT000040_InfrastructureRoot_typeId(II):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = II
    def __init__(self, nullFlavor: 'NullFlavor' = None, root: 'uid' = '2.16.840.1.113883.1.3', extension: 'st' = None, assigningAuthorityName: 'st' = None, displayable: 'bl' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("POCD_MT000040_InfrastructureRoot_typeId"), self).__init__(nullFlavor, root, extension, assigningAuthorityName, displayable,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InfrastructureRoot_typeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InfrastructureRoot_typeId.subclass:
            return POCD_MT000040_InfrastructureRoot_typeId.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InfrastructureRoot_typeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(POCD_MT000040_InfrastructureRoot_typeId, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.typeId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InfrastructureRoot.typeId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InfrastructureRoot.typeId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.typeId')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InfrastructureRoot.typeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InfrastructureRoot.typeId'):
        super(POCD_MT000040_InfrastructureRoot_typeId, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.typeId')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.typeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        super(POCD_MT000040_InfrastructureRoot_typeId, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class POCD_MT000040_InfrastructureRoot_typeId


class IVXB_TS(TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, inclusive: 'bl' = 'true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_TS.subclass:
            return IVXB_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_TS'):
        super(IVXB_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_TS


class SXCM_TS(TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_TS"), self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_TS.subclass:
            return SXCM_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_TS'):
        super(SXCM_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_TS


class BXIT_IVL_PQ(IVL_PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IVL_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, operator: 'SetOperator' = 'I', low: 'IVXB_PQ' = None, high: 'IVXB_PQ' = None, width: 'PQ' = None, center: 'PQ' = None, qty: 'int' = '1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BXIT_IVL_PQ"), self).__init__(nullFlavor, value, unit, translation, operator, low, high, width, center,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_IVL_PQ.subclass:
            return BXIT_IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return BXIT_IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            super(BXIT_IVL_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BXIT_IVL_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_IVL_PQ'):
        super(BXIT_IVL_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(BXIT_IVL_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_IVL_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BXIT_IVL_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_IVL_PQ


class IVL_MO(SXCM_MO):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_MO
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, currency: 'cs' = None, operator: 'SetOperator' = 'I', low: 'IVXB_MO' = None, high: 'IVXB_MO' = None, width: 'MO' = None, center: 'MO' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_MO"), self).__init__(nullFlavor, value, currency, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_MO.subclass:
            return IVL_MO.subclass(*args_, **kwargs_)
        else:
            return IVL_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_MO, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_MO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_MO'):
        super(IVL_MO, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_MO', fromsubclass_=False, pretty_print=True):
        super(IVL_MO, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_MO, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_MO, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_MO


class IVL_REAL(SXCM_REAL):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_REAL
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, operator: 'SetOperator' = 'I', low: 'IVXB_REAL' = None, high: 'IVXB_REAL' = None, width: 'REAL' = None, center: 'REAL' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_REAL"), self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_REAL.subclass:
            return IVL_REAL.subclass(*args_, **kwargs_)
        else:
            return IVL_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_REAL, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_REAL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_REAL'):
        super(IVL_REAL, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_REAL', fromsubclass_=False, pretty_print=True):
        super(IVL_REAL, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_REAL, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_REAL, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_REAL


class IVL_INT(SXCM_INT):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_INT
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'int' = None, operator: 'SetOperator' = 'I', low: 'IVXB_INT' = None, high: 'IVXB_INT' = None, width: 'INT' = None, center: 'INT' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_INT"), self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_INT.subclass:
            return IVL_INT.subclass(*args_, **kwargs_)
        else:
            return IVL_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_INT, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_INT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_INT'):
        super(IVL_INT, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_INT', fromsubclass_=False, pretty_print=True):
        super(IVL_INT, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_INT, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_INT, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_INT


class SXPR_TS(SXCM_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', comp: List_['SXCM_TS'] = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXPR_TS"), self).__init__(nullFlavor, value, operator,  **kwargs_)
        if comp is None:
            self.comp = []
        else:
            self.comp = comp
        self.comp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXPR_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXPR_TS.subclass:
            return SXPR_TS.subclass(*args_, **kwargs_)
        else:
            return SXPR_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_comp(self):
        return self.comp
    def set_comp(self, comp):
        self.comp = comp
    def add_comp(self, value):
        self.comp.append(value)
    def insert_comp_at(self, index, value):
        self.comp.insert(index, value)
    def replace_comp_at(self, index, value):
        self.comp[index] = value
    def has__content(self):
        if (
            self.comp or
            super(SXPR_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SXPR_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXPR_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXPR_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXPR_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXPR_TS'):
        super(SXPR_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='SXPR_TS', fromsubclass_=False, pretty_print=True):
        super(SXPR_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comp_ in self.comp:
            namespaceprefix_ = self.comp_nsprefix_ + ':' if (UseCapturedNS_ and self.comp_nsprefix_) else ''
            comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SXPR_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'comp':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comp.append(obj_)
            obj_.original_tagname_ = 'comp'
        super(SXPR_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class SXPR_TS


class IVXB_PPD_PQ(PPD_PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_PQ.subclass:
            return IVXB_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_PQ'):
        super(IVXB_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_PQ


class SXCM_PPD_PQ(PPD_PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_PQ.subclass:
            return SXCM_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_PQ'):
        super(SXCM_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_PQ


class IVL_PPD_PQ(SXCM_PPD_PQ):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_PQ
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'real' = None, unit: 'cs' = '1', translation: List_['PQR'] = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', low: 'IVXB_PPD_PQ' = None, high: 'IVXB_PPD_PQ' = None, width: 'PPD_PQ' = None, center: 'PPD_PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PPD_PQ"), self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_PQ.subclass:
            return IVL_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PPD_PQ, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_PQ'):
        super(IVL_PPD_PQ, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_PQ, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_PQ, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PPD_PQ, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_PQ


class IVXB_PPD_TS(PPD_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, inclusive: 'bl' = 'true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVXB_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_TS.subclass:
            return IVXB_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            super(IVXB_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_TS'):
        super(IVXB_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_TS


class SXCM_PPD_TS(PPD_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SXCM_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_TS.subclass:
            return SXCM_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def has__content(self):
        if (
            super(SXCM_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_TS'):
        super(SXCM_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_TS


class PIVL_PPD_TS(SXCM_PPD_TS):
    """phase --  A prototype of the repeating interval specifying the
    duration of each occurrence and anchors the periodic interval
    sequence at a certain point in time.
    period --  A time duration specifying a reciprocal measure of
    the frequency at which the periodic interval repeats.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', alignment: 'CalendarCycle' = None, institutionSpecified: 'bl' = 'false', phase: 'IVL_PPD_TS' = None, period: 'PPD_PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PIVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_PPD_TS.subclass:
            return PIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on None.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.phase is not None or
            self.period is not None or
            super(PIVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PIVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_PPD_TS'):
        super(PIVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.period = obj_
            obj_.original_tagname_ = 'period'
        super(PIVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PIVL_PPD_TS


class EIVL_TS(SXCM_TS):
    """event --  A code for a common (periodical) activity of daily
    living based on which the event related periodic interval is
    specified.
    offset --  An interval of elapsed time (duration, not absolute
    point in time) that marks the offsets for the beginning, width and
    end of the event-related periodic interval measured from the time
    each such event actually occurred.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', event: 'EIVL.event' = None, offset: 'IVL_PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_TS"), self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_TS.subclass:
            return EIVL_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.event is not None or
            self.offset is not None or
            super(EIVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_TS'):
        super(EIVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EIVL_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EIVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        super(EIVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class EIVL_TS


class PIVL_TS(SXCM_TS):
    """phase --  A prototype of the repeating interval specifying the
    duration of each occurrence and anchors the periodic interval
    sequence at a certain point in time.
    period --  A time duration specifying a reciprocal measure of
    the frequency at which the periodic interval repeats.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', alignment: 'CalendarCycle' = None, institutionSpecified: 'bl' = 'false', phase: 'IVL_TS' = None, period: 'PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PIVL_TS"), self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_TS.subclass:
            return PIVL_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on None.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def has__content(self):
        if (
            self.phase is not None or
            self.period is not None or
            super(PIVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PIVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_TS'):
        super(PIVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PIVL_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.period = obj_
            obj_.original_tagname_ = 'period'
        super(PIVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class PIVL_TS


class xELGA_EIVL_TS(SXCM_TS):
    """event --  A code for a common (periodical) activity of daily
    living based on which the event related periodic interval is
    specified.
    offset --  An interval of elapsed time (duration, not absolute
    point in time) that marks the offsets for the beginning, width and
    end of the event-related periodic interval measured from the time
    each such event actually occurred.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', event: 'xELGA_EIVL.event' = None, offset: 'IVL_PQ' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "hl7v3"
        super(globals().get("xELGA_EIVL_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = "hl7v3"
        self.offset = offset
        self.offset_nsprefix_ = "hl7v3"
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xELGA_EIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xELGA_EIVL_TS.subclass:
            return xELGA_EIVL_TS.subclass(*args_, **kwargs_)
        else:
            return xELGA_EIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.event is not None or
            self.offset is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(xELGA_EIVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3" ', name_='xELGA_EIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xELGA_EIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'xELGA_EIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xELGA_EIVL_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='hl7v3:', name_='xELGA_EIVL_TS'):
        super(xELGA_EIVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xELGA_EIVL_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='hl7v3:', namespacedef_=' xmlns:hl7v3="urn:hl7-org:v3" ', name_='xELGA_EIVL_TS', fromsubclass_=False, pretty_print=True):
        super(xELGA_EIVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(xELGA_EIVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = xELGA_EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'event', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_event'):
              self.add_event(obj_.value)
            elif hasattr(self, 'set_event'):
              self.set_event(obj_.value)
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'offset', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_offset'):
              self.add_offset(obj_.value)
            elif hasattr(self, 'set_offset'):
              self.set_offset(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(xELGA_EIVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class xELGA_EIVL_TS


class IVL_TS(SXCM_TS):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, operator: 'SetOperator' = 'I', low: 'IVXB_TS' = None, high: 'IVXB_TS' = None, width: 'PQ' = None, center: 'TS' = None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_TS"), self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_TS.subclass:
            return IVL_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_TS'):
        super(IVL_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_TS


class EIVL_PPD_TS(SXCM_PPD_TS):
    """event --  A code for a common (periodical) activity of daily
    living based on which the event related periodic interval is
    specified.
    offset --  An interval of elapsed time (duration, not absolute
    point in time) that marks the offsets for the beginning, width and
    end of the event-related periodic interval measured from the time
    each such event actually occurred.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', event: 'EIVL.event' = None, offset: 'IVL_PPD_PQ' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EIVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_PPD_TS.subclass:
            return EIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def has__content(self):
        if (
            self.event is not None or
            self.offset is not None or
            super(EIVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_PPD_TS'):
        super(EIVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EIVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'offset':
            obj_ = IVL_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        super(EIVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class EIVL_PPD_TS


class IVL_PPD_TS(SXCM_PPD_TS):
    """low --  The low limit of the interval.
      
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
      
    * high --  The high limit of the interval.
      
    * center --  The arithmetic mean of the interval (low plus
      high divided by 2). The purpose of distinguishing the center as
      a semantic property is for conversions of intervals from and to
      point values.
    * width --  The difference between high and low boundary. The
      purpose of distinguishing a width property is to handle all
      cases of incomplete information symmetrically. In any interval
      representation only two of the three properties high, low, and
      width need to be stated and the third can be derived.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor: 'NullFlavor' = None, value: 'ts' = None, distributionType: 'ProbabilityDistributionType' = None, standardDeviation: 'PQ' = None, operator: 'SetOperator' = 'I', low: 'IVXB_PPD_TS' = None, high: 'IVXB_PPD_TS' = None, width: 'PPD_PQ' = None, center: 'PPD_TS' = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IVL_PPD_TS"), self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_TS.subclass:
            return IVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def has__content(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PPD_TS, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_TS'):
        super(IVL_PPD_TS, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='IVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_TS, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        if SaveNodeDict:
            node_dict[node] = self 
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_TS, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PPD_TS, self)._buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_TS


#
# End data representation classes.
#


GDSClassesMapping = {
    'ClinicalDocument': POCD_MT000040_ClinicalDocument,
    'asContent': COCT_MT230100UV_Content,
    'asDistributedProduct': COCT_MT230100UV_DistributedProduct,
    'asMedicineManufacturer': COCT_MT230100UV_MedicineManufacturer,
    'asPatientRelationship': AsPatientRelationship,
    'asSpecializedKind': COCT_MT230100UV_SpecializedKind,
    'birthTime': TS,
    'deceasedInd': BL,
    'deceasedTime': TS,
    'desc': ED,
    'desc': ED,
    'designation': ST,
    'dischargeDispositionCode': CE,
    'ethnicGroupCode': CE,
    'expirationTime': IVL_TS,
    'formCode': CE,
    'formatCode': CD,
    'functionCode': CE,
    'handlingCode': CE,
    'id': II,
    'id': II,
    'inFulfillmentOf1': InFulfillmentOf1,
    'ingredient': COCT_MT230100UV_Ingredient,
    'medication': COCT_MT230100UV_Medication,
    'multipleBirthInd': BL,
    'multipleBirthOrderNumber': INT_POS,
    'part': COCT_MT230100UV_Part,
    'patient': SdtcPatient,
    'practiceSettingCode': CD,
    'precondition1': Precondition1,
    'priorityNumber': INT,
    'raceCode': CE,
    'riskCode': CE,
    'signatureText': ED,
    'stabilityTime': IVL_TS,
    'statusCode': CS,
    'subjectOf1': COCT_MT230100UV_Subject2,
    'subjectOf2': COCT_MT230100UV_Subject1,
    'subjectOf3': COCT_MT230100UV_Subject22,
    'subjectOf4': COCT_MT230100UV_Subject3,
    'subjectOf5': COCT_MT230100UV_Subject7,
    'terminologyDate': TS,
    'text': ED,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from at_ext import *\n\n')
        sys.stdout.write('import at_ext as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:hl7-at:v3': [],
 'urn:hl7-org:ips': [],
 'urn:hl7-org:sdtc': [('int_pos',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'ST'),
                      ('INT_POS',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('ActReference',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('InFulfillmentOf1',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('SdtcPatient',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('AsPatientRelationship',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('Precondition1',
                       '../cda-schema/coreschemas/../SDTC.xsd',
                       'CT'),
                      ('int_pos', '../cda-schema/SDTC.xsd', 'ST'),
                      ('INT_POS', '../cda-schema/SDTC.xsd', 'CT'),
                      ('ActReference', '../cda-schema/SDTC.xsd', 'CT'),
                      ('InFulfillmentOf1', '../cda-schema/SDTC.xsd', 'CT'),
                      ('SdtcPatient', '../cda-schema/SDTC.xsd', 'CT'),
                      ('AsPatientRelationship', '../cda-schema/SDTC.xsd', 'CT'),
                      ('Precondition1', '../cda-schema/SDTC.xsd', 'CT')],
 'urn:hl7-org:v3': [('cs', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('Classes', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('AddressPartType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('AdditionalLocator',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('DeliveryAddressLine',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('StreetAddressLine',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('BuildingNumber',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('StreetName', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('CalendarCycle',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('CalendarCycleOneLetter',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('CalendarCycleTwoLetter',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('GregorianCalendarCycle',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('CompressionAlgorithm',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('Currency', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('EntityNamePartQualifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('OrganizationNamePartQualifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PersonNamePartQualifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PersonNamePartAffixTypes',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PersonNamePartChangeQualifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PersonNamePartMiscQualifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityNamePartType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_OrganizationNamePartType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_PersonNamePartType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityNameUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('OrganizationNameUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PersonNameUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityNameSearchUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('NamePseudonymUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('IntegrityCheckAlgorithm',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('MediaType', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ApplicationMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('AudioMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ImageMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ModelMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('MultipartMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('TextMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('VideoMediaType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('PostalAddressUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('NameRepresentationUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ProbabilityDistributionType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('SetOperator', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('TelecommunicationAddressUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('AddressUse', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('HomeAddressUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('WorkPlaceAddressUse',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('TimingEvent', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('URLScheme', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActClass', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActClassRoot', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActClassContract',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassFinancialContract',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassControlAct',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassObservation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassCondition',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassPublicHealthCase',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassObservationSeries',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassROI', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActClassSupply',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActContainer', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActClassComposition',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassDocument',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClinicalDocument',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassEntry',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassExtract',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActClassOrganizer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActClassDocumentEntryAct',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActClassDocumentEntryOrganizer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActMood', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActMoodCompletionTrack',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActMoodPredicate',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodDefEvn',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodDefEvnRqoPrmsPrp',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodDocumentObservation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodEvnOrdPrmsPrp',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodIntentEvent',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActMoodIntent',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodOrdPrms',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodOrdPrmsEvn',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActMoodRqoPrpAptArq',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentActMood',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentEncounterMood',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentProcedureMood',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentSubstanceMood',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipConditional',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipReason',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipHasComponent',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipOutcome',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipObjective',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipPertains',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipAccounting',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipCostTracking',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipPosting',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('TemporallyPertains',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('hasSupport', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('ActRelationshipSequel',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipExcerpt',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipFulfills',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ActRelationshipReplacement',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipDocument',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipEntry',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipEntryRelationship',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipExternalReference',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipPatientTransport',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ActRelationshipPertinentInfo',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('CommunicationFunctionType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ContextControl',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ContextControlAdditive',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ContextControlNonPropagating',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ContextControlOverriding',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ContextControlPropagating',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClass', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('EntityClassRoot',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassLivingSubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassNonPersonLivingSubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassMaterial',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassManufacturedMaterial',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassContainer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassDevice',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassPlace',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_EntityClassDocumentReceiving',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_EntityClassPersonOrOrgReceiving',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityClassOrganization',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('State', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('EntityDeterminer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('EntityDeterminerDetermined',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DeterminerInstanceKind',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('NullFlavor', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('NoInformation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('Other', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('Unknown', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('AskedButUnknown',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationAncillary',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationIndirectTarget',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationInformationGenerator',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationInformationRecipient',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationPhysicalPerformer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationTargetDirect',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationTargetDevice',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationTargetSubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationTargetLocation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('ParticipationVerifier',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_EncounterParticipant',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_EncounterPerformerParticipation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_InformationRecipient',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ParticipationAuthorPerformer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ParticipationEntVrf',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ParticipationPrfEntVrf',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ParticipationVrfRespSprfWit',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_ServiceEventPerformer',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClass', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('RoleClassRoot',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassAssociative',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassMutualRelationship',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassRelationshipFormal',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassAgent',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassAssignedEntity',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassContact',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassEmployee',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassInvestigationSubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassPassive',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassDistributedMaterial',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassManufacturedProduct',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassServiceDeliveryLocation',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassOntological',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassIsSpeciesEntity',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassPartitive',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassIngredientEntity',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassInactiveIngredient',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassLocatedEntity',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleClassSpecimen',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentEntrySubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_DocumentSubject',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_InformationRecipientRole',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_RoleClassAccommodationRequestor',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_RoleClassCoverage',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_RoleClassCoverageInvoice',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_RoleClassCredentialedEntity',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('LicensedEntityRole',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('x_RoleClassPayeePolicyRelationship',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('RoleLinkType', '../cda-schema/coreschemas/voc.xsd', 'ST'),
                    ('RelatedLinkType',
                     '../cda-schema/coreschemas/voc.xsd',
                     'ST'),
                    ('POCD_MT000040_InfrastructureRoot_typeId',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Act',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedAuthor',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedCustodian',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedEntity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssociatedEntity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authenticator',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Author',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AuthoringDevice',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authorization',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Birthplace',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ClinicalDocument',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component1',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component2',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component3',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component4',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component5',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consent',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consumable',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Criterion',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Custodian',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_CustodianOrganization',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DataEnterer',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Device',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DocumentationOf',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncompassingEncounter',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Encounter',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncounterParticipant',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entry',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EntryRelationship',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalAct',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalDocument',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalObservation',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalProcedure',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Guardian',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_HealthCareFacility',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Informant12',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InformationRecipient',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InFulfillmentOf',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_IntendedRecipient',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LabeledDrug',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LanguageCommunication',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LegalAuthenticator',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Location',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_MaintainedEntity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ManufacturedProduct',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Material',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_NonXMLBody',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Observation',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationMedia',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationRange',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Order',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organization',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_OrganizationPartOf',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organizer',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParentDocument',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant1',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant2',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParticipantRole',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Patient',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PatientRole',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer1',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer2',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Person',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Place',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PlayingEntity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Precondition',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Procedure',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Product',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RecordTarget',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Reference',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ReferenceRange',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest_value',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedDocument',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedEntity',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedSubject',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ResponsibleParty',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Section',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ServiceEvent',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Specimen',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SpecimenRole',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_StructuredBody',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Subject',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubjectPerson',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubstanceAdministration',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Supply',
                     '../cda-schema/coreschemas/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InfrastructureRoot_typeId',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Act',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedAuthor',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedCustodian',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedEntity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssociatedEntity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authenticator',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Author',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AuthoringDevice',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authorization',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Birthplace',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ClinicalDocument',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component1',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component2',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component3',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component4',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component5',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consent',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consumable',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Criterion',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Custodian',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_CustodianOrganization',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DataEnterer',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Device',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DocumentationOf',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncompassingEncounter',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Encounter',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncounterParticipant',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entry',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EntryRelationship',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalAct',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalDocument',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalObservation',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalProcedure',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Guardian',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_HealthCareFacility',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Informant12',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InformationRecipient',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InFulfillmentOf',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_IntendedRecipient',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LabeledDrug',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LanguageCommunication',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LegalAuthenticator',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Location',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_MaintainedEntity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ManufacturedProduct',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Material',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_NonXMLBody',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Observation',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationMedia',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationRange',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Order',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organization',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_OrganizationPartOf',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organizer',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParentDocument',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant1',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant2',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParticipantRole',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Patient',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PatientRole',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer1',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer2',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Person',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Place',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PlayingEntity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Precondition',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Procedure',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Product',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RecordTarget',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Reference',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ReferenceRange',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest_value',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedDocument',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedEntity',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedSubject',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ResponsibleParty',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Section',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ServiceEvent',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Specimen',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SpecimenRole',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_StructuredBody',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Subject',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubjectPerson',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubstanceAdministration',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Supply',
                     '../cda-schema/coreschemas/../extIPS/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('bl',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bn',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bin',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('BinaryDataEncoding',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('st',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uid',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('oid',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uuid',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ruid',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('url',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ts',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('int',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('real',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('probability',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_TelecommunicationAddressUse',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_PostalAddressUse',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNamePartQualifier',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNameUse',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ANY',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BL',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ANYNonNull',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BN',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BIN',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ED',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('thumbnail',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ST',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CD',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CE',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CV',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CS',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CO',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CR',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SC',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('II',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('URL',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TS',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TEL',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ADXP',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_delimiter',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_country',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_state',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_county',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_city',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postalCode',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetAddressLine',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumber',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumberNumeric',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_direction',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetName',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameBase',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameType',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_additionalLocator',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitID',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitType',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_careOf',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_censusTract',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryAddressLine',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationType',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationArea',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationQualifier',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryMode',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryModeIdentifier',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_buildingNumberSuffix',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postBox',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_precinct',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('AD',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ENXP',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_delimiter',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_family',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_given',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_prefix',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_suffix',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EN',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PN',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ON',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TN',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('QTY',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('INT',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('REAL',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQR',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQ',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('MO',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EIVL_event',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SXCM_TS',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVL_TS',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVXB_TS',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO_QTY_QTY',
                     '../cda-schema/coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('list_int',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'ST'),
                    ('PIVL_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PQ', '../cda-schema/coreschemas/datatypes.xsd', 'CT'),
                    ('SXCM_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('PPD_TS', '../cda-schema/coreschemas/datatypes.xsd', 'CT'),
                    ('PPD_PQ', '../cda-schema/coreschemas/datatypes.xsd', 'CT'),
                    ('PIVL_PPD_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_PPD_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXPR_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_CD',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_MO',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_INT',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_REAL',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_INT',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_INT',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_REAL',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_REAL',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_MO', '../cda-schema/coreschemas/datatypes.xsd', 'CT'),
                    ('IVXB_MO',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_CE',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_CD',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_IVL_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_TS',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_PQ_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_MO_PQ',
                     '../cda-schema/coreschemas/datatypes.xsd',
                     'CT'),
                    ('UVP_TS', '../cda-schema/coreschemas/datatypes.xsd', 'CT'),
                    ('StrucDoc_Text',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Title',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Br',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Caption',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Col',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Colgroup',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Content',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_TitleContent',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Footnote',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_TitleFootnote',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_FootnoteRef',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Item',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_LinkHtml',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_List',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Paragraph',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_RenderMultiMedia',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Sub',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Sup',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Table',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Tbody',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Td',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Tfoot',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Th',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Thead',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('StrucDoc_Tr',
                     '../cda-schema/coreschemas/narrative-block.xsd',
                     'CT'),
                    ('list_int',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'ST'),
                    ('PIVL_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PPD_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PIVL_PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_PPD_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXPR_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_CD',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_MO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_INT',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_REAL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_INT',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_INT',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_REAL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_REAL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_MO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_MO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_CE',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_CD',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_IVL_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_PQ_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_MO_PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('UVP_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('bl',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bn',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bin',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('BinaryDataEncoding',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('st',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uid',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('oid',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uuid',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ruid',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('url',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ts',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('int',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('real',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('probability',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_TelecommunicationAddressUse',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_PostalAddressUse',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNamePartQualifier',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNameUse',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ANY',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ANYNonNull',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BN',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BIN',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ED',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('thumbnail',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ST',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CD',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CE',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CV',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CR',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SC',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('II',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('URL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TEL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ADXP',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_delimiter',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_country',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_state',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_county',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_city',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postalCode',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetAddressLine',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumber',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumberNumeric',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_direction',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetName',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameBase',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameType',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_additionalLocator',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitID',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitType',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_careOf',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_censusTract',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryAddressLine',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationType',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationArea',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationQualifier',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryMode',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryModeIdentifier',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_buildingNumberSuffix',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postBox',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_precinct',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('AD',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ENXP',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_delimiter',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_family',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_given',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_prefix',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_suffix',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EN',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PN',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ON',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TN',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('QTY',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('INT',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('REAL',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQR',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQ',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('MO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EIVL_event',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SXCM_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVL_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVXB_TS',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO_QTY_QTY',
                     '../cda-schema/extPHARM/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EntityClassPublicInstitution',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('EntityDeterminerSpecific',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ActMoodEventOccurrence',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ParticipationAuthorOriginator',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('RoleClassContent',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('EntityClassState',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ParticipationHolder',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('RoleClassAdministerableMaterial',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ActMoodGoal',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('RoleClassPart',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ActMoodDefinition',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('RoleClassTerritoryOfAuthority',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('ActClassInvoiceElement',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'ST'),
                    ('all_InfrastructureRoot_typeId',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'CT'),
                    ('all_InfrastructureRoot_templateId',
                     '../cda-schema/extPHARM/hl7v3_extPHARM.xsd',
                     'CT'),
                    ('list_int',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'ST'),
                    ('PIVL_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PPD_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('PIVL_PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('EIVL_PPD_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_PPD_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_PPD_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_PPD_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXPR_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_CD',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_MO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_INT',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SXCM_REAL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_INT',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_INT',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_REAL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_REAL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVL_MO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('IVXB_MO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('HXIT_CE',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_CD',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('BXIT_IVL_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('SLIST_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('GLIST_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_PQ_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('RTO_MO_PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('UVP_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes.xsd',
                     'CT'),
                    ('bl',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bn',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('bin',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('BinaryDataEncoding',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('st',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uid',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('oid',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('uuid',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ruid',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('url',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ts',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('int',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('real',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('probability',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_TelecommunicationAddressUse',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_PostalAddressUse',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNamePartQualifier',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('set_EntityNameUse',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'ST'),
                    ('ANY',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ANYNonNull',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BN',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('BIN',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ED',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('thumbnail',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ST',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CD',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CE',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CV',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('CR',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SC',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('II',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('URL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TEL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ADXP',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_delimiter',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_country',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_state',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_county',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_city',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postalCode',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetAddressLine',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumber',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_houseNumberNumeric',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_direction',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetName',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameBase',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_streetNameType',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_additionalLocator',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitID',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_unitType',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_careOf',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_censusTract',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryAddressLine',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationType',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationArea',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryInstallationQualifier',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryMode',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_deliveryModeIdentifier',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_buildingNumberSuffix',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_postBox',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('adxp_precinct',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('AD',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ENXP',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_delimiter',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_family',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_given',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_prefix',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('en_suffix',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EN',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PN',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('ON',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('TN',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('QTY',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('INT',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('REAL',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQR',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('PQ',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('MO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('EIVL_event',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('SXCM_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVL_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('IVXB_TS',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('RTO_QTY_QTY',
                     '../cda-schema/extHL7at/../coreschemas/datatypes-base_SDTC.xsd',
                     'CT'),
                    ('xELGA_TimingEvent',
                     '../cda-schema/extHL7at/hl7v3_extELGA.xsd',
                     'ST'),
                    ('xELGA_URLScheme',
                     '../cda-schema/extHL7at/hl7v3_extELGA.xsd',
                     'ST'),
                    ('xELGA_EIVL_event',
                     '../cda-schema/extHL7at/hl7v3_extELGA.xsd',
                     'CT'),
                    ('xELGA_EIVL_TS',
                     '../cda-schema/extHL7at/hl7v3_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InfrastructureRoot_typeId',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Act',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedAuthor',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedCustodian',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedEntity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssociatedEntity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authenticator',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Author',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AuthoringDevice',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authorization',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Birthplace',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ClinicalDocument',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component1',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component2',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component3',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component4',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component5',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consent',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consumable',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Criterion',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Custodian',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_CustodianOrganization',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DataEnterer',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Device',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DocumentationOf',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncompassingEncounter',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Encounter',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncounterParticipant',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entry',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EntryRelationship',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalAct',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalDocument',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalObservation',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalProcedure',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Guardian',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_HealthCareFacility',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Informant12',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InformationRecipient',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InFulfillmentOf',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_IntendedRecipient',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LabeledDrug',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LanguageCommunication',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LegalAuthenticator',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Location',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_MaintainedEntity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ManufacturedProduct',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Material',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_NonXMLBody',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Observation',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationMedia',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationRange',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Order',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organization',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_OrganizationPartOf',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organizer',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParentDocument',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant1',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant2',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParticipantRole',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Patient',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PatientRole',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer1',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer2',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Person',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Place',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PlayingEntity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Precondition',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Procedure',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Product',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RecordTarget',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Reference',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ReferenceRange',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest_value',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedDocument',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedEntity',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedSubject',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ResponsibleParty',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Section',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ServiceEvent',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Specimen',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SpecimenRole',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_StructuredBody',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Subject',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubjectPerson',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubstanceAdministration',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Supply',
                     '../cda-schema/extHL7at/../POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InfrastructureRoot_typeId',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Act',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedAuthor',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedCustodian',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedEntity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AssociatedEntity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authenticator',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Author',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_AuthoringDevice',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Authorization',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Birthplace',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ClinicalDocument',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component1',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component2',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component3',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component4',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Component5',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consent',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Consumable',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Criterion',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Custodian',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_CustodianOrganization',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DataEnterer',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Device',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_DocumentationOf',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncompassingEncounter',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Encounter',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EncounterParticipant',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Entry',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_EntryRelationship',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalAct',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalDocument',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalObservation',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalProcedure',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Guardian',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_HealthCareFacility',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Informant12',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InformationRecipient',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_InFulfillmentOf',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_IntendedRecipient',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LabeledDrug',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LanguageCommunication',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_LegalAuthenticator',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Location',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_MaintainedEntity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ManufacturedProduct',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Material',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_NonXMLBody',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Observation',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationMedia',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationRange',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Order',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organization',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_OrganizationPartOf',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Organizer',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParentDocument',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant1',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant2',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ParticipantRole',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Patient',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PatientRole',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer1',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Performer2',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Person',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Place',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_PlayingEntity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Precondition',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Procedure',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Product',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RecordTarget',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Reference',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ReferenceRange',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest_value',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedDocument',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedEntity',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedSubject',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ResponsibleParty',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Section',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_ServiceEvent',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Specimen',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SpecimenRole',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_StructuredBody',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Subject',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubjectPerson',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_SubstanceAdministration',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT'),
                    ('POCD_MT000040_Supply',
                     '../cda-schema/POCD_MT000040_SDTC_extELGA.xsd',
                     'CT')],
 'urn:ihe:pharm:medication': [('COCT_MT440001UV09_ValuedItem',
                               '../cda-schema/extPHARM/COCT_MT440001UV09_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Agency',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Approval',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Author',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Characteristic',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Content',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Country',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_DistributedProduct',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Holder',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Ingredient',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_ManufacturedProduct',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Manufacturer',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Medication',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Medicine',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_MedicineClass',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_MedicineManufacturer',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_ObservationGoal',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_PackagedMedicine',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Part',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Policy',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_RelatedManufacturer',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Role',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_SpecializedKind',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_SubContent',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_SubIngredient',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject1',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject11',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject14',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject15',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject16',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject2',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject22',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject25',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject3',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject4',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Subject7',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_Substance',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_SubstanceManufacturer',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_SuperContent',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT'),
                              ('COCT_MT230100UV_TerritorialAuthority',
                               '../cda-schema/extPHARM/COCT_MT230100UV_extPHARM.xsd',
                               'CT')]}

__all__ = [
    "AD",
    "ADXP",
    "ANY",
    "ANYNonNull",
    "ActReference",
    "AsPatientRelationship",
    "BIN",
    "BL",
    "BN",
    "BXIT_CD",
    "BXIT_IVL_PQ",
    "CD",
    "CE",
    "CO",
    "COCT_MT230100UV_Agency",
    "COCT_MT230100UV_Approval",
    "COCT_MT230100UV_Author",
    "COCT_MT230100UV_Characteristic",
    "COCT_MT230100UV_Content",
    "COCT_MT230100UV_Country",
    "COCT_MT230100UV_DistributedProduct",
    "COCT_MT230100UV_Holder",
    "COCT_MT230100UV_Ingredient",
    "COCT_MT230100UV_ManufacturedProduct",
    "COCT_MT230100UV_Manufacturer",
    "COCT_MT230100UV_Medication",
    "COCT_MT230100UV_Medicine",
    "COCT_MT230100UV_MedicineClass",
    "COCT_MT230100UV_MedicineManufacturer",
    "COCT_MT230100UV_ObservationGoal",
    "COCT_MT230100UV_PackagedMedicine",
    "COCT_MT230100UV_Part",
    "COCT_MT230100UV_Policy",
    "COCT_MT230100UV_RelatedManufacturer",
    "COCT_MT230100UV_Role",
    "COCT_MT230100UV_SpecializedKind",
    "COCT_MT230100UV_SubContent",
    "COCT_MT230100UV_SubIngredient",
    "COCT_MT230100UV_Subject1",
    "COCT_MT230100UV_Subject11",
    "COCT_MT230100UV_Subject14",
    "COCT_MT230100UV_Subject15",
    "COCT_MT230100UV_Subject16",
    "COCT_MT230100UV_Subject2",
    "COCT_MT230100UV_Subject22",
    "COCT_MT230100UV_Subject25",
    "COCT_MT230100UV_Subject3",
    "COCT_MT230100UV_Subject4",
    "COCT_MT230100UV_Subject7",
    "COCT_MT230100UV_Substance",
    "COCT_MT230100UV_SubstanceManufacturer",
    "COCT_MT230100UV_SuperContent",
    "COCT_MT230100UV_TerritorialAuthority",
    "COCT_MT440001UV09_ValuedItem",
    "CR",
    "CS",
    "CV",
    "ED",
    "EIVL_PPD_TS",
    "EIVL_TS",
    "EIVL_event",
    "EN",
    "ENXP",
    "GLIST_PQ",
    "GLIST_TS",
    "HXIT_CE",
    "HXIT_PQ",
    "II",
    "INT",
    "INT_POS",
    "IVL_INT",
    "IVL_MO",
    "IVL_PPD_PQ",
    "IVL_PPD_TS",
    "IVL_PQ",
    "IVL_REAL",
    "IVL_TS",
    "IVXB_INT",
    "IVXB_MO",
    "IVXB_PPD_PQ",
    "IVXB_PPD_TS",
    "IVXB_PQ",
    "IVXB_REAL",
    "IVXB_TS",
    "InFulfillmentOf1",
    "MO",
    "ON",
    "PIVL_PPD_TS",
    "PIVL_TS",
    "PN",
    "POCD_MT000040_Act",
    "POCD_MT000040_AssignedAuthor",
    "POCD_MT000040_AssignedCustodian",
    "POCD_MT000040_AssignedEntity",
    "POCD_MT000040_AssociatedEntity",
    "POCD_MT000040_Authenticator",
    "POCD_MT000040_Author",
    "POCD_MT000040_AuthoringDevice",
    "POCD_MT000040_Authorization",
    "POCD_MT000040_Birthplace",
    "POCD_MT000040_ClinicalDocument",
    "POCD_MT000040_Component1",
    "POCD_MT000040_Component2",
    "POCD_MT000040_Component3",
    "POCD_MT000040_Component4",
    "POCD_MT000040_Component5",
    "POCD_MT000040_Consent",
    "POCD_MT000040_Consumable",
    "POCD_MT000040_Criterion",
    "POCD_MT000040_Custodian",
    "POCD_MT000040_CustodianOrganization",
    "POCD_MT000040_DataEnterer",
    "POCD_MT000040_Device",
    "POCD_MT000040_DocumentationOf",
    "POCD_MT000040_EncompassingEncounter",
    "POCD_MT000040_Encounter",
    "POCD_MT000040_EncounterParticipant",
    "POCD_MT000040_Entity",
    "POCD_MT000040_Entry",
    "POCD_MT000040_EntryRelationship",
    "POCD_MT000040_ExternalAct",
    "POCD_MT000040_ExternalDocument",
    "POCD_MT000040_ExternalObservation",
    "POCD_MT000040_ExternalProcedure",
    "POCD_MT000040_Guardian",
    "POCD_MT000040_HealthCareFacility",
    "POCD_MT000040_InFulfillmentOf",
    "POCD_MT000040_Informant12",
    "POCD_MT000040_InformationRecipient",
    "POCD_MT000040_InfrastructureRoot_typeId",
    "POCD_MT000040_IntendedRecipient",
    "POCD_MT000040_LabeledDrug",
    "POCD_MT000040_LanguageCommunication",
    "POCD_MT000040_LegalAuthenticator",
    "POCD_MT000040_Location",
    "POCD_MT000040_MaintainedEntity",
    "POCD_MT000040_ManufacturedProduct",
    "POCD_MT000040_Material",
    "POCD_MT000040_NonXMLBody",
    "POCD_MT000040_Observation",
    "POCD_MT000040_ObservationMedia",
    "POCD_MT000040_ObservationRange",
    "POCD_MT000040_Order",
    "POCD_MT000040_Organization",
    "POCD_MT000040_OrganizationPartOf",
    "POCD_MT000040_Organizer",
    "POCD_MT000040_ParentDocument",
    "POCD_MT000040_Participant1",
    "POCD_MT000040_Participant2",
    "POCD_MT000040_ParticipantRole",
    "POCD_MT000040_Patient",
    "POCD_MT000040_PatientRole",
    "POCD_MT000040_Performer1",
    "POCD_MT000040_Performer2",
    "POCD_MT000040_Person",
    "POCD_MT000040_Place",
    "POCD_MT000040_PlayingEntity",
    "POCD_MT000040_Precondition",
    "POCD_MT000040_Procedure",
    "POCD_MT000040_Product",
    "POCD_MT000040_RecordTarget",
    "POCD_MT000040_Reference",
    "POCD_MT000040_ReferenceRange",
    "POCD_MT000040_RegionOfInterest",
    "POCD_MT000040_RegionOfInterest_value",
    "POCD_MT000040_RelatedDocument",
    "POCD_MT000040_RelatedEntity",
    "POCD_MT000040_RelatedSubject",
    "POCD_MT000040_ResponsibleParty",
    "POCD_MT000040_Section",
    "POCD_MT000040_ServiceEvent",
    "POCD_MT000040_Specimen",
    "POCD_MT000040_SpecimenRole",
    "POCD_MT000040_StructuredBody",
    "POCD_MT000040_Subject",
    "POCD_MT000040_SubjectPerson",
    "POCD_MT000040_SubstanceAdministration",
    "POCD_MT000040_Supply",
    "PPD_PQ",
    "PPD_TS",
    "PQ",
    "PQR",
    "Precondition1",
    "QTY",
    "REAL",
    "RTO",
    "RTO_MO_PQ",
    "RTO_PQ_PQ",
    "RTO_QTY_QTY",
    "SC",
    "SLIST_PQ",
    "SLIST_TS",
    "ST",
    "SXCM_CD",
    "SXCM_INT",
    "SXCM_MO",
    "SXCM_PPD_PQ",
    "SXCM_PPD_TS",
    "SXCM_PQ",
    "SXCM_REAL",
    "SXCM_TS",
    "SXPR_TS",
    "SdtcPatient",
    "StrucDoc_Br",
    "StrucDoc_Caption",
    "StrucDoc_Col",
    "StrucDoc_Colgroup",
    "StrucDoc_Content",
    "StrucDoc_Footnote",
    "StrucDoc_FootnoteRef",
    "StrucDoc_Item",
    "StrucDoc_LinkHtml",
    "StrucDoc_List",
    "StrucDoc_Paragraph",
    "StrucDoc_RenderMultiMedia",
    "StrucDoc_Sub",
    "StrucDoc_Sup",
    "StrucDoc_Table",
    "StrucDoc_Tbody",
    "StrucDoc_Td",
    "StrucDoc_Text",
    "StrucDoc_Tfoot",
    "StrucDoc_Th",
    "StrucDoc_Thead",
    "StrucDoc_Title",
    "StrucDoc_TitleContent",
    "StrucDoc_TitleFootnote",
    "StrucDoc_Tr",
    "TEL",
    "TN",
    "TS",
    "URL",
    "UVP_TS",
    "adxp_additionalLocator",
    "adxp_buildingNumberSuffix",
    "adxp_careOf",
    "adxp_censusTract",
    "adxp_city",
    "adxp_country",
    "adxp_county",
    "adxp_delimiter",
    "adxp_deliveryAddressLine",
    "adxp_deliveryInstallationArea",
    "adxp_deliveryInstallationQualifier",
    "adxp_deliveryInstallationType",
    "adxp_deliveryMode",
    "adxp_deliveryModeIdentifier",
    "adxp_direction",
    "adxp_houseNumber",
    "adxp_houseNumberNumeric",
    "adxp_postBox",
    "adxp_postalCode",
    "adxp_precinct",
    "adxp_state",
    "adxp_streetAddressLine",
    "adxp_streetName",
    "adxp_streetNameBase",
    "adxp_streetNameType",
    "adxp_unitID",
    "adxp_unitType",
    "all_InfrastructureRoot_templateId",
    "all_InfrastructureRoot_typeId",
    "en_delimiter",
    "en_family",
    "en_given",
    "en_prefix",
    "en_suffix",
    "functionCode",
    "thumbnail",
    "xELGA_EIVL_TS",
    "xELGA_EIVL_event"
]
